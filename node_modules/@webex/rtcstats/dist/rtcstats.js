// @todo WEBEX-425803: fix types issues with inline ts-ignore rules.
// @see https://jira-eng-gpk2.cisco.com/jira/browse/WEBEX-425803
/**
 * Copies values of any nested depth.
 *
 * @param value - The value to be copied.
 * @returns - Copied value.
 */
const deepCopy = (value) => JSON.parse(JSON.stringify(value));
/**
 * Check deep equality between two values.
 *
 * @param value1 - First value to check.
 * @param value2 - Second value to check.
 * @returns True if values are deeply equal, false otherwise.
 */
const deepEqual = (value1, value2) => {
    // If both immutable values are equal, return true.
    if (value1 === value2) {
        return true;
    }
    // If both are objects, we check the length and properties of each.
    if (value1 && value2 && typeof value1 === 'object' && typeof value2 === 'object') {
        if (value1.constructor !== value2.constructor)
            return false;
        // Return false if the objects are of different sizes.
        if (Object.keys(value1).length !== Object.keys(value2).length) {
            return false;
        }
        // Deep equal check each property in the object, returns true if we found no
        // differing properties.
        return Object.keys(value1).reduce((val, prop) => {
            // @ts-ignore
            if (value2[prop]) {
                // @ts-ignore
                if (!deepEqual(value1[prop], value2[prop])) {
                    return false;
                }
            }
            else {
                return false;
            }
            return val;
        }, true);
    }
    // Return false if no other conditions are met.
    return false;
};
/**
 * Translates a Map into an object.
 *
 * @param report - The report in Map form.
 * @returns - A deduped object.
 */
const map2obj = (report) => {
    if (!report.size) {
        return report;
    }
    const o = {};
    report.forEach((value, key) => {
        // @ts-ignore
        o[key] = value;
    });
    return o;
};
const dumpStream = (stream) => ({
    id: stream.id,
    tracks: stream.getTracks().map((track) => ({
        id: track.id,
        kind: track.kind,
        label: track.label,
        enabled: track.enabled,
        muted: track.muted,
        readyState: track.readyState,
    })),
});
const persistedKeys = ['type', 'id', 'timestamp'];
/**
 * Check to see if the report consists of more than just the persisted metadata.
 *
 * @param report - The report line being checked.
 * @returns True if the report item contains non-persisted keys, false otherwise.
 */
const hasNonMetadata = (report) => !!Object.keys(report).filter((key) => !persistedKeys.includes(key)).length;
/**
 * Apply a delta compression to the stats report. Reduces size by ~90%.
 * To reduce further, report keys could be compressed.
 *
 * @param oldStats - Previous report items that we dedupe against.
 * @param newStats - New incoming stats.
 * @returns - Compressed Stats.
 */
const deltaCompression = (oldStats, newStats) => {
    const updatedStats = deepCopy(newStats);
    Object.keys(updatedStats).forEach((id) => {
        // @ts-ignore
        const report = updatedStats[id];
        // @ts-ignore
        if (!oldStats[id]) {
            return;
        }
        // Persist specific values beyond delta compression, as long as they
        // aren't the only non-deduped keys.
        Object.keys(report).forEach((name) => {
            // @ts-ignore
            if (deepEqual(report[name], oldStats[id][name]) && !persistedKeys.includes(name)) {
                // @ts-ignore
                delete updatedStats[id][name];
            }
            if (!hasNonMetadata(report)) {
                // @ts-ignore
                delete updatedStats[id];
            }
        });
    });
    // Use the most recent timestamp.
    let timestamp = -Infinity;
    Object.keys(updatedStats).forEach((id) => {
        // @ts-ignore
        const report = updatedStats[id];
        if (report.timestamp > timestamp) {
            timestamp = report.timestamp;
        }
    });
    // Delete the timestamps on each item.
    Object.keys(updatedStats).forEach((id) => {
        // @ts-ignore
        const report = updatedStats[id];
        if (report.timestamp === timestamp) {
            delete report.timestamp;
        }
    });
    updatedStats.timestamp = timestamp;
    return updatedStats;
};
/**
 * Format the stats report into an array.
 *
 * @param report - A WebRTC stats report.
 * @returns - An array of Stats Report items.
 */
const formatStatsReport = (report) => {
    return (Object.keys(report)
        .filter((name) => name !== 'timestamp')
        // @ts-ignore
        .map((name) => JSON.stringify(report[name])));
};
/**
 * Parametrize a single string event to contain type and an (empty) id.
 *
 * @param value - The value to parametrize.
 * @returns An event object.
 */
const makeEvent = (value) => [JSON.stringify({ value, type: 'string', id: '' })];
/**
 * Attach a Peer Connection to periodically get updated on events and stats.
 *
 * @param pc - Peer Connection in which we attach.
 * @param logger - Logging function to log events and stats.
 * @param intervalTime - Time between each `getStats` check.
 * @param statsPreProcessor - Optional function that modifies stats.
 */
export const rtcStats = (pc, logger, intervalTime, 
// eslint-disable-next-line no-unused-vars
statsPreProcessor = () => Promise.resolve()) => {
    let prev = {};
    /**
     * Log stats or event data with additional tracking information.
     *
     * @param name - Name of the event to log.
     * @param payload - Log data pertaining to the event.
     * @param timestamp - Time the event happened in milliseconds.
     */
    const trace = (name, payload, timestamp) => {
        logger({ timestamp: timestamp ? Math.round(timestamp) : Date.now(), name, payload });
    };
    trace('rtcConfiguration', makeEvent(JSON.stringify(pc.getConfiguration())));
    const origPeerConnection = window.RTCPeerConnection;
    pc.addEventListener('icecandidate', (e) => {
        if (e.candidate) {
            trace('onicecandidate', makeEvent(JSON.stringify(e.candidate)));
        }
    });
    pc.addEventListener('icecandidateerror', (event) => {
        const { url, errorCode, errorText } = event;
        trace('onicecandidateerror', makeEvent(`[${url}] ${errorCode}: ${errorText}`));
    });
    pc.addEventListener('track', (e) => {
        trace('ontrack', makeEvent(`${e.track.kind}:${e.track.id} ${e.streams
            .map((stream) => `stream:${stream.id}`)
            .join(' ')}`));
    });
    pc.addEventListener('signalingstatechange', () => {
        trace('onsignalingstatechange', makeEvent(pc.signalingState));
    });
    pc.addEventListener('iceconnectionstatechange', () => {
        trace('oniceconnectionstatechange', makeEvent(pc.iceConnectionState));
    });
    pc.addEventListener('icegatheringstatechange', () => {
        trace('onicegatheringstatechange', makeEvent(pc.iceGatheringState));
    });
    pc.addEventListener('connectionstatechange', () => {
        trace('onconnectionstatechange', makeEvent(pc.connectionState));
    });
    pc.addEventListener('negotiationneeded', () => {
        trace('onnegotiationneeded', makeEvent('negotiationneeded'));
    });
    pc.addEventListener('datachannel', (event) => {
        trace('ondatachannel', makeEvent(`${event.channel.id}: ${event.channel.label}`));
    });
    ['close'].forEach((method) => {
        // @ts-ignore
        const nativeMethod = origPeerConnection.prototype[method];
        if (nativeMethod) {
            // @ts-ignore
            origPeerConnection.prototype[method] = function () {
                trace(`on${method}`, makeEvent(method));
                return nativeMethod.apply(this, arguments);
            };
        }
    });
    ['createDataChannel'].forEach((method) => {
        // @ts-ignore
        const nativeMethod = origPeerConnection.prototype[method];
        if (nativeMethod) {
            // @ts-ignore
            origPeerConnection.prototype[method] = function () {
                trace(`on${method}`, makeEvent(method));
                const dataChannel = nativeMethod.apply(this, arguments);
                dataChannel.addEventListener('open', () => {
                    trace(`ondataChannelOpen`, makeEvent(`${dataChannel.id}:${dataChannel.label}`));
                });
                dataChannel.addEventListener('close', () => {
                    trace(`ondataChannelClose`, makeEvent(`${dataChannel.id}:${dataChannel.label}`));
                });
                dataChannel.addEventListener('error', (event) => {
                    const { error } = event;
                    trace(`ondataChannelError`, makeEvent(`${dataChannel.id}:${dataChannel.label}: ${error.errorDetail}`));
                });
                return dataChannel;
            };
        }
    });
    ['addStream', 'removeStream'].forEach((method) => {
        // @ts-ignore
        const nativeMethod = origPeerConnection.prototype[method];
        if (nativeMethod) {
            // @ts-ignore
            origPeerConnection.prototype[method] = function () {
                const stream = arguments[0];
                const streamInfo = stream
                    .getTracks()
                    .map((t) => `${t.kind}:${t.id}`)
                    .join(',');
                trace(`on${method}`, makeEvent(`${stream.id} ${streamInfo}`));
                return nativeMethod.apply(this, arguments);
            };
        }
    });
    ['addTrack'].forEach((method) => {
        // @ts-ignore
        const nativeMethod = origPeerConnection.prototype[method];
        if (nativeMethod) {
            // @ts-ignore
            origPeerConnection.prototype[method] = function () {
                const track = arguments[0];
                const streams = [].slice.call(arguments, 1);
                trace(`on${method}`, makeEvent(`${track.kind}:${track.id} ${streams.map((s) => `stream:${s.id}`).join(';') || '-'}`));
                return nativeMethod.apply(this, arguments);
            };
        }
    });
    ['removeTrack'].forEach((method) => {
        // @ts-ignore
        const nativeMethod = origPeerConnection.prototype[method];
        if (nativeMethod) {
            // @ts-ignore
            origPeerConnection.prototype[method] = function () {
                const track = arguments[0].track;
                trace(`on${method}`, makeEvent(track ? `${track.kind}:${track.id}` : 'null'));
                return nativeMethod.apply(this, arguments);
            };
        }
    });
    ['createOffer', 'createAnswer'].forEach((method) => {
        // @ts-ignore
        const nativeMethod = origPeerConnection.prototype[method];
        if (nativeMethod) {
            // @ts-ignore
            origPeerConnection.prototype[method] = function () {
                let opts;
                const args = arguments;
                if (arguments.length === 1 && typeof arguments[0] === 'object') {
                    opts = arguments[0];
                }
                else if (arguments.length === 3 && typeof arguments[2] === 'object') {
                    opts = arguments[2];
                }
                trace(`on${method}`, makeEvent(opts || ''));
                return nativeMethod.apply(this, opts ? [opts] : undefined).then(
                // @ts-ignore
                (description) => {
                    trace(`on${method}OnSuccess`, makeEvent(description.sdp));
                    if (args.length > 0 && typeof args[0] === 'function') {
                        args[0].apply(null, [description]);
                        return undefined;
                    }
                    return description;
                }, (err) => {
                    trace(`on${method}OnFailure`, makeEvent(err.toString()));
                    if (args.length > 1 && typeof args[1] === 'function') {
                        args[1].apply(null, [err]);
                        return;
                    }
                    throw err;
                });
            };
        }
    });
    ['setLocalDescription', 'setRemoteDescription', 'addIceCandidate'].forEach((method) => {
        // @ts-ignore
        const nativeMethod = origPeerConnection.prototype[method];
        if (nativeMethod) {
            // @ts-ignore
            origPeerConnection.prototype[method] = function () {
                const args = arguments;
                trace(`on${method}`, makeEvent(method === 'addIceCandidate'
                    ? arguments[0]
                    : arguments[0]
                        ? arguments[0].sdp
                        : 'undefined'));
                return nativeMethod.apply(this, [arguments[0]]).then(() => {
                    var _a;
                    trace(`on${method}OnSuccess`, makeEvent('success'));
                    if (method.endsWith('Description')) {
                        // @ts-ignore
                        if (!this.transportEventsPreviouslyAdded) {
                            const senders = this.getSenders();
                            for (const sender of senders) {
                                if (sender.transport) {
                                    sender.transport.addEventListener('statechange', () => {
                                        if (sender && sender.transport) {
                                            trace(`ondtlsStateChange`, makeEvent(sender.transport.state));
                                        }
                                    });
                                    sender.transport.addEventListener('error', (error) => {
                                        const errorEvent = error;
                                        trace(`ondtlsError`, makeEvent(errorEvent.error.errorDetail));
                                    });
                                    if (sender.transport.iceTransport) {
                                        sender.transport.iceTransport.addEventListener('selectedcandidatepairchange', () => {
                                            var _a, _b, _c, _d, _e, _f;
                                            if (sender.transport && sender.transport.iceTransport) {
                                                const pair = sender.transport.iceTransport.getSelectedCandidatePair();
                                                const localCandidate = `${(_a = pair === null || pair === void 0 ? void 0 : pair.local) === null || _a === void 0 ? void 0 : _a.address}:${(_b = pair === null || pair === void 0 ? void 0 : pair.local) === null || _b === void 0 ? void 0 : _b.port}/${(_c = pair === null || pair === void 0 ? void 0 : pair.local) === null || _c === void 0 ? void 0 : _c.protocol}`;
                                                const remoteCandidate = `${(_d = pair === null || pair === void 0 ? void 0 : pair.remote) === null || _d === void 0 ? void 0 : _d.address}:${(_e = pair === null || pair === void 0 ? void 0 : pair.remote) === null || _e === void 0 ? void 0 : _e.port}/${(_f = pair === null || pair === void 0 ? void 0 : pair.remote) === null || _f === void 0 ? void 0 : _f.protocol}`;
                                                const pairString = `local: ${localCandidate}, remote: ${remoteCandidate}`;
                                                trace('onselectedCandidatePairChange', makeEvent(pairString));
                                            }
                                        });
                                    }
                                    // @ts-ignore
                                    this.transportEventsPreviouslyAdded = true;
                                    if (pc.getConfiguration().bundlePolicy === 'max-bundle') {
                                        break;
                                    }
                                }
                            }
                        }
                        // @ts-ignore
                        if (!this.sctpEventsPreviouslyAdded) {
                            // Some Firefox versions prior to 113 have sctp defined but not the events, so check both here.
                            if ((_a = this.sctp) === null || _a === void 0 ? void 0 : _a.addEventListener) {
                                this.sctp.addEventListener('statechange', () => {
                                    // @ts-ignore
                                    trace('onsctpStateChange', makeEvent(this.sctp.state));
                                });
                                // @ts-ignore
                                this.sctpEventsPreviouslyAdded = true;
                            }
                        }
                    }
                    if (args.length >= 2 && typeof args[1] === 'function') {
                        args[1].apply(null, []);
                        return undefined;
                    }
                    return undefined;
                }, (err) => {
                    trace(`on${method}OnFailure`, makeEvent(err.toString()));
                    if (args.length >= 3 && typeof args[2] === 'function') {
                        args[2].apply(null, [err]);
                        return undefined;
                    }
                    throw err;
                });
            };
        }
    });
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        const origGetUserMedia = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);
        const gum = function () {
            trace('onnavigator.mediaDevices.getUserMedia', makeEvent(JSON.stringify(arguments[0])));
            return origGetUserMedia
                .apply(navigator.mediaDevices, arguments)
                .then((stream) => {
                trace('onnavigator.mediaDevices.getUserMediaOnSuccess', makeEvent(JSON.stringify(dumpStream(stream))));
                return stream;
            }, (err) => {
                trace('onnavigator.mediaDevices.getUserMediaOnFailure', makeEvent(err.name));
                return Promise.reject(err);
            });
        };
        navigator.mediaDevices.getUserMedia = gum.bind(navigator.mediaDevices);
    }
    if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
        const origGetDisplayMedia = navigator.mediaDevices.getDisplayMedia.bind(navigator.mediaDevices);
        const gdm = function () {
            trace('onnavigator.mediaDevices.getDisplayMedia', makeEvent(JSON.stringify(arguments[0])));
            return origGetDisplayMedia
                .apply(navigator.mediaDevices, arguments)
                .then((stream) => {
                trace('onnavigator.mediaDevices.getDisplayMediaOnSuccess', makeEvent(JSON.stringify(dumpStream(stream))));
                return stream;
            }, (err) => {
                trace('onnavigator.mediaDevices.getDisplayMediaOnFailure', makeEvent(err.name));
                return Promise.reject(err);
            });
        };
        navigator.mediaDevices.getDisplayMedia = gdm.bind(navigator.mediaDevices);
    }
    const getStatsReport = async () => pc.getStats(null).then((res) => {
        // Convert from stats report to js Map in order to have values set in `statsPreProcessor`
        const statsMap = new Map();
        res.forEach((stats, key) => statsMap.set(key, stats));
        return statsPreProcessor(statsMap).then(() => {
            const now = map2obj(statsMap);
            const base = deepCopy(now); // our new prev
            const compressed = deltaCompression(prev, now);
            trace('stats-report', formatStatsReport(compressed), compressed.timestamp !== -Infinity ? compressed.timestamp : undefined);
            prev = base;
            return Promise.resolve();
        });
    });
    const interval = window.setInterval(() => {
        if (pc.signalingState === 'closed') {
            window.clearInterval(interval);
            return;
        }
        getStatsReport();
    }, intervalTime);
    const forceStatsReport = async () => {
        return getStatsReport();
    };
    return { forceStatsReport };
};
