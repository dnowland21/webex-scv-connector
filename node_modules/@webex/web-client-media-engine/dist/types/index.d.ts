import { LocalStream, ConnectionState, ConnectionType, media } from '@webex/webrtc-core';
export { AudioDeviceConstraints, ConnectionState, ConnectionType, LocalCameraStream, LocalDisplayStream, LocalMicrophoneStream, LocalStream, LocalStreamEventNames, LocalSystemAudioStream, MediaStreamTrackKind, PeerConnection, RemoteMediaState, RemoteStream, RemoteStreamEventNames, StreamEventNames, VideoContentHint, VideoDeviceConstraints, Logger as WebRtcCoreLogger, WebrtcCoreError, WebrtcCoreErrorType, createCameraAndMicrophoneStreams, createCameraStream, createDisplayMedia, createDisplayStream, createDisplayStreamWithAudio, createMicrophoneStream, getAudioInputDevices, getAudioOutputDevices, getDevices, getVideoInputDevices, setOnDeviceChangeHandler } from '@webex/webrtc-core';
import { SsrcStreamId, StreamState, MediaContent, MediaType, NamedMediaGroup, Policy, PolicySpecificInfo, CodecInfo, StreamRequest as StreamRequest$1 } from '@webex/json-multistream';
export { ActiveSpeakerInfo, CodecInfo, H264Codec, Logger as JMPLogger, MediaContent, MediaFamily, MediaType, NamedMediaGroup, Policy, PolicySpecificInfo, ReceiverSelectedInfo, StreamState, getMediaContent, getMediaFamily, getMediaType } from '@webex/json-multistream';
import { LoggerCallback } from '@webex/rtcstats';
export { LogData, LoggerCallback as MetricsCallback } from '@webex/rtcstats';
import TypedEmitter, { EventMap } from 'typed-emitter';
import { TypedEvent } from '@webex/ts-events';
import { AvMediaDescription } from '@webex/ts-sdp';
import { ILogLevel, ILogHandler } from 'js-logger';
export { ILogHandler, default as Logger } from 'js-logger';

declare enum MediaCodecMimeType {
    H264 = "video/H264",
    AV1 = "video/AV1",
    OPUS = "audio/opus"
}
type EncodingParams = {
    maxPayloadBitsPerSecond?: number;
    maxFs?: number;
    maxWidth?: number;
    maxHeight?: number;
};
declare enum RecommendedOpusBitrates {
    NB = 12000,
    WB = 20000,
    FB = 40000,
    FB_MONO_MUSIC = 64000,
    FB_STEREO_MUSIC = 128000
}
declare function getRecommendedMaxBitrateForFrameSize(requestedMaxFs: number): number;

declare enum WcmeErrorType {
    CREATE_OFFER_FAILED = "CREATE_OFFER_FAILED",
    SET_ANSWER_FAILED = "SET_ANSWER_FAILED",
    OFFER_ANSWER_MISMATCH = "OFFER_ANSWER_MISMATCH",
    SDP_MUNGE_FAILED = "SDP_MUNGE_FAILED",
    SDP_MUNGE_MISSING_CODECS = "SDP_MUNGE_MISSING_CODECS",
    INVALID_STREAM_REQUEST = "INVALID_STREAM_REQUEST",
    GET_TRANSCEIVER_FAILED = "GET_TRANSCEIVER_FAILED",
    GET_MAX_BITRATE_FAILED = "GET_MAX_BITRATE_FAILED",
    GET_PAYLOAD_TYPE_FAILED = "GET_PAYLOAD_TYPE_FAILED",
    SET_NMG_FAILED = "SET_NMG_FAILED",
    DATA_CHANNEL_SEND_FAILED = "DATA_CHANNEL_SEND_FAILED"
}
declare class WcmeError {
    type: string;
    message: string;
    constructor(type: WcmeErrorType, message?: string);
}

declare const EventEmitter_base: new <TT extends EventMap>() => TypedEmitter<TT>;
declare class EventEmitter<T extends EventMap> extends EventEmitter_base<T> {
}

declare enum OveruseState {
    NOT_OVERUSED = 0,
    OVERUSED = 1
}

type OveruseUpdateCallback = (state: OveruseState) => void;

type ReceiveSlotId = SsrcStreamId;
declare function areReceiveSlotIdsEqual(id1: ReceiveSlotId, id2: ReceiveSlotId): boolean;
declare enum ReceiveSlotEvents {
    MediaStarted = "media-started",
    MediaStopped = "media-stopped",
    MediaEnded = "media-ended",
    SourceUpdate = "source-update"
}
interface ReceiverEvents extends EventMap {
    [ReceiveSlotEvents.MediaStarted]: () => void;
    [ReceiveSlotEvents.MediaStopped]: () => void;
    [ReceiveSlotEvents.MediaEnded]: () => void;
    [ReceiveSlotEvents.SourceUpdate]: (state: StreamState, csi?: number) => void;
}
declare class ReceiveSlot extends EventEmitter<ReceiverEvents> {
    static Events: typeof ReceiveSlotEvents;
    private _idGetter;
    private _stream;
    private _sourceState?;
    private _currentRxCsi?;
    constructor(idGetter: () => ReceiveSlotId | null, track: MediaStreamTrack);
    private handleStreamMediaStateChange;
    private handleStreamEnded;
    _replaceTrack(newTrack: MediaStreamTrack): void;
    _updateSource(state: StreamState, csi?: number): void;
    close(): void;
    get id(): ReceiveSlotId | null;
    get stream(): MediaStream;
    get currentRxCsi(): number | undefined;
    get sourceState(): StreamState | undefined;
}

declare class EgressSdpMunger {
    private streamIds;
    private customCodecParameters;
    reset(): void;
    mungeLocalDescription(mediaDescription: AvMediaDescription, options: {
        simulcastEnabled: boolean;
        rtxEnabled: boolean;
        twccDisabled: boolean;
        forceSoftwareEncoder: boolean;
    }): void;
    mungeLocalDescriptionForRemoteServer(mediaDescription: AvMediaDescription, mediaContent: MediaContent, csi: number, mungeOptions?: {
        injectDummyCandidates: boolean;
    }): void;
    mungeRemoteDescription(mediaDescription: AvMediaDescription): void;
    getSenderIds(): SsrcStreamId[];
    getEncodingIndexForStreamId(streamId: SsrcStreamId): number;
    setCodecParameters(parameters: {
        [key: string]: string | undefined;
    }): void;
    deleteCodecParameters(parameters: string[]): void;
}

type StatsMap = Map<string, any>;

declare abstract class Transceiver {
    protected _rtcRtpTransceiver: RTCRtpTransceiver;
    mid: string;
    protected mediaType: MediaType;
    twccDisabled: boolean;
    constructor(config: {
        rtcRtpTransceiver: RTCRtpTransceiver;
        mid: string;
        mediaType: MediaType;
    });
    replaceTransceiver(newRtcRtpTransceiver: RTCRtpTransceiver): void;
    protected get receiver(): RTCRtpReceiver;
    protected get sender(): RTCRtpSender;
    close(): void;
    abstract resetSdpMunger(): void;
}

declare enum OfferAnswerType {
    LocalOnly = 0,
    Remote = 1
}
declare class SendOnlyTransceiver extends Transceiver {
    publishedStream?: LocalStream;
    csi: number;
    private direction;
    private munger;
    rtxEnabled: boolean;
    streamMuteStateChange: TypedEvent<() => void>;
    streamPublishStateChange: TypedEvent<() => void>;
    negotiationNeeded: TypedEvent<(offerAnswerType: OfferAnswerType) => void>;
    namedMediaGroupsChange: TypedEvent<() => void>;
    private requestedIdEncodingParamsMap;
    namedMediaGroups?: NamedMediaGroup[];
    private updateSendParametersQueue;
    private sourceStateOverride?;
    sourceStateOverrideChange: TypedEvent<() => void>;
    metadata: {
        lastRequestedUpdateTimestampsMap: Map<number, number>;
    };
    constructor(config: {
        rtcRtpTransceiver: RTCRtpTransceiver;
        mid: string;
        mediaType: MediaType;
        munger: EgressSdpMunger;
        csi: number;
    });
    private replaceSenderSource;
    private handleTrackChange;
    private handleStreamConstraintsChange;
    private handleStreamMuteStateChange;
    get requested(): boolean;
    replaceTransceiver(newRtcRtpTransceiver: RTCRtpTransceiver): Promise<void>;
    private replacePublishedStream;
    setNamedMediaGroups(namedMediaGroups?: NamedMediaGroup[]): void;
    publishStream(stream: LocalStream): Promise<void>;
    unpublishStream(): Promise<void>;
    get active(): boolean;
    set active(enabled: boolean);
    getStats(): Promise<StatsMap>;
    updateSendParameters(requestedIdEncodingParamsMap: Map<number, EncodingParams>): Promise<void>;
    private isSimulcastEnabled;
    mungeLocalDescription(mediaDescription: AvMediaDescription): void;
    mungeLocalDescriptionForRemoteServer(mediaDescription: AvMediaDescription, mungeOptions?: {
        injectDummyCandidates: boolean;
    }): void;
    mungeRemoteDescription(mediaDescription: AvMediaDescription): void;
    get senderIds(): SsrcStreamId[];
    get numActiveSimulcastLayers(): number | undefined;
    getEncodingIndexForStreamId(id: SsrcStreamId): number;
    resetSdpMunger(): void;
    setCodecParameters(parameters: {
        [key: string]: string | undefined;
    }): void;
    deleteCodecParameters(parameters: string[]): void;
    setSourceStateOverride(state?: StreamState): void;
    get currentSourceState(): StreamState;
}

declare class SendSlot {
    private sendTransceiver;
    constructor(sendTransceiver: SendOnlyTransceiver);
    publishStream(stream: LocalStream): Promise<void>;
    unpublishStream(): Promise<void>;
    setNamedMediaGroups(namedMediaGroups: NamedMediaGroup[]): void;
    clearNamedMediaGroups(): void;
    get active(): boolean;
    set active(active: boolean);
    setCodecParameters(parameters: {
        [key: string]: string | undefined;
    }): Promise<void>;
    deleteCodecParameters(parameters: string[]): Promise<void>;
    setSourceStateOverride(state: StreamState): void;
    clearSourceStateOverride(): void;
}

declare class StreamRequest {
    policy: Policy;
    policySpecificInfo: PolicySpecificInfo;
    receiveSlots: ReceiveSlot[];
    maxPayloadBitsPerSecond: number;
    codecInfos: CodecInfo[];
    constructor(policy: Policy, policySpecificInfo: PolicySpecificInfo, receiveSlots: ReceiveSlot[], maxPayloadBitsPerSecond: number, codecInfos?: CodecInfo[]);
    _toJmpStreamRequest(): StreamRequest$1;
}

interface TransceiverStatItem {
    report: StatsMap | RTCStatsReport;
    currentDirection: RTCRtpTransceiverDirection | null;
    csi?: number;
    mid?: string | null;
    localTrackLabel?: string;
}
interface TransceiverStats {
    audio: {
        senders: TransceiverStatItem[];
        receivers: TransceiverStatItem[];
    };
    video: {
        senders: TransceiverStatItem[];
        receivers: TransceiverStatItem[];
    };
    screenShareAudio: {
        senders: TransceiverStatItem[];
        receivers: TransceiverStatItem[];
    };
    screenShareVideo: {
        senders: TransceiverStatItem[];
        receivers: TransceiverStatItem[];
    };
}

type BundlePolicy = 'max-bundle' | 'max-compat';

declare enum MultistreamConnectionEventNames {
    VideoSourceCountUpdate = "video-source-count-update",
    AudioSourceCountUpdate = "audio-source-count-update",
    ActiveSpeakerNotification = "active-speaker-notification",
    PeerConnectionStateUpdate = "peer-connection-state-update",
    IceConnectionStateUpdate = "ice-connection-state-update",
    IceGatheringStateUpdate = "ice-gathering-state-update",
    NegotiationNeeded = "negotiation-needed",
    CreateOfferOnSuccess = "createofferonsuccess",
    CreateAnswerOnSuccess = "createansweronsuccess",
    SetLocalDescriptionOnSuccess = "setlocaldescriptiononsuccess",
    SetRemoteDescriptionOnSuccess = "setremotedescriptiononsuccess",
    IceCandidate = "icecandidate",
    IceCandidateError = "icecandidateerror"
}
interface MultistreamConnectionEvents extends EventMap {
    [MultistreamConnectionEventNames.ActiveSpeakerNotification]: (csis: number[]) => void;
    [MultistreamConnectionEventNames.VideoSourceCountUpdate]: (numTotalSources: number, numLiveSources: number, mediaContent: MediaContent) => void;
    [MultistreamConnectionEventNames.AudioSourceCountUpdate]: (numTotalSources: number, numLiveSources: number, mediaContent: MediaContent) => void;
    [MultistreamConnectionEventNames.PeerConnectionStateUpdate]: (state: RTCPeerConnectionState) => void;
    [MultistreamConnectionEventNames.IceConnectionStateUpdate]: (state: RTCIceConnectionState) => void;
    [MultistreamConnectionEventNames.IceGatheringStateUpdate]: (state: RTCIceGatheringState) => void;
    [MultistreamConnectionEventNames.NegotiationNeeded]: () => void;
    [MultistreamConnectionEventNames.CreateAnswerOnSuccess]: (answer: RTCSessionDescriptionInit) => void;
    [MultistreamConnectionEventNames.CreateOfferOnSuccess]: (offer: RTCSessionDescriptionInit) => void;
    [MultistreamConnectionEventNames.SetLocalDescriptionOnSuccess]: (description: RTCSessionDescriptionInit) => void;
    [MultistreamConnectionEventNames.SetRemoteDescriptionOnSuccess]: (description: RTCSessionDescriptionInit) => void;
    [MultistreamConnectionEventNames.IceCandidate]: (event: RTCPeerConnectionIceEvent) => void;
    [MultistreamConnectionEventNames.IceCandidateError]: (error: RTCPeerConnectionIceErrorEvent) => void;
}
type MultistreamConnectionOptions = {
    disableSimulcast: boolean;
    bundlePolicy: BundlePolicy;
    iceServers: RTCIceServer[] | undefined;
    iceTransportPolicy: RTCIceTransportPolicy;
    disableContentSimulcast: boolean;
    disableAudioTwcc: boolean;
    doFullIce: boolean;
    metricsCallback: LoggerCallback;
};
declare class MultistreamConnection extends EventEmitter<MultistreamConnectionEvents> {
    private pc;
    private sendTransceivers;
    private recvTransceivers;
    private dataChannel;
    private jmpSessions;
    private pendingJmpTasks;
    private statsManager;
    private metricsCallback;
    private forceStatsReport?;
    private overuseStateManager;
    private overuseUpdateCallback;
    private options;
    private midPredictor;
    private offerAnswerQueue;
    private currentCreateOfferId;
    private setAnswerResolve?;
    constructor(userOptions?: Partial<MultistreamConnectionOptions>);
    private initializePeerConnection;
    private propagatePeerConnectionEvents;
    getConnectionState(): ConnectionState;
    getPeerConnectionState(): RTCPeerConnectionState;
    getIceConnectionState(): RTCIceConnectionState;
    getCurrentConnectionType(): Promise<ConnectionType>;
    getIceGatheringState(): RTCIceGatheringState;
    private getVideoEncodingOptions;
    private createSendTransceiver;
    createSendSlot(mediaType: MediaType, active?: boolean): SendSlot;
    private createJmpSession;
    private updateRequestedStreams;
    private createDataChannel;
    close(): void;
    private sendMediaRequestStatus;
    sendSourceAdvertisement(mediaType: MediaType): void;
    private getVideoStreamStates;
    private createReceiveTransceiver;
    createReceiveSlot(mediaType: MediaType): Promise<ReceiveSlot>;
    createReceiveSlots(mediaType: MediaType, count?: number): Promise<ReceiveSlot[]>;
    getIngressPayloadType(mediaType: MediaType, mimeType: MediaCodecMimeType): number;
    waitForIceGatheringComplete(): Promise<void>;
    createOffer(): Promise<RTCSessionDescriptionInit>;
    setAnswer(answer: string): Promise<void>;
    private doLocalOfferAnswer;
    private queueLocalOfferAnswer;
    private preProcessLocalOffer;
    private prepareLocalOfferForRemoteServer;
    private preProcessRemoteAnswer;
    private getSendTransceiverOrThrow;
    private getSendTransceiverByMidOrThrow;
    private getRecvTransceiverByMidOrThrow;
    requestMedia(mediaType: MediaType, streamRequests: StreamRequest[]): void;
    renewPeerConnection(userOptions?: Partial<MultistreamConnectionOptions>): void;
    private getReceiveSlotById;
    getStats(): Promise<StatsMap>;
    getTransceiverStats(): Promise<TransceiverStats>;
    private preProcessStats;
    private attachMetricsObserver;
    forceRtcMetricsCallback(): void | undefined;
    setOveruseUpdateCallback(callback: OveruseUpdateCallback): void;
    getCsiByMediaType(mediaType: MediaType): number | undefined;
    getAllCsis(): Record<string, number | undefined>;
}

declare function setLogLevel(level: ILogLevel): void;
declare function getLogLevel(): ILogLevel;
declare function logErrorAndThrow(errorType: WcmeErrorType, message: string): never;
declare function setLogHandler(logHandler: ILogHandler): void;

declare const DeviceKind: typeof media.DeviceKind;
//# sourceMappingURL=index.d.ts.map

export { DeviceKind, MediaCodecMimeType, MultistreamConnection, MultistreamConnectionEventNames, MultistreamConnectionEvents, ReceiveSlot, ReceiveSlotEvents, ReceiveSlotId, ReceiverEvents, RecommendedOpusBitrates, SendSlot, StatsMap, StreamRequest, TransceiverStatItem, TransceiverStats, WcmeError, WcmeErrorType, areReceiveSlotIdsEqual, getLogLevel, getRecommendedMaxBitrateForFrameSize, logErrorAndThrow, setLogHandler, setLogLevel };
