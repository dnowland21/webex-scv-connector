var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as ort from 'onnxruntime-web';
import { sharedResourceManager } from './shared-resource-manager';
export class LocalGenerator {
    constructor(config) {
        this.config = config;
        this.lastMaskGenerationTime = 0;
        this.lastMask = new ort.Tensor('float32', new Float32Array(this.config.mask.output_size.height * this.config.mask.output_size.width), [1, 1, this.config.mask.output_size.height, this.config.mask.output_size.width]);
        this.lastResult = {
            data: this.lastMask.data,
            facesAndLandmarks: { data: new Float32Array(0), dims: [] },
            gesture: new Float32Array(0),
            motion: 0,
            timestamp: 0,
            warm: false,
        };
    }
    /**
     * This method preprocesses an input Uint8ClampedArray to a Float32Array
     * while maintaining memory efficiency by reusing a class-scoped output buffer.
     * If the model rank is 4 (e.g., newer tiny model), it sets an alpha channel value.
     *
     * @param {Uint8ClampedArray} input - The input data to be preprocessed
     * @param {Float32Array} alpha - The alpha channel data
     * @returns {Float32Array} - The processed data
     */
    preprocess(input, alpha) {
        var _a;
        const { model_rank, input_size, output_size } = this.config.mask;
        const { height, width } = input_size;
        const numImagePixels = height * width;
        // Initialize the output buffer if it is not already set
        (_a = this.output) !== null && _a !== void 0 ? _a : (this.output = new Float32Array(numImagePixels * model_rank));
        // In-place modification of class-scoped output buffer
        const channelFlipOffset = 2;
        const numInputPixels = input.length / 4;
        // Loop over all color channels in the image
        for (let channel = 0; channel < 3; channel++) {
            // For each pixel in the input image...
            for (let pixel = 0; pixel < numInputPixels; pixel++) {
                // ...copy the color channel value from input to output, potentially
                // potentially flipping the color channel order for the tiny.
                this.output[pixel + channel * numImagePixels] =
                    input[pixel * 4 + Math.abs(channelFlipOffset - channel)];
            }
        }
        // Scaling factors for width and height based on the ratio of output to input sizes
        const widthScale = output_size.width / width;
        const heightScale = output_size.height / height;
        // Iterate over each pixel in the width of the input image
        for (let x = 0; x < width; x++) {
            const nearestNeighborX = Math.floor(x * widthScale);
            // Iterate over each pixel in the height of the input image
            for (let y = 0; y < height; y++) {
                const nearestNeighborY = Math.floor(y * heightScale);
                const maskIdx = nearestNeighborX + nearestNeighborY * output_size.width;
                const outputIdx = x + y * width + 3 * numImagePixels;
                // Normalize the alpha value to range between 0 and 1, and scale it to the range of 0-255
                // This step is necessary because the rendering pipeline expects alpha values in the [0, 255] range
                const normalizedValue = Math.min(Math.max(alpha[maskIdx], 0), 255);
                // Assign the normalized value to the output at the computed index
                this.output[outputIdx] = normalizedValue;
            }
        }
        return this.output;
    }
    getTimeSinceLastGeneration() {
        return Date.now() - this.lastMaskGenerationTime;
    }
    getLadonOutput(input, timestamp) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.maskModel) {
                throw new Error('[ladon-ts] - mask model not loaded.');
            }
            if (this.getTimeSinceLastGeneration() < this.config.mask.generation_interval_ms) {
                return {
                    data: this.lastMask.data,
                    facesAndLandmarks: this.lastResult.facesAndLandmarks,
                    gesture: this.lastResult.gesture,
                    motion: this.lastResult.motion,
                    timestamp: this.lastResult.timestamp,
                    warm: false,
                };
            }
            this.lastMaskGenerationTime = Date.now();
            const imageTensor = new ort.Tensor('float32', this.preprocess(input, this.lastMask.data), [
                1,
                this.config.mask.model_rank,
                this.config.mask.input_size.height,
                this.config.mask.input_size.width,
            ]);
            const results = yield this.maskModel.run({ input: imageTensor });
            this.lastMask = results.segmentation;
            this.lastResult = {
                data: (_a = this.lastMask.data) !== null && _a !== void 0 ? _a : new Float32Array(0),
                facesAndLandmarks: {
                    data: (_c = (_b = results.faces_and_landmarks) === null || _b === void 0 ? void 0 : _b.data) !== null && _c !== void 0 ? _c : new Float32Array(0),
                    dims: (_e = (_d = results.faces_and_landmarks) === null || _d === void 0 ? void 0 : _d.dims) !== null && _e !== void 0 ? _e : [],
                },
                gesture: (_g = (_f = results.gesture) === null || _f === void 0 ? void 0 : _f.data) !== null && _g !== void 0 ? _g : new Float32Array(0),
                motion: (_j = (_h = results.motion) === null || _h === void 0 ? void 0 : _h.data[0]) !== null && _j !== void 0 ? _j : 0,
                timestamp,
                warm: true,
            };
            return this.lastResult;
        });
    }
    load() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const modelUrl = yield sharedResourceManager.getModelUrl(this.config);
            // Attempt to retrieve a preloaded InferenceSession from the shared resource manager.
            this.maskModel = sharedResourceManager.getModelSession(modelUrl);
            // If the model is not preloaded, load it from the provided model URL.
            (_a = this.maskModel) !== null && _a !== void 0 ? _a : (this.maskModel = yield sharedResourceManager.preloadModel(this.config));
            if (!this.maskModel) {
                throw new Error('Failed to load the ONNX model.');
            }
        });
    }
    isLoaded() {
        return !!this.maskModel;
    }
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    postRender(_) {
        return __awaiter(this, void 0, void 0, function* () {
            // empty for local generator
        });
    }
    destroy() {
        // empty for local generator
    }
}
export class NullGenerator {
    constructor(config) {
        this.config = config;
        this.lastMask = new Float32Array(this.config.mask.output_size.height * this.config.mask.output_size.width);
    }
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    getLadonOutput(_) {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                data: this.lastMask,
                facesAndLandmarks: { data: new Float32Array(0), dims: [] },
                gesture: new Float32Array(0),
                motion: 0,
                timestamp: 0,
                warm: false,
            };
        });
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            // empty for null generator
        });
    }
    isLoaded() {
        return true;
    }
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    postRender(_) {
        return __awaiter(this, void 0, void 0, function* () {
            // empty for null generator
        });
    }
    destroy() {
        // empty for null generator
    }
}
export class WorkerGenerator {
    constructor(config) {
        this.config = config;
        this.newMask = true;
        this.lastMask = new Float32Array(this.config.mask.output_size.height * this.config.mask.output_size.width);
        this.lastResult = {
            data: this.lastMask,
            facesAndLandmarks: { data: new Float32Array(0), dims: [] },
            gesture: new Float32Array(0),
            motion: 0,
            timestamp: 0,
            warm: false,
        };
    }
    /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
    getLadonOutput(_) {
        return __awaiter(this, void 0, void 0, function* () {
            const toReturn = {
                data: this.lastMask,
                facesAndLandmarks: this.lastResult.facesAndLandmarks,
                gesture: this.lastResult.gesture,
                motion: this.lastResult.motion,
                timestamp: this.lastResult.timestamp,
                warm: this.newMask,
            };
            this.newMask = false;
            return toReturn;
        });
    }
    load() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            this.worker = sharedResourceManager.getWorker();
            (_a = this.worker) !== null && _a !== void 0 ? _a : (this.worker = yield sharedResourceManager.initializeWorker(this.config));
            if (!this.worker) {
                throw new Error('[ladon-ts] - worker is not defined.');
            }
            const modelUrl = yield sharedResourceManager.getModelUrl(this.config);
            const workerConfig = {
                base_url: this.config.base_url,
                input: this.config.input,
                mask: Object.assign(Object.assign({}, this.config.mask), { model_url_resolver: modelUrl }),
                wasm_uri: this.config.wasm_uri,
                render: { type: 'passthrough' },
            };
            this.worker.postMessage({ type: 'init', config: workerConfig });
            let resolutionCb;
            const result = new Promise((resolve) => {
                resolutionCb = resolve;
            });
            this.worker.onmessage = (event) => {
                if (event.data.status === 'generated') {
                    this.lastMask = event.data.mask;
                    this.lastResult = {
                        data: event.data.mask,
                        facesAndLandmarks: event.data.facesAndLandmarks,
                        gesture: event.data.gesture,
                        motion: event.data.motion,
                        timestamp: event.data.timestamp,
                        warm: true,
                    };
                    this.newMask = true;
                }
                else {
                    const workerUrl = sharedResourceManager.getWorkerUrl();
                    if (workerUrl) {
                        URL.revokeObjectURL(workerUrl);
                    }
                    resolutionCb === null || resolutionCb === void 0 ? void 0 : resolutionCb();
                }
            };
            return result;
        });
    }
    isLoaded() {
        return !!this.worker;
    }
    postRender(input, timestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            // claim ownership of the input tensor's buffer and forward to worker
            if (!this.worker) {
                throw new Error('[ladon-ts] - worker is not defined.');
            }
            this.worker.postMessage({
                type: 'generate',
                image: input,
                timestamp,
            }, [input.buffer]);
        });
    }
    destroy() {
        sharedResourceManager.terminateWorker();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2xpYi9nZW5lcmF0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsT0FBTyxLQUFLLEdBQUcsTUFBTSxpQkFBaUIsQ0FBQztBQUd2QyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQStCbEUsTUFBTSxPQUFPLGNBQWM7SUFPdkIsWUFBNEIsTUFBc0I7UUFBdEIsV0FBTSxHQUFOLE1BQU0sQ0FBZ0I7UUFIMUMsMkJBQXNCLEdBQUcsQ0FBQyxDQUFDO1FBSS9CLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUMxQixTQUFTLEVBQ1QsSUFBSSxZQUFZLENBQ1osSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUMzRSxFQUNELENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FDbEYsQ0FBQztRQUNGLElBQUksQ0FBQyxVQUFVLEdBQUc7WUFDZCxJQUFJLEVBQUUsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJO1lBQ3hCLGlCQUFpQixFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUU7WUFDMUQsT0FBTyxFQUFFLElBQUksWUFBWSxDQUFDLENBQUMsQ0FBQztZQUM1QixNQUFNLEVBQUUsQ0FBQztZQUNULFNBQVMsRUFBRSxDQUFDO1lBQ1osSUFBSSxFQUFFLEtBQUs7U0FDZCxDQUFDO0lBQ04sQ0FBQztJQUVEOzs7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