var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { LocalGenerator, NullGenerator, WorkerGenerator, } from './generator';
import { BlurRenderer, PassthroughRenderer, ReplacementRenderer } from './renderer';
import { resizeImage } from './util';
export class Pipeline {
    constructor(inputCanvas, outputCanvas, config, videoElement) {
        this.inputCanvas = inputCanvas;
        this.outputCanvas = outputCanvas;
        this.config = config;
        this.videoElement = videoElement;
        this.loaded = false;
        this.frameQueue = [];
        this.maskQueue = [];
        const inputCanvasCtx = this.inputCanvas.getContext('2d', {
            alpha: false,
            willReadFrequently: true,
        });
        if (!inputCanvasCtx) {
            throw new Error('[ladon-ts] - error getting input context 2d');
        }
        this.inputCanvasCtx = inputCanvasCtx;
    }
    /**
     * Processes a single frame and returns the inference result.
     *
     * @param timestamp - The timestamp of the frame.
     * @param [performInference=true] - Flag to perform mask inference.
     * @returns The result of the frame processing.
     * @throws If the pipeline (generator or renderer) is not loaded.
     */
    onFrame(timestamp, performInference = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.generator || !this.renderer) {
                throw new Error('[ladon-ts] - pipeline is not loaded.');
            }
            // Get the current frame (raw image data or video element)
            const frameData = this.getInputFrameData(performInference);
            // Add the frame to the queue with its timestamp
            this.frameQueue.push({ timestamp, frameData });
            if (performInference || !this.lastMaskResult) {
                // Perform inference and add the new mask to the mask queue
                const rawImageData = frameData;
                const maskImageData = this.getMaskImageData(rawImageData);
                const maskResult = yield this.generator.getLadonOutput(maskImageData, timestamp);
                // Add the mask to the queue and use the mask timestamp to sync frames and masks.
                this.maskQueue.push({ timestamp: maskResult.timestamp, maskResult });
                this.lastMaskResult = maskResult;
                // Sync frames and masks to render together
                yield this.renderSyncedFrameAndMask();
                // Post-process the mask after rendering
                yield this.generator.postRender(maskImageData, timestamp);
            }
            else {
                // Skipping inference. Update the last mask result's timestamp to match the current frame.
                this.maskQueue.push({ timestamp, maskResult: this.lastMaskResult });
                // Sync frames and masks to render together
                yield this.renderSyncedFrameAndMask();
            }
            // Return the inference result
            return this.createInferenceResult(timestamp, performInference);
        });
    }
    /**
     * Synchronizes frames and masks to ensure they are rendered together.
     */
    renderSyncedFrameAndMask() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            while (this.frameQueue.length > 0 && this.maskQueue.length > 0) {
                const frame = this.frameQueue[0];
                const maskEntry = this.maskQueue[0];
                if (frame.timestamp === maskEntry.timestamp) {
                    // Render the frame and mask together
                    yield ((_a = this.renderer) === null || _a === void 0 ? void 0 : _a.render(frame.frameData, maskEntry.maskResult));
                    this.frameQueue.shift();
                    this.maskQueue.shift();
                }
                else if (frame.timestamp < maskEntry.timestamp) {
                    // Discard the older frame
                    this.frameQueue.shift();
                }
                else {
                    // Discard the older mask
                    this.maskQueue.shift();
                }
            }
        });
    }
    /**
     * Gets the raw image data from the input canvas context.
     *
     * @param needFreshImageData - Flag to indicate if fresh image data is needed.
     *
     * @returns The raw image data.
     */
    getInputFrameData(needFreshImageData) {
        if (needFreshImageData || !this.videoElement) {
            return this.inputCanvasCtx.getImageData(0, 0, this.config.input.width, this.config.input.height).data;
        }
        return this.videoElement;
    }
    /**
     * Resizes the image data if the model expects a fixed size input.
     *
     * @param {Uint8ClampedArray} rawImageData - The raw image data.
     * @returns {Uint8ClampedArray} - The processed mask image data.
     */
    getMaskImageData(rawImageData) {
        // Check if resizing is needed based on configuration.
        if (this.config.mask.input_size.width === this.config.input.width) {
            return rawImageData;
        }
        // Resize the image data.
        return resizeImage(rawImageData, this.config.input.width, this.config.input.height, this.config.mask.input_size.width, this.config.mask.input_size.height);
    }
    /**
     * Creates the inference result object.
     *
     * @param {number} timestamp - The timestamp of the frame.
     * @param {boolean} performedInference - Indicates if the inference was performed.
     * @returns {IFrameInferenceResult} - The result object containing inference details.
     */
    createInferenceResult(timestamp, performedInference) {
        if (!this.lastMaskResult) {
            return {
                facesAndLandmarks: { data: new Float32Array(0), dims: [] },
                gesture: new Float32Array(0),
                motion: 0,
                skipped: true,
                timestamp,
            };
        }
        return {
            facesAndLandmarks: this.lastMaskResult.facesAndLandmarks,
            gesture: this.lastMaskResult.gesture,
            motion: this.lastMaskResult.motion,
            skipped: !performedInference,
            timestamp,
        };
    }
    /**
     * Checks if the pipeline is loaded.
     *
     * @returns True if the pipeline is loaded, false otherwise.
     */
    isLoaded() {
        return this.loaded;
    }
    /**
     * Loads the pipeline components such as the generator and renderer.
     */
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            switch (this.config.render.type) {
                case 'blur':
                    this.renderer = new BlurRenderer(this.outputCanvas, this.config);
                    break;
                case 'passthrough':
                    this.renderer = new PassthroughRenderer(this.outputCanvas, this.config);
                    break;
                case 'replacement':
                    this.renderer = new ReplacementRenderer(this.outputCanvas, this.config);
                    break;
                default:
                    throw new Error('[ladon-ts] - renderer not implemented.');
            }
            yield this.renderer.load();
            if (this.config.render.type === 'passthrough') {
                // automatically disable model evaluation when the renderer is set to passthrough
                // Note: this may change when gestures are detected (model eval will be a dependency for more than rendering)
                this.generator = new NullGenerator(this.config);
            }
            else {
                switch (this.config.mask.generator) {
                    case 'local':
                        this.generator = new LocalGenerator(this.config);
                        break;
                    case 'worker':
                        this.generator = new WorkerGenerator(this.config);
                        break;
                    default:
                        throw new Error('[ladon-ts] - generator not implemented.');
                }
            }
            yield this.generator.load();
            this.loaded = true;
        });
    }
    /**
     * Resets the frame and mask queues.
     */
    resetQueues() {
        this.frameQueue = [];
        this.maskQueue = [];
    }
    reset() {
        this.resetQueues();
        this.lastMaskResult = undefined;
    }
    /**
     * Destroys the pipeline and cleans up resources.
     */
    destroy() {
        var _a, _b;
        this.reset();
        (_a = this.generator) === null || _a === void 0 ? void 0 : _a.destroy();
        (_b = this.renderer) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGlwZWxpbmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3BpcGVsaW5lLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUNBLE9BQU8sRUFJSCxjQUFjLEVBRWQsYUFBYSxFQUNiLGVBQWUsR0FDbEIsTUFBTSxhQUFhLENBQUM7QUFDckIsT0FBTyxFQUFFLFlBQVksRUFBaUIsbUJBQW1CLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDbkcsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQXFCckMsTUFBTSxPQUFPLFFBQVE7SUFXakIsWUFDWSxXQUE4QixFQUM5QixZQUErQixFQUN2QixNQUFzQixFQUNyQixZQUErQjtRQUh4QyxnQkFBVyxHQUFYLFdBQVcsQ0FBbUI7UUFDOUIsaUJBQVksR0FBWixZQUFZLENBQW1CO1FBQ3ZCLFdBQU0sR0FBTixNQUFNLENBQWdCO1FBQ3JCLGlCQUFZLEdBQVosWUFBWSxDQUFtQjtRQVo1QyxXQUFNLEdBQUcsS0FBSyxDQUFDO1FBS2YsZUFBVSxHQUF1RCxFQUFFLENBQUM7UUFDcEUsY0FBUyxHQUEwRCxFQUFFLENBQUM7UUFRMUUsTUFBTSxjQUFjLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxVQUFVLENBQUMsSUFBSSxFQUFFO1lBQ3JELEtBQUssRUFBRSxLQUFLO1lBQ1osa0JBQWtCLEVBQUUsSUFBSTtTQUMzQixDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsY0FBYyxFQUFFO1lBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsNkNBQTZDLENBQUMsQ0FBQztTQUNsRTtRQUNELElBQUksQ0FBQyxjQUFjLEdBQUcsY0FBYyxDQUFDO0lBQ3pDLENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ1UsT0FBTyxDQUNoQixTQUFpQixFQUNqQixnQkFBZ0IsR0FBRyxJQUFJOztZQUV2QixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsSUFBSSxDQUFD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