import { WebexPlugin } from '@webex/webex-core';
import CallDiagnosticMetrics from './call-diagnostic/call-diagnostic-metrics';
import BehavioralMetrics from './behavioral-metrics';
import OperationalMetrics from './operational-metrics';
import BusinessMetrics from './business-metrics';
import { RecursivePartial, MetricEventProduct, MetricEventAgent, MetricEventVerb, ClientEvent, FeatureEvent, EventPayload, MediaQualityEvent, InternalEvent, SubmitClientEventOptions, Table, DelayedClientEvent } from './metrics.types';
import CallDiagnosticLatencies from './call-diagnostic/call-diagnostic-metrics-latencies';
/**
 * Metrics plugin to centralize all types of metrics.
 * https://confluence-eng-gpk2.cisco.com/conf/pages/viewpage.action?pageId=231011379
 * @class
 */
declare class Metrics extends WebexPlugin {
    static instance: Metrics;
    callDiagnosticLatencies: CallDiagnosticLatencies;
    callDiagnosticMetrics: CallDiagnosticMetrics;
    behavioralMetrics: BehavioralMetrics;
    operationalMetrics: OperationalMetrics;
    businessMetrics: BusinessMetrics;
    isReady: boolean;
    /**
     * Whether or not to delay the submission of client events.
     */
    delaySubmitClientEvents: boolean;
    /**
     * Overrides for delayed client events. E.g. if you want to override the correlationId for all delayed client events, you can set this to { correlationId: 'newCorrelationId' }
     */
    delayedClientEventsOverrides: Partial<DelayedClientEvent['options']>;
    /**
     * Constructor
     * @param args
     * @constructor
     * @private
     * @returns
     */
    constructor(...args: any[]);
    /**
     * On Ready
     */
    private onReady;
    /**
     * Used for internal purposes only
     * @param args
     */
    submitInternalEvent({ name, payload, options, }: {
        name: InternalEvent['name'];
        payload?: RecursivePartial<InternalEvent['payload']>;
        options?: any;
    }): void;
    /**
     * if webex metrics is ready, build behavioral metric backend if not already done.
     */
    private lazyBuildBehavioralMetrics;
    /**
     * if webex metrics is ready, build operational metric backend if not already done.
     */
    private lazyBuildOperationalMetrics;
    /**
     * if webex metrics is ready, build business metric backend if not already done.
     */
    private lazyBuildBusinessMetrics;
    /**
     * @returns true once we have the deviceId we need to submit behavioral events to Amplitude
     */
    isReadyToSubmitBehavioralEvents(): boolean;
    /**
     * @returns true once we have the deviceId we need to submit operational events
     */
    isReadyToSubmitOperationalEvents(): boolean;
    /**
     * @returns true once we have the deviceId we need to submit business events
     */
    isReadyToSubmitBusinessEvents(): boolean;
    /**
     * Behavioral event
     * @param args
     */
    submitBehavioralEvent({ product, agent, target, verb, payload, }: {
        product: MetricEventProduct;
        agent: MetricEventAgent;
        target: string;
        verb: MetricEventVerb;
        payload?: EventPayload;
    }): void | Promise<void>;
    /**
     * Operational event
     * @param args
     */
    submitOperationalEvent({ name, payload }: {
        name: string;
        payload?: EventPayload;
    }): void | Promise<void>;
    /**
     * Business event
     * @param args
     */
    submitBusinessEvent({ name, payload, table, metadata, }: {
        name: string;
        payload: EventPayload;
        table?: Table;
        metadata?: EventPayload;
    }): Promise<void>;
    /**
     * Call Analyzer: Media Quality Event
     * @param args
     */
    submitMQE({ name, payload, options, }: {
        name: MediaQualityEvent['name'];
        payload: RecursivePartial<MediaQualityEvent['payload']> & {
            intervals: MediaQualityEvent['payload']['intervals'];
        };
        options: any;
    }): void;
    /**
     * Call Analyzer: Feature Usage Event
     * @param args
     */
    submitFeatureEvent({ name, payload, options, }: {
        name: FeatureEvent['name'];
        payload?: RecursivePartial<FeatureEvent['payload']>;
        options: any;
    }): void;
    /**
     * Call Analyzer: Client Event
     * @public
     * @param args
     */
    submitClientEvent({ name, payload, options, }: {
        name: ClientEvent['name'];
        payload?: RecursivePartial<ClientEvent['payload']>;
        options?: SubmitClientEventOptions;
    }): Promise<any>;
    /**
     * Issue request to alias a user's pre-login ID with their CI UUID
     * @param {string} preLoginId
     * @returns {Object} HttpResponse object
     */
    clientMetricsAliasUser(preLoginId: string): any;
    /**
     * Returns a promise that will resolve to fetch options for submitting a metric.
     *
     * This is to support quickly submitting metrics when the browser/tab is closing.
     * Calling submitClientEvent will not work because there some async steps that will
     * not complete before the browser is closed.  Instead, we pre-gather all the
     * information/options needed for the request(s), and then simply and quickly
     * fire the fetch(es) when beforeUnload is triggered.
     *
     * We must use fetch instead of request because fetch has a keepalive option that
     * allows the request it to outlive the page.
     *
     * Note: the timings values will be wrong, but setMetricTimingsAndFetch() will
     * properly adjust them before submitting.
     *
     * @public
     * @param {Object} arg
     * @param {String} arg.name - event name
     * @param {Object} arg.payload - event payload
     * @param {Object} arg.options - other options
     * @returns {Promise} promise that resolves to options to be used with fetch
     */
    buildClientEventFetchRequestOptions({ name, payload, options, }: {
        name: ClientEvent['name'];
        payload?: RecursivePartial<ClientEvent['payload']>;
        options?: SubmitClientEventOptions;
    }): Promise<any>;
    /**
     * Submits a metric from pre-built request options via the fetch API. Updates
     * the "$timings" and "originTime" values to Date.now() since the existing times
     * were set when the options were built (not submitted).
  
     * @param {any} options - the pre-built request options for submitting a metric
     * @returns {Promise} promise that resolves to the response object
     */
    setMetricTimingsAndFetch(options: any): Promise<any>;
    /**
     * Returns true if the specified serviceErrorCode maps to an expected error.
     * @param {number} serviceErrorCode the service error code
     * @returns {boolean}
     */
    isServiceErrorExpected(serviceErrorCode: number): boolean;
    /**
     * Sets the value of delaySubmitClientEvents. If set to true, client events will be delayed until submitDelayedClientEvents is called. If
     * set to false, delayed client events will be submitted.
     *
     * @param {object} options - {shouldDelay: A boolean value indicating whether to delay the submission of client events, overrides: An object containing overrides for the client events}
     */
    setDelaySubmitClientEvents({ shouldDelay, overrides, }: {
        shouldDelay: boolean;
        overrides?: Partial<DelayedClientEvent['options']>;
    }): Promise<any[]> | Promise<void>;
}
export default Metrics;
