"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _uuid = _interopRequireDefault(require("uuid"));
var CallDiagnosticUtils = _interopRequireWildcard(require("../call-diagnostic/call-diagnostic-metrics.util"));
var _constants = _interopRequireDefault(require("./constants"));
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/* eslint-disable class-methods-use-this */

var parseJsonPayload = function parseJsonPayload(payload) {
  try {
    if (payload && payload[0]) {
      return JSON.parse(payload[0]);
    }
    return null;
  } catch (_) {
    return null;
  }
};

/**
 * Rtc Metrics
 */
var RtcMetrics = exports.default = /*#__PURE__*/function () {
  /**
   * Initialize the interval.
   *
   * @param {object} webex - The main `webex` object.
   * @param {IdType} Ids - Meeting or Calling id.
   * @param {string} correlationId - The correlation id.
   */
  function RtcMetrics(webex, _ref, correlationId) {
    var meetingId = _ref.meetingId,
      callId = _ref.callId;
    (0, _classCallCheck2.default)(this, RtcMetrics);
    /**
     * Array of MetricData items to be sent to the metrics service.
     */
    (0, _defineProperty2.default)(this, "metricsQueue", []);
    (0, _defineProperty2.default)(this, "intervalId", void 0);
    (0, _defineProperty2.default)(this, "webex", void 0);
    (0, _defineProperty2.default)(this, "meetingId", void 0);
    (0, _defineProperty2.default)(this, "callId", void 0);
    (0, _defineProperty2.default)(this, "correlationId", void 0);
    (0, _defineProperty2.default)(this, "connectionId", void 0);
    (0, _defineProperty2.default)(this, "shouldSendMetricsOnNextStatsReport", void 0);
    // `window` is used to prevent typescript from returning a NodeJS.Timer.
    this.intervalId = window.setInterval(this.sendMetricsInQueue.bind(this), 30 * 1000);
    this.meetingId = meetingId;
    this.callId = callId;
    this.webex = webex;
    this.correlationId = correlationId;
    this.resetConnection();
  }

  /**
   * Updates the call identifier with the provided value.
   *
   * @param {string} callId - The new call identifier to set.
   * @returns {void}
   */
  (0, _createClass2.default)(RtcMetrics, [{
    key: "updateCallId",
    value: function updateCallId(callId) {
      this.callId = callId;
    }

    /**
     * Check to see if the metrics queue has any items.
     *
     * @returns {void}
     */
  }, {
    key: "sendMetricsInQueue",
    value: function sendMetricsInQueue() {
      if (this.metricsQueue.length) {
        this.sendMetrics();
        this.metricsQueue = [];
      }
    }

    /**
     * Forces sending metrics when we get the next stats-report
     *
     * This is useful for cases when something important happens that affects the media connection,
     * for example when we move from lobby into the meeting.
     *
     * @returns {void}
     */
  }, {
    key: "sendNextMetrics",
    value: function sendNextMetrics() {
      this.shouldSendMetricsOnNextStatsReport = true;
    }

    /**
     * Add metrics items to the metrics queue.
     *
     * @param {object} data - An object with a payload array of metrics items.
     *
     * @returns {void}
     */
  }, {
    key: "addMetrics",
    value: function addMetrics(data) {
      if (data.payload.length) {
        if (data.name === 'stats-report') {
          data.payload = data.payload.map(this.anonymizeIp);
        }
        this.metricsQueue.push(data);
        if (this.shouldSendMetricsOnNextStatsReport && data.name === 'stats-report') {
          // this is the first useful set of data (WCME gives it to us after 5s), send it out immediately
          // in case the user is unhappy and closes the browser early
          this.sendMetricsInQueue();
          this.shouldSendMetricsOnNextStatsReport = false;
        }
        try {
          // If a connection fails, send the rest of the metrics in queue and get a new connection id.
          var parsedPayload = parseJsonPayload(data.payload);
          if (data.name === 'onconnectionstatechange' && parsedPayload && parsedPayload.value === 'failed') {
            this.sendMetricsInQueue();
            this.resetConnection();
          }
        } catch (e) {
          console.error(e);
        }
      }
    }

    /**
     * Clear the metrics interval.
     *
     * @returns {void}
     */
  }, {
    key: "closeMetrics",
    value: function closeMetrics() {
      this.sendMetricsInQueue();
      clearInterval(this.intervalId);
    }

    /**
     * Anonymize IP addresses.
     *
     * @param {array} stats - An RTCStatsReport organized into an array of strings.
     * @returns {string}
     */
  }, {
    key: "anonymizeIp",
    value: function anonymizeIp(stats) {
      var data = JSON.parse(stats);
      // on local and remote candidates, anonymize the last 4 bits.
      if (data.type === 'local-candidate' || data.type === 'remote-candidate') {
        data.ip = CallDiagnosticUtils.anonymizeIPAddress(data.ip) || undefined;
        data.address = CallDiagnosticUtils.anonymizeIPAddress(data.address) || undefined;
        data.relatedAddress = CallDiagnosticUtils.anonymizeIPAddress(data.relatedAddress) || undefined;
      }
      return (0, _stringify.default)(data);
    }

    /**
     * Set a new connection id.
     *
     * @returns {void}
     */
  }, {
    key: "resetConnection",
    value: function resetConnection() {
      this.connectionId = _uuid.default.v4();
      this.shouldSendMetricsOnNextStatsReport = true;
    }

    /**
     * Send metrics to the metrics service.
     *
     * @returns {void}
     */
  }, {
    key: "sendMetrics",
    value: function sendMetrics() {
      var metricsAttributes = {
        type: 'webrtc',
        version: '1.1.0',
        userId: this.webex.internal.device.userId,
        correlationId: this.correlationId,
        connectionId: this.connectionId,
        data: this.metricsQueue
      };
      if (this.meetingId) {
        metricsAttributes.meetingId = this.meetingId;
      } else if (this.callId) {
        metricsAttributes.callId = this.callId;
      }
      this.webex.request({
        method: 'POST',
        service: 'unifiedTelemetry',
        resource: 'metric/v2',
        headers: {
          type: 'webrtcMedia',
          appId: _constants.default.APP_ID
        },
        body: {
          metrics: [metricsAttributes]
        }
      });
    }
  }]);
  return RtcMetrics;
}();
//# sourceMappingURL=index.js.map
