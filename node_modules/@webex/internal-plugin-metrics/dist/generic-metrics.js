"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _webexCore = require("@webex/webex-core");
var _common = require("@webex/common");
var _lodash = require("lodash");
var _clientMetricsBatcher = _interopRequireDefault(require("./client-metrics-batcher"));
var _metrics = require("./metrics");
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var _BrowserDetection = (0, _common.BrowserDetection)(),
  getOSVersion = _BrowserDetection.getOSVersion,
  getBrowserName = _BrowserDetection.getBrowserName,
  getBrowserVersion = _BrowserDetection.getBrowserVersion;

/**
 * @description top-level abstract class to handle Metrics and common routines.
 * @export
 * @class GenericMetrics
 */
var GenericMetrics = exports.default = /*#__PURE__*/function (_StatelessWebexPlugin) {
  (0, _inherits2.default)(GenericMetrics, _StatelessWebexPlugin);
  var _super = _createSuper(GenericMetrics);
  /**
   * Constructor
   * @param {any[]} args
   */
  function GenericMetrics() {
    var _this;
    (0, _classCallCheck2.default)(this, GenericMetrics);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    // @ts-ignore
    // @ts-ignore
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "clientMetricsBatcher", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "logger", void 0);
    // to avoid adding @ts-ignore everywhere
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "device", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "version", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "deviceId", '');
    _this.logger = _this.webex.logger;
    // @ts-ignore
    _this.clientMetricsBatcher = new _clientMetricsBatcher.default({}, {
      parent: _this.webex
    });
    // @ts-ignore
    _this.device = _this.webex.internal.device;
    // @ts-ignore
    _this.version = _this.webex.version;
    return _this;
  }

  /**
   * Submit a business metric to our metrics endpoint.
   * @param {string} kind of metric for logging
   * @param {string} name of the metric
   * @param {object} event
   * @returns {Promise<any>}
   */
  (0, _createClass2.default)(GenericMetrics, [{
    key: "submitEvent",
    value: function submitEvent(_ref) {
      var kind = _ref.kind,
        name = _ref.name,
        event = _ref.event;
      this.logger.log(kind, "@submitEvent. Submit event: ".concat(name));
      return this.clientMetricsBatcher.request(event);
    }

    /**
     * Returns the deviceId from our registration with WDM.
     * @returns {string} deviceId or empty string
     */
  }, {
    key: "getDeviceId",
    value: function getDeviceId() {
      if (this.deviceId === '') {
        var url = this.device.url;
        if (url && url.length !== 0) {
          var n = url.lastIndexOf('/');
          if (n !== -1) {
            this.deviceId = url.substring(n + 1);
          }
        }
      }
      return this.deviceId;
    }

    /**
     * Returns the context object to be submitted with all metrics.
     * @returns {DeviceContext}
     */
  }, {
    key: "getContext",
    value: function getContext() {
      return {
        app: {
          version: this.version
        },
        device: {
          id: this.getDeviceId()
        },
        locale: window.navigator.language,
        os: {
          name: (0, _metrics.getOSNameInternal)(),
          version: getOSVersion()
        }
      };
    }

    /**
     * Returns the browser details to be included with all metrics.
     * @returns {object}
     */
  }, {
    key: "getBrowserDetails",
    value: function getBrowserDetails() {
      return {
        browser: getBrowserName(),
        browserHeight: window.innerHeight,
        browserVersion: getBrowserVersion(),
        browserWidth: window.innerWidth,
        domain: window.location.hostname,
        inIframe: window.self !== window.top,
        locale: window.navigator.language,
        os: (0, _metrics.getOSNameInternal)()
      };
    }

    /**
     * Returns true once we have the deviceId we need to submit behavioral/operational/business events
     * @returns {boolean}
     */
  }, {
    key: "isReadyToSubmitEvents",
    value: function isReadyToSubmitEvents() {
      var deviceId = this.getDeviceId();
      return deviceId && deviceId.length !== 0;
    }

    /**
     * Creates the object to send to our metrics endpoint for a tagged event (i.e. behavoral or operational)
     * @param {[MetricType]} list of event type (i.e. ['behavioral'], ['operational', 'behavioral'])
     * @param {string} metric name
     * @param {EventPayload} user payload
     * @returns {EventPayload}
     */
  }, {
    key: "createTaggedEventObject",
    value: function createTaggedEventObject(_ref2) {
      var type = _ref2.type,
        name = _ref2.name,
        payload = _ref2.payload;
      var allTags = payload;
      allTags = (0, _lodash.merge)(allTags, this.getBrowserDetails());
      var event = {
        context: this.getContext(),
        metricName: name,
        tags: allTags,
        timestamp: (0, _now.default)(),
        type: type
      };
      return event;
    }
  }]);
  return GenericMetrics;
}(_webexCore.StatelessWebexPlugin);
//# sourceMappingURL=generic-metrics.js.map
