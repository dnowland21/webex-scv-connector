"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _webexCore = require("@webex/webex-core");
var _callDiagnosticMetrics = _interopRequireDefault(require("./call-diagnostic/call-diagnostic-metrics"));
var _behavioralMetrics = _interopRequireDefault(require("./behavioral-metrics"));
var _operationalMetrics = _interopRequireDefault(require("./operational-metrics"));
var _businessMetrics = _interopRequireDefault(require("./business-metrics"));
var _callDiagnosticMetricsLatencies = _interopRequireDefault(require("./call-diagnostic/call-diagnostic-metrics-latencies"));
var _callDiagnosticMetrics2 = require("./call-diagnostic/call-diagnostic-metrics.util");
var _utils = require("./utils");
var _class;
/* eslint-disable @typescript-eslint/no-unused-vars */
/* eslint-disable class-methods-use-this */
/* eslint-disable valid-jsdoc */
// @ts-ignore
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * Metrics plugin to centralize all types of metrics.
 * https://confluence-eng-gpk2.cisco.com/conf/pages/viewpage.action?pageId=231011379
 * @class
 */
var Metrics = /*#__PURE__*/function (_WebexPlugin) {
  (0, _inherits2.default)(Metrics, _WebexPlugin);
  var _super = _createSuper(Metrics);
  /**
   * Constructor
   * @param args
   * @constructor
   * @private
   * @returns
   */
  function Metrics() {
    var _this;
    (0, _classCallCheck2.default)(this, Metrics);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));

    // @ts-ignore
    // Call Diagnostic latencies
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "callDiagnosticLatencies", void 0);
    // Helper classes to handle the different types of metrics
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "callDiagnosticMetrics", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "behavioralMetrics", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "operationalMetrics", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "businessMetrics", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "isReady", false);
    /**
     * Whether or not to delay the submission of client events.
     */
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "delaySubmitClientEvents", false);
    /**
     * Overrides for delayed client events. E.g. if you want to override the correlationId for all delayed client events, you can set this to { correlationId: 'newCorrelationId' }
     */
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "delayedClientEventsOverrides", {});
    _this.callDiagnosticLatencies = new _callDiagnosticMetricsLatencies.default({}, {
      parent: _this.webex
    });
    _this.onReady();
    return _this;
  }

  /**
   * On Ready
   */
  (0, _createClass2.default)(Metrics, [{
    key: "onReady",
    value: function onReady() {
      var _this2 = this;
      // @ts-ignore
      this.webex.once('ready', function () {
        // @ts-ignore
        _this2.callDiagnosticMetrics = new _callDiagnosticMetrics.default({}, {
          parent: _this2.webex
        });
        _this2.isReady = true;
        _this2.setDelaySubmitClientEvents({
          shouldDelay: _this2.delaySubmitClientEvents,
          overrides: _this2.delayedClientEventsOverrides
        });
      });
    }

    /**
     * Used for internal purposes only
     * @param args
     */
  }, {
    key: "submitInternalEvent",
    value: function submitInternalEvent(_ref) {
      var name = _ref.name,
        payload = _ref.payload,
        options = _ref.options;
      if (name === 'internal.reset.join.latencies') {
        this.callDiagnosticLatencies.clearTimestamps();
      } else {
        this.callDiagnosticLatencies.saveTimestamp({
          key: name
        });
      }
    }

    /**
     * if webex metrics is ready, build behavioral metric backend if not already done.
     */
  }, {
    key: "lazyBuildBehavioralMetrics",
    value: function lazyBuildBehavioralMetrics() {
      if (this.isReady && !this.behavioralMetrics) {
        // @ts-ignore
        this.behavioralMetrics = new _behavioralMetrics.default({}, {
          parent: this.webex
        });
      }
    }

    /**
     * if webex metrics is ready, build operational metric backend if not already done.
     */
  }, {
    key: "lazyBuildOperationalMetrics",
    value: function lazyBuildOperationalMetrics() {
      if (this.isReady && !this.operationalMetrics) {
        // @ts-ignore
        this.operationalMetrics = new _operationalMetrics.default({}, {
          parent: this.webex
        });
      }
    }

    /**
     * if webex metrics is ready, build business metric backend if not already done.
     */
  }, {
    key: "lazyBuildBusinessMetrics",
    value: function lazyBuildBusinessMetrics() {
      if (this.isReady && !this.businessMetrics) {
        // @ts-ignore
        this.businessMetrics = new _businessMetrics.default({}, {
          parent: this.webex
        });
      }
    }

    /**
     * @returns true once we have the deviceId we need to submit behavioral events to Amplitude
     */
  }, {
    key: "isReadyToSubmitBehavioralEvents",
    value: function isReadyToSubmitBehavioralEvents() {
      var _this$behavioralMetri, _this$behavioralMetri2;
      this.lazyBuildBehavioralMetrics();
      return (_this$behavioralMetri = (_this$behavioralMetri2 = this.behavioralMetrics) === null || _this$behavioralMetri2 === void 0 ? void 0 : _this$behavioralMetri2.isReadyToSubmitEvents()) !== null && _this$behavioralMetri !== void 0 ? _this$behavioralMetri : false;
    }

    /**
     * @returns true once we have the deviceId we need to submit operational events
     */
  }, {
    key: "isReadyToSubmitOperationalEvents",
    value: function isReadyToSubmitOperationalEvents() {
      var _this$operationalMetr, _this$operationalMetr2;
      this.lazyBuildOperationalMetrics();
      return (_this$operationalMetr = (_this$operationalMetr2 = this.operationalMetrics) === null || _this$operationalMetr2 === void 0 ? void 0 : _this$operationalMetr2.isReadyToSubmitEvents()) !== null && _this$operationalMetr !== void 0 ? _this$operationalMetr : false;
    }

    /**
     * @returns true once we have the deviceId we need to submit business events
     */
  }, {
    key: "isReadyToSubmitBusinessEvents",
    value: function isReadyToSubmitBusinessEvents() {
      var _this$businessMetrics, _this$businessMetrics2;
      this.lazyBuildBusinessMetrics();
      return (_this$businessMetrics = (_this$businessMetrics2 = this.businessMetrics) === null || _this$businessMetrics2 === void 0 ? void 0 : _this$businessMetrics2.isReadyToSubmitEvents()) !== null && _this$businessMetrics !== void 0 ? _this$businessMetrics : false;
    }

    /**
     * Behavioral event
     * @param args
     */
  }, {
    key: "submitBehavioralEvent",
    value: function submitBehavioralEvent(_ref2) {
      var product = _ref2.product,
        agent = _ref2.agent,
        target = _ref2.target,
        verb = _ref2.verb,
        payload = _ref2.payload;
      if (!this.isReady) {
        // @ts-ignore
        this.webex.logger.log("NewMetrics: @submitBehavioralEvent. Attempted to submit before webex.ready: ".concat(product, ".").concat(agent, ".").concat(target, ".").concat(verb));
        return _promise.default.resolve();
      }
      this.lazyBuildBehavioralMetrics();
      return this.behavioralMetrics.submitBehavioralEvent({
        product: product,
        agent: agent,
        target: target,
        verb: verb,
        payload: payload
      });
    }

    /**
     * Operational event
     * @param args
     */
  }, {
    key: "submitOperationalEvent",
    value: function submitOperationalEvent(_ref3) {
      var name = _ref3.name,
        payload = _ref3.payload;
      if (!this.isReady) {
        // @ts-ignore
        this.webex.logger.log("NewMetrics: @submitOperationalEvent. Attempted to submit before webex.ready: ".concat(name));
        return _promise.default.resolve();
      }
      this.lazyBuildOperationalMetrics();
      return this.operationalMetrics.submitOperationalEvent({
        name: name,
        payload: payload
      });
    }

    /**
     * Business event
     * @param args
     */
  }, {
    key: "submitBusinessEvent",
    value: function submitBusinessEvent(_ref4) {
      var name = _ref4.name,
        payload = _ref4.payload,
        table = _ref4.table,
        metadata = _ref4.metadata;
      if (!this.isReady) {
        // @ts-ignore
        this.webex.logger.log("NewMetrics: @submitBusinessEvent. Attempted to submit before webex.ready: ".concat(name));
        return _promise.default.resolve();
      }
      this.lazyBuildBusinessMetrics();
      return this.businessMetrics.submitBusinessEvent({
        name: name,
        payload: payload,
        table: table,
        metadata: metadata
      });
    }

    /**
     * Call Analyzer: Media Quality Event
     * @param args
     */
  }, {
    key: "submitMQE",
    value: function submitMQE(_ref5) {
      var name = _ref5.name,
        payload = _ref5.payload,
        options = _ref5.options;
      this.callDiagnosticLatencies.saveTimestamp({
        key: name
      });
      this.callDiagnosticMetrics.submitMQE({
        name: name,
        payload: payload,
        options: options
      });
    }

    /**
     * Call Analyzer: Feature Usage Event
     * @param args
     */
  }, {
    key: "submitFeatureEvent",
    value: function submitFeatureEvent(_ref6) {
      var name = _ref6.name,
        payload = _ref6.payload,
        options = _ref6.options;
      throw new Error('Not implemented.');
    }

    /**
     * Call Analyzer: Client Event
     * @public
     * @param args
     */
  }, {
    key: "submitClientEvent",
    value: function submitClientEvent(_ref7) {
      var name = _ref7.name,
        payload = _ref7.payload,
        options = _ref7.options;
      if (!this.callDiagnosticLatencies || !this.callDiagnosticMetrics) {
        // @ts-ignore
        this.webex.logger.log("NewMetrics: @submitClientEvent. Attempted to submit before webex.ready. Event name: ".concat(name));
        return _promise.default.resolve();
      }
      this.callDiagnosticLatencies.saveTimestamp({
        key: name,
        options: {
          meetingId: options === null || options === void 0 ? void 0 : options.meetingId
        }
      });
      return this.callDiagnosticMetrics.submitClientEvent({
        name: name,
        payload: payload,
        options: options,
        delaySubmitEvent: this.delaySubmitClientEvents
      });
    }

    /**
     * Issue request to alias a user's pre-login ID with their CI UUID
     * @param {string} preLoginId
     * @returns {Object} HttpResponse object
     */
  }, {
    key: "clientMetricsAliasUser",
    value: function clientMetricsAliasUser(preLoginId) {
      var _this3 = this;
      // @ts-ignore
      return this.webex.request({
        method: 'POST',
        api: 'metrics',
        resource: 'clientmetrics',
        headers: {
          'x-prelogin-userid': preLoginId
        },
        body: {},
        qs: {
          alias: true
        }
      }).then(function (res) {
        // @ts-ignore
        _this3.webex.logger.log("NewMetrics: @clientMetricsAliasUser. Request successful.");
        return res;
      }).catch(function (err) {
        // @ts-ignore
        _this3.logger.error("NewMetrics: @clientMetricsAliasUser. Request failed:", "err: ".concat((0, _utils.generateCommonErrorMetadata)(err)));
        return _promise.default.reject(err);
      });
    }

    /**
     * Returns a promise that will resolve to fetch options for submitting a metric.
     *
     * This is to support quickly submitting metrics when the browser/tab is closing.
     * Calling submitClientEvent will not work because there some async steps that will
     * not complete before the browser is closed.  Instead, we pre-gather all the
     * information/options needed for the request(s), and then simply and quickly
     * fire the fetch(es) when beforeUnload is triggered.
     *
     * We must use fetch instead of request because fetch has a keepalive option that
     * allows the request it to outlive the page.
     *
     * Note: the timings values will be wrong, but setMetricTimingsAndFetch() will
     * properly adjust them before submitting.
     *
     * @public
     * @param {Object} arg
     * @param {String} arg.name - event name
     * @param {Object} arg.payload - event payload
     * @param {Object} arg.options - other options
     * @returns {Promise} promise that resolves to options to be used with fetch
     */
  }, {
    key: "buildClientEventFetchRequestOptions",
    value: (function () {
      var _buildClientEventFetchRequestOptions = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(_ref8) {
        var name, payload, options;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              name = _ref8.name, payload = _ref8.payload, options = _ref8.options;
              return _context.abrupt("return", this.callDiagnosticMetrics.buildClientEventFetchRequestOptions({
                name: name,
                payload: payload,
                options: options
              }));
            case 2:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function buildClientEventFetchRequestOptions(_x) {
        return _buildClientEventFetchRequestOptions.apply(this, arguments);
      }
      return buildClientEventFetchRequestOptions;
    }()
    /**
     * Submits a metric from pre-built request options via the fetch API. Updates
     * the "$timings" and "originTime" values to Date.now() since the existing times
     * were set when the options were built (not submitted).
      * @param {any} options - the pre-built request options for submitting a metric
     * @returns {Promise} promise that resolves to the response object
     */
    )
  }, {
    key: "setMetricTimingsAndFetch",
    value: function setMetricTimingsAndFetch(options) {
      // @ts-ignore
      return this.webex.setTimingsAndFetch((0, _callDiagnosticMetrics2.setMetricTimings)(options));
    }

    /**
     * Returns true if the specified serviceErrorCode maps to an expected error.
     * @param {number} serviceErrorCode the service error code
     * @returns {boolean}
     */
  }, {
    key: "isServiceErrorExpected",
    value: function isServiceErrorExpected(serviceErrorCode) {
      return this.callDiagnosticMetrics.isServiceErrorExpected(serviceErrorCode);
    }

    /**
     * Sets the value of delaySubmitClientEvents. If set to true, client events will be delayed until submitDelayedClientEvents is called. If
     * set to false, delayed client events will be submitted.
     *
     * @param {object} options - {shouldDelay: A boolean value indicating whether to delay the submission of client events, overrides: An object containing overrides for the client events}
     */
  }, {
    key: "setDelaySubmitClientEvents",
    value: function setDelaySubmitClientEvents(_ref9) {
      var shouldDelay = _ref9.shouldDelay,
        overrides = _ref9.overrides;
      this.delaySubmitClientEvents = shouldDelay;
      this.delayedClientEventsOverrides = overrides || {};
      if (this.isReady && !shouldDelay) {
        return this.callDiagnosticMetrics.submitDelayedClientEvents(overrides);
      }
      return _promise.default.resolve();
    }
  }]);
  return Metrics;
}(_webexCore.WebexPlugin);
_class = Metrics;
// eslint-disable-next-line no-use-before-define
(0, _defineProperty2.default)(Metrics, "instance", void 0);
var _default = exports.default = Metrics;
//# sourceMappingURL=new-metrics.js.map
