import { TypedEvent } from './typed-event';
type Constructor = (new (...args: any[]) => {}) | (abstract new (...args: any[]) => {});
type eventHandlerType<Type> = Type extends TypedEvent<infer X> ? X : never;
export declare function AddEvents<TBase extends Constructor, U>(Base: TBase): {
    new (...args: any[]): {
        on<K extends keyof U, E extends eventHandlerType<U[K]>>(eventName: K, handler: E): void;
        once<K_1 extends keyof U, E_1 extends eventHandlerType<U[K_1]>>(eventName: K_1, handler: E_1): void;
        off<K_2 extends keyof U, E_2 extends eventHandlerType<U[K_2]>>(eventName: K_2, handler: E_2): void;
    };
} & TBase;
export type WithEventsDummyType<U> = {
    on<K extends keyof U, E extends eventHandlerType<U[K]>>(eventName: K, handler: E): void;
    once<K extends keyof U, E extends eventHandlerType<U[K]>>(eventName: K, handler: E): void;
    off<K extends keyof U, E extends eventHandlerType<U[K]>>(eventName: K, handler: E): void;
};
export {};
//# sourceMappingURL=event-mixin.d.ts.map