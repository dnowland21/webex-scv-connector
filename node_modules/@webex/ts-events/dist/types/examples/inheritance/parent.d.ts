import { WithEventsDummyType } from '../../event-mixin';
import { TypedEvent } from '../../typed-event';
interface ParentEvents {
    eventOne: TypedEvent<(value: number) => void>;
    eventTwo: TypedEvent<(value: boolean) => void>;
}
declare class _Parent {
    protected eventOne: TypedEvent<(value: number) => void>;
    protected eventTwo: TypedEvent<(value: boolean) => void>;
    fireEventOne(): void;
    fireEventTwo(): void;
}
export declare const Parent: {
    new (...args: any[]): {
        on<K extends keyof ParentEvents, E extends ParentEvents[K] extends infer T ? T extends ParentEvents[K] ? T extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K, handler: E): void;
        once<K_1 extends keyof ParentEvents, E_1 extends ParentEvents[K_1] extends infer T_1 ? T_1 extends ParentEvents[K_1] ? T_1 extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K_1, handler: E_1): void;
        off<K_2 extends keyof ParentEvents, E_2 extends ParentEvents[K_2] extends infer T_2 ? T_2 extends ParentEvents[K_2] ? T_2 extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K_2, handler: E_2): void;
    };
} & typeof _Parent;
export type Parent = _Parent & WithEventsDummyType<ParentEvents>;
export {};
//# sourceMappingURL=parent.d.ts.map