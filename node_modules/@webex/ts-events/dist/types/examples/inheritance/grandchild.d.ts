import { WithEventsDummyType } from 'event-mixin';
import { TypedEvent } from 'typed-event';
import { Child } from './child';
export type EventFour = {
    field: number;
};
interface GrandchildEvents {
    eventFour: TypedEvent<(ev: EventFour) => void>;
}
declare class _Grandchild extends Child {
    protected eventFour: TypedEvent<(value: EventFour) => void>;
    fireEventFour(): void;
}
export declare const Grandchild: {
    new (...args: any[]): {
        on<K extends "eventFour", E extends GrandchildEvents[K] extends infer T ? T extends GrandchildEvents[K] ? T extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K, handler: E): void;
        once<K_1 extends "eventFour", E_1 extends GrandchildEvents[K_1] extends infer T_1 ? T_1 extends GrandchildEvents[K_1] ? T_1 extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K_1, handler: E_1): void;
        off<K_2 extends "eventFour", E_2 extends GrandchildEvents[K_2] extends infer T_2 ? T_2 extends GrandchildEvents[K_2] ? T_2 extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K_2, handler: E_2): void;
    };
} & typeof _Grandchild;
export type Grandchild = _Grandchild & WithEventsDummyType<GrandchildEvents>;
export {};
//# sourceMappingURL=grandchild.d.ts.map