import { WithEventsDummyType } from '../../event-mixin';
import { TypedEvent } from '../../typed-event';
interface MyClassEvents {
    eventOne: TypedEvent<(value: number) => void>;
    eventTwo: TypedEvent<(value: boolean) => void>;
}
declare class _MyClass {
    protected eventOne: TypedEvent<(value: number) => void>;
    protected eventTwo: TypedEvent<(value: boolean) => void>;
    fireEventOne(): void;
    fireEventTwo(): void;
}
export declare const MyClass: {
    new (...args: any[]): {
        on<K extends keyof MyClassEvents, E extends MyClassEvents[K] extends infer T ? T extends MyClassEvents[K] ? T extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K, handler: E): void;
        once<K_1 extends keyof MyClassEvents, E_1 extends MyClassEvents[K_1] extends infer T_1 ? T_1 extends MyClassEvents[K_1] ? T_1 extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K_1, handler: E_1): void;
        off<K_2 extends keyof MyClassEvents, E_2 extends MyClassEvents[K_2] extends infer T_2 ? T_2 extends MyClassEvents[K_2] ? T_2 extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K_2, handler: E_2): void;
    };
} & typeof _MyClass;
export type MyClass = _MyClass & WithEventsDummyType<MyClassEvents>;
export {};
//# sourceMappingURL=my-class.d.ts.map