{"version":3,"names":["_sha","_interopRequireDefault","require","_lodash","_webexPlugin","_metrics","_serviceCatalog","_serviceFedRamp","_constants","ownKeys","e","r","t","_Object$keys2","_Object$getOwnPropertySymbols","o","filter","_Object$getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","arguments","length","Object","forEach","_defineProperty2","default","_Object$getOwnPropertyDescriptors","_Object$defineProperties","_Object$defineProperty","trailingSlashes","DEFAULT_CLUSTER","exports","DEFAULT_CLUSTER_SERVICE","CLUSTER_SERVICE","process","env","WEBEX_CONVERSATION_CLUSTER_SERVICE","DEFAULT_CLUSTER_IDENTIFIER","WEBEX_CONVERSATION_DEFAULT_CLUSTER","concat","Services","WebexPlugin","extend","namespace","props","validateDomains","initFailed","_catalogs","_weakMap","_activeServices","_services","_getCatalog","get","webex","name","priorityHost","serviceGroup","catalog","hasAllowedDomains","getAllowedDomains","list","markFailedUrl","url","noPriorityHosts","_updateActiveServices","activeServices","_updateServices","services","unionBy","updateServices","_this","_ref","undefined","from","query","token","forceRefresh","formattedQuery","status","collecting","waitForCatalog","queryKey","_keys","includes","_promise","reject","Error","email","emailhash","sha256","toLowerCase","toString","_fetchNewServiceHostmap","then","serviceHostMap","updateServiceGroups","updateCredentialsConfig","catch","error","validateUser","_ref2","_this2","_ref2$reqId","reqId","_ref2$forceRefresh","_ref2$activationOptio","activationOptions","preloginUserId","logger","info","canAuthorize","credentials","getUserToken","sendUserActivation","userObj","activated","exists","details","user","_this$webex$credentia","config","client_id","client_secret","collectPreauthCatalog","idbrokerService","getClientToken","uri","scope","tokenObj","collectSigninCatalog","rto","all","_ref3","_ref4","_slicedToArray2","response","statusCode","responseText","body","message","getMeetingPreferences","_this3","request","method","service","resource","res","err","fetchClientRegionInfo","_this4","discovery","sqdiscovery","addAuthHeader","headers","timeout","_ref5","_this5","countryCode","timezone","clientRegionInfo","accept","authorization","timeZone","shouldRefreshAccessToken","_ref6","updateCatalog","hostMap","_formatReceivedHostmap","mode","_ref7","_this$list","idbroker","identity","_this$webex$config$cr","authorizationString","authorizeUrl","replace","setConfig","supertoken","access_token","postauth","ready","preauth","initServiceCatalogs","waitForService","_ref8","_this6","_ref8$timeout","fetchFromServiceUrl","servicesNotNeedValidation","find","resolve","priorityUrl","priorityUrlObj","getServiceFromUrl","isReady","internal","metrics","submitClientMetrics","METRICS","JS_SDK_SERVICE_NOT_FOUND","fields","service_name","groupsToCheck","checkCatalog","catalogGroup","scopedPriorityUrl","scopedPrioriryUrlObj","map","group","replaceHostFromHostmap","URL","hostCatalog","host","newHost","_formatHostMapEntry","_ref9","id","serviceName","serviceUrls","formattedServiceUrls","serviceUrl","baseUrl","_ref10","_this7","formattedHostmap","getClusterId","findClusterId","getServiceFromClusterId","params","findServiceFromClusterId","getServiceUrlFromClusterId","_ref11","_ref11$cluster","cluster","clusterId","split","_ref12","findServiceUrlFromUrl","defaultUrl","isAllowedDomainUrl","findAllowedDomain","convertUrlToPriorityHostUrl","data","_this8","_ref13","qs","format","timestamp","Date","getTime","requestObject","newMetrics","callDiagnosticLatencies","measureLatency","_ref14","initConfig","_this9","_this$webex$config","fedramp","fedRampServices","formattedDiscoveryServices","key","priority","override","formattedOverrideServices","allowedDomains","union","COMMERCIAL_ALLOWED_DOMAINS","setAllowedDomains","_this10","getOrgId","orgId","warn","initialize","_this11","ServiceCatalog","set","listenToOnce","version","_default"],"sources":["services-v2.js"],"sourcesContent":["import sha256 from 'crypto-js/sha256';\n\nimport {union, unionBy} from 'lodash';\nimport WebexPlugin from '../webex-plugin';\n\nimport METRICS from './metrics';\nimport ServiceCatalog from './service-catalog';\nimport fedRampServices from './service-fed-ramp';\nimport {COMMERCIAL_ALLOWED_DOMAINS} from './constants';\n\nconst trailingSlashes = /(?:^\\/)|(?:\\/$)/;\n\n// The default cluster when one is not provided (usually as 'US' from hydra)\nexport const DEFAULT_CLUSTER = 'urn:TEAM:us-east-2_a';\n// The default service name for convo (currently identityLookup due to some weird CSB issue)\nexport const DEFAULT_CLUSTER_SERVICE = 'identityLookup';\n\nconst CLUSTER_SERVICE = process.env.WEBEX_CONVERSATION_CLUSTER_SERVICE || DEFAULT_CLUSTER_SERVICE;\nconst DEFAULT_CLUSTER_IDENTIFIER =\n  process.env.WEBEX_CONVERSATION_DEFAULT_CLUSTER || `${DEFAULT_CLUSTER}:${CLUSTER_SERVICE}`;\n\n/* eslint-disable no-underscore-dangle */\n/**\n * @class\n */\nconst Services = WebexPlugin.extend({\n  namespace: 'Services',\n\n  props: {\n    validateDomains: ['boolean', false, true],\n    initFailed: ['boolean', false, false],\n  },\n\n  _catalogs: new WeakMap(),\n\n  _activeServices: {},\n\n  _services: [],\n\n  /**\n   * @private\n   * Get the current catalog based on the assocaited\n   * webex instance.\n   * @returns {ServiceCatalog}\n   */\n  _getCatalog() {\n    return this._catalogs.get(this.webex);\n  },\n\n  /**\n   * Get a service url from the current services list by name\n   * from the associated instance catalog.\n   * @param {string} name\n   * @param {boolean} [priorityHost]\n   * @param {string} [serviceGroup]\n   * @returns {string|undefined}\n   */\n  get(name, priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.get(name, priorityHost, serviceGroup);\n  },\n\n  /**\n   * Determine if a whilelist exists in the service catalog.\n   *\n   * @returns {boolean} - True if a allowed domains list exists.\n   */\n  hasAllowedDomains() {\n    const catalog = this._getCatalog();\n\n    return catalog.getAllowedDomains().length > 0;\n  },\n\n  /**\n   * Generate a service catalog as an object from\n   * the associated instance catalog.\n   * @param {boolean} [priorityHost] - use highest priority host if set to `true`\n   * @param {string} [serviceGroup]\n   * @returns {Record<string, string>}\n   */\n  list(priorityHost, serviceGroup) {\n    const catalog = this._getCatalog();\n\n    return catalog.list(priorityHost, serviceGroup);\n  },\n\n  /**\n   * Mark a priority host service url as failed.\n   * This will mark the host associated with the\n   * `ServiceUrl` to be removed from the its\n   * respective host array, and then return the next\n   * viable host from the `ServiceUrls` host array,\n   * or the `ServiceUrls` default url if no other priority\n   * hosts are available, or if `noPriorityHosts` is set to\n   * `true`.\n   * @param {string} url\n   * @param {boolean} noPriorityHosts\n   * @returns {string}\n   */\n  markFailedUrl(url, noPriorityHosts) {\n    const catalog = this._getCatalog();\n\n    return catalog.markFailedUrl(url, noPriorityHosts);\n  },\n\n  /**\n   * saves all the services from the pre and post catalog service\n   * @param {Object} activeServices\n   * @returns {void}\n   */\n  _updateActiveServices(activeServices) {\n    this._activeServices = {...this._activeServices, ...activeServices};\n  },\n\n  /**\n   * saves the hostCatalog object\n   * @param {Object} services\n   * @returns {void}\n   */\n  _updateServices(services) {\n    this._services = unionBy(services, this._services, 'id');\n  },\n\n  /**\n   * Update a list of `serviceUrls` to the most current\n   * catalog via the defined `discoveryUrl` then returns the current\n   * list of services.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  updateServices({from, query, token, forceRefresh} = {}) {\n    const catalog = this._getCatalog();\n    let formattedQuery;\n    let serviceGroup;\n\n    // map catalog name to service group name.\n    switch (from) {\n      case 'limited':\n        serviceGroup = 'preauth';\n        break;\n      case 'signin':\n        serviceGroup = 'signin';\n        break;\n      default:\n        serviceGroup = 'postauth';\n        break;\n    }\n\n    // confirm catalog update for group is not in progress.\n    if (catalog.status[serviceGroup].collecting) {\n      return this.waitForCatalog(serviceGroup);\n    }\n\n    catalog.status[serviceGroup].collecting = true;\n\n    if (serviceGroup === 'preauth') {\n      const queryKey = query && Object.keys(query)[0];\n\n      if (!['email', 'emailhash', 'userId', 'orgId', 'mode'].includes(queryKey)) {\n        return Promise.reject(\n          new Error('a query param of email, emailhash, userId, orgId, or mode is required')\n        );\n      }\n    }\n    // encode email when query key is email\n    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {\n      const queryKey = Object.keys(query)[0];\n\n      formattedQuery = {};\n\n      if (queryKey === 'email' && query.email) {\n        formattedQuery.emailhash = sha256(query.email.toLowerCase()).toString();\n      } else {\n        formattedQuery[queryKey] = query[queryKey];\n      }\n    }\n\n    return this._fetchNewServiceHostmap({\n      from,\n      token,\n      query: formattedQuery,\n      forceRefresh,\n    })\n      .then((serviceHostMap) => {\n        catalog.updateServiceGroups(serviceGroup, serviceHostMap);\n        this.updateCredentialsConfig();\n        catalog.status[serviceGroup].collecting = false;\n      })\n      .catch((error) => {\n        catalog.status[serviceGroup].collecting = false;\n\n        return Promise.reject(error);\n      });\n  },\n\n  /**\n   * User validation parameter transfer object for {@link validateUser}.\n   * @param {object} ValidateUserPTO\n   * @property {string} ValidateUserPTO.email - The email of the user.\n   * @property {string} [ValidateUserPTO.reqId] - The activation requester.\n   * @property {object} [ValidateUserPTO.activationOptions] - Extra options to pass when sending the activation\n   * @property {object} [ValidateUserPTO.preloginUserId] - The prelogin user id to set when sending the activation.\n   */\n\n  /**\n   * User validation return transfer object for {@link validateUser}.\n   * @param {object} ValidateUserRTO\n   * @property {boolean} ValidateUserRTO.activated - If the user is activated.\n   * @property {boolean} ValidateUserRTO.exists - If the user exists.\n   * @property {string} ValidateUserRTO.details - A descriptive status message.\n   * @property {object} ValidateUserRTO.user - **License** service user object.\n   */\n\n  /**\n   * Validate if a user is activated and update the service catalogs as needed\n   * based on the user's activation status.\n   *\n   * @param {ValidateUserPTO} - The parameter transfer object.\n   * @returns {ValidateUserRTO} - The return transfer object.\n   */\n  validateUser({\n    email,\n    reqId = 'WEBCLIENT',\n    forceRefresh = false,\n    activationOptions = {},\n    preloginUserId,\n  }) {\n    this.logger.info('services: validating a user');\n\n    // Validate that an email parameter key was provided.\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n\n    // Destructure the credentials object.\n    const {canAuthorize} = this.webex.credentials;\n\n    // Validate that the user is already authorized.\n    if (canAuthorize) {\n      return this.updateServices({forceRefresh})\n        .then(() => this.webex.credentials.getUserToken())\n        .then((token) =>\n          this.sendUserActivation({\n            email,\n            reqId,\n            token: token.toString(),\n            activationOptions,\n            preloginUserId,\n          })\n        )\n        .then((userObj) => ({\n          activated: true,\n          exists: true,\n          details: 'user is authorized via a user token',\n          user: userObj,\n        }));\n    }\n\n    // Destructure the client authorization details.\n    /* eslint-disable camelcase */\n    const {client_id, client_secret} = this.webex.credentials.config;\n\n    // Validate that client authentication details exist.\n    if (!client_id || !client_secret) {\n      return Promise.reject(new Error('client authentication details are not available'));\n    }\n    /* eslint-enable camelcase */\n\n    // Declare a class-memeber-scoped token for usage within the promise chain.\n    let token;\n\n    // Begin client authentication user validation.\n    return (\n      this.collectPreauthCatalog({email})\n        .then(() => {\n          // Retrieve the service url from the updated catalog. This is required\n          // since `WebexCore` is usually not fully initialized at the time this\n          // request completes.\n          const idbrokerService = this.get('idbroker', true);\n\n          // Collect the client auth token.\n          return this.webex.credentials.getClientToken({\n            uri: `${idbrokerService}idb/oauth2/v1/access_token`,\n            scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM',\n          });\n        })\n        .then((tokenObj) => {\n          // Generate the token string.\n          token = tokenObj.toString();\n\n          // Collect the signin catalog using the client auth information.\n          return this.collectSigninCatalog({email, token, forceRefresh});\n        })\n        // Validate if collecting the signin catalog failed and populate the RTO\n        // with the appropriate content.\n        .catch((error) => ({\n          exists: error.name !== 'NotFound',\n          activated: false,\n          details:\n            error.name !== 'NotFound'\n              ? 'user exists but is not activated'\n              : 'user does not exist and is not activated',\n        }))\n        // Validate if the previous promise resolved with an RTO and populate the\n        // new RTO accordingly.\n        .then((rto) =>\n          Promise.all([\n            rto || {\n              activated: true,\n              exists: true,\n              details: 'user exists and is activated',\n            },\n            this.sendUserActivation({\n              email,\n              reqId,\n              token,\n              activationOptions,\n              preloginUserId,\n            }),\n          ])\n        )\n        .then(([rto, user]) => ({...rto, user}))\n        .catch((error) => {\n          const response = {\n            statusCode: error.statusCode,\n            responseText: error.body && error.body.message,\n            body: error.body,\n          };\n\n          return Promise.reject(response);\n        })\n    );\n  },\n\n  /**\n   * Get user meeting preferences (preferred webex site).\n   *\n   * @returns {object} - User Information including user preferrences .\n   */\n  getMeetingPreferences() {\n    return this.request({\n      method: 'GET',\n      service: 'hydra',\n      resource: 'meetingPreferences',\n    })\n      .then((res) => {\n        this.logger.info('services: received user region info');\n\n        return res.body;\n      })\n      .catch((err) => {\n        this.logger.info('services: was not able to fetch user login information', err);\n        // resolve successfully even if request failed\n      });\n  },\n\n  /**\n   * Fetches client region info such as countryCode and timezone.\n   *\n   * @returns {object} - The region info object.\n   */\n  fetchClientRegionInfo() {\n    const {services} = this.webex.config;\n\n    return this.request({\n      uri: services.discovery.sqdiscovery,\n      addAuthHeader: false,\n      headers: {\n        'spark-user-agent': null,\n      },\n      timeout: 5000,\n    })\n      .then((res) => {\n        this.logger.info('services: received user region info');\n\n        return res.body;\n      })\n      .catch((err) => {\n        this.logger.info('services: was not able to get user region info', err);\n        // resolve successfully even if request failed\n      });\n  },\n\n  /**\n   * User activation parameter transfer object for {@link sendUserActivation}.\n   * @typedef {object} SendUserActivationPTO\n   * @property {string} SendUserActivationPTO.email - The email of the user.\n   * @property {string} SendUserActivationPTO.reqId - The activation requester.\n   * @property {string} SendUserActivationPTO.token - The client auth token.\n   * @property {object} SendUserActivationPTO.activationOptions - Extra options to pass when sending the activation.\n   * @property {object} SendUserActivationPTO.preloginUserId - The prelogin user id to set when sending the activation.\n   */\n\n  /**\n   * Send a request to activate a user using a client token.\n   *\n   * @param {SendUserActivationPTO} - The Parameter transfer object.\n   * @returns {LicenseDTO} - The DTO returned from the **License** service.\n   */\n  sendUserActivation({email, reqId, token, activationOptions, preloginUserId}) {\n    this.logger.info('services: sending user activation request');\n    let countryCode;\n    let timezone;\n\n    // try to fetch client region info first\n    return (\n      this.fetchClientRegionInfo()\n        .then((clientRegionInfo) => {\n          if (clientRegionInfo) {\n            ({countryCode, timezone} = clientRegionInfo);\n          }\n\n          // Send the user activation request to the **License** service.\n          return this.request({\n            service: 'license',\n            resource: 'users/activations',\n            method: 'POST',\n            headers: {\n              accept: 'application/json',\n              authorization: token,\n              'x-prelogin-userid': preloginUserId,\n            },\n            body: {\n              email,\n              reqId,\n              countryCode,\n              timeZone: timezone,\n              ...activationOptions,\n            },\n            shouldRefreshAccessToken: false,\n          });\n        })\n        // On success, return the **License** user object.\n        .then(({body}) => body)\n        // On failure, reject with error from **License**.\n        .catch((error) => Promise.reject(error))\n    );\n  },\n\n  /**\n   * Updates a given service group i.e. preauth, signin, postauth with a new hostmap.\n   * @param {string} serviceGroup - preauth, signin, postauth\n   * @param {object} hostMap - The new hostmap to update the service group with.\n   * @returns {Promise<void>}\n   */\n  updateCatalog(serviceGroup, hostMap) {\n    const catalog = this._getCatalog();\n\n    const serviceHostMap = this._formatReceivedHostmap(hostMap);\n\n    return catalog.updateServiceGroups(serviceGroup, serviceHostMap);\n  },\n\n  /**\n   * simplified method to update the preauth catalog via email\n   *\n   * @param {object} query\n   * @param {string} query.email - A standard format email.\n   * @param {string} query.orgId - The user's OrgId.\n   * @param {boolean} forceRefresh - Boolean to bypass u2c cache control header\n   * @returns {Promise<void>}\n   */\n  collectPreauthCatalog(query, forceRefresh = false) {\n    if (!query) {\n      return this.updateServices({\n        from: 'limited',\n        query: {mode: 'DEFAULT_BY_PROXIMITY'},\n        forceRefresh,\n      });\n    }\n\n    return this.updateServices({from: 'limited', query, forceRefresh});\n  },\n\n  /**\n   * simplified method to update the signin catalog via email and token\n   * @param {object} param\n   * @param {string} param.email - must be a standard-format email\n   * @param {string} param.token - must be a client token\n   * @returns {Promise<void>}\n   */\n  collectSigninCatalog({email, token, forceRefresh} = {}) {\n    if (!email) {\n      return Promise.reject(new Error('`email` is required'));\n    }\n    if (!token) {\n      return Promise.reject(new Error('`token` is required'));\n    }\n\n    return this.updateServices({\n      from: 'signin',\n      query: {email},\n      token,\n      forceRefresh,\n    });\n  },\n\n  /**\n   * Updates credentials config to utilize u2c catalog\n   * urls.\n   * @returns {void}\n   */\n  updateCredentialsConfig() {\n    const {idbroker, identity} = this.list(true);\n\n    if (idbroker && identity) {\n      const {authorizationString, authorizeUrl} = this.webex.config.credentials;\n\n      // This must be set outside of the setConfig method used to assign the\n      // idbroker and identity url values.\n      this.webex.config.credentials.authorizeUrl = authorizationString\n        ? authorizeUrl\n        : `${idbroker.replace(trailingSlashes, '')}/idb/oauth2/v1/authorize`;\n\n      this.webex.setConfig({\n        credentials: {\n          idbroker: {\n            url: idbroker.replace(trailingSlashes, ''), // remove trailing slash\n          },\n          identity: {\n            url: identity.replace(trailingSlashes, ''), // remove trailing slash\n          },\n        },\n      });\n    }\n  },\n\n  /**\n   * Wait until the service catalog is available,\n   * or reject afte ra timeout of 60 seconds.\n   * @param {string} serviceGroup\n   * @param {number} [timeout] - in seconds\n   * @returns {Promise<void>}\n   */\n  waitForCatalog(serviceGroup, timeout) {\n    const catalog = this._getCatalog();\n    const {supertoken} = this.webex.credentials;\n\n    if (\n      serviceGroup === 'postauth' &&\n      supertoken &&\n      supertoken.access_token &&\n      !catalog.status.postauth.collecting &&\n      !catalog.status.postauth.ready\n    ) {\n      if (!catalog.status.preauth.ready) {\n        return this.initServiceCatalogs();\n      }\n\n      return this.updateServices();\n    }\n\n    return catalog.waitForCatalog(serviceGroup, timeout);\n  },\n\n  /**\n   * Service waiting parameter transfer object for {@link waitForService}.\n   *\n   * @typedef {object} WaitForServicePTO\n   * @property {string} [WaitForServicePTO.name] - The service name.\n   * @property {string} [WaitForServicePTO.url] - The service url.\n   * @property {string} [WaitForServicePTO.timeout] - wait duration in seconds.\n   */\n\n  /**\n   * Wait until the service has been ammended to any service catalog. This\n   * method prioritizes the service name over the service url when searching.\n   *\n   * @param {WaitForServicePTO} - The parameter transfer object.\n   * @returns {Promise<string>} - Resolves to the priority host of a service.\n   */\n  waitForService({name, timeout = 5, url}) {\n    const {services} = this.webex.config;\n\n    // Save memory by grabbing the catalog after there isn't a priortyURL\n    const catalog = this._getCatalog();\n\n    const fetchFromServiceUrl = services.servicesNotNeedValidation.find(\n      (service) => service === name\n    );\n\n    if (fetchFromServiceUrl) {\n      return Promise.resolve(this._activeServices[name]);\n    }\n\n    const priorityUrl = this.get(name, true);\n    const priorityUrlObj = this.getServiceFromUrl(url);\n\n    if (priorityUrl || priorityUrlObj) {\n      return Promise.resolve(priorityUrl || priorityUrlObj.priorityUrl);\n    }\n\n    if (catalog.isReady) {\n      if (url) {\n        return Promise.resolve(url);\n      }\n\n      this.webex.internal.metrics.submitClientMetrics(METRICS.JS_SDK_SERVICE_NOT_FOUND, {\n        fields: {service_name: name},\n      });\n\n      return Promise.reject(\n        new Error(`services: service '${name}' was not found in any of the catalogs`)\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      const groupsToCheck = ['preauth', 'signin', 'postauth'];\n      const checkCatalog = (catalogGroup) =>\n        catalog\n          .waitForCatalog(catalogGroup, timeout)\n          .then(() => {\n            const scopedPriorityUrl = this.get(name, true);\n            const scopedPrioriryUrlObj = this.getServiceFromUrl(url);\n\n            if (scopedPriorityUrl || scopedPrioriryUrlObj) {\n              resolve(scopedPriorityUrl || scopedPrioriryUrlObj.priorityUrl);\n            }\n          })\n          .catch(() => undefined);\n\n      Promise.all(groupsToCheck.map((group) => checkCatalog(group))).then(() => {\n        this.webex.internal.metrics.submitClientMetrics(METRICS.JS_SDK_SERVICE_NOT_FOUND, {\n          fields: {service_name: name},\n        });\n        reject(new Error(`services: service '${name}' was not found after waiting`));\n      });\n    });\n  },\n\n  /**\n   * Looks up the hostname in the host catalog\n   * and replaces it with the first host if it finds it\n   * @param {string} uri\n   * @returns {string} uri with the host replaced\n   */\n  replaceHostFromHostmap(uri) {\n    const url = new URL(uri);\n    const hostCatalog = this._services;\n\n    if (!hostCatalog) {\n      return uri;\n    }\n\n    const host = hostCatalog[url.host];\n\n    if (host && host[0]) {\n      const newHost = host[0].host;\n\n      url.host = newHost;\n\n      return url.toString();\n    }\n\n    return uri;\n  },\n\n  /**\n   * Formats a host map entry for use in service catalog.\n   *\n   * @param {Object} entry - The host map entry to format.\n   * @param {string} entry.serviceName - i.e. conversation, identity, etc.\n   * @param {string} entry.id - The unique identifier for the service, usually clusterId.\n   * @param {Array<IServiceDetail>} entry.serviceUrls - The group to which the service belongs.\n   * @returns {Object} - The formatted host map entry.\n   */\n  _formatHostMapEntry({id, serviceName, serviceUrls}) {\n    const formattedServiceUrls = serviceUrls.map((serviceUrl) => ({\n      host: new URL(serviceUrl.baseUrl).host,\n      ...serviceUrl,\n    }));\n\n    return {\n      id,\n      serviceName,\n      serviceUrls: formattedServiceUrls,\n    };\n  },\n\n  /**\n   * @private\n   * Organize a received hostmap from a service\n   * @param {object} serviceHostmap\n   * catalog endpoint.\n   * @returns {object}\n   */\n  _formatReceivedHostmap({services, activeServices}) {\n    const formattedHostmap = services.map((service) => this._formatHostMapEntry(service));\n    this._updateActiveServices(activeServices);\n    this._updateServices(services);\n\n    return formattedHostmap;\n  },\n\n  /**\n   * Get the clusterId associated with a URL string.\n   * @param {string} url\n   * @returns {string} - Cluster ID of url provided\n   */\n  getClusterId(url) {\n    const catalog = this._getCatalog();\n\n    return catalog.findClusterId(url);\n  },\n\n  /**\n   * Get a service value from a provided clusterId. This method will\n   * return an object containing both the name and url of a found service.\n   * @param {object} params\n   * @param {string} params.clusterId - clusterId of found service\n   * @param {boolean} [params.priorityHost] - returns priority host url if true\n   * @param {string} [params.serviceGroup] - specify service group\n   * @returns {object} service\n   * @returns {string} service.name\n   * @returns {string} service.url\n   */\n  getServiceFromClusterId(params) {\n    const catalog = this._getCatalog();\n\n    return catalog.findServiceFromClusterId(params);\n  },\n\n  /**\n   * @param {String} cluster the cluster containing the id\n   * @param {UUID} [id] the id of the conversation.\n   *  If empty, just return the base URL.\n   * @returns {String} url of the service\n   */\n  getServiceUrlFromClusterId({cluster = 'us'} = {}) {\n    let clusterId = cluster === 'us' ? DEFAULT_CLUSTER_IDENTIFIER : cluster;\n\n    // Determine if cluster has service name (non-US clusters from hydra do not)\n    if (clusterId.split(':').length < 4) {\n      // Add Service to cluster identifier\n      clusterId = `${cluster}:${CLUSTER_SERVICE}`;\n    }\n\n    const {url} = this.getServiceFromClusterId({clusterId}) || {};\n\n    if (!url) {\n      throw Error(`Could not find service for cluster [${cluster}]`);\n    }\n\n    return url;\n  },\n\n  /**\n   * Get a service object from a service url if the service url exists in the\n   * catalog.\n   *\n   * @param {string} url - The url to be validated.\n   * @returns {object} - Service object.\n   * @returns {object.name} - The name of the service found.\n   * @returns {object.priorityUrl} - The priority url of the found service.\n   * @returns {object.defaultUrl} - The default url of the found service.\n   */\n  getServiceFromUrl(url = '') {\n    const service = this._getCatalog().findServiceUrlFromUrl(url);\n\n    if (!service) {\n      return undefined;\n    }\n\n    return {\n      name: service.name,\n      priorityUrl: service.get(true),\n      defaultUrl: service.get(),\n    };\n  },\n\n  /**\n   * Determine if a provided url is in the catalog's allowed domains.\n   *\n   * @param {string} url - The url to match allowed domains against.\n   * @returns {boolean} - True if the url provided is allowed.\n   */\n  isAllowedDomainUrl(url) {\n    const catalog = this._getCatalog();\n\n    return !!catalog.findAllowedDomain(url);\n  },\n\n  /**\n   * Converts the host portion of the url from default host\n   * to a priority host\n   *\n   * @param {string} url a service url that contains a default host\n   * @returns {string} a service url that contains the top priority host.\n   * @throws if url isn't a service url\n   */\n  convertUrlToPriorityHostUrl(url = '') {\n    const data = this.getServiceFromUrl(url);\n\n    if (!data) {\n      throw Error(`No service associated with url: [${url}]`);\n    }\n\n    return url.replace(data.defaultUrl, data.priorityUrl);\n  },\n\n  /**\n   * @private\n   * Simplified method wrapper for sending a request to get\n   * an updated service hostmap.\n   * @param {object} [param]\n   * @param {string} [param.from] - This accepts `limited` or `signin`\n   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values\n   * @param {string} [param.query.email] - must be a standard-format email\n   * @param {string} [param.query.orgId] - must be an organization id\n   * @param {string} [param.query.userId] - must be a user id\n   * @param {string} [param.token] - used for signin catalog\n   * @returns {Promise<object>}\n   */\n  _fetchNewServiceHostmap({from, query, token, forceRefresh} = {}) {\n    const service = 'u2c';\n    const resource = from ? `/${from}/catalog` : '/catalog';\n    const qs = {...(query || {}), format: 'hostmap'};\n\n    if (forceRefresh) {\n      qs.timestamp = new Date().getTime();\n    }\n\n    const requestObject = {\n      method: 'GET',\n      service,\n      resource,\n      qs,\n    };\n\n    if (token) {\n      requestObject.headers = {authorization: token};\n    }\n\n    return this.webex.internal.newMetrics.callDiagnosticLatencies\n      .measureLatency(() => this.request(requestObject), 'internal.get.u2c.time')\n      .then(({body}) => this._formatReceivedHostmap(body));\n  },\n\n  /**\n   * Initialize the discovery services and the whitelisted services.\n   *\n   * @returns {void}\n   */\n  initConfig() {\n    // Get the catalog and destructure the services config.\n    const catalog = this._getCatalog();\n    const {services, fedramp} = this.webex.config;\n\n    // Validate that the services configuration exists.\n    if (services) {\n      if (fedramp) {\n        services.discovery = fedRampServices;\n      }\n      // Check for discovery services.\n      if (services.discovery) {\n        // Format the discovery configuration into an injectable array.\n        const formattedDiscoveryServices = Object.keys(services.discovery).map((key) =>\n          this._formatHostMapEntry({\n            id: key,\n            serviceName: key,\n            serviceUrls: [{baseUrl: services.discovery[key], priority: 1}],\n          })\n        );\n\n        // Inject formatted discovery services into services catalog.\n        catalog.updateServiceGroups('discovery', formattedDiscoveryServices);\n      }\n\n      if (services.override) {\n        // Format the override configuration into an injectable array.\n        const formattedOverrideServices = Object.keys(services.override).map((key) =>\n          this._formatHostMapEntry({\n            id: key,\n            serviceName: key,\n            serviceUrls: [{baseUrl: services.override[key], priority: 1}],\n          })\n        );\n\n        // Inject formatted override services into services catalog.\n        catalog.updateServiceGroups('override', formattedOverrideServices);\n      }\n\n      // if not fedramp, append on the commercialAllowedDomains\n      if (!fedramp) {\n        services.allowedDomains = union(services.allowedDomains, COMMERCIAL_ALLOWED_DOMAINS);\n      }\n\n      // Check for allowed host domains.\n      if (services.allowedDomains) {\n        // Store the allowed domains as a property of the catalog.\n        catalog.setAllowedDomains(services.allowedDomains);\n      }\n\n      // Set `validateDomains` property to match configuration\n      this.validateDomains = services.validateDomains;\n    }\n  },\n\n  /**\n   * Make the initial requests to collect the root catalogs.\n   *\n   * @returns {Promise<void, Error>} - Errors if the token is unavailable.\n   */\n  initServiceCatalogs() {\n    this.logger.info('services: initializing initial service catalogs');\n\n    // Destructure the credentials plugin.\n    const {credentials} = this.webex;\n\n    // Init a promise chain. Must be done as a Promise.resolve() to allow\n    // credentials#getOrgId() to properly throw.\n    return (\n      Promise.resolve()\n        // Get the user's OrgId.\n        .then(() => credentials.getOrgId())\n        // Begin collecting the preauth/limited catalog.\n        .then((orgId) => this.collectPreauthCatalog({orgId}))\n        .then(() => {\n          // Validate if the token is authorized.\n          if (credentials.canAuthorize) {\n            // Attempt to collect the postauth catalog.\n            return this.updateServices().catch(() => {\n              this.initFailed = true;\n              this.logger.warn('services: cannot retrieve postauth catalog');\n            });\n          }\n\n          // Return a resolved promise for consistent return value.\n          return Promise.resolve();\n        })\n    );\n  },\n\n  /**\n   * Initializer\n   *\n   * @instance\n   * @memberof Services\n   * @returns {Services}\n   */\n  initialize() {\n    const catalog = new ServiceCatalog();\n    this._catalogs.set(this.webex, catalog);\n\n    // Listen for configuration changes once.\n    this.listenToOnce(this.webex, 'change:config', () => {\n      this.initConfig();\n    });\n\n    // wait for webex instance to be ready before attempting\n    // to update the service catalogs\n    this.listenToOnce(this.webex, 'ready', () => {\n      const {supertoken} = this.webex.credentials;\n      // Validate if the supertoken exists.\n      if (supertoken && supertoken.access_token) {\n        this.initServiceCatalogs()\n          .then(() => {\n            catalog.isReady = true;\n          })\n          .catch((error) => {\n            this.initFailed = true;\n            this.logger.error(\n              `services: failed to init initial services when credentials available, ${error?.message}`\n            );\n          });\n      } else {\n        const {email} = this.webex.config;\n\n        this.collectPreauthCatalog(email ? {email} : undefined).catch((error) => {\n          this.initFailed = true;\n          this.logger.error(\n            `services: failed to init initial services when no credentials available, ${error?.message}`\n          );\n        });\n      }\n    });\n  },\n});\n/* eslint-enable no-underscore-dangle */\n\nexport default Services;\n"],"mappings":"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"}