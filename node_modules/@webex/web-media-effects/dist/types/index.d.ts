import TypedEmitter from 'typed-emitter';
import * as js_logger from 'js-logger';
export { default as Logger } from 'js-logger';
import { Generator, Quality, BlurStrength, Pipeline } from '@webex/ladon-ts';
export { BlurStrength, Generator, Quality } from '@webex/ladon-ts';

declare const EventEmitter_base: new <TT>() => TypedEmitter<TT>;
declare class EventEmitter<T> extends EventEmitter_base<T> {
}

type MediaStreamOrTrack = MediaStream | MediaStreamTrack;
interface TrackEffect {
    getUnderlyingStream(): MediaStream | undefined;
    getOutputTrack(): MediaStreamTrack | undefined;
    load(input: MediaStreamOrTrack): Promise<MediaStreamOrTrack>;
    loadMediaStream(stream: MediaStream): Promise<MediaStream>;
    loadMediaStreamTrack(track: MediaStreamTrack): Promise<MediaStreamTrack>;
    replaceInputTrack(track: MediaStreamTrack): Promise<void>;
    setEnabled(enable: boolean): Promise<void>;
    enable(): Promise<void | boolean>;
    disable(): Promise<void | boolean>;
    dispose(): void;
}

declare enum EffectEnv {
    Prod = "prod",
    Int = "int"
}
declare enum EffectEvent {
    TrackUpdated = "track-updated",
    Enabled = "enabled",
    Disabled = "disabled",
    Disposed = "disposed"
}
interface EffectEventCallback {
    [EffectEvent.TrackUpdated]: (track: MediaStreamTrack) => void;
    [EffectEvent.Enabled]: () => void;
    [EffectEvent.Disabled]: () => void;
    [EffectEvent.Disposed]: () => void;
}
interface EffectOptions {
    [key: string]: unknown;
}
declare abstract class BaseEffect extends EventEmitter<EffectEventCallback> implements TrackEffect {
    protected effectTrack?: MediaStreamTrack;
    protected outputTrack?: MediaStreamTrack;
    protected inputStream?: MediaStream;
    protected outputStream?: MediaStream;
    readonly id: string;
    readonly kind: string;
    isEnabled: boolean;
    get underlyingStream(): MediaStream | undefined;
    get inputTrack(): MediaStreamTrack | undefined;
    constructor();
    getOutputTrack(): MediaStreamTrack | undefined;
    getOutputStream(): MediaStream | undefined;
    getUnderlyingStream(): MediaStream | undefined;
    preloadAssets(): Promise<void>;
    load(stream: MediaStream): Promise<MediaStream>;
    load(track: MediaStreamTrack): Promise<MediaStreamTrack>;
    loadMediaStream(input: MediaStream): Promise<MediaStream>;
    loadMediaStreamTrack(input: MediaStreamTrack): Promise<MediaStreamTrack>;
    loadMedia(inputTrack: MediaStreamTrack, inputStream?: MediaStream): Promise<void>;
    replaceInputTrack(track: MediaStreamTrack): Promise<void>;
    enable(): Promise<void | boolean>;
    disable(): Promise<void | boolean>;
    dispose(): Promise<void>;
    setEnabled(enable: boolean): Promise<void>;
}
declare const createEffect: <T extends BaseEffect, O>(EffectClass: new (opts?: O | undefined) => T, options?: EffectOptions & O, preloadAssets?: boolean) => Promise<T>;

declare abstract class BaseCameraEffect extends BaseEffect {
}

declare abstract class BaseMicrophoneEffect extends BaseEffect {
    audioContext: AudioContext;
    constructor(audioCtx?: AudioContext);
}

interface GainEffectOptions {
    audioContext: AudioContext;
    maxGain: number;
    rampTime: number;
}
declare class GainEffect extends BaseMicrophoneEffect {
    static readonly kind = "gain-effect";
    gainNode: GainNode;
    gainValue: number;
    options: GainEffectOptions;
    constructor(options: GainEffectOptions);
    loadMediaStream(input: MediaStream): Promise<MediaStream>;
    loadMediaStreamTrack(input: MediaStreamTrack): Promise<MediaStreamTrack>;
    createOutputStream(): Promise<MediaStream>;
    setGainValue(value: number): void;
    enable(): Promise<void>;
    disable(): Promise<void>;
    dispose(): Promise<void>;
}

declare enum NoiseReductionMode {
    Legacy = "LEGACY",
    Worklet = "WORKLET"
}
interface NoiseReductionEffectOptions extends EffectOptions {
    authToken: string;
    audioContext?: AudioContext;
    mode?: NoiseReductionMode;
    env?: EffectEnv;
    avoidSimd?: boolean;
    workletProcessorUrl?: string;
    legacyProcessorUrl?: string;
}
declare class NoiseReductionEffect extends BaseMicrophoneEffect {
    static readonly kind = "noise-reduction-effect";
    static supportsSimd: () => Promise<boolean>;
    static Events: {
        Ready: string;
        Disabled: string;
        Disposed: string;
        Enabled: string;
        Error: string;
    };
    sourceNode?: MediaStreamAudioSourceNode;
    workletNode?: AudioWorkletNode;
    legacyProcessor?: typeof window.WebMediaEffects.NoiseReductionLegacyProcessor;
    legacyScriptNode?: ScriptProcessorNode;
    isReady: boolean;
    options: Partial<NoiseReductionEffectOptions>;
    private disableFuture;
    private enableFuture;
    private preloadFuture?;
    private loadFuture?;
    private disposeFuture?;
    get isLoaded(): boolean;
    constructor(options?: Partial<NoiseReductionEffectOptions>);
    private fetchUrl;
    loadMediaStream(input: MediaStream): Promise<MediaStream>;
    loadMediaStreamTrack(input: MediaStreamTrack): Promise<MediaStreamTrack>;
    createOutputStream(): Promise<MediaStream>;
    preloadAssets(): Promise<void>;
    private fetchAndLoadWorkletProcessor;
    private fetchAndLoadLegacyProcessor;
    loadWorklet(stream: MediaStream, destination: MediaStreamAudioDestinationNode): Promise<MediaStream>;
    loadLegacy(stream: MediaStream, destination: MediaStreamAudioDestinationNode): Promise<MediaStream>;
    enable(): Promise<void>;
    disable(): Promise<void>;
    dispose(): Promise<void>;
    handleDisabled(): Promise<void>;
    handleEnabled(): Promise<void>;
}
declare const createNoiseReductionEffect: (options?: NoiseReductionEffectOptions, preloadAssets?: boolean) => Promise<NoiseReductionEffect>;

declare const logger: js_logger.ILogger;
//# sourceMappingURL=logger.d.ts.map

interface RateEstimatorOptions {
    hysteresisMargin: number;
    lowDuration: number;
    lowThreshold: number;
    minSamples: number;
    maxSamples: number;
}
declare enum RateEstimatorEvent {
    RateOk = "rate-ok",
    RateLow = "rate-low",
    RateLagging = "rate-lagging"
}
interface RateEstimatorEventCallback {
    [RateEstimatorEvent.RateLow]: (rate: number) => void;
    [RateEstimatorEvent.RateOk]: (rate: number) => void;
    [RateEstimatorEvent.RateLagging]: (rate: number) => void;
}
declare enum RateEstimatorStatus {
    Idle = "idle",
    Init = "init",
    Lagging = "lagging",
    Low = "low",
    Ok = "ok"
}
interface RateEstimatedValues {
    rate?: number;
    status: RateEstimatorStatus;
    threshold: number;
}
declare class RateEstimator extends EventEmitter<RateEstimatorEventCallback> {
    private timestamps;
    private targetRate?;
    private estimatedRate?;
    private lowRateStartTime?;
    private options;
    status: RateEstimatorStatus;
    constructor(targetRate: number, options?: Partial<RateEstimatorOptions>);
    getEstimatedValues(): RateEstimatedValues;
    getOptions(): Readonly<RateEstimatorOptions>;
    getTimestamps(): Readonly<number[]>;
    addTimestamp(timestamp: DOMHighResTimeStamp): void;
    private calculateAndUpdateRate;
    private evaluateRate;
    private isRateLow;
    private handleLowRate;
    private handleReturnToNormalRate;
    reset(): void;
    updateOptions(newOptions: Partial<RateEstimatorOptions>): void;
}

declare function debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(func: F, delay: number): (...args: Parameters<F>) => void;

declare const DEFAULT_FRAME_RATE = 24;

declare enum VirtualBackgroundMode {
    Blur = "BLUR",
    Image = "IMAGE",
    Video = "VIDEO"
}
interface VirtualBackgroundEffectOptions extends EffectOptions {
    generator: Generator;
    mode: VirtualBackgroundMode;
    quality: Quality;
    frameRate?: number;
    blurStrength?: BlurStrength;
    bgImageUrl?: string;
    bgVideoUrl?: string;
    authToken: string;
    mirror: boolean;
    env?: EffectEnv;
    preventBackgroundThrottling?: boolean;
}
declare const defaultOptions: VirtualBackgroundEffectOptions;
declare class VirtualBackgroundEffect extends BaseCameraEffect {
    static readonly kind = "virtual-background-effect";
    static readonly BlurStrength: typeof BlurStrength;
    static readonly Quality: typeof Quality;
    readonly defaultOptions: VirtualBackgroundEffectOptions;
    inputEl?: HTMLCanvasElement;
    outputEl?: HTMLCanvasElement;
    videoEl?: HTMLVideoElement;
    virtualVideoEl?: HTMLVideoElement;
    backgroundEl?: HTMLCanvasElement;
    options: VirtualBackgroundEffectOptions;
    model?: Pipeline;
    uniqueId: number;
    requestFrame?: ReturnType<typeof debounce>;
    trackSettings?: MediaTrackSettings;
    private preloadFuture?;
    private loadFuture?;
    private disposeFuture?;
    private onFrameProcessedCallback?;
    private lastFrameTime;
    private frameInterval;
    private restoreEffectOnTrackEnable;
    private timerId?;
    get isReady(): boolean;
    get isLoaded(): boolean;
    get frameRate(): number;
    constructor(options?: Partial<VirtualBackgroundEffectOptions>);
    preloadAssets(): Promise<void>;
    loadMediaStream(input: MediaStream): Promise<MediaStream>;
    loadMediaStreamTrack(input: MediaStreamTrack): Promise<MediaStreamTrack>;
    loadDomAndModel(): Promise<void>;
    private setupVisibilityChange;
    private handleVisibilityChange;
    private requestAnimationFrameWrapper;
    private setTimeoutWrapper;
    private clearTimers;
    private createPipeline;
    private loadModel;
    private handleFrame;
    private manageEffectRestoration;
    private setupDom;
    private detectQuirks;
    private handleOrientationChange;
    private handleVideoLoadedMetadata;
    private handleVideoResize;
    private handleModelResolver;
    enable(): Promise<boolean>;
    disable(): Promise<boolean>;
    dispose(): Promise<void>;
    setOnFrameProcessedCallback(callback: (timestamp: number) => void): void;
    updateOptions(options: Partial<VirtualBackgroundEffectOptions>): Promise<void>;
    updateSize(width: number, height: number): Promise<void>;
}
declare const createVirtualBackgroundEffect: (options?: VirtualBackgroundEffectOptions, preloadAssets?: boolean) => Promise<VirtualBackgroundEffect>;

export { BaseCameraEffect, BaseEffect, BaseMicrophoneEffect, DEFAULT_FRAME_RATE, EffectEnv, EffectEvent, EffectEventCallback, EffectOptions, GainEffect, MediaStreamOrTrack, NoiseReductionEffect, NoiseReductionEffectOptions, NoiseReductionMode, RateEstimatedValues, RateEstimator, RateEstimatorEvent, RateEstimatorEventCallback, RateEstimatorOptions, RateEstimatorStatus, TrackEffect, VirtualBackgroundEffect, VirtualBackgroundEffectOptions, VirtualBackgroundMode, createEffect, createNoiseReductionEffect, createVirtualBackgroundEffect, defaultOptions, logger };
