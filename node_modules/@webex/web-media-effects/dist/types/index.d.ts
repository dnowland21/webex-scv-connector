import TypedEmitter from 'typed-emitter';
import { IFrameInferenceResult, Generator, Quality, BlurStrength, Pipeline } from '@webex/ladon-ts';
export { BlurStrength, Generator, Quality } from '@webex/ladon-ts';
import * as js_logger from 'js-logger';
export { default as Logger } from 'js-logger';

declare const EventEmitter_base: new <TT>() => TypedEmitter<TT>;
declare class EventEmitter<T> extends EventEmitter_base<T> {
}

declare type MediaStreamOrTrack = MediaStream | MediaStreamTrack;
interface TrackEffect {
    getUnderlyingStream(): MediaStream | undefined;
    getOutputTrack(): MediaStreamTrack | undefined;
    load(input: MediaStreamOrTrack): Promise<MediaStreamOrTrack>;
    loadMediaStream(stream: MediaStream): Promise<MediaStream>;
    loadMediaStreamTrack(track: MediaStreamTrack): Promise<MediaStreamTrack>;
    replaceInputTrack(track: MediaStreamTrack): Promise<void>;
    setEnabled(enable: boolean): Promise<void>;
    enable(): Promise<void | boolean>;
    disable(): Promise<void | boolean>;
    dispose(): void;
}

declare enum EffectEnv {
    Prod = "prod",
    Int = "int"
}
declare enum EffectState {
    Idle = "idle",
    Init = "init",
    Disabled = "disabled",
    Enabled = "enabled",
    Disposed = "disposed",
    Error = "error"
}
declare enum EffectEvent {
    TrackUpdated = "track-updated",
    Enabled = "enabled",
    Disabled = "disabled",
    Disposed = "disposed"
}
interface EffectEventCallback {
    [EffectEvent.TrackUpdated]: (track: MediaStreamTrack) => void;
    [EffectEvent.Enabled]: () => void;
    [EffectEvent.Disabled]: () => void;
    [EffectEvent.Disposed]: () => void;
}
interface EffectOptions {
    baseUrl?: string;
    authToken?: string;
    env?: EffectEnv;
    [key: string]: unknown;
}
declare abstract class BaseEffect extends EventEmitter<EffectEventCallback> implements TrackEffect {
    protected state: EffectState;
    protected effectTrack?: MediaStreamTrack;
    protected outputTrack?: MediaStreamTrack;
    protected inputStream?: MediaStream;
    protected outputStream?: MediaStream;
    readonly id: string;
    readonly kind: string;
    isEnabled: boolean;
    get underlyingStream(): MediaStream | undefined;
    get inputTrack(): MediaStreamTrack | undefined;
    constructor();
    getOutputTrack(): MediaStreamTrack | undefined;
    getOutputStream(): MediaStream | undefined;
    getUnderlyingStream(): MediaStream | undefined;
    preloadAssets(): Promise<void>;
    load(stream: MediaStream): Promise<MediaStream>;
    load(track: MediaStreamTrack): Promise<MediaStreamTrack>;
    loadMediaStream(input: MediaStream): Promise<MediaStream>;
    loadMediaStreamTrack(input: MediaStreamTrack): Promise<MediaStreamTrack>;
    loadMedia(inputTrack: MediaStreamTrack, inputStream?: MediaStream): Promise<void>;
    replaceInputTrack(track: MediaStreamTrack): Promise<void>;
    enable(): Promise<void | boolean>;
    disable(): Promise<void | boolean>;
    dispose(): Promise<void>;
    setEnabled(enable: boolean): Promise<void>;
}
declare const createEffect: <T extends BaseEffect, O>(EffectClass: new (opts?: O | undefined) => T, options?: EffectOptions & O, preloadAssets?: boolean) => Promise<T>;

declare abstract class BaseCameraEffect extends BaseEffect {
}

declare abstract class BaseMicrophoneEffect extends BaseEffect {
    audioContext: AudioContext;
    constructor(audioCtx?: AudioContext);
    updateAudioContext(audioContext: AudioContext): void;
}

interface GainEffectOptions {
    audioContext: AudioContext;
    maxGain: number;
    rampTime: number;
}
declare class GainEffect extends BaseMicrophoneEffect {
    static readonly kind = "gain-effect";
    gainNode: GainNode;
    gainValue: number;
    options: GainEffectOptions;
    constructor(options: GainEffectOptions);
    loadMediaStream(input: MediaStream): Promise<MediaStream>;
    loadMediaStreamTrack(input: MediaStreamTrack): Promise<MediaStreamTrack>;
    createOutputStream(): Promise<MediaStream>;
    setGainValue(value: number): void;
    enable(): Promise<void>;
    disable(): Promise<void>;
    dispose(): Promise<void>;
}

declare enum NoiseReductionMode {
    Legacy = "LEGACY",
    Worklet = "WORKLET"
}
interface NoiseReductionEffectOptions extends EffectOptions {
    audioContext?: AudioContext;
    avoidSimd?: boolean;
    mode?: NoiseReductionMode;
    legacyProcessorUrl?: string;
    workletProcessorUrl?: string;
}

declare class NoiseReductionEffect extends BaseMicrophoneEffect {
    static readonly kind = "noise-reduction-effect";
    static supportsSimd: () => Promise<boolean>;
    static Events: {
        Ready: string;
        Disabled: string;
        Disposed: string;
        Enabled: string;
        Error: string;
    };
    sourceNode?: MediaStreamAudioSourceNode;
    workletNode?: AudioWorkletNode;
    legacyProcessor?: typeof window.WebMediaEffects.NoiseReductionLegacyProcessor;
    legacyScriptNode?: ScriptProcessorNode;
    isReady: boolean;
    options: Partial<NoiseReductionEffectOptions>;
    private disableFuture;
    private enableFuture;
    private processorLoadFuture?;
    private loadFuture?;
    private disposeFuture?;
    get isLoaded(): boolean;
    constructor(options?: Partial<NoiseReductionEffectOptions>);
    private fetchUrl;
    loadMediaStream(input: MediaStream): Promise<MediaStream>;
    loadMediaStreamTrack(input: MediaStreamTrack): Promise<MediaStreamTrack>;
    createOutputStream(): Promise<MediaStream>;
    preloadAssets(): Promise<void>;
    private ensureProcessorLoaded;
    private fetchAndLoadWorkletProcessor;
    private fetchAndLoadLegacyProcessor;
    loadWorklet(stream: MediaStream, destination: MediaStreamAudioDestinationNode): Promise<MediaStream>;
    loadLegacy(stream: MediaStream, destination: MediaStreamAudioDestinationNode): Promise<MediaStream>;
    enable(): Promise<void>;
    disable(): Promise<void>;
    dispose(): Promise<void>;
    handleDisabled(): Promise<void>;
    handleEnabled(): Promise<void>;
    updateSampleRate(sampleRate: number): void;
    updateAudioContext(audioContext: AudioContext): Promise<void>;
}
declare const createNoiseReductionEffect: (options?: NoiseReductionEffectOptions, preloadAssets?: boolean) => Promise<NoiseReductionEffect>;

declare enum BeRightBackAction {
    TurnOn = "turn-on",
    TurnOff = "turn-off"
}
declare enum BeRightBackState {
    Idle = "idle",
    Off = "off",
    On = "on"
}
interface BeRightBackOptions {
    motionIouThreshold: number;
    onHysteresisMaxMs: number;
    offHysteresisMaxMs: number;
}
interface BeRightBackDebugInfo {
    action: BeRightBackAction;
    isMoving: boolean;
    offHysteresisDurationMs: number;
    onHysteresisDurationMs: number;
    numFaces: number;
    state: BeRightBackState;
    timeDiffMs: number;
}
declare enum BeRightBackEvent {
    On = "on",
    Off = "off",
    StateChange = "state-change"
}
interface BeRightBackEventCallback {
    [BeRightBackEvent.StateChange]: (newState: BeRightBackState, oldState: BeRightBackState) => void;
    [BeRightBackEvent.On]: () => void;
    [BeRightBackEvent.Off]: () => void;
}
declare enum BeRightBackPluginMode {
    Off = "off",
    Conservative = "conservative",
    Aggressive = "aggressive"
}
interface BeRightBackPluginOptions {
    mode: BeRightBackPluginMode;
    debug?: boolean;
    coreOptions?: Partial<BeRightBackOptions>;
}

declare class BeRightBack extends EventEmitter<BeRightBackEventCallback> {
    private debugBuffer;
    private state;
    private options;
    private onHysteresisDurationMs;
    private offHysteresisDurationMs;
    private lastTimestampMs;
    private isEnabled;
    private isFirstFrame;
    constructor(options?: Partial<BeRightBackOptions>);
    destroy(): void;
    getDebugInfo(): BeRightBackDebugInfo[];
    getLatestDebugInfo(): BeRightBackDebugInfo;
    getState(): BeRightBackState;
    setEnable(enable: boolean): void;
    updateOptions(newOptions: Partial<BeRightBackOptions>): void;
    processFrame(faces: Float32Array, shape: readonly number[], motion: number, timestampMs: number): BeRightBackState;
    private initializeFirstFrameState;
    private determineActionFromInferenceResult;
    private handleHysteresisAndStateChange;
    private accumulateHysteresisAndAttemptTurnOn;
    private accumulateHysteresisAndAttemptTurnOff;
    private changeState;
    private resetHysteresis;
}

interface Plugin {
    isInitialized: boolean;
    initialize(effect: VirtualBackgroundEffect): void;
    dispose(effect: VirtualBackgroundEffect): void;
}
declare type BeforeInferenceResult = {
    shouldInfer: boolean;
    modifiedCanvas?: HTMLCanvasElement;
};
declare type BeforeInferenceCallback = (timestamp: number, lastResult: IFrameInferenceResult, inputCanvas?: HTMLCanvasElement) => Promise<BeforeInferenceResult>;
declare type AfterInferenceCallback = (timestamp: number, result?: IFrameInferenceResult) => Promise<void>;
interface BeforeInferencePlugin extends Plugin {
    onBeforeInference: BeforeInferenceCallback;
}
interface AfterInferencePlugin extends Plugin {
    onAfterInference: AfterInferenceCallback;
}
declare type PluginType = BeforeInferencePlugin | AfterInferencePlugin;
declare class PluginManager {
    private plugins;
    private effect;
    register(name: string, plugin: PluginType): void;
    initialize(effect: VirtualBackgroundEffect): void;
    dispose(): void;
    getPlugin<T extends PluginType>(name: string): T | undefined;
    getPlugins(): Map<string, Plugin>;
}

declare function debounce<F extends (...args: Parameters<F>) => ReturnType<F>>(func: F, delay: number): (...args: Parameters<F>) => void;

declare enum VirtualBackgroundMode {
    Blur = "BLUR",
    Image = "IMAGE",
    Video = "VIDEO",
    Passthrough = "PASSTHROUGH"
}
declare type LadonOverrides = {
    modelUri?: string;
    modelRank?: number;
    workerUri?: string;
    executionProviders?: string[];
    inputSize?: {
        width: number;
        height: number;
    };
    outputSize?: {
        width: number;
        height: number;
    };
    upscaleSize?: {
        width: number;
        height: number;
    };
    modelUrlResolver?: (modelPath: string) => Promise<string>;
};
interface VirtualBackgroundEffectOptions extends EffectOptions {
    generator: Generator;
    mode: VirtualBackgroundMode;
    quality: Quality;
    frameRate?: number;
    blurStrength?: BlurStrength;
    bgImageUrl?: string;
    bgVideoUrl?: string;
    mirror: boolean;
    preventBackgroundThrottling?: boolean;
    canvasResolutionScaling?: number;
    modelOverrides?: LadonOverrides;
}

declare const DEFAULT_FRAME_RATE = 24;

declare class VirtualBackgroundEffect extends BaseCameraEffect {
    static readonly kind = "virtual-background-effect";
    static readonly BlurStrength: typeof BlurStrength;
    static readonly Quality: typeof Quality;
    readonly defaultOptions: VirtualBackgroundEffectOptions;
    inputEl?: HTMLCanvasElement;
    outputEl?: HTMLCanvasElement;
    videoEl?: HTMLVideoElement;
    virtualVideoEl?: HTMLVideoElement;
    backgroundEl?: HTMLCanvasElement;
    options: VirtualBackgroundEffectOptions;
    model?: Pipeline;
    uniqueId: number;
    requestFrame?: ReturnType<typeof debounce>;
    trackSettings?: MediaTrackSettings;
    private preloadFuture?;
    private loadFuture?;
    private disposeFuture?;
    private lastFrameTime;
    private frameInterval;
    private restoreEffectOnTrackEnable;
    private timerId?;
    private lastFrame?;
    private pluginManager;
    private beforeInferenceCallbacks;
    private afterInferenceCallbacks;
    private offscreenCanvas?;
    private inputCanvasContext?;
    private configBuilder;
    get isReady(): boolean;
    get isLoaded(): boolean;
    get frameRate(): number;
    constructor(options?: Partial<VirtualBackgroundEffectOptions>);
    preloadAssets(): Promise<void>;
    loadMediaStream(input: MediaStream): Promise<MediaStream>;
    loadMediaStreamTrack(input: MediaStreamTrack): Promise<MediaStreamTrack>;
    loadDomAndModel(): Promise<void>;
    private setupVisibilityChange;
    private handleVisibilityChange;
    private requestAnimationFrameWrapper;
    private setTimeoutWrapper;
    private clearTimers;
    private configureBuilder;
    private createPipeline;
    private loadModel;
    private handleFrame;
    private manageEffectRestoration;
    private prepareInputCanvas;
    private executeBeforeInferenceCallbacks;
    private executeAfterInferenceCallbacks;
    private setupDom;
    private detectQuirks;
    private handleOrientationChange;
    private handleVideoLoadedMetadata;
    private handleVideoResize;
    private handleAssetUrlResolver;
    enable(): Promise<boolean>;
    disable(): Promise<boolean>;
    dispose(): Promise<void>;
    addBeforeInferenceCallback(callback: BeforeInferenceCallback): void;
    addAfterInferenceCallback(callback: AfterInferenceCallback): void;
    removeBeforeInferenceCallback(callback: BeforeInferenceCallback): void;
    removeAfterInferenceCallback(callback: AfterInferenceCallback): void;
    setOnFrameProcessedCallback(callback: AfterInferenceCallback): void;
    updateOptions(options: Partial<VirtualBackgroundEffectOptions>): Promise<void>;
    updateSize(width: number, height: number): Promise<void>;
    registerPlugin: (name: string, plugin: PluginType) => void;
    initializePlugins: () => void;
    getPlugin: <T extends PluginType>(name: string) => T | undefined;
    getPluginManager: () => PluginManager;
}
declare const createVirtualBackgroundEffect: (options?: VirtualBackgroundEffectOptions, preloadAssets?: boolean) => Promise<VirtualBackgroundEffect>;

declare abstract class BaseInferencePlugin<T, O> {
    protected core: T;
    protected options: O;
    protected isEffectEnabled: boolean;
    isInitialized: boolean;
    constructor(options?: Partial<O>);
    initialize(effect: VirtualBackgroundEffect): void;
    dispose(): void;
    updateOptions(newOptions: Partial<O>): void;
    protected getDefaultOptions(options?: Partial<O>): O;
    protected createCore(): T;
    protected onCoreCreated(): void;
    protected onEffectEnabled(): void;
    protected onEffectDisabled(): void;
    protected cleanup(): void;
    protected onOptionsUpdated(): void;
    protected abstract destroyCore(): void;
}

declare abstract class BaseEventEmitterPlugin<T extends EventEmitter<unknown>, O> extends BaseInferencePlugin<T, O> {
    on?: T['on'];
    off?: T['off'];
    once?: T['once'];
    constructor(options?: Partial<O>);
    destroyCore(): void;
}

declare abstract class BaseAfterInferencePlugin<T extends EventEmitter<unknown> = EventEmitter<unknown>, O extends object = Record<string, never>> extends BaseEventEmitterPlugin<T, O> {
    constructor(options?: Partial<O>);
    initialize(effect: VirtualBackgroundEffect): void;
    dispose(): void;
    abstract onAfterInference(timestamp: number, result?: IFrameInferenceResult): Promise<void>;
}

declare class BeRightBackPlugin extends BaseAfterInferencePlugin<BeRightBack, BeRightBackPluginOptions> {
    protected getDefaultOptions(): BeRightBackPluginOptions;
    protected createCore(): BeRightBack;
    onAfterInference(timestamp: number, result?: IFrameInferenceResult): Promise<void>;
    onOptionsUpdated(): void;
    getDebugInfo(): BeRightBackDebugInfo[];
    getLatestDebugInfo(): BeRightBackDebugInfo;
}

declare function getOptionsByMode(mode: BeRightBackPluginMode): BeRightBackOptions;
declare function makeBeRightBackOptions(mode: BeRightBackPluginMode, coreOptions?: Partial<BeRightBackOptions>): BeRightBackOptions;

interface FrameSkipperOptions {
    baseMinSkipTime: number;
    baseMaxSkipTime: number;
    historySize: number;
    skipTimeIncrement: number;
    forcedInferenceInterval: number;
    highMotionThreshold: number;
    smoothingFactor: number;
}
declare enum FrameSkipperInferenceReason {
    Initial = "initial",
    HighMotion = "high-motion",
    TimeForced = "time-forced",
    SkipIntervalElapsed = "skip-interval-elapsed"
}
interface FrameSkipperDebugInfo {
    averageMotion: number;
    currentTime: number;
    currentSkipTime: number;
    isHighMotion: boolean;
    isSkipIntervalElapsed: boolean;
    isTimeForced: boolean;
    lastInferenceReason: FrameSkipperInferenceReason;
    lastInferenceTime: number;
    motionValue: number;
    shouldInfer: boolean;
    smoothedMotion: number;
    timeSinceLastInference: number;
}
declare enum FrameSkipperPluginMode {
    Off = "off",
    Conservative = "conservative",
    Aggressive = "aggressive"
}
interface FrameSkipperPluginOptions {
    mode: FrameSkipperPluginMode;
    debug?: boolean;
    coreOptions?: Partial<FrameSkipperOptions>;
}

declare class AdaptiveFrameSkipper extends EventEmitter<unknown> {
    private options;
    private debugBuffer;
    private motionData;
    private lastInferenceTime;
    private currentSkipTime;
    private lastSmoothedMotion;
    constructor(options?: FrameSkipperOptions);
    destroy(): void;
    getDebugInfo(): FrameSkipperDebugInfo[];
    getLatestDebugInfo(): FrameSkipperDebugInfo;
    shouldPerformInference(motionValue: number, motionTimestamp: number): boolean;
    updateOptions(newOptions: FrameSkipperOptions): void;
    private updateMotionData;
    private adjustSkipTime;
    private calculateSmoothedMotion;
    private calculateAverageMotion;
}

declare abstract class BaseBeforeInferencePlugin<T extends EventEmitter<unknown> = EventEmitter<unknown>, O extends object = Record<string, never>> extends BaseEventEmitterPlugin<T, O> {
    constructor(options: O);
    initialize(effect: VirtualBackgroundEffect): void;
    abstract onBeforeInference(timestamp: number, lastResult: IFrameInferenceResult, inputCanvas?: HTMLCanvasElement): Promise<BeforeInferenceResult>;
}

declare class FrameSkipperPlugin extends BaseBeforeInferencePlugin<AdaptiveFrameSkipper, FrameSkipperPluginOptions> {
    protected getDefaultOptions(): FrameSkipperPluginOptions;
    protected createCore(): AdaptiveFrameSkipper;
    destroyCore(): void;
    onBeforeInference(timestamp: number, lastResult: IFrameInferenceResult): Promise<BeforeInferenceResult>;
    onOptionsUpdated(): void;
    getDebugInfo(): FrameSkipperDebugInfo[];
    getLatestDebugInfo(): FrameSkipperDebugInfo;
}

declare function makeFrameSkipperOptions(mode: FrameSkipperPluginMode, coreOptions?: Partial<FrameSkipperOptions>): FrameSkipperOptions;

declare enum RateEstimatorStatus {
    Idle = "idle",
    Init = "init",
    Lagging = "lagging",
    Low = "low",
    Ok = "ok"
}
interface RateEstimatedValues {
    rate?: number;
    status: RateEstimatorStatus;
    threshold: number;
}
interface RateEstimatorOptions {
    hysteresisMargin: number;
    lowDuration: number;
    lowThreshold: number;
    minSamples: number;
    maxSamples: number;
}
declare enum RateEstimatorEvent {
    RateOk = "rate-ok",
    RateLow = "rate-low",
    RateLagging = "rate-lagging"
}
interface RateEstimatorEventCallback {
    [RateEstimatorEvent.RateLow]: (rate: number) => void;
    [RateEstimatorEvent.RateOk]: (rate: number) => void;
    [RateEstimatorEvent.RateLagging]: (rate: number) => void;
}
interface RateEstimationPluginOptions {
    targetRate: number;
    debug?: boolean;
    coreOptions?: Partial<RateEstimatorOptions>;
}

declare class RateEstimator extends EventEmitter<RateEstimatorEventCallback> {
    private timestamps;
    private estimatedRate?;
    private lowRateStartTime?;
    private options;
    status: RateEstimatorStatus;
    constructor(targetRate: number, options?: Partial<RateEstimatorOptions>);
    dispose(): void;
    getEstimatedValues(): RateEstimatedValues;
    getOptions(): Readonly<RateEstimatorOptions>;
    getTimestamps(): Readonly<number[]>;
    addTimestamp(timestamp: DOMHighResTimeStamp): void;
    private calculateAndUpdateRate;
    private evaluateRate;
    private isRateLow;
    private handleLowRate;
    private handleReturnToNormalRate;
    reset(): void;
    updateOptions(newOptions: Partial<RateEstimatorOptions>): void;
}

declare class RateEstimationPlugin extends BaseAfterInferencePlugin<RateEstimator, RateEstimationPluginOptions> {
    protected createCore(): RateEstimator;
    onCoreCreated(): void;
    onEffectDisabled(): void;
    onEffectEnabled(): void;
    destroyCore(): void;
    onAfterInference(timestamp: number): Promise<void>;
    getRate(): number | undefined;
    getThreshold(): number | undefined;
    getStatus(): RateEstimatorStatus | undefined;
}

declare class SkippedFrameRatePlugin extends BaseAfterInferencePlugin {
    private frameHistory;
    private readonly frameWindowSize;
    onAfterInference(timestamp: number, result?: IFrameInferenceResult): Promise<void>;
    getSkippedPercentage(): number;
    getSkippedFrameCount(): number;
    getTotalFrameCount(): number;
}

declare const logger: js_logger.ILogger;
//# sourceMappingURL=logger.d.ts.map

export { AdaptiveFrameSkipper, BaseCameraEffect, BaseEffect, BaseMicrophoneEffect, BeRightBack, BeRightBackAction, BeRightBackDebugInfo, BeRightBackEvent, BeRightBackEventCallback, BeRightBackOptions, BeRightBackPlugin, BeRightBackPluginMode, BeRightBackPluginOptions, BeRightBackState, DEFAULT_FRAME_RATE, EffectEnv, EffectEvent, EffectEventCallback, EffectOptions, EffectState, FrameSkipperDebugInfo, FrameSkipperInferenceReason, FrameSkipperOptions, FrameSkipperPlugin, FrameSkipperPluginMode, FrameSkipperPluginOptions, GainEffect, LadonOverrides, MediaStreamOrTrack, NoiseReductionEffect, NoiseReductionEffectOptions, NoiseReductionMode, RateEstimatedValues, RateEstimationPlugin, RateEstimationPluginOptions, RateEstimator, RateEstimatorEvent, RateEstimatorEventCallback, RateEstimatorOptions, RateEstimatorStatus, SkippedFrameRatePlugin, TrackEffect, VirtualBackgroundEffect, VirtualBackgroundEffectOptions, VirtualBackgroundMode, createEffect, createNoiseReductionEffect, createVirtualBackgroundEffect, getOptionsByMode, logger, makeBeRightBackOptions, makeFrameSkipperOptions };
