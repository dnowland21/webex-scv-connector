/**
 * Copyright (c) 2024 Cisco Systems, Inc. and/or its affiliated entities.
 * 
 * Your use of the AI effects in this library (e.g., noise reduction, virtual background, etc.) are subject to the Cisco End User License Agreement located at: https://www.cisco.com/c/dam/en_us/about/doing_business/legal/eula/cisco_end_user_license_agreement-eng.pdf
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

// Unique ID creation requires a high quality random # generator. In the browser we therefore
// require the crypto API and do not support built-in fallback to lower quality random number
// generators (like Math.random()).
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  // lazy load so that environments that need to polyfill have a chance to do so
  if (!getRandomValues) {
    // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

    if (!getRandomValues) {
      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
    }
  }

  return getRandomValues(rnds8);
}

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */

const byteToHex = [];

for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 0x100).toString(16).slice(1));
}

function unsafeStringify(arr, offset = 0) {
  // Note: Be careful editing this code!  It's been tuned for performance
  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
}

const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native = {
  randomUUID
};

function v4(options, buf, offset) {
  if (native.randomUUID && !buf && !options) {
    return native.randomUUID();
  }

  options = options || {};
  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

  rnds[6] = rnds[6] & 0x0f | 0x40;
  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

  if (buf) {
    offset = offset || 0;

    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }

    return buf;
  }

  return unsafeStringify(rnds);
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var events = {exports: {}};

var R$2 = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R$2 && typeof R$2.apply === 'function'
  ? R$2.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };

var ReflectOwnKeys;
if (R$2 && typeof R$2.ownKeys === 'function') {
  ReflectOwnKeys = R$2.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events.exports = EventEmitter$1;
events.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter$1.EventEmitter = EventEmitter$1;

EventEmitter$1.prototype._events = undefined;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter$1, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter$1.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter$1.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter$1.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter$1.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter$1.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter$1.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;

EventEmitter$1.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter$1.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter$1.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter$1.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;

EventEmitter$1.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter$1.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter$1.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter$1.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter$1.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

class EventEmitter extends events.exports.EventEmitter {
}

var logger$1 = {exports: {}};

/*!
 * js-logger - http://github.com/jonnyreeves/js-logger
 * Jonny Reeves, http://jonnyreeves.co.uk/
 * js-logger may be freely distributed under the MIT license.
 */

(function (module) {
(function (global) {

	// Top level module for the global, static logger instance.
	var Logger = { };

	// For those that are at home that are keeping score.
	Logger.VERSION = "1.6.1";

	// Function which handles all incoming log messages.
	var logHandler;

	// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.
	var contextualLoggersByNameMap = {};

	// Polyfill for ES5's Function.bind.
	var bind = function(scope, func) {
		return function() {
			return func.apply(scope, arguments);
		};
	};

	// Super exciting object merger-matron 9000 adding another 100 bytes to your download.
	var merge = function () {
		var args = arguments, target = args[0], key, i;
		for (i = 1; i < args.length; i++) {
			for (key in args[i]) {
				if (!(key in target) && args[i].hasOwnProperty(key)) {
					target[key] = args[i][key];
				}
			}
		}
		return target;
	};

	// Helper to define a logging level object; helps with optimisation.
	var defineLogLevel = function(value, name) {
		return { value: value, name: name };
	};

	// Predefined logging levels.
	Logger.TRACE = defineLogLevel(1, 'TRACE');
	Logger.DEBUG = defineLogLevel(2, 'DEBUG');
	Logger.INFO = defineLogLevel(3, 'INFO');
	Logger.TIME = defineLogLevel(4, 'TIME');
	Logger.WARN = defineLogLevel(5, 'WARN');
	Logger.ERROR = defineLogLevel(8, 'ERROR');
	Logger.OFF = defineLogLevel(99, 'OFF');

	// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently
	// of each other.
	var ContextualLogger = function(defaultContext) {
		this.context = defaultContext;
		this.setLevel(defaultContext.filterLevel);
		this.log = this.info;  // Convenience alias.
	};

	ContextualLogger.prototype = {
		// Changes the current logging level for the logging instance.
		setLevel: function (newLevel) {
			// Ensure the supplied Level object looks valid.
			if (newLevel && "value" in newLevel) {
				this.context.filterLevel = newLevel;
			}
		},
		
		// Gets the current logging level for the logging instance
		getLevel: function () {
			return this.context.filterLevel;
		},

		// Is the logger configured to output messages at the supplied level?
		enabledFor: function (lvl) {
			var filterLevel = this.context.filterLevel;
			return lvl.value >= filterLevel.value;
		},

		trace: function () {
			this.invoke(Logger.TRACE, arguments);
		},

		debug: function () {
			this.invoke(Logger.DEBUG, arguments);
		},

		info: function () {
			this.invoke(Logger.INFO, arguments);
		},

		warn: function () {
			this.invoke(Logger.WARN, arguments);
		},

		error: function () {
			this.invoke(Logger.ERROR, arguments);
		},

		time: function (label) {
			if (typeof label === 'string' && label.length > 0) {
				this.invoke(Logger.TIME, [ label, 'start' ]);
			}
		},

		timeEnd: function (label) {
			if (typeof label === 'string' && label.length > 0) {
				this.invoke(Logger.TIME, [ label, 'end' ]);
			}
		},

		// Invokes the logger callback if it's not being filtered.
		invoke: function (level, msgArgs) {
			if (logHandler && this.enabledFor(level)) {
				logHandler(msgArgs, merge({ level: level }, this.context));
			}
		}
	};

	// Protected instance which all calls to the to level `Logger` module will be routed through.
	var globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });

	// Configure the global Logger instance.
	(function() {
		// Shortcut for optimisers.
		var L = Logger;

		L.enabledFor = bind(globalLogger, globalLogger.enabledFor);
		L.trace = bind(globalLogger, globalLogger.trace);
		L.debug = bind(globalLogger, globalLogger.debug);
		L.time = bind(globalLogger, globalLogger.time);
		L.timeEnd = bind(globalLogger, globalLogger.timeEnd);
		L.info = bind(globalLogger, globalLogger.info);
		L.warn = bind(globalLogger, globalLogger.warn);
		L.error = bind(globalLogger, globalLogger.error);

		// Don't forget the convenience alias!
		L.log = L.info;
	}());

	// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments
	// object with the supplied log messages and the second being a context object which contains a hash of stateful
	// parameters which the logging function can consume.
	Logger.setHandler = function (func) {
		logHandler = func;
	};

	// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.
	// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).
	Logger.setLevel = function(level) {
		// Set the globalLogger's level.
		globalLogger.setLevel(level);

		// Apply this level to all registered contextual loggers.
		for (var key in contextualLoggersByNameMap) {
			if (contextualLoggersByNameMap.hasOwnProperty(key)) {
				contextualLoggersByNameMap[key].setLevel(level);
			}
		}
	};

	// Gets the global logging filter level
	Logger.getLevel = function() {
		return globalLogger.getLevel();
	};

	// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,
	// default context and log handler.
	Logger.get = function (name) {
		// All logger instances are cached so they can be configured ahead of use.
		return contextualLoggersByNameMap[name] ||
			(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));
	};

	// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will
	// write to the window's console object (if present); the optional options object can be used to customise the
	// formatter used to format each log message.
	Logger.createDefaultHandler = function (options) {
		options = options || {};

		options.formatter = options.formatter || function defaultMessageFormatter(messages, context) {
			// Prepend the logger's name to the log message for easy identification.
			if (context.name) {
				messages.unshift("[" + context.name + "]");
			}
		};

		// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments
		// that don't offer a native console method.
		var timerStartTimeByLabelMap = {};

		// Support for IE8+ (and other, slightly more sane environments)
		var invokeConsoleMethod = function (hdlr, messages) {
			Function.prototype.apply.call(hdlr, console, messages);
		};

		// Check for the presence of a logger.
		if (typeof console === "undefined") {
			return function () { /* no console */ };
		}

		return function(messages, context) {
			// Convert arguments object to Array.
			messages = Array.prototype.slice.call(messages);

			var hdlr = console.log;
			var timerLabel;

			if (context.level === Logger.TIME) {
				timerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];

				if (messages[1] === 'start') {
					if (console.time) {
						console.time(timerLabel);
					}
					else {
						timerStartTimeByLabelMap[timerLabel] = new Date().getTime();
					}
				}
				else {
					if (console.timeEnd) {
						console.timeEnd(timerLabel);
					}
					else {
						invokeConsoleMethod(hdlr, [ timerLabel + ': ' +
							(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);
					}
				}
			}
			else {
				// Delegate through to custom warn/error loggers if present on the console.
				if (context.level === Logger.WARN && console.warn) {
					hdlr = console.warn;
				} else if (context.level === Logger.ERROR && console.error) {
					hdlr = console.error;
				} else if (context.level === Logger.INFO && console.info) {
					hdlr = console.info;
				} else if (context.level === Logger.DEBUG && console.debug) {
					hdlr = console.debug;
				} else if (context.level === Logger.TRACE && console.trace) {
					hdlr = console.trace;
				}

				options.formatter(messages, context);
				invokeConsoleMethod(hdlr, messages);
			}
		};
	};

	// Configure and example a Default implementation which writes to the `window.console` (if present).  The
	// `options` hash can be used to configure the default logLevel and provide a custom message formatter.
	Logger.useDefaults = function(options) {
		Logger.setLevel(options && options.defaultLevel || Logger.DEBUG);
		Logger.setHandler(Logger.createDefaultHandler(options));
	};

	// Createa an alias to useDefaults to avoid reaking a react-hooks rule.
	Logger.setDefaults = Logger.useDefaults;

	// Export to popular environments boilerplate.
	if (module.exports) {
		module.exports = Logger;
	}
	else {
		Logger._prevLogger = global.Logger;

		Logger.noConflict = function () {
			global.Logger = Logger._prevLogger;
			return Logger;
		};

		global.Logger = Logger;
	}
}(commonjsGlobal));
}(logger$1));

var Logger = logger$1.exports;

const logger = Logger.get('web-media-effects');
const consoleLogHandler = Logger.createDefaultHandler({
    formatter: (msg, context) => {
        msg.unshift(context.name);
    },
});
Logger.setHandler(consoleLogHandler);

exports.EffectEnv = void 0;
(function (EffectEnv) {
    EffectEnv["Prod"] = "prod";
    EffectEnv["Int"] = "int";
})(exports.EffectEnv || (exports.EffectEnv = {}));
exports.EffectState = void 0;
(function (EffectState) {
    EffectState["Idle"] = "idle";
    EffectState["Init"] = "init";
    EffectState["Disabled"] = "disabled";
    EffectState["Enabled"] = "enabled";
    EffectState["Disposed"] = "disposed";
    EffectState["Error"] = "error";
})(exports.EffectState || (exports.EffectState = {}));
exports.EffectEvent = void 0;
(function (EffectEvent) {
    EffectEvent["TrackUpdated"] = "track-updated";
    EffectEvent["Enabled"] = "enabled";
    EffectEvent["Disabled"] = "disabled";
    EffectEvent["Disposed"] = "disposed";
})(exports.EffectEvent || (exports.EffectEvent = {}));
class BaseEffect extends EventEmitter {
    constructor() {
        super();
        this.state = exports.EffectState.Idle;
        this.id = v4();
        this.isEnabled = false;
        const constructor = this.constructor;
        if (constructor.kind === undefined) {
            throw new Error("base effect: derived class must define a static 'kind' property.");
        }
        this.kind = constructor.kind;
    }
    get underlyingStream() {
        return this.getUnderlyingStream();
    }
    get inputTrack() {
        var _a;
        return (_a = this.inputStream) === null || _a === void 0 ? void 0 : _a.getTracks()[0];
    }
    getOutputTrack() {
        return this.outputTrack;
    }
    getOutputStream() {
        return this.outputStream;
    }
    getUnderlyingStream() {
        logger.warn('getUnderlyingStream() is deprecated and will be removed in a future major release. Please use getOutputStream() instead.');
        return this.getOutputStream();
    }
    preloadAssets() {
        return __awaiter(this, void 0, void 0, function* () { });
    }
    load(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!input) {
                throw new Error('base effect: track is a required parameter');
            }
            if (input instanceof MediaStream) {
                return this.loadMediaStream(input);
            }
            if (input instanceof MediaStreamTrack) {
                return this.loadMediaStreamTrack(input);
            }
            this.isEnabled = false;
            throw new Error('base effect: invalid argument type');
        });
    }
    loadMediaStream(input) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadMedia(input.getTracks()[0], input);
            if (!this.outputStream) {
                throw new Error('base effect: load failed to create output stream');
            }
            return this.outputStream;
        });
    }
    loadMediaStreamTrack(input) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.loadMedia(input);
            if (!this.outputTrack) {
                throw new Error('base effect: load failed to create output track');
            }
            return this.outputTrack;
        });
    }
    loadMedia(inputTrack, inputStream) {
        return __awaiter(this, void 0, void 0, function* () {
            this.outputTrack = inputTrack;
            if (!inputStream) {
                this.inputStream = new MediaStream([inputTrack]);
                return;
            }
            this.inputStream = inputStream;
            this.outputStream = new MediaStream();
            this.outputStream.addTrack(this.outputTrack);
        });
    }
    replaceInputTrack(track) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!track) {
                throw new Error('base effect: track is a required parameter');
            }
            if (this.inputStream && this.inputTrack) {
                this.inputStream.removeTrack(this.inputTrack);
            }
            if (this.inputStream) {
                this.inputStream.addTrack(track);
            }
        });
    }
    enable() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.effectTrack) {
                throw new Error('base effect: effect track is undefined');
            }
            this.isEnabled = true;
            this.outputTrack = this.effectTrack;
            this.emit(exports.EffectEvent.Enabled);
            this.emit(exports.EffectEvent.TrackUpdated, this.effectTrack);
        });
    }
    disable() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.inputTrack) {
                throw new Error('base effect: input track is undefined');
            }
            this.isEnabled = false;
            this.outputTrack = this.inputTrack;
            this.emit(exports.EffectEvent.Disabled);
            this.emit(exports.EffectEvent.TrackUpdated, this.inputTrack);
        });
    }
    dispose() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = this.effectTrack) === null || _a === void 0 ? void 0 : _a.stop();
            delete this.outputTrack;
            delete this.effectTrack;
            this.emit(exports.EffectEvent.Disposed);
        });
    }
    setEnabled(enable) {
        return __awaiter(this, void 0, void 0, function* () {
            if (enable) {
                yield this.enable();
            }
            else {
                yield this.disable();
            }
        });
    }
}
const createEffect = (EffectClass, options = {}, preloadAssets = false) => __awaiter(void 0, void 0, void 0, function* () {
    const effectInstance = new EffectClass(options);
    if (preloadAssets) {
        yield effectInstance.preloadAssets().catch((e) => {
            logger.error('base effect: effect preload failed:', e);
            throw e;
        });
    }
    return effectInstance;
});

class BaseCameraEffect extends BaseEffect {
}

class BaseMicrophoneEffect extends BaseEffect {
    constructor(audioCtx) {
        super();
        this.audioContext = audioCtx || new AudioContext();
    }
    updateAudioContext(audioContext) {
        this.audioContext = audioContext;
    }
}

const defaultOptions$4 = {
    maxGain: 2,
    rampTime: 1,
};
class GainEffect extends BaseMicrophoneEffect {
    constructor(options) {
        super(options.audioContext);
        this.gainValue = 1;
        this.options = Object.assign(Object.assign({}, defaultOptions$4), options);
        logger.log('GainEffect init', { options: this.options });
    }
    loadMediaStream(input) {
        const _super = Object.create(null, {
            loadMediaStream: { get: () => super.loadMediaStream }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.loadMediaStream.call(this, input);
            this.outputStream = yield this.createOutputStream();
            if (!this.outputStream) {
                throw new Error('gain effect: failed to create output stream');
            }
            this.outputStream.getAudioTracks()[0].enabled = input.getTracks()[0].enabled;
            return this.outputStream;
        });
    }
    loadMediaStreamTrack(input) {
        const _super = Object.create(null, {
            loadMediaStreamTrack: { get: () => super.loadMediaStreamTrack }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.loadMediaStreamTrack.call(this, input);
            [this.outputTrack] = (yield this.createOutputStream()).getTracks();
            if (!this.outputTrack) {
                throw new Error('gain effect: failed to create output track');
            }
            return this.outputTrack;
        });
    }
    createOutputStream() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.inputStream) {
                throw new Error('gain effect: failed to create input stream');
            }
            const source = this.audioContext.createMediaStreamSource(this.inputStream);
            this.gainNode = new GainNode(this.audioContext);
            source.connect(this.gainNode);
            const mediaStreamDestination = this.audioContext.createMediaStreamDestination();
            this.gainNode.connect(mediaStreamDestination);
            [this.effectTrack] = mediaStreamDestination.stream.getTracks();
            return mediaStreamDestination.stream;
        });
    }
    setGainValue(value) {
        if (value > this.options.maxGain) {
            value = this.options.maxGain;
        }
        this.gainValue = value;
        this.gainNode.gain.linearRampToValueAtTime(value, this.audioContext.currentTime + this.options.rampTime);
    }
    enable() {
        const _super = Object.create(null, {
            enable: { get: () => super.enable }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.gainNode.gain.linearRampToValueAtTime(this.gainValue, this.audioContext.currentTime + this.options.rampTime);
            yield _super.enable.call(this);
        });
    }
    disable() {
        const _super = Object.create(null, {
            disable: { get: () => super.disable }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.gainNode.gain.linearRampToValueAtTime(1, this.audioContext.currentTime + this.options.rampTime);
            yield _super.disable.call(this);
        });
    }
    dispose() {
        const _super = Object.create(null, {
            dispose: { get: () => super.dispose }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.gainNode.disconnect();
            yield _super.dispose.call(this);
        });
    }
}
GainEffect.kind = 'gain-effect';

exports.NoiseReductionMode = void 0;
(function (NoiseReductionMode) {
    NoiseReductionMode["Legacy"] = "LEGACY";
    NoiseReductionMode["Worklet"] = "WORKLET";
})(exports.NoiseReductionMode || (exports.NoiseReductionMode = {}));

const defaultOptions$3 = Object.freeze({
    mode: exports.NoiseReductionMode.Worklet,
    avoidSimd: false,
    authToken: '',
});

const appendScript = (url) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve, reject) => {
        var _a;
        const fs = document.getElementsByTagName('script')[0];
        const s = document.createElement('script');
        s.type = 'text/javascript';
        s.async = true;
        s.src = url;
        s.onload = resolve;
        s.onerror = reject;
        (_a = fs.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(s, fs);
    });
});

const fetchUrls = (paths, token, env) => {
    const url = (env === exports.EffectEnv.Int
        ? "https://models-auth.us-east-2.int.infra.intelligence.webex.com/generate"
        : "https://models-auth.intelligence.webex.com/generate");
    const body = { items: Array.isArray(paths) ? paths : [paths] };
    const options = {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(body),
    };
    return fetch(url, options).then((resp) => {
        if (!resp.ok) {
            throw resp;
        }
        return resp.json();
    });
};
const fetchSignedUrl = (path, token, env) => __awaiter(void 0, void 0, void 0, function* () {
    return fetchUrls(path, token, env)
        .then((resp) => { var _a, _b; return (_b = (_a = resp.items) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.url; })
        .catch(() => {
        throw new Error('Fetching signed url failed. Please check the auth token and try again.');
    });
});
const memoizeBlobUrl = (func) => {
    const cache = new Map();
    function memoizedFunc(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            const cacheKey = JSON.stringify(args);
            const cachedResult = cache.get(cacheKey);
            if (cachedResult !== undefined) {
                return cachedResult;
            }
            const result = yield func.apply(this, args);
            const item = yield fetch(result);
            const url = URL.createObjectURL(yield item.blob());
            cache.set(cacheKey, url);
            return url;
        });
    }
    memoizedFunc.clearCache = () => {
        cache.clear();
    };
    return memoizedFunc;
};
const memoizedFetchSignedUrl = memoizeBlobUrl(fetchSignedUrl);

var FutureState;
(function (FutureState) {
    FutureState["Pending"] = "pending";
    FutureState["Resolved"] = "resolved";
    FutureState["Rejected"] = "rejected";
})(FutureState || (FutureState = {}));
class Future {
    constructor(promise) {
        this.state = FutureState.Pending;
        this.promise =
            promise !== null && promise !== void 0 ? promise : new Promise((resolve, reject) => {
                this.resolve = (arg) => {
                    this.state = FutureState.Resolved;
                    resolve(arg);
                };
                this.reject = (e) => {
                    this.state = FutureState.Rejected;
                    reject(e);
                };
            });
    }
}

const hasSimdSupport = () => __awaiter(void 0, void 0, void 0, function* () {
    return WebAssembly.validate(new Uint8Array([
        0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253,
        15, 253, 98, 11,
    ]));
});

const omitKey = (key, obj) => Object.fromEntries(Object.entries(obj).filter((i) => i[0] !== key));

class NoiseReductionEffect extends BaseMicrophoneEffect {
    constructor(options) {
        super(options === null || options === void 0 ? void 0 : options.audioContext);
        this.isReady = false;
        this.disableFuture = new Future();
        this.enableFuture = new Future();
        this.options = Object.assign(Object.assign({}, defaultOptions$3), options);
        logger.log('noise reduction: init effect', omitKey('authToken', this.options));
    }
    get isLoaded() {
        return !!this.loadFuture;
    }
    fetchUrl(url) {
        return __awaiter(this, void 0, void 0, function* () {
            let validatedUrl = url;
            if (!this.options.authToken) {
                throw new Error('noise reduction: auth token is required');
            }
            if (!this.options.avoidSimd && (yield NoiseReductionEffect.supportsSimd())) {
                validatedUrl = url.replace('.js', '.simd.js');
            }
            return memoizedFetchSignedUrl(validatedUrl, this.options.authToken, this.options.env).catch((e) => {
                throw new Error(`noise reduction: ${e.message}`);
            });
        });
    }
    loadMediaStream(input) {
        const _super = Object.create(null, {
            loadMedia: { get: () => super.loadMedia }
        });
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('noise reduction: load stream', input);
            const [audioTrack] = input.getAudioTracks();
            if (!audioTrack) {
                throw new Error('noise reduction: load stream failed, no audio track found');
            }
            yield _super.loadMedia.call(this, audioTrack, input);
            this.outputStream = yield this.createOutputStream();
            if (!this.outputStream) {
                throw new Error('noise reduction: failed to create output stream');
            }
            this.outputStream.getAudioTracks()[0].enabled = audioTrack.enabled;
            return this.outputStream;
        });
    }
    loadMediaStreamTrack(input) {
        const _super = Object.create(null, {
            loadMediaStreamTrack: { get: () => super.loadMediaStreamTrack }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.loadMediaStreamTrack.call(this, input);
            [this.outputTrack] = (yield this.createOutputStream()).getTracks();
            if (!this.outputTrack) {
                throw new Error('noise reduction: failed to create output track');
            }
            return this.outputTrack;
        });
    }
    createOutputStream() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.inputStream) {
                throw new Error('noise reduction: failed to create input stream');
            }
            const mediaStreamDestination = this.audioContext.createMediaStreamDestination();
            [this.effectTrack] = mediaStreamDestination.stream.getTracks();
            if (this.loadFuture) {
                return this.loadFuture.promise;
            }
            this.loadFuture = new Future();
            yield ((_a = this.disposeFuture) === null || _a === void 0 ? void 0 : _a.promise);
            this.disposeFuture = new Future();
            if (this.options.mode === exports.NoiseReductionMode.Legacy) {
                return this.loadLegacy(this.inputStream, mediaStreamDestination);
            }
            return this.loadWorklet(this.inputStream, mediaStreamDestination);
        });
    }
    preloadAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            const start = performance.now();
            logger.log('noise reduction: preloading assets', this.options.mode);
            try {
                yield this.ensureProcessorLoaded();
                const end = performance.now();
                const duration = Math.round(end - start) / 1000;
                logger.log(`noise reduction: preload completed in ${duration} seconds`);
            }
            catch (error) {
                logger.error('noise reduction: preload failed:', error);
                throw error;
            }
        });
    }
    ensureProcessorLoaded() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.processorLoadFuture) {
                yield this.processorLoadFuture.promise;
                return;
            }
            if (this.isReady) {
                return;
            }
            this.processorLoadFuture = new Future();
            try {
                if (this.options.mode === exports.NoiseReductionMode.Worklet) {
                    yield this.fetchAndLoadWorkletProcessor();
                }
                else if (this.options.mode === exports.NoiseReductionMode.Legacy) {
                    yield this.fetchAndLoadLegacyProcessor();
                }
                this.processorLoadFuture.resolve();
            }
            catch (error) {
                this.processorLoadFuture.reject(error);
                this.processorLoadFuture = undefined;
                throw error;
            }
        });
    }
    fetchAndLoadWorkletProcessor() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const processorPath = "denoise/processors/2.4.2/noise-reduction-processor.worklet.js";
            let workletProcessorUrl;
            if (this.options.workletProcessorUrl) {
                workletProcessorUrl = this.options.workletProcessorUrl;
            }
            else if (this.options.baseUrl) {
                workletProcessorUrl = `${this.options.baseUrl}/${processorPath}`;
            }
            else {
                workletProcessorUrl = yield this.fetchUrl(processorPath);
            }
            logger.log('noise reduction: fetch worklet processor', workletProcessorUrl);
            logger.log('noise reduction: add worklet processor to audio context');
            yield ((_b = (_a = this.audioContext) === null || _a === void 0 ? void 0 : _a.audioWorklet) === null || _b === void 0 ? void 0 : _b.addModule(workletProcessorUrl));
        });
    }
    fetchAndLoadLegacyProcessor() {
        return __awaiter(this, void 0, void 0, function* () {
            const defaultPath = "denoise/processors/2.4.2/noise-reduction-processor.legacy.js";
            let legacyProcessorUrl;
            if (this.options.legacyProcessorUrl) {
                legacyProcessorUrl = this.options.legacyProcessorUrl;
            }
            else if (this.options.baseUrl) {
                legacyProcessorUrl = `${this.options.baseUrl}/${defaultPath}`;
            }
            else {
                legacyProcessorUrl = yield this.fetchUrl(defaultPath);
            }
            logger.log('noise reduction: fetch legacy processor url', legacyProcessorUrl);
            logger.log('noise reduction: append legacy processor to global scope');
            yield appendScript(legacyProcessorUrl);
        });
    }
    loadWorklet(stream, destination) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.loadFuture) {
                throw new Error('noise reduction: the load future was not initialized correctly');
            }
            logger.log('noise reduction: load worklet');
            try {
                yield this.ensureProcessorLoaded();
                if (!AudioWorkletNode) {
                    throw new Error('noise reduction: `AudioWorkletNode` unavailable in current scope');
                }
                logger.log('noise reduction: attach worklet processor');
                this.workletNode = new AudioWorkletNode(this.audioContext, 'noise-reduction-worklet-processor');
                this.workletNode.port.onmessage = (ev) => {
                    var _a, _b, _c;
                    logger.log(`noise reduction: worklet processor ${ev.data.type.toLowerCase()}`);
                    switch (ev.data.type) {
                        case NoiseReductionEffect.Events.Ready: {
                            this.isReady = true;
                            (_a = this.loadFuture) === null || _a === void 0 ? void 0 : _a.resolve(destination.stream);
                            break;
                        }
                        case NoiseReductionEffect.Events.Disabled: {
                            this.handleDisabled();
                            break;
                        }
                        case NoiseReductionEffect.Events.Enabled: {
                            this.handleEnabled();
                            break;
                        }
                        case NoiseReductionEffect.Events.Disposed: {
                            this.isEnabled = false;
                            this.isReady = false;
                            (_b = this.disposeFuture) === null || _b === void 0 ? void 0 : _b.resolve();
                            this.emit(exports.EffectEvent.Disposed);
                            break;
                        }
                        case NoiseReductionEffect.Events.Error: {
                            const err = new Error(`noise reduction: worklet processor error, "${ev.data.payload}"`);
                            (_c = this.loadFuture) === null || _c === void 0 ? void 0 : _c.reject(err);
                            logger.error(err);
                            break;
                        }
                        default:
                            logger.warn('noise reduction: worklet processor unhandled message', ev.data);
                    }
                };
                this.workletNode.connect(destination);
                this.sourceNode = this.audioContext.createMediaStreamSource(stream);
                this.sourceNode.connect(this.workletNode);
            }
            catch (e) {
                const errorMessage = e instanceof Error ? e.message : e;
                this.loadFuture.reject(new Error(`noise reduction: failed to load worklet processor: ${errorMessage}`));
            }
            return this.loadFuture.promise;
        });
    }
    loadLegacy(stream, destination) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.loadFuture) {
                throw new Error('noise reduction: the load future was not initialized correctly');
            }
            logger.log('noise reduction: load legacy');
            try {
                yield this.ensureProcessorLoaded();
                this.legacyProcessor = new window.WebMediaEffects.NoiseReductionLegacyProcessor(this.audioContext.sampleRate);
                const bufferLengthMap = { 16000: 256, 32000: 512, 48000: 512 };
                const bufferLength = bufferLengthMap[this.audioContext.sampleRate];
                this.legacyScriptNode = this.audioContext.createScriptProcessor(bufferLength, 1, 1);
                this.legacyScriptNode.connect(destination);
                this.legacyScriptNode.onaudioprocess = this.legacyProcessor.processAudioChunk;
                this.sourceNode = this.audioContext.createMediaStreamSource(stream);
                this.sourceNode.connect(this.legacyScriptNode);
                this.isReady = true;
                this.loadFuture.resolve(destination.stream);
            }
            catch (e) {
                this.loadFuture.reject(new Error('noise reduction: failed to load legacy processor'));
            }
            return this.loadFuture.promise;
        });
    }
    enable() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('noise reduction: enable effect');
            if (!this.isReady) {
                throw new Error('noise reduction: not setup or ready');
            }
            this.enableFuture = new Future();
            (_a = this.workletNode) === null || _a === void 0 ? void 0 : _a.port.postMessage('ENABLE');
            (_b = this.legacyProcessor) === null || _b === void 0 ? void 0 : _b.setEnabled(true).then(() => this.handleEnabled());
            return this.enableFuture.promise;
        });
    }
    disable() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('noise reduction: disable effect');
            if (!this.isReady) {
                throw new Error('noise reduction: not setup or ready');
            }
            this.disableFuture = new Future();
            (_a = this.workletNode) === null || _a === void 0 ? void 0 : _a.port.postMessage('DISABLE');
            (_b = this.legacyProcessor) === null || _b === void 0 ? void 0 : _b.setEnabled(false).then(() => this.handleDisabled());
            return this.disableFuture.promise;
        });
    }
    dispose() {
        const _super = Object.create(null, {
            dispose: { get: () => super.dispose }
        });
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('noise reduction: dispose effect');
            if (!this.loadFuture) {
                return;
            }
            yield this.loadFuture.promise;
            this.loadFuture = undefined;
            (_a = this.workletNode) === null || _a === void 0 ? void 0 : _a.port.postMessage('DISPOSE');
            (_b = this.legacyProcessor) === null || _b === void 0 ? void 0 : _b.dispose().then((_c = this.disposeFuture) === null || _c === void 0 ? void 0 : _c.resolve);
            yield ((_d = this.disposeFuture) === null || _d === void 0 ? void 0 : _d.promise);
            (_e = this.workletNode) === null || _e === void 0 ? void 0 : _e.disconnect();
            (_f = this.legacyScriptNode) === null || _f === void 0 ? void 0 : _f.disconnect();
            (_g = this.sourceNode) === null || _g === void 0 ? void 0 : _g.disconnect();
            yield _super.dispose.call(this);
            logger.log('noise reduction: effect disposed');
        });
    }
    handleDisabled() {
        const _super = Object.create(null, {
            disable: { get: () => super.disable }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.disable.call(this);
            this.disableFuture.resolve();
        });
    }
    handleEnabled() {
        const _super = Object.create(null, {
            enable: { get: () => super.enable }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.enable.call(this);
            this.enableFuture.resolve();
        });
    }
    updateSampleRate(sampleRate) {
        const supportedRates = [16000, 32000, 48000];
        if (!supportedRates.includes(sampleRate)) {
            throw new Error(`noise reduction: unsupported sample rate ${sampleRate}Hz, must be one of ${supportedRates.join(', ')}Hz`);
        }
        if (this.isReady || this.loadFuture) {
            throw new Error('noise reduction: cannot update sample rate after effect is loaded or loading');
        }
        if (this.audioContext.sampleRate === sampleRate) {
            logger.log(`noise reduction: sample rate already at ${sampleRate}Hz`);
            return;
        }
        logger.log(`noise reduction: updating sample rate to ${sampleRate}Hz`);
        try {
            this.audioContext.close().catch((e) => {
                logger.warn('noise reduction: error closing audio context', e);
            });
            const newAudioContext = new AudioContext({ sampleRate });
            this.processorLoadFuture = undefined;
            super.updateAudioContext(newAudioContext);
            logger.log(`noise reduction: sample rate updated to ${sampleRate}Hz`);
        }
        catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            logger.error(`noise reduction: failed to update sample rate: ${message}`);
            throw new Error(`noise reduction: failed to update sample rate: ${message}`);
        }
    }
    updateAudioContext(audioContext) {
        const _super = Object.create(null, {
            updateAudioContext: { get: () => super.updateAudioContext }
        });
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('noise reduction: updating audio context');
            const wasLoaded = this.isLoaded;
            const wasReady = this.isReady;
            const wasEnabled = this.isEnabled;
            const inputStream = this.inputStream;
            if (wasLoaded || wasReady) {
                logger.log('noise reduction: disposing current pipeline');
                (_a = this.workletNode) === null || _a === void 0 ? void 0 : _a.disconnect();
                (_b = this.legacyScriptNode) === null || _b === void 0 ? void 0 : _b.disconnect();
                (_c = this.sourceNode) === null || _c === void 0 ? void 0 : _c.disconnect();
                this.isReady = false;
                this.processorLoadFuture = undefined;
                const loadFutureBackup = this.loadFuture;
                this.loadFuture = undefined;
                try {
                    _super.updateAudioContext.call(this, audioContext);
                    logger.log('noise reduction: audio context updated successfully');
                    if (wasLoaded && inputStream) {
                        logger.log('noise reduction: reloading effect with new audio context');
                        yield this.loadMediaStream(inputStream);
                        if (wasEnabled) {
                            yield this.enable();
                        }
                        if (loadFutureBackup && this.outputStream) {
                            loadFutureBackup.resolve(this.outputStream);
                        }
                    }
                }
                catch (error) {
                    const message = error instanceof Error ? error.message : String(error);
                    logger.error(`noise reduction: failed to update audio context: ${message}`);
                    if (loadFutureBackup) {
                        loadFutureBackup.reject(new Error(`noise reduction: failed to update audio context: ${message}`));
                    }
                    throw error;
                }
            }
            else {
                logger.log('noise reduction: simple audio context update (not loaded yet)');
                _super.updateAudioContext.call(this, audioContext);
            }
        });
    }
}
NoiseReductionEffect.kind = 'noise-reduction-effect';
NoiseReductionEffect.supportsSimd = hasSimdSupport;
NoiseReductionEffect.Events = {
    Ready: 'READY',
    Disabled: 'DISABLED',
    Disposed: 'DISPOSED',
    Enabled: 'ENABLED',
    Error: 'ERROR',
};
const createNoiseReductionEffect = (options, preloadAssets) => __awaiter(void 0, void 0, void 0, function* () { return createEffect(NoiseReductionEffect, options, preloadAssets); });

function memoize(func) {
    const cache = new Map();
    return function doMemoize(arg) {
        if (cache.has(arg)) {
            return cache.get(arg);
        }
        const result = func(arg);
        cache.set(arg, result);
        return result;
    };
}

const NUM_BOX_COORDS = 4;
const NUM_COORDS_PER_KEYPOINT = 3;
const BOX_COORDS_END_IDX = 4;
const CONFIDENCE_OFFSET = 1;
function decodeModelOutputShape(shape) {
    const [batchSize, numAnchors, gridHeight, gridWidth, totalCoords] = shape;
    const numKeypoints = (totalCoords - (NUM_BOX_COORDS + CONFIDENCE_OFFSET)) / NUM_COORDS_PER_KEYPOINT;
    const indexOfConfidence = BOX_COORDS_END_IDX + numKeypoints * NUM_COORDS_PER_KEYPOINT;
    const decodedShape = {
        batchSize,
        numAnchors,
        gridHeight,
        gridWidth,
        numBoxCoords: NUM_BOX_COORDS,
        numLandmarks: numKeypoints * NUM_COORDS_PER_KEYPOINT,
        numKeypoints,
        indexOfConfidence,
    };
    return decodedShape;
}
function centerToCornerCoords(box) {
    return {
        centerX: box.centerX - box.width / 2,
        centerY: box.centerY - box.height / 2,
        width: box.centerX + box.width / 2,
        height: box.centerY + box.height / 2,
        score: box.score,
        landmarks: box.landmarks,
    };
}
function extractBoxesAndScores(output, numAnchors, height, width, numBoxCoords, numLandmarks) {
    const numBoxes = numAnchors * height * width;
    const stride = numBoxCoords + numLandmarks * 3 + 1;
    const boxes = [];
    for (let i = 0; i < numBoxes; i += 1) {
        const baseIndex = i * stride;
        const scoreIndex = baseIndex + stride - 1;
        const landmarks = [];
        const box = centerToCornerCoords({
            centerX: output[baseIndex],
            centerY: output[baseIndex + 1],
            width: output[baseIndex + 2],
            height: output[baseIndex + 3],
            score: output[scoreIndex],
            landmarks,
        });
        boxes.push(box);
    }
    return boxes;
}
function computeIoU(boxA, boxB) {
    const xA = Math.max(boxA.centerX, boxB.centerX);
    const yA = Math.max(boxA.centerY, boxB.centerY);
    const xB = Math.min(boxA.width, boxB.width);
    const yB = Math.min(boxA.height, boxB.height);
    const intersectionArea = Math.max(0, xB - xA) * Math.max(0, yB - yA);
    const boxAArea = (boxA.width - boxA.centerX) * (boxA.height - boxA.centerY);
    const boxBArea = (boxB.width - boxB.centerX) * (boxB.height - boxB.centerY);
    const iou = intersectionArea / (boxAArea + boxBArea - intersectionArea);
    return iou;
}
function applyNMS(boxes, nmsThreshold) {
    const sortedBoxes = boxes.sort((a, b) => b.score - a.score);
    const selectedBoxes = [];
    sortedBoxes.forEach((currentBox) => {
        let keep = true;
        for (let i = 0; i < selectedBoxes.length; i += 1) {
            const selectedBox = selectedBoxes[i];
            const iou = computeIoU({
                centerX: currentBox.centerX,
                centerY: currentBox.centerY,
                width: currentBox.width,
                height: currentBox.height,
            }, {
                centerX: selectedBox.centerX,
                centerY: selectedBox.centerY,
                width: selectedBox.width,
                height: selectedBox.height,
            });
            if (iou > nmsThreshold) {
                keep = false;
                break;
            }
        }
        if (keep) {
            selectedBoxes.push(currentBox);
        }
    });
    return selectedBoxes;
}
const memoizedDecodeModelOutputShape = memoize(decodeModelOutputShape);
function getNumFaces(output, shape, filterBoxesThreshold = 0.3, nmsThreshold = 0.3) {
    const decodedShape = memoizedDecodeModelOutputShape(shape);
    const boxes = extractBoxesAndScores(output, decodedShape.numAnchors, decodedShape.gridHeight, decodedShape.gridWidth, decodedShape.numBoxCoords, decodedShape.numKeypoints);
    const filteredBoxes = boxes.filter((box) => box.score > filterBoxesThreshold);
    const finalBoxes = applyNMS(filteredBoxes, nmsThreshold);
    return finalBoxes.length;
}

exports.BeRightBackAction = void 0;
(function (BeRightBackAction) {
    BeRightBackAction["TurnOn"] = "turn-on";
    BeRightBackAction["TurnOff"] = "turn-off";
})(exports.BeRightBackAction || (exports.BeRightBackAction = {}));
exports.BeRightBackState = void 0;
(function (BeRightBackState) {
    BeRightBackState["Idle"] = "idle";
    BeRightBackState["Off"] = "off";
    BeRightBackState["On"] = "on";
})(exports.BeRightBackState || (exports.BeRightBackState = {}));
exports.BeRightBackEvent = void 0;
(function (BeRightBackEvent) {
    BeRightBackEvent["On"] = "on";
    BeRightBackEvent["Off"] = "off";
    BeRightBackEvent["StateChange"] = "state-change";
})(exports.BeRightBackEvent || (exports.BeRightBackEvent = {}));
exports.BeRightBackPluginMode = void 0;
(function (BeRightBackPluginMode) {
    BeRightBackPluginMode["Off"] = "off";
    BeRightBackPluginMode["Conservative"] = "conservative";
    BeRightBackPluginMode["Aggressive"] = "aggressive";
})(exports.BeRightBackPluginMode || (exports.BeRightBackPluginMode = {}));

class DebugBuffer {
    constructor(bufferSize = 30) {
        this.buffer = [];
        this.bufferSize = bufferSize;
    }
    add(entry) {
        this.buffer.push(entry);
        if (this.buffer.length > this.bufferSize) {
            this.buffer.shift();
        }
    }
    getDebugInfo() {
        return [...this.buffer];
    }
    getLatestDebugInfo() {
        return this.buffer[this.buffer.length - 1];
    }
    clear() {
        this.buffer = [];
    }
    setBufferSize(size) {
        this.bufferSize = size;
    }
}

const defaultOptions$2 = {
    motionIouThreshold: 0.5,
    onHysteresisMaxMs: 3000,
    offHysteresisMaxMs: 2000,
};
class BeRightBack extends EventEmitter {
    constructor(options = defaultOptions$2) {
        super();
        this.debugBuffer = new DebugBuffer();
        this.state = exports.BeRightBackState.Idle;
        this.onHysteresisDurationMs = 0;
        this.offHysteresisDurationMs = 0;
        this.lastTimestampMs = 0;
        this.isEnabled = true;
        this.isFirstFrame = true;
        this.updateOptions(options);
    }
    destroy() {
        this.removeAllListeners();
    }
    getDebugInfo() {
        return this.debugBuffer.getDebugInfo();
    }
    getLatestDebugInfo() {
        return this.debugBuffer.getLatestDebugInfo();
    }
    getState() {
        return this.state;
    }
    setEnable(enable) {
        this.isEnabled = enable;
        if (!enable) {
            this.changeState(exports.BeRightBackState.Idle);
            this.resetHysteresis();
            this.isFirstFrame = true;
        }
    }
    updateOptions(newOptions) {
        this.options = Object.assign(Object.assign({}, defaultOptions$2), newOptions);
        if (this.options.motionIouThreshold < 0 || this.options.motionIouThreshold > 1) {
            throw new Error('Invalid motionIouThreshold: must be between 0 and 1.');
        }
        if (this.options.onHysteresisMaxMs < 0) {
            throw new Error('Invalid onHysteresisMaxMs: must be greater than 0.');
        }
        if (this.options.offHysteresisMaxMs < 0) {
            throw new Error('Invalid offHysteresisMaxMs: must be greater than 0.');
        }
    }
    processFrame(faces, shape, motion, timestampMs) {
        if (!this.isEnabled) {
            return exports.BeRightBackState.Idle;
        }
        const numFaces = getNumFaces(faces, shape);
        const isMoving = motion < this.options.motionIouThreshold;
        if (this.isFirstFrame) {
            this.initializeFirstFrameState(timestampMs);
        }
        const action = this.determineActionFromInferenceResult(numFaces, isMoving);
        const timeDiffMs = timestampMs - this.lastTimestampMs;
        this.handleHysteresisAndStateChange(action, timeDiffMs);
        this.lastTimestampMs = timestampMs;
        this.debugBuffer.add({
            action,
            isMoving,
            offHysteresisDurationMs: this.offHysteresisDurationMs,
            onHysteresisDurationMs: this.onHysteresisDurationMs,
            numFaces,
            state: this.state,
            timeDiffMs,
        });
        return this.state;
    }
    initializeFirstFrameState(timestampMs) {
        this.isFirstFrame = false;
        this.lastTimestampMs = timestampMs;
        this.changeState(exports.BeRightBackState.Off);
        this.resetHysteresis();
    }
    determineActionFromInferenceResult(numFaces, isMoving) {
        if (this.state === exports.BeRightBackState.On) {
            return numFaces > 0 ? exports.BeRightBackAction.TurnOff : exports.BeRightBackAction.TurnOn;
        }
        if (numFaces > 0 || isMoving) {
            return exports.BeRightBackAction.TurnOff;
        }
        return exports.BeRightBackAction.TurnOn;
    }
    handleHysteresisAndStateChange(action, timeDiffMs) {
        if (this.state === exports.BeRightBackState.Off && action === exports.BeRightBackAction.TurnOn) {
            this.accumulateHysteresisAndAttemptTurnOn(timeDiffMs);
        }
        else if (this.state === exports.BeRightBackState.On && action === exports.BeRightBackAction.TurnOff) {
            this.accumulateHysteresisAndAttemptTurnOff(timeDiffMs);
        }
        else {
            this.resetHysteresis();
        }
    }
    accumulateHysteresisAndAttemptTurnOn(timeDiffMs) {
        this.onHysteresisDurationMs += timeDiffMs;
        if (this.onHysteresisDurationMs >= this.options.onHysteresisMaxMs) {
            this.changeState(exports.BeRightBackState.On);
            this.resetHysteresis();
        }
    }
    accumulateHysteresisAndAttemptTurnOff(timeDiffMs) {
        this.offHysteresisDurationMs += timeDiffMs;
        if (this.offHysteresisDurationMs >= this.options.offHysteresisMaxMs) {
            this.changeState(exports.BeRightBackState.Off);
            this.resetHysteresis();
        }
    }
    changeState(newState) {
        if (this.state !== newState) {
            this.emit(exports.BeRightBackEvent.StateChange, newState, this.state);
        }
        if (newState === exports.BeRightBackState.On) {
            this.emit(exports.BeRightBackEvent.On);
        }
        if (newState === exports.BeRightBackState.Off) {
            this.emit(exports.BeRightBackEvent.Off);
        }
        this.state = newState;
    }
    resetHysteresis() {
        this.onHysteresisDurationMs = 0;
        this.offHysteresisDurationMs = 0;
    }
}

class BaseInferencePlugin {
    constructor(options) {
        this.isEffectEnabled = false;
        this.isInitialized = false;
        this.options = Object.assign(Object.assign({}, this.getDefaultOptions()), options);
        this.core = this.createCore();
        this.onEffectEnabled = this.onEffectEnabled.bind(this);
        this.onEffectDisabled = this.onEffectDisabled.bind(this);
        this.onCoreCreated();
    }
    initialize(effect) {
        this.isEffectEnabled = effect.isEnabled;
        this.isInitialized = true;
        const handleEffectEnabled = () => {
            this.isEffectEnabled = true;
            this.onEffectEnabled();
        };
        const handleEffectDisabled = () => {
            this.isEffectEnabled = false;
            this.onEffectDisabled();
        };
        effect.on(exports.EffectEvent.Enabled, handleEffectEnabled);
        effect.on(exports.EffectEvent.Disabled, handleEffectDisabled);
        this.cleanup = () => {
            effect.off(exports.EffectEvent.Enabled, handleEffectEnabled);
            effect.off(exports.EffectEvent.Disabled, handleEffectDisabled);
        };
    }
    dispose() {
        this.isInitialized = false;
        this.destroyCore();
        this.cleanup();
    }
    updateOptions(newOptions) {
        this.options = Object.assign(Object.assign({}, this.options), newOptions);
        this.onOptionsUpdated();
    }
    getDefaultOptions(options) {
        return {};
    }
    createCore() {
        return undefined;
    }
    onCoreCreated() {
    }
    onEffectEnabled() {
    }
    onEffectDisabled() {
    }
    cleanup() {
    }
    onOptionsUpdated() {
    }
}

class BaseEventEmitterPlugin extends BaseInferencePlugin {
    constructor(options) {
        super(options);
        if (this.core) {
            this.on = this.core.on.bind(this.core);
            this.off = this.core.off.bind(this.core);
            this.once = this.core.once.bind(this.core);
        }
    }
    destroyCore() {
        var _a;
        (_a = this.core) === null || _a === void 0 ? void 0 : _a.removeAllListeners();
    }
}

class BaseAfterInferencePlugin extends BaseEventEmitterPlugin {
    constructor(options) {
        super(options);
        this.onAfterInference = this.onAfterInference.bind(this);
    }
    initialize(effect) {
        super.initialize(effect);
        effect.addAfterInferenceCallback(this.onAfterInference);
        this.cleanup = () => {
            effect.removeAfterInferenceCallback(this.onAfterInference);
        };
    }
    dispose() {
        super.dispose();
    }
}

const filterValidEntries = (obj) => {
    return Object.fromEntries(Object.entries(obj || {}).filter(([, value]) => value !== undefined && value !== null && value.toString() !== ''));
};
function getPluginOptions(mode, modesMap, defaultMode, coreOptions) {
    const validMode = Object.values(modesMap).includes(modesMap[mode]) ? mode : defaultMode;
    return Object.assign(Object.assign({}, modesMap[validMode]), filterValidEntries(coreOptions));
}

const modesMap$1 = {
    [exports.BeRightBackPluginMode.Off]: {
        motionIouThreshold: 0,
        onHysteresisMaxMs: 0,
        offHysteresisMaxMs: 0,
    },
    [exports.BeRightBackPluginMode.Conservative]: {
        motionIouThreshold: 0.9,
        onHysteresisMaxMs: 3000,
        offHysteresisMaxMs: 2000,
    },
    [exports.BeRightBackPluginMode.Aggressive]: {
        motionIouThreshold: 0.95,
        onHysteresisMaxMs: 1500,
        offHysteresisMaxMs: 1000,
    },
};
function getOptionsByMode(mode) {
    return modesMap$1[mode];
}
function makeBeRightBackOptions(mode, coreOptions) {
    const defaultMode = exports.BeRightBackPluginMode.Conservative;
    return getPluginOptions(mode, modesMap$1, defaultMode, coreOptions);
}

class BeRightBackPlugin extends BaseAfterInferencePlugin {
    getDefaultOptions() {
        return {
            mode: exports.BeRightBackPluginMode.Conservative,
        };
    }
    createCore() {
        const options = makeBeRightBackOptions(this.options.mode, this.options.coreOptions);
        return new BeRightBack(options);
    }
    onAfterInference(timestamp, result) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.isEffectEnabled) {
                return;
            }
            if (this.options.mode === exports.BeRightBackPluginMode.Off) {
                return;
            }
            if ((_a = result === null || result === void 0 ? void 0 : result.facesAndLandmarks) === null || _a === void 0 ? void 0 : _a.dims.length) {
                (_b = this.core) === null || _b === void 0 ? void 0 : _b.processFrame(result.facesAndLandmarks.data, result.facesAndLandmarks.dims, result.motion, timestamp);
            }
        });
    }
    onOptionsUpdated() {
        var _a;
        const options = makeBeRightBackOptions(this.options.mode, this.options.coreOptions);
        (_a = this.core) === null || _a === void 0 ? void 0 : _a.updateOptions(options);
    }
    getDebugInfo() {
        var _a, _b;
        return (_b = (_a = this.core) === null || _a === void 0 ? void 0 : _a.getDebugInfo()) !== null && _b !== void 0 ? _b : [];
    }
    getLatestDebugInfo() {
        var _a;
        return (_a = this.core) === null || _a === void 0 ? void 0 : _a.getLatestDebugInfo();
    }
}

exports.FrameSkipperInferenceReason = void 0;
(function (FrameSkipperInferenceReason) {
    FrameSkipperInferenceReason["Initial"] = "initial";
    FrameSkipperInferenceReason["HighMotion"] = "high-motion";
    FrameSkipperInferenceReason["TimeForced"] = "time-forced";
    FrameSkipperInferenceReason["SkipIntervalElapsed"] = "skip-interval-elapsed";
})(exports.FrameSkipperInferenceReason || (exports.FrameSkipperInferenceReason = {}));
exports.FrameSkipperPluginMode = void 0;
(function (FrameSkipperPluginMode) {
    FrameSkipperPluginMode["Off"] = "off";
    FrameSkipperPluginMode["Conservative"] = "conservative";
    FrameSkipperPluginMode["Aggressive"] = "aggressive";
})(exports.FrameSkipperPluginMode || (exports.FrameSkipperPluginMode = {}));

const defaultOptions$1 = {
    baseMaxSkipTime: 1000,
    baseMinSkipTime: 100,
    forcedInferenceInterval: 1000,
    highMotionThreshold: 0.1,
    historySize: 10,
    skipTimeIncrement: 100,
    smoothingFactor: 0.8,
};
class AdaptiveFrameSkipper extends EventEmitter {
    constructor(options = defaultOptions$1) {
        super();
        this.options = options;
        this.debugBuffer = new DebugBuffer();
        this.motionData = [];
        this.lastInferenceTime = Date.now();
        this.lastSmoothedMotion = 0;
        this.currentSkipTime = this.options.baseMaxSkipTime;
    }
    destroy() {
        this.motionData = [];
        this.lastInferenceTime = 0;
        this.currentSkipTime = 0;
        this.debugBuffer.clear();
    }
    getDebugInfo() {
        return this.debugBuffer.getDebugInfo();
    }
    getLatestDebugInfo() {
        return this.debugBuffer.getLatestDebugInfo();
    }
    shouldPerformInference(motionValue, motionTimestamp) {
        var _a;
        if (!motionValue || !motionTimestamp) {
            return true;
        }
        const smoothedMotion = this.calculateSmoothedMotion(motionValue);
        this.updateMotionData(smoothedMotion, motionTimestamp);
        const averageMotion = this.calculateAverageMotion();
        const currentTime = Date.now();
        const timeSinceLastInference = currentTime - this.lastInferenceTime;
        this.adjustSkipTime(averageMotion);
        const isHighMotion = averageMotion < this.options.highMotionThreshold;
        const isTimeForced = timeSinceLastInference >= this.options.forcedInferenceInterval;
        const isSkipIntervalElapsed = timeSinceLastInference >= this.currentSkipTime;
        const shouldInfer = isHighMotion || isTimeForced || isSkipIntervalElapsed;
        if (shouldInfer) {
            this.lastInferenceTime = currentTime;
        }
        {
            const lastReason = (_a = this.getLatestDebugInfo()) === null || _a === void 0 ? void 0 : _a.lastInferenceReason;
            let lastInferenceReason = lastReason || exports.FrameSkipperInferenceReason.Initial;
            if (isHighMotion) {
                lastInferenceReason = exports.FrameSkipperInferenceReason.HighMotion;
            }
            else if (isTimeForced) {
                lastInferenceReason = exports.FrameSkipperInferenceReason.TimeForced;
            }
            else if (isSkipIntervalElapsed) {
                lastInferenceReason = exports.FrameSkipperInferenceReason.SkipIntervalElapsed;
            }
            this.debugBuffer.add({
                averageMotion,
                currentTime,
                currentSkipTime: this.currentSkipTime,
                isHighMotion,
                isSkipIntervalElapsed,
                isTimeForced,
                lastInferenceReason,
                lastInferenceTime: this.lastInferenceTime,
                motionValue,
                shouldInfer,
                smoothedMotion,
                timeSinceLastInference,
            });
        }
        return shouldInfer;
    }
    updateOptions(newOptions) {
        this.options = Object.assign(Object.assign({}, this.options), newOptions);
        this.currentSkipTime = this.options.baseMaxSkipTime;
        this.motionData = [];
    }
    updateMotionData(value, timestamp) {
        this.motionData.push({ value, timestamp });
        if (this.motionData.length > this.options.historySize) {
            this.motionData.shift();
        }
    }
    adjustSkipTime(averageMotion) {
        const adjustmentDirection = averageMotion < this.options.highMotionThreshold ? -1 : 1;
        const adjustmentAmount = this.options.skipTimeIncrement * adjustmentDirection;
        this.currentSkipTime = Math.max(this.options.baseMinSkipTime, Math.min(this.options.baseMaxSkipTime, this.currentSkipTime + adjustmentAmount));
    }
    calculateSmoothedMotion(currentMotion) {
        this.lastSmoothedMotion =
            this.options.smoothingFactor * currentMotion +
                (1 - this.options.smoothingFactor) * this.lastSmoothedMotion;
        return this.lastSmoothedMotion;
    }
    calculateAverageMotion() {
        return this.motionData.reduce((acc, data) => acc + data.value, 0) / this.motionData.length;
    }
}

class BaseBeforeInferencePlugin extends BaseEventEmitterPlugin {
    constructor(options) {
        super(options);
        this.onBeforeInference = this.onBeforeInference.bind(this);
    }
    initialize(effect) {
        super.initialize(effect);
        effect.addBeforeInferenceCallback(this.onBeforeInference);
    }
}

const modesMap = {
    [exports.FrameSkipperPluginMode.Off]: {
        baseMinSkipTime: 0,
        baseMaxSkipTime: 0,
        historySize: 0,
        skipTimeIncrement: 0,
        forcedInferenceInterval: 0,
        highMotionThreshold: 0,
        smoothingFactor: 0,
    },
    [exports.FrameSkipperPluginMode.Conservative]: {
        baseMinSkipTime: 150,
        baseMaxSkipTime: 250,
        historySize: 25,
        skipTimeIncrement: 50,
        forcedInferenceInterval: 300,
        highMotionThreshold: 0.96,
        smoothingFactor: 0.9,
    },
    [exports.FrameSkipperPluginMode.Aggressive]: {
        baseMinSkipTime: 50,
        baseMaxSkipTime: 350,
        historySize: 20,
        skipTimeIncrement: 50,
        forcedInferenceInterval: 500,
        highMotionThreshold: 0.94,
        smoothingFactor: 0.5,
    },
};
function makeFrameSkipperOptions(mode, coreOptions) {
    const defaultMode = exports.FrameSkipperPluginMode.Conservative;
    return getPluginOptions(mode, modesMap, defaultMode, coreOptions);
}

class FrameSkipperPlugin extends BaseBeforeInferencePlugin {
    getDefaultOptions() {
        return {
            mode: exports.FrameSkipperPluginMode.Conservative,
        };
    }
    createCore() {
        const options = makeFrameSkipperOptions(this.options.mode, this.options.coreOptions);
        return new AdaptiveFrameSkipper(options);
    }
    destroyCore() {
        var _a;
        (_a = this.core) === null || _a === void 0 ? void 0 : _a.destroy();
    }
    onBeforeInference(timestamp, lastResult) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let shouldInfer = true;
            if (this.options.mode !== exports.FrameSkipperPluginMode.Off) {
                shouldInfer = (_b = (_a = this.core) === null || _a === void 0 ? void 0 : _a.shouldPerformInference(lastResult.motion, timestamp)) !== null && _b !== void 0 ? _b : true;
            }
            return { shouldInfer };
        });
    }
    onOptionsUpdated() {
        var _a;
        const options = makeFrameSkipperOptions(this.options.mode, this.options.coreOptions);
        (_a = this.core) === null || _a === void 0 ? void 0 : _a.updateOptions(options);
    }
    getDebugInfo() {
        var _a, _b;
        return (_b = (_a = this.core) === null || _a === void 0 ? void 0 : _a.getDebugInfo()) !== null && _b !== void 0 ? _b : [];
    }
    getLatestDebugInfo() {
        var _a;
        return (_a = this.core) === null || _a === void 0 ? void 0 : _a.getLatestDebugInfo();
    }
}

exports.RateEstimatorStatus = void 0;
(function (RateEstimatorStatus) {
    RateEstimatorStatus["Idle"] = "idle";
    RateEstimatorStatus["Init"] = "init";
    RateEstimatorStatus["Lagging"] = "lagging";
    RateEstimatorStatus["Low"] = "low";
    RateEstimatorStatus["Ok"] = "ok";
})(exports.RateEstimatorStatus || (exports.RateEstimatorStatus = {}));
exports.RateEstimatorEvent = void 0;
(function (RateEstimatorEvent) {
    RateEstimatorEvent["RateOk"] = "rate-ok";
    RateEstimatorEvent["RateLow"] = "rate-low";
    RateEstimatorEvent["RateLagging"] = "rate-lagging";
})(exports.RateEstimatorEvent || (exports.RateEstimatorEvent = {}));

const makeRateEstimatorDefaultOptions = (targetRate) => Object.freeze({
    targetRate,
    hysteresisMargin: 0.05,
    lowDuration: 5,
    lowThreshold: targetRate * 0.8,
    minSamples: Math.max(30, targetRate),
    maxSamples: Math.max(120, targetRate * 4),
});

class RateEstimator extends EventEmitter {
    constructor(targetRate, options) {
        super();
        this.timestamps = [];
        this.status = exports.RateEstimatorStatus.Idle;
        if (typeof targetRate !== 'number' || targetRate <= 0) {
            throw new Error('Invalid target rate: must be a positive number.');
        }
        const defaultOptions = makeRateEstimatorDefaultOptions(targetRate);
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
    }
    dispose() {
        this.removeAllListeners();
        this.status = exports.RateEstimatorStatus.Idle;
        this.estimatedRate = undefined;
        this.lowRateStartTime = undefined;
        this.timestamps = [];
    }
    getEstimatedValues() {
        return {
            rate: this.estimatedRate,
            status: this.status,
            threshold: this.options.lowThreshold,
        };
    }
    getOptions() {
        return this.options;
    }
    getTimestamps() {
        return this.timestamps;
    }
    addTimestamp(timestamp) {
        if (this.status === exports.RateEstimatorStatus.Idle) {
            this.status = exports.RateEstimatorStatus.Init;
        }
        this.timestamps.unshift(timestamp);
        if (this.timestamps.length > this.options.maxSamples) {
            this.timestamps.pop();
        }
        if (this.timestamps.length >= this.options.minSamples) {
            this.calculateAndUpdateRate();
            this.evaluateRate(timestamp);
        }
    }
    calculateAndUpdateRate() {
        const sampleCount = this.timestamps.length - 1;
        const timeDifference = (this.timestamps[0] - this.timestamps[sampleCount]) / 1000;
        const estimatedRate = sampleCount / timeDifference;
        this.estimatedRate = Number(estimatedRate.toFixed(1));
    }
    evaluateRate(timestamp) {
        if (this.isRateLow()) {
            this.handleLowRate(timestamp);
            return;
        }
        if (this.lowRateStartTime) {
            this.handleReturnToNormalRate();
            return;
        }
        this.status = exports.RateEstimatorStatus.Ok;
    }
    isRateLow() {
        const { hysteresisMargin, lowThreshold } = this.options;
        if (!this.estimatedRate) {
            return false;
        }
        const tolerance = lowThreshold * hysteresisMargin;
        const lowerBound = lowThreshold - tolerance;
        const upperBound = lowThreshold + tolerance;
        if (this.status === exports.RateEstimatorStatus.Ok || this.status === exports.RateEstimatorStatus.Init) {
            return this.estimatedRate < lowerBound;
        }
        return this.estimatedRate < upperBound;
    }
    handleLowRate(timestamp) {
        var _a;
        if (this.estimatedRate === undefined) {
            return;
        }
        if (this.status === exports.RateEstimatorStatus.Lagging) {
            return;
        }
        if (this.status !== exports.RateEstimatorStatus.Low) {
            this.emit(exports.RateEstimatorEvent.RateLow, this.estimatedRate);
            this.status = exports.RateEstimatorStatus.Low;
            (_a = this.lowRateStartTime) !== null && _a !== void 0 ? _a : (this.lowRateStartTime = timestamp);
            return;
        }
        if (this.status === exports.RateEstimatorStatus.Low) {
            const timeElapsed = timestamp - (this.lowRateStartTime || 0);
            if (timeElapsed >= this.options.lowDuration * 1000) {
                this.emit(exports.RateEstimatorEvent.RateLagging, this.estimatedRate);
                this.status = exports.RateEstimatorStatus.Lagging;
            }
        }
    }
    handleReturnToNormalRate() {
        if (this.estimatedRate !== undefined) {
            this.emit(exports.RateEstimatorEvent.RateOk, this.estimatedRate);
            this.status = exports.RateEstimatorStatus.Ok;
            this.lowRateStartTime = undefined;
        }
    }
    reset() {
        this.timestamps = [];
        this.estimatedRate = undefined;
        this.lowRateStartTime = undefined;
        this.status = exports.RateEstimatorStatus.Idle;
    }
    updateOptions(newOptions) {
        this.options = Object.assign(Object.assign({}, this.options), newOptions);
    }
}

class RateEstimationPlugin extends BaseAfterInferencePlugin {
    createCore() {
        var _a;
        return new RateEstimator(this.options.targetRate, (_a = this.options) === null || _a === void 0 ? void 0 : _a.coreOptions);
    }
    onCoreCreated() {
        var _a, _b, _c;
        const { targetRate } = this.options;
        if (this.options.debug) {
            logger.log('rate estimator: initializing with options:', this.options);
        }
        (_a = this.core) === null || _a === void 0 ? void 0 : _a.on(exports.RateEstimatorEvent.RateLow, (rate) => {
            if (this.options.debug) {
                logger.log(`rate estimator: rate low, target = ${targetRate}, estimated = ${rate.toFixed(2)}`);
            }
        });
        (_b = this.core) === null || _b === void 0 ? void 0 : _b.on(exports.RateEstimatorEvent.RateOk, (rate) => {
            if (this.options.debug) {
                logger.log(`rate estimator: rate returned to normal, target = ${targetRate}, estimated = ${rate.toFixed(2)}`);
            }
        });
        (_c = this.core) === null || _c === void 0 ? void 0 : _c.on(exports.RateEstimatorEvent.RateLagging, (rate) => {
            if (this.options.debug) {
                logger.log(`rate estimator: rate lagging, target = ${targetRate}, estimated = ${rate.toFixed(2)}`);
            }
        });
    }
    onEffectDisabled() {
        var _a;
        (_a = this.core) === null || _a === void 0 ? void 0 : _a.reset();
    }
    onEffectEnabled() {
        var _a;
        (_a = this.core) === null || _a === void 0 ? void 0 : _a.reset();
    }
    destroyCore() {
        var _a;
        (_a = this.core) === null || _a === void 0 ? void 0 : _a.dispose();
    }
    onAfterInference(timestamp) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = this.core) === null || _a === void 0 ? void 0 : _a.addTimestamp(timestamp);
        });
    }
    getRate() {
        var _a, _b;
        return (_b = (_a = this.core) === null || _a === void 0 ? void 0 : _a.getEstimatedValues()) === null || _b === void 0 ? void 0 : _b.rate;
    }
    getThreshold() {
        var _a, _b;
        return (_b = (_a = this.core) === null || _a === void 0 ? void 0 : _a.getEstimatedValues()) === null || _b === void 0 ? void 0 : _b.threshold;
    }
    getStatus() {
        var _a;
        return (_a = this.core) === null || _a === void 0 ? void 0 : _a.status;
    }
}

class SkippedFrameRatePlugin extends BaseAfterInferencePlugin {
    constructor() {
        super(...arguments);
        this.frameHistory = [];
        this.frameWindowSize = 5000;
    }
    onAfterInference(timestamp, result) {
        return __awaiter(this, void 0, void 0, function* () {
            this.frameHistory.push({ timestamp, skipped: !!(result === null || result === void 0 ? void 0 : result.skipped) });
            this.frameHistory = this.frameHistory.filter((frame) => timestamp - frame.timestamp <= this.frameWindowSize);
        });
    }
    getSkippedPercentage() {
        const totalFrames = this.frameHistory.length;
        const skippedFrames = this.frameHistory.filter((frame) => frame.skipped).length;
        return totalFrames > 0 ? (skippedFrames / totalFrames) * 100 : 0;
    }
    getSkippedFrameCount() {
        return this.frameHistory.filter((frame) => frame.skipped).length;
    }
    getTotalFrameCount() {
        return this.frameHistory.length;
    }
}

const e$1 = "1.20.1", t$1 = "0.7.7.2", i$1 = "segmentation.js", n = { int: "https://models.int.infra.intelligence.webex.com", prod: "https://models.intelligence.webex.com" }, o$2 = { models: "ladon/models", wasm: "ladon/wasm", workers: "ladon/workers" }, l$1 = { weak: { kernelSize: 9, sigma: 2 }, moderate: { kernelSize: 15, sigma: 6 }, strong: { kernelSize: 25, sigma: 11 }, stronger: { kernelSize: 37, sigma: 17 }, strongest: { kernelSize: 49, sigma: 23 } }, h = { tiny: { modelFile: "tiny-640x360.onnx", inputSize: { width: 640, height: 360 }, outputSize: { width: 640, height: 360 }, upscaleSize: { width: 640, height: 360 }, generationIntervalMs: 48, modelRank: 4 }, low: { modelFile: "low-640x360.onnx", inputSize: { width: 640, height: 360 }, outputSize: { width: 640, height: 360 }, upscaleSize: { width: 640, height: 360 }, generationIntervalMs: 48, modelRank: 4 }, medium: { modelFile: "medium-640x360.onnx", inputSize: { width: 640, height: 360 }, outputSize: { width: 640, height: 360 }, upscaleSize: { width: 640, height: 360 }, generationIntervalMs: 36, modelRank: 4 }, high: { modelFile: "medium-640x360.onnx", inputSize: { width: 640, height: 360 }, outputSize: { width: 640, height: 360 }, upscaleSize: { width: 640, height: 360 }, generationIntervalMs: 24, modelRank: 4 }, ultra: { modelFile: "medium-640x360.onnx", inputSize: { width: 640, height: 360 }, outputSize: { width: 640, height: 360 }, upscaleSize: { width: 640, height: 360 }, generationIntervalMs: 0, modelRank: 4 } }, s = "${BASE_PATH_MODELS}/${MODEL_VERSION}/${MODEL_FILE}", a$1 = "${BASE_PATH_WASM}/${ONNX_VERSION}/", d$2 = "${BASE_PATH_WORKERS}/${LIB_VERSION}/${WORKER_FILE}", m$1 = {
  onnxVersion: e$1,
  modelVersion: t$1,
  workerFile: i$1,
  baseUrls: n,
  basePaths: o$2,
  blurStrengths: l$1,
  modelQualities: h,
  modelUrlTemplate: s,
  wasmPathTemplate: a$1,
  workerUrlTemplate: d$2
};

const o$1 = "5.5.1";

class a {
  constructor(e = "prod") {
    this.env = e, this.config = {};
  }
  /**
   * Sets the base URL for the configuration.
   * @param baseUrl The base URL to use.
   */
  setBaseUrl(e) {
    return this.config.baseUrl = e.replace(/\/+$/, ""), this;
  }
  /**
   * Sets the WASM URI for the configuration.
   * @param wasmUri The WASM URI to use.
   */
  setWasmUri(e) {
    return this.config.wasmUri = e, this;
  }
  /**
   * Sets the asset URL resolver.
   * @param assetUrlResolver The asset URL resolver to use
   * @returns The current ConfigurationBuilder instance.
   */
  setAssetUrlResolver(e) {
    return this.config.assetUrlResolver = e, this;
  }
  /**
   * Sets the execution providers for the ONNX runtime.
   *
   * @param executionProviders The execution providers to use.
   */
  setExecutionProviders(e) {
    return typeof e == "string" && (e = [e]), this.config.executionProviders = e, this;
  }
  /**
   * Sets the input size for the configuration.
   * @param height The height of the input.
   * @param width The width of the input.
   */
  setInputSize(e, r) {
    return this.config.input = { height: e, width: r }, this;
  }
  /**
   * Sets the input configuration.
   * @param inputConfig The input configuration to use.
   */
  setInputConfig(e) {
    return this.config.input = { ...e }, this;
  }
  /**
   * Sets the render configuration.
   * @param renderConfig The render configuration to use.
   */
  setRenderConfig(e) {
    return this.config.render = { ...e }, this;
  }
  /**
   * Sets the render type.
   * @param type The render type ('blur', 'passthrough', 'replacement').
   */
  setRenderType(e) {
    return this.config.render ? this.config.render.type = e : this.config.render = { type: e }, this;
  }
  /**
   * Sets the horizontal mirror property for the render configuration.
   * @param horizontalMirror Boolean indicating if horizontal mirror should be applied.
   */
  setRenderHorizontalMirror(e) {
    if (!this.config.render)
      throw new Error("Render config must be set before setting horizontal mirror.");
    return this.config.render.horizontalMirror = e, this;
  }
  /**
   * Sets the blur strength for the render configuration.
   * @param blurStrength The blur strength to use.
   */
  setBlurStrength(e) {
    var t;
    const r = a.getBlurConfig(
      e,
      (t = this.config.render) == null ? void 0 : t.horizontalMirror
    );
    return this.config.render = { ...this.config.render, ...r }, this;
  }
  /**
   * Sets the blur kernel size.
   * @param kernelSize The kernel size for the blur effect.
   */
  setBlurKernelSize(e) {
    if (!this.config.render || this.config.render.type !== "blur")
      throw new Error("Render config must be of type blur to set blur properties.");
    return this.config.render.kernelSize = e, this;
  }
  /**
   * Sets the blur sigma value.
   * @param sigma The sigma value for the blur effect.
   */
  setBlurSigma(e) {
    if (!this.config.render || this.config.render.type !== "blur")
      throw new Error("Render config must be of type blur to set blur properties.");
    return this.config.render.sigma = e, this;
  }
  /**
   * Sets the replacement background.
   * @param background The background to use for replacement.
   */
  setReplacementBackground(e) {
    if (!this.config.render || this.config.render.type !== "replacement")
      throw new Error(
        "Render config must be of type replacement to set replacement properties."
      );
    return this.config.render.background = e, this;
  }
  /**
   * Sets the replacement static property.
   * @param isStatic Boolean indicating if the replacement is static.
   */
  setReplacementStatic(e) {
    if (!this.config.render || this.config.render.type !== "replacement")
      throw new Error(
        "Render config must be of type replacement to set replacement properties."
      );
    return this.config.render.static = e, this;
  }
  /**
   * Sets the mask configuration.
   * @param maskConfig The mask configuration to use.
   */
  setMaskConfig(e) {
    return this.config.mask = { ...e }, this;
  }
  /**
   * Sets the mask generator.
   * @param generator The generator type (most be 'worker'; 'local' is deprecated).
   */
  setMaskGenerator(e) {
    e !== "worker" && console.warn('[ladon-ts] Mask generator must be "worker". "local" is deprecated.');
    const r = this.getMaskConfig();
    return r.generator = e, this;
  }
  /**
   * Sets the mask generation interval in milliseconds.
   * @param intervalMs The generation interval in milliseconds.
   */
  setMaskGenerationIntervalMs(e) {
    const r = this.getMaskConfig();
    return r.generationIntervalMs = e, this;
  }
  /**
   * Sets the mask model rank.
   * @param modelRank The model rank to use.
   */
  setMaskModelRank(e) {
    const r = this.getMaskConfig();
    return r.modelRank = e, this;
  }
  /**
   * Sets the mask model URI.
   * @param modelUri The model URI to use.
   */
  setMaskModelUri(e) {
    const r = this.getMaskConfig();
    return r.modelUri = e, this;
  }
  /**
   * Sets the mask worker URI.
   * @param workerUri The worker URI to use.
   */
  setMaskWorkerUri(e) {
    const r = this.getMaskConfig();
    return r.workerUri = e, this;
  }
  /**
   * Sets the mask input size.
   * @param height The height of the mask input.
   * @param width The width of the mask input.
   */
  setMaskInputSize(e, r) {
    const t = this.getMaskConfig();
    return t.inputSize = { height: e, width: r }, this;
  }
  /**
   * Sets the mask output size.
   * @param height The height of the mask output.
   * @param width The width of the mask output.
   */
  setMaskOutputSize(e, r) {
    const t = this.getMaskConfig();
    return t.outputSize = { height: e, width: r }, this;
  }
  /**
   * Sets the mask upscaled size.
   * @param height The height of the upscaled mask.
   * @param width The width of the upscaled mask.
   */
  setMaskUpscaleSize(e, r) {
    const t = this.getMaskConfig();
    return t.upscaleSize = { height: e, width: r }, this;
  }
  /**
   * Sets the quality level and updates mask configurations accordingly.
   * @param quality The desired quality level.
   */
  setMaskQuality(e) {
    const { modelQualities: r } = m$1, t = this.getMaskConfig(), i = e.toLowerCase(), o = r[i];
    if (!o)
      throw new Error(`[ladon-ts] - unknown quality option: ${e}`);
    return t.qualityKey = i, Object.assign(t, o), this;
  }
  /**
   * Builds and returns the PreloadConfig or PipelineConfig object.
   *
   * @param requireInputConfig Whether to require the input configuration to be set before building.
   * Input size is not available at preload so this needs to be optional. The default value is true.
   *
   */
  build(e = !0) {
    const r = this.resolveBaseUrl(), t = this.resolveModelUri(), i = this.resolveWasmUri(), o = this.resolveWorkerUri(), l = this.config.input, g = this.config.render, n = this.config.mask, c = this.config.executionProviders, f = this.config.assetUrlResolver;
    if (!n)
      throw new Error("Mask configuration must be set before building the configuration.");
    const u = {
      generator: n.generator,
      generationIntervalMs: n.generationIntervalMs,
      modelRank: n.modelRank,
      inputSize: n.inputSize,
      outputSize: n.outputSize,
      upscaleSize: n.upscaleSize,
      modelUri: t,
      workerUri: o
    }, h = {
      assetUrlResolver: f,
      executionProviders: c,
      baseUrl: r,
      wasmUri: i,
      mask: u
    };
    if (e) {
      if (!l)
        throw new Error("Input must be set before building the configuration.");
      if (!g)
        throw new Error("Render must be set before building the configuration.");
      return {
        ...h,
        input: l,
        render: g
      };
    }
    return h;
  }
  /**
   * Returns the mask configuration, initializing it if necessary.
   */
  getMaskConfig() {
    return this.config.mask || (this.config.mask = {}), this.config.mask;
  }
  /**
   * Returns the base URL for the configuration.
   */
  resolveBaseUrl() {
    return this.config.baseUrl || m$1.baseUrls[this.env];
  }
  /**
   * Returns the base URL for the configuration.
   *
   * @returns The base URL for the configuration.
   */
  resolveModelUri() {
    var r;
    if ((r = this.config.mask) != null && r.modelUri)
      return this.config.mask.modelUri;
    const e = this.getMaskConfig();
    if (!e.qualityKey)
      throw new Error("[ladon-ts] No quality set, cannot infer modelFile.");
    return this.resolveTemplate(m$1.modelUrlTemplate, {
      BASE_PATH_MODELS: m$1.basePaths.models,
      MODEL_VERSION: m$1.modelVersion,
      MODEL_FILE: m$1.modelQualities[e.qualityKey].modelFile
    });
  }
  resolveWasmUri() {
    return this.config.wasmUri ? this.config.wasmUri : this.resolveTemplate(m$1.wasmPathTemplate, {
      BASE_PATH_WASM: m$1.basePaths.wasm,
      ONNX_VERSION: m$1.onnxVersion
    });
  }
  resolveWorkerUri() {
    var e;
    return (e = this.config.mask) != null && e.workerUri ? this.config.mask.workerUri : this.resolveTemplate(m$1.workerUrlTemplate, {
      BASE_PATH_WORKERS: m$1.basePaths.workers,
      LIB_VERSION: a.getLibVersion(),
      WORKER_FILE: m$1.workerFile
    });
  }
  /**
   * Resolves a template string with the specified values.
   *
   * @param template The template string to resolve.
   * @param values The values to use for resolution.
   * @returns The resolved template string.
   */
  resolveTemplate(e, r) {
    return e.replace(/\$\{([A-Z_]+)\}/g, (t, i) => {
      if (!r[i])
        throw new Error(`Missing value for template variable: ${i}`);
      return r[i];
    });
  }
  /**
   * Generates a blur configuration based on the specified blur strength.
   * @param blurStrength The desired blur strength.
   * @param horizontalMirror Whether to apply horizontal mirroring.
   */
  static getBlurConfig(e, r) {
    const t = e.toLowerCase(), i = m$1.blurStrengths[t];
    if (!i)
      throw new Error(`[ladon-ts] Unknown blur strength: ${e}`);
    return {
      type: "blur",
      horizontalMirror: r,
      ...i
    };
  }
  static getPassthroughConfig(e) {
    return {
      type: "passthrough",
      horizontalMirror: e
    };
  }
  /**
   * Returns the library version.
   *
   * @returns The library version.
   */
  static getLibVersion() {
    return o$1;
  }
}

var E = /* @__PURE__ */ ((T) => (T.TINY = "TINY", T.LOW = "LOW", T.MEDIUM = "MEDIUM", T.HIGH = "HIGH", T.ULTRA = "ULTRA", T))(E || {}), R$1 = /* @__PURE__ */ ((T) => (T.WEAK = "WEAK", T.MODERATE = "MODERATE", T.STRONG = "STRONG", T.STRONGER = "STRONGER", T.STRONGEST = "STRONGEST", T))(R$1 || {});

const A = (o, n, u, r, e) => {
  const l = new Uint8ClampedArray(r * e * 4), p = n / r, y = u / e, s = n * 4;
  let a = 0;
  for (let t = 0; t < e; t++) {
    const f = Math.floor(t * y) * s;
    for (let c = 0; c < r; c++) {
      const m = f + Math.floor(c * p) * 4;
      l[a++] = o[m], l[a++] = o[m + 1], l[a++] = o[m + 2], l[a++] = o[m + 3];
    }
  }
  return l;
};
function d$1(o, n, u, r, e) {
  const l = new Uint8ClampedArray(r * e);
  if (n === r && u === e) {
    for (let s = 0; s < o.length; s++)
      l[s] = Math.min(Math.max(o[s], 0), 255);
    return l;
  }
  const p = (n - 1) / (r - 1), y = (u - 1) / (e - 1);
  for (let s = 0; s < e; s++)
    for (let a = 0; a < r; a++) {
      const t = p * a, f = y * s, c = Math.floor(t), m = Math.floor(f), S = Math.min(Math.ceil(t), n - 1), x = Math.min(Math.ceil(f), u - 1), w = t - c, i = f - m, M = o[m * n + c], h = o[m * n + S], k = o[x * n + c], P = o[x * n + S], I = M * (1 - w) * (1 - i) + h * w * (1 - i) + k * (1 - w) * i + P * w * i;
      l[s * r + a] = Math.min(Math.max(I, 0), 255);
    }
  return l;
}
function L(o, n, u) {
  const r = o.createShader(n);
  if (!r)
    throw new Error("[ladon-ts] - error creating shader");
  if (o.shaderSource(r, u), o.compileShader(r), !o.getShaderParameter(r, o.COMPILE_STATUS)) {
    const e = o.getShaderInfoLog(r) ?? "unknown error compiling shader.";
    throw new Error("[ladon-ts] - " + e);
  }
  return r;
}
function R(o, n, u) {
  const r = o.createProgram();
  if (!r)
    throw new Error("[ladon-ts] - error creating GPU program");
  if (o.attachShader(r, n), o.attachShader(r, u), o.linkProgram(r), !o.getProgramParameter(r, o.LINK_STATUS)) {
    const e = o.getProgramInfoLog(r) ?? "unknown error linking program.";
    throw new Error("[ladon-ts] - " + e);
  }
  return r;
}
function C(o) {
  if (o.startsWith("blob:"))
    return !0;
  try {
    return new URL(o), !0;
  } catch {
    return !1;
  }
}
const T = (o, n) => !n || o.startsWith("http") ? new URL(o).href : o ? n.replace(/\/+$/, "") + "/" + o.replace(/^\/+/, "") : n;

class t {
  constructor() {
    this.resolvedUriCache = /* @__PURE__ */ new Map();
  }
  /**
   * Resolves the full URL for a given asset. Non-file URIs are treated as paths and resolved
   * using the `toAbsoluteURI` method. If the assetUri is already resolved, or if it's found in
   * cache, it will be returned directly. If an assetUrlResolver function is provided in the
   * configuration, it will be used to resolve the URL if the assetUri is not fully qualified,
   * a blob URL, or in the cache.
   *
   * @param config - The preload configuration.
   * @param assetUri - The asset URI from the config.
   * @returns The resolved full URL.
   */
  async resolveUri(o, e) {
    if (!e)
      throw new Error("Asset URI is undefined.");
    if (this.resolvedUriCache.has(e))
      return this.resolvedUriCache.get(e);
    let r;
    if (C(e) ? r = e : e.match(/\.[a-z0-9]+$/i) ? typeof o.assetUrlResolver == "function" && (r = await o.assetUrlResolver(e, o)) : r = T(e, o.baseUrl), !r)
      throw new Error(`Failed to resolve asset URI: ${e}`);
    return this.resolvedUriCache.set(e, r), r;
  }
}
const d = new t();

class i {
  /**
   * Initialize the worker using the provided configuration.
   *
   * @param config - The configuration object.
   * @returns A promise that resolves when the worker is initialized.
   */
  async initializeWorker(r) {
    if (typeof Worker > "u")
      throw new Error("[ladon-ts] web workers are not supported in this environment");
    const e = await d.resolveUri(r, r.mask.workerUri), s = await (await fetch(e, { cache: "force-cache" })).text();
    return this.workerUrl = URL.createObjectURL(new Blob([s], { type: "text/javascript" })), new Worker(this.workerUrl, { type: "module" });
  }
  /**
   * Terminate the worker.
   */
  terminateWorker() {
    this.worker && (this.worker.terminate(), this.worker = void 0);
  }
  /**
   * Preload the worker using the provided configuration.
   *
   * @param config - The configuration object.
   * @returns A promise that resolves when the worker is preloaded.
   */
  async preloadWorker(r) {
    const e = await this.prepareWorkerConfig(r);
    this.worker = await this.initializeWorker(e), this.worker.postMessage({ type: "preload", config: e });
  }
  getWorker() {
    return this.worker;
  }
  getWorkerUrl() {
    return this.workerUrl;
  }
  /**
   * Prepare the worker configuration by resolving the final URLs and paths to send to the
   * worker. This is necessary because we can't send functions to the worker. We also need to
   * remove the assetUrlResolver function from the configuration.
   *
   * @param config - The preload configuration.
   * @returns The worker configuration.
   */
  async prepareWorkerConfig(r) {
    const t = { ...{
      ...r,
      mask: {
        ...r.mask,
        modelUri: await d.resolveUri(r, r.mask.modelUri),
        workerUri: await d.resolveUri(r, r.mask.workerUri)
      },
      wasmUri: await d.resolveUri(r, r.wasmUri)
    }, assetUrlResolver: void 0 };
    return JSON.parse(JSON.stringify(t));
  }
}
const k$1 = new i();

class m {
  constructor(t) {
    this.config = t, this.newMask = !0, this.lastMask = new Float32Array(
      this.config.mask.outputSize.height * this.config.mask.outputSize.width
    ), this.lastResult = {
      data: this.lastMask,
      facesAndLandmarks: { data: new Float32Array(0), dims: [] },
      gesture: new Float32Array(0),
      motion: 0,
      timestamp: 0,
      warm: !1
    };
  }
  /* eslint-disable-next-line @typescript-eslint/no-unused-vars */
  async getLadonOutput(t) {
    const e = {
      data: this.lastMask,
      facesAndLandmarks: this.lastResult.facesAndLandmarks,
      gesture: this.lastResult.gesture,
      motion: this.lastResult.motion,
      timestamp: this.lastResult.timestamp,
      warm: this.newMask
    };
    return this.newMask = !1, e;
  }
  async load() {
    const t = await k$1.prepareWorkerConfig(this.config);
    if (this.worker = k$1.getWorker(), this.worker ?? (this.worker = await k$1.initializeWorker(t)), !this.worker)
      throw new Error("[ladon-ts] - worker is not defined.");
    this.worker.onmessage = (s) => {
      if (s.data.type === "log") {
        const { message: o, severity: n } = s.data, i = `[ladon-ts] Message received from worker: ${o}`;
        switch (n) {
          case "warn":
            console.warn(i);
            break;
          case "error":
            console.error(i);
            break;
          default:
            console.log(i);
        }
      } else if (s.data.status === "generated")
        this.lastMask = s.data.mask, this.lastResult = {
          data: s.data.mask,
          facesAndLandmarks: s.data.facesAndLandmarks,
          gesture: s.data.gesture,
          motion: s.data.motion,
          timestamp: s.data.timestamp,
          warm: !0
        }, this.newMask = !0;
      else {
        const o = k$1.getWorkerUrl();
        o && URL.revokeObjectURL(o), r == null || r();
      }
    };
    const e = {
      baseUrl: t.baseUrl,
      input: t.input,
      mask: t.mask,
      wasmUri: t.wasmUri,
      render: { type: "passthrough" }
    };
    this.worker.postMessage({ type: "init", config: e });
    let r;
    return new Promise((s) => {
      r = s;
    });
  }
  isLoaded() {
    return !!this.worker;
  }
  async postRender(t, e) {
    if (!this.worker)
      throw new Error("[ladon-ts] - worker is not defined.");
    this.worker.postMessage(
      {
        type: "generate",
        image: t,
        timestamp: e
      },
      [t.buffer]
    );
  }
  destroy() {
    k$1.terminateWorker();
  }
}

class o {
  constructor(t, i) {
    this.output_canvas = t, this.config = i, this.verts = new Float32Array([
      -1,
      -1,
      0,
      // Vertex 1
      -1,
      1,
      0,
      // Vertex 2
      1,
      1,
      0,
      // Vertex 3
      1,
      1,
      0,
      // Vertex 4
      1,
      -1,
      0,
      // Vertex 5
      -1,
      -1,
      0
      // Vertex 6
    ]), this.vertex_shader_src = `#version 300 es

in vec4 position;

void main() {
    gl_Position = position;
}
`, this.fragment_shader_header = `#version 300 es
precision highp float;

out vec4 outColor;

uniform sampler2D u_image;
uniform sampler2D u_mask;
uniform vec2 u_resolution;
`, this.shared_shader_functions = `
float get_mask(vec2 uv) {
    float maskValue = texture(u_mask, uv).r;
    return smoothstep(0.0, 1.0, maskValue);
}
`;
    const e = this.output_canvas.getContext("webgl2", { antialias: !0 });
    if (e)
      this.gl = e;
    else {
      const s = this.output_canvas.getContext("2d");
      if (!s)
        throw new Error("[ladon-ts] - output canvas context must be webgl2 or 2d");
      this.output_canvas_2d = s, this.intermediate_canvas = document.createElement("canvas"), this.intermediate_canvas.height = this.config.input.height, this.intermediate_canvas.width = this.config.input.width;
      const r = this.intermediate_canvas.getContext("webgl2", {
        antialias: !0
      });
      if (!r)
        throw new Error("[ladon-ts] - error getting output context webgl");
      this.gl = r;
    }
    this.initTexturesAndBuffers();
  }
  initTexturesAndBuffers() {
    this.image_texture = this.createTexture(
      this.gl.RGBA,
      this.config.input.width,
      this.config.input.height
    ), this.mask_texture = this.createTexture(
      this.gl.R8,
      this.config.mask.upscaleSize.width,
      this.config.mask.upscaleSize.height
    );
    const t = this.gl.createVertexArray();
    if (!t)
      throw new Error("[ladon-ts] - error creating vertex array");
    this.gl.bindVertexArray(t);
    const i = this.gl.createBuffer();
    if (!i)
      throw new Error("[ladon-ts] - error creating buffer");
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, i), this.gl.bufferData(this.gl.ARRAY_BUFFER, this.verts, this.gl.STATIC_DRAW), this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, !1, 0, 0), this.gl.enableVertexAttribArray(0), this.gl.viewport(0, 0, this.config.input.width, this.config.input.height);
  }
  createTexture(t, i, e, s = () => {
    this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      t,
      i,
      e,
      0,
      t === this.gl.RGBA ? this.gl.RGBA : this.gl.RED,
      this.gl.UNSIGNED_BYTE,
      null
    );
  }) {
    const r = this.gl.createTexture();
    if (!r)
      throw new Error("[ladon-ts] - error creating texture");
    return this.gl.bindTexture(this.gl.TEXTURE_2D, r), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), s(), this.gl.bindTexture(this.gl.TEXTURE_2D, null), r;
  }
  getUVCalculation() {
    return this.config.render.horizontalMirror ? "vec2 st = vec2(1.0 - gl_FragCoord.x / u_resolution.x, 1.0 - gl_FragCoord.y / u_resolution.y);" : "vec2 st = vec2(gl_FragCoord.x / u_resolution.x, 1.0 - gl_FragCoord.y / u_resolution.y);";
  }
  setSharedUniforms(t) {
    const i = this.gl.getUniformLocation(t, "u_resolution");
    if (!i)
      throw new Error('[ladon-ts] - error finding "u_resolution" uniform');
    this.gl.uniform2f(i, this.config.input.width, this.config.input.height);
    const e = this.gl.getUniformLocation(t, "u_image");
    if (!e)
      throw new Error('[ladon-ts] - error finding "u_image" uniform');
    this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, this.image_texture), this.gl.uniform1i(e, 0);
    const s = this.gl.getUniformLocation(t, "u_mask");
    s && (this.gl.activeTexture(this.gl.TEXTURE1), this.gl.bindTexture(this.gl.TEXTURE_2D, this.mask_texture), this.gl.uniform1i(s, 1));
  }
  uploadVideoStream(t) {
    this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, this.image_texture), t instanceof HTMLVideoElement ? this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      this.gl.RGBA,
      this.gl.RGBA,
      this.gl.UNSIGNED_BYTE,
      t
    ) : this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      this.gl.RGBA,
      this.config.input.width,
      this.config.input.height,
      0,
      this.gl.RGBA,
      this.gl.UNSIGNED_BYTE,
      t
    );
  }
  uploadMask(t) {
    if (t != null && t.warm) {
      const i = d$1(
        t.data,
        this.config.mask.outputSize.width,
        this.config.mask.outputSize.height,
        this.config.mask.upscaleSize.width,
        this.config.mask.upscaleSize.height
      );
      this.gl.activeTexture(this.gl.TEXTURE1), this.gl.bindTexture(this.gl.TEXTURE_2D, this.mask_texture), this.gl.texImage2D(
        this.gl.TEXTURE_2D,
        0,
        this.gl.R8,
        this.config.mask.upscaleSize.width,
        this.config.mask.upscaleSize.height,
        0,
        this.gl.RED,
        this.gl.UNSIGNED_BYTE,
        i
      );
    }
  }
  postDraw() {
    this.output_canvas_2d && this.intermediate_canvas && this.output_canvas_2d.drawImage(
      this.intermediate_canvas,
      0,
      0,
      this.config.input.width,
      this.config.input.height
    );
  }
}

class _ extends o {
  constructor(r, i) {
    if (super(r, i), this.output_canvas = r, this.config = i, this.fragment_shader_common = `#version 300 es
precision highp float;

#define KERNEL_SIZE     ${this.config.render.kernelSize}
#define HORIZONTAL      vec2(1.0, 0.0)
#define VERTICAL        vec2(0.0, 1.0)

out vec4 outColor;

uniform sampler2D       u_image;
uniform sampler2D       u_mask;
uniform vec2            u_resolution;
uniform float           u_kernel[KERNEL_SIZE];

// Function to retrieve the mask value
float get_mask(vec2 st) {
    return texture(u_mask, st).r;
}

// Get the inverse of the masked area
float get_inv_mask(vec2 st) {
    return 1.0 - get_mask(st);
}

// Blurring function
vec3 blur(sampler2D src, vec2 uv, vec2 direction) {
    vec4 accum = vec4(0.0);
    vec2 step = direction / u_resolution;
    int offset = (KERNEL_SIZE - 1) / 2;

    float weightSum = 0.0;
    for (int i = 0; i < KERNEL_SIZE; i++) {
        vec2 sampleUV = uv + step * float(i - offset);
        vec4 sampleTex = texture(src, sampleUV);
        float weight = u_kernel[i];
        accum += sampleTex * weight;
        weightSum += weight;
    }

    weightSum = max(weightSum, 0.001); // Avoid division by zero
    return accum.rgb / weightSum;
}
`, this.fragment_shader_pass_1_src = this.fragment_shader_common + `
void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    outColor = vec4(blur(u_image, st, HORIZONTAL), 1.0);
}
`, this.fragment_shader_pass_2_src = this.fragment_shader_common + `
uniform sampler2D   u_blur;

void main() {
    ${this.getUVCalculation()};

    vec3 blurred = blur(u_blur, st, VERTICAL);
    vec3 original = texture(u_image, st).rgb;
    float mask = get_inv_mask(st); // Use inverse mask to blur background, not user

    // Correct blending based on the mask
    vec3 color = mix(original, blurred, mask); // Ensure mask properly determines blur influence on background
    outColor = vec4(color, 1.0);
}
`, this.config.render.kernelSize % 2 === 0)
      throw new Error("[ladon-ts] - kernel_size must be odd");
    {
      const e = L(
        this.gl,
        this.gl.VERTEX_SHADER,
        this.vertex_shader_src
      ), t = L(
        this.gl,
        this.gl.FRAGMENT_SHADER,
        this.fragment_shader_pass_1_src
      );
      this.program_1 = R(this.gl, e, t), this.gl.useProgram(this.program_1);
      const s = this.gl.createFramebuffer();
      if (!s)
        throw new Error("[ladon-ts] - error creating framebuffer");
      this.framebuffer = s;
      const n = this.gl.createTexture();
      if (!n)
        throw new Error("[ladon-ts] - error creating output texture");
      this.transfer_texture = n, this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer), this.gl.bindTexture(this.gl.TEXTURE_2D, this.transfer_texture), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(
        this.gl.TEXTURE_2D,
        this.gl.TEXTURE_WRAP_S,
        this.gl.CLAMP_TO_EDGE
      ), this.gl.texParameteri(
        this.gl.TEXTURE_2D,
        this.gl.TEXTURE_WRAP_T,
        this.gl.CLAMP_TO_EDGE
      ), this.gl.texImage2D(
        this.gl.TEXTURE_2D,
        0,
        this.gl.RGBA,
        this.config.input.width,
        this.config.input.height,
        0,
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        null
      ), this.gl.framebufferTexture2D(
        this.gl.FRAMEBUFFER,
        this.gl.COLOR_ATTACHMENT0,
        this.gl.TEXTURE_2D,
        this.transfer_texture,
        0
      ), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.setSharedUniforms(this.program_1);
      const l = this.gl.getUniformLocation(this.program_1, "u_kernel");
      if (!l)
        throw new Error('[ladon-ts] - error finding "u_kernel" uniform');
      this.gl.uniform1fv(l, this.getBlurKernel());
    }
    {
      const e = L(
        this.gl,
        this.gl.VERTEX_SHADER,
        this.vertex_shader_src
      ), t = L(
        this.gl,
        this.gl.FRAGMENT_SHADER,
        this.fragment_shader_pass_2_src
      );
      this.program_2 = R(this.gl, e, t), this.gl.useProgram(this.program_2);
      const s = this.gl.getUniformLocation(this.program_2, "u_blur");
      if (!s)
        throw new Error('[ladon-ts] - error finding "u_blur" uniform');
      this.u_blur = s, this.gl.activeTexture(this.gl.TEXTURE2), this.gl.bindTexture(this.gl.TEXTURE_2D, this.transfer_texture), this.gl.uniform1i(this.u_blur, 2), this.setSharedUniforms(this.program_2);
      const n = this.gl.getUniformLocation(this.program_2, "u_kernel");
      if (!n)
        throw new Error('[ladon-ts] - error finding "u_kernel" uniform');
      this.gl.uniform1fv(n, this.getBlurKernel());
    }
  }
  async render(r, i) {
    this.uploadVideoStream(r), this.uploadMask(i), this.gl.useProgram(this.program_1), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer), this.gl.drawArrays(this.gl.TRIANGLES, 0, this.verts.length / 3), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.gl.useProgram(this.program_2), this.gl.drawArrays(this.gl.TRIANGLES, 0, this.verts.length / 3), this.postDraw();
  }
  async load() {
  }
  destroy() {
  }
  getBlurKernel() {
    const r = [];
    let i = 0;
    for (let e = 0; e < this.config.render.kernelSize; e++) {
      let t = e - (this.config.render.kernelSize - 1) / 2;
      t = Math.exp(-(t ** 2) / this.config.render.sigma ** 2), r.push(t), i += t;
    }
    for (let e = 0; e < this.config.render.kernelSize; e++)
      r[e] = r[e] / i;
    return new Float32Array(r);
  }
}

class l extends o {
  constructor(r, s) {
    super(r, s), this.output_canvas = r, this.config = s, this.fragment_shader = `#version 300 es
precision highp float;

out vec4 outColor;

uniform sampler2D       u_image;
uniform vec2            u_resolution;


void main() {
    ${this.getUVCalculation()}

    outColor = vec4(texture(u_image, st).rgb, 1.0);
}
`;
    const e = L(this.gl, this.gl.VERTEX_SHADER, this.vertex_shader_src), i = L(
      this.gl,
      this.gl.FRAGMENT_SHADER,
      this.fragment_shader
    );
    this.program = R(this.gl, e, i), this.gl.useProgram(this.program), this.setSharedUniforms(this.program);
  }
  async render(r) {
    this.uploadVideoStream(r), this.gl.useProgram(this.program), this.gl.drawArrays(this.gl.TRIANGLES, 0, this.verts.length / 3), this.postDraw();
  }
  async load() {
  }
  destroy() {
  }
}

class c extends o {
  constructor(t, r) {
    super(t, r), this.output_canvas = t, this.config = r;
    const e = this.config.render.background.getContext("2d", { willReadFrequently: !0 });
    if (!e)
      throw new Error("[ladon-ts] - could not get background canvas context 2d");
    this.background_canvas_ctx = e, this.fragment_shader = this.buildFragmentShader();
    const s = L(this.gl, this.gl.VERTEX_SHADER, this.vertex_shader_src), a = L(
      this.gl,
      this.gl.FRAGMENT_SHADER,
      this.fragment_shader
    );
    this.program = R(this.gl, s, a), this.gl.useProgram(this.program), this.setSharedUniforms(this.program), this.setupBackgroundTexture();
  }
  buildFragmentShader() {
    return `${this.fragment_shader_header}
    
uniform sampler2D u_background;

${this.shared_shader_functions}

void main() {
    ${this.getUVCalculation()}

    vec3 background = texture(u_background, st).rgb;
    vec3 image = texture(u_image, st).rgb;
    float mask = get_mask(st);

    vec3 color = mix(background, image, mask);
    outColor = vec4(color, 1.0);
}`;
  }
  setupBackgroundTexture() {
    const t = this.background_canvas_ctx.getImageData(
      0,
      0,
      this.config.render.background.width,
      this.config.render.background.height
    );
    this.background_texture = this.createTexture(
      this.gl.RGBA,
      this.config.render.background.width,
      this.config.render.background.height,
      () => {
        this.gl.texImage2D(
          this.gl.TEXTURE_2D,
          0,
          this.gl.RGBA,
          t.width,
          t.height,
          0,
          this.gl.RGBA,
          this.gl.UNSIGNED_BYTE,
          t.data
        );
      }
    );
    const r = this.gl.getUniformLocation(this.program, "u_background");
    if (!r)
      throw new Error('[ladon-ts] - error finding "u_background" uniform');
    this.gl.activeTexture(this.gl.TEXTURE2), this.gl.bindTexture(this.gl.TEXTURE_2D, this.background_texture), this.gl.uniform1i(r, 2);
  }
  async render(t, r) {
    if (this.uploadVideoStream(t), this.uploadMask(r), !this.config.render.static) {
      const e = this.background_canvas_ctx.getImageData(
        0,
        0,
        this.config.render.background.width,
        this.config.render.background.height
      ).data;
      this.gl.activeTexture(this.gl.TEXTURE2), this.gl.bindTexture(this.gl.TEXTURE_2D, this.background_texture), this.gl.texImage2D(
        this.gl.TEXTURE_2D,
        0,
        this.gl.RGBA,
        this.config.render.background.width,
        this.config.render.background.height,
        0,
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        e
      );
    }
    this.gl.useProgram(this.program), this.gl.drawArrays(this.gl.TRIANGLES, 0, this.verts.length / 3), this.postDraw();
  }
  async load() {
  }
  destroy() {
  }
}

class k {
  constructor(e, t, s, r) {
    this.inputCanvas = e, this.outputCanvas = t, this.config = s, this.videoElement = r, this.loaded = !1, this.frameQueue = [], this.maskQueue = [];
    const a = this.inputCanvas.getContext("2d", {
      alpha: !1,
      willReadFrequently: !0
    });
    if (!a)
      throw new Error("[ladon-ts] - error getting input context 2d");
    this.inputCanvasCtx = a;
  }
  /**
   * Processes a single frame and returns the inference result.
   *
   * @param timestamp - The timestamp of the frame.
   * @param performInference - Flag to perform mask inference.
   * @returns The result of the frame processing.
   * @throws If the pipeline (generator or renderer) is not loaded.
   */
  async onFrame(e, t = !0) {
    if (!this.generator || !this.renderer)
      throw new Error("[ladon-ts] - pipeline is not loaded.");
    const s = this.getInputFrameData(t);
    if (s instanceof Uint8ClampedArray ? ((!this.frameDataBuffer || this.frameDataBuffer.length !== s.length) && (this.frameDataBuffer = new Uint8ClampedArray(s.length)), this.frameDataBuffer.set(s), this.frameQueue.push({ timestamp: e, frameData: this.frameDataBuffer })) : this.frameQueue.push({ timestamp: e, frameData: s }), t || !this.lastMaskResult) {
      const r = s, a = this.getMaskImageData(r), i = await this.generator.getLadonOutput(a, e);
      this.maskQueue.push({ timestamp: i.timestamp, maskResult: i }), this.lastMaskResult = i, await this.renderSyncedFrameAndMask(), await this.generator.postRender(a, e);
    } else
      this.maskQueue.push({ timestamp: e, maskResult: this.lastMaskResult }), await this.renderSyncedFrameAndMask();
    return this.createInferenceResult(e, t);
  }
  /**
   * Synchronizes frames and masks to ensure they are rendered together.
   */
  async renderSyncedFrameAndMask() {
    var e;
    for (; this.frameQueue.length > 0 && this.maskQueue.length > 0; ) {
      const t = this.frameQueue[0], s = this.maskQueue[0];
      t.timestamp === s.timestamp ? (await ((e = this.renderer) == null ? void 0 : e.render(t.frameData, s.maskResult)), this.frameQueue.shift(), this.maskQueue.shift()) : t.timestamp < s.timestamp ? this.frameQueue.shift() : this.maskQueue.shift();
    }
  }
  /**
   * Gets the raw image data from the input canvas context.
   *
   * @param needFreshImageData - Flag to indicate if fresh image data is needed.
   *
   * @returns The raw image data.
   */
  getInputFrameData(e) {
    return e || !this.videoElement ? this.inputCanvasCtx.getImageData(
      0,
      0,
      this.config.input.width,
      this.config.input.height
    ).data : this.videoElement;
  }
  /**
   * Resizes the image data if the model expects a fixed size input.
   *
   * @param {Uint8ClampedArray} rawImageData - The raw image data.
   * @returns {Uint8ClampedArray} - The processed mask image data.
   */
  getMaskImageData(e) {
    const t = this.config.mask.inputSize, s = this.config.input;
    return t.width === s.width && t.height === s.height ? e : A(
      e,
      s.width,
      s.height,
      t.width,
      t.height
    );
  }
  /**
   * Creates the inference result object.
   *
   * @param {number} timestamp - The timestamp of the frame.
   * @param {boolean} performedInference - Indicates if the inference was performed.
   * @returns {IFrameInferenceResult} - The result object containing inference details.
   */
  createInferenceResult(e, t) {
    return this.lastMaskResult ? {
      facesAndLandmarks: this.lastMaskResult.facesAndLandmarks,
      gesture: this.lastMaskResult.gesture,
      motion: this.lastMaskResult.motion,
      skipped: !t,
      timestamp: e
    } : {
      facesAndLandmarks: { data: new Float32Array(0), dims: [] },
      gesture: new Float32Array(0),
      motion: 0,
      skipped: !0,
      timestamp: e
    };
  }
  /**
   * Checks if the pipeline is loaded.
   *
   * @returns True if the pipeline is loaded, false otherwise.
   */
  isLoaded() {
    return this.loaded;
  }
  /**
   * Loads the pipeline components such as the generator and renderer.
   */
  async load() {
    switch (this.config.render.type) {
      case "blur":
        this.renderer = new _(this.outputCanvas, this.config);
        break;
      case "passthrough":
        this.renderer = new l(this.outputCanvas, this.config);
        break;
      case "replacement":
        this.renderer = new c(this.outputCanvas, this.config);
        break;
      default:
        throw new Error("[ladon-ts] - renderer not implemented.");
    }
    await this.renderer.load(), this.generator = new m(this.config), await this.generator.load(), this.loaded = !0;
  }
  /**
   * Resets the frame and mask queues.
   */
  resetQueues() {
    this.frameQueue = [], this.maskQueue = [];
  }
  reset() {
    this.resetQueues(), this.lastMaskResult = void 0;
  }
  /**
   * Destroys the pipeline and cleans up resources.
   */
  destroy() {
    var e, t;
    this.reset(), (e = this.generator) == null || e.destroy(), (t = this.renderer) == null || t.destroy(), this.frameDataBuffer = void 0;
  }
}

const e = async (r) => {
  await k$1.preloadWorker(r);
};

var bundle = {exports: {}};

(function (module, exports) {
(function (global, factory) {
    factory(exports) ;
})(commonjsGlobal, (function (exports) {
    var createAddUniqueNumber = function createAddUniqueNumber(generateUniqueNumber) {
      return function (set) {
        var number = generateUniqueNumber(set);
        set.add(number);
        return number;
      };
    };

    var createCache = function createCache(lastNumberWeakMap) {
      return function (collection, nextNumber) {
        lastNumberWeakMap.set(collection, nextNumber);
        return nextNumber;
      };
    };

    /*
     * The value of the constant Number.MAX_SAFE_INTEGER equals (2 ** 53 - 1) but it
     * is fairly new.
     */
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === undefined ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
    var TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;
    var TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;
    var createGenerateUniqueNumber = function createGenerateUniqueNumber(cache, lastNumberWeakMap) {
      return function (collection) {
        var lastNumber = lastNumberWeakMap.get(collection);
        /*
         * Let's try the cheapest algorithm first. It might fail to produce a new
         * number, but it is so cheap that it is okay to take the risk. Just
         * increase the last number by one or reset it to 0 if we reached the upper
         * bound of SMIs (which stands for small integers). When the last number is
         * unknown it is assumed that the collection contains zero based consecutive
         * numbers.
         */
        var nextNumber = lastNumber === undefined ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;
        if (!collection.has(nextNumber)) {
          return cache(collection, nextNumber);
        }
        /*
         * If there are less than half of 2 ** 30 numbers stored in the collection,
         * the chance to generate a new random number in the range from 0 to 2 ** 30
         * is at least 50%. It's benifitial to use only SMIs because they perform
         * much better in any environment based on V8.
         */
        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {
          while (collection.has(nextNumber)) {
            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);
          }
          return cache(collection, nextNumber);
        }
        // Quickly check if there is a theoretical chance to generate a new number.
        if (collection.size > MAX_SAFE_INTEGER) {
          throw new Error('Congratulations, you created a collection of unique numbers which uses all available integers!');
        }
        // Otherwise use the full scale of safely usable integers.
        while (collection.has(nextNumber)) {
          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);
        }
        return cache(collection, nextNumber);
      };
    };

    var LAST_NUMBER_WEAK_MAP = new WeakMap();
    var cache = createCache(LAST_NUMBER_WEAK_MAP);
    var generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);
    var addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);

    exports.addUniqueNumber = addUniqueNumber;
    exports.generateUniqueNumber = generateUniqueNumber;

}));
}(bundle, bundle.exports));

const isCallNotification = (message) => {
    return message.method !== undefined && message.method === 'call';
};

const isClearResponse = (message) => {
    return typeof message.id === 'number' && typeof message.result === 'boolean';
};

const load = (url) => {
    // Prefilling the Maps with a function indexed by zero is necessary to be compliant with the specification.
    const scheduledIntervalFunctions = new Map([[0, () => { }]]); // tslint:disable-line no-empty
    const scheduledTimeoutFunctions = new Map([[0, () => { }]]); // tslint:disable-line no-empty
    const unrespondedRequests = new Map();
    const worker = new Worker(url);
    worker.addEventListener('message', ({ data }) => {
        if (isCallNotification(data)) {
            const { params: { timerId, timerType } } = data;
            if (timerType === 'interval') {
                const idOrFunc = scheduledIntervalFunctions.get(timerId);
                if (typeof idOrFunc === undefined) {
                    throw new Error('The timer is in an undefined state.');
                }
                if (typeof idOrFunc === 'number') {
                    const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
                    if (timerIdAndTimerType === undefined ||
                        timerIdAndTimerType.timerId !== timerId ||
                        timerIdAndTimerType.timerType !== timerType) {
                        throw new Error('The timer is in an undefined state.');
                    }
                }
                else if (typeof idOrFunc === 'function') {
                    idOrFunc();
                }
            }
            else if (timerType === 'timeout') {
                const idOrFunc = scheduledTimeoutFunctions.get(timerId);
                if (typeof idOrFunc === undefined) {
                    throw new Error('The timer is in an undefined state.');
                }
                if (typeof idOrFunc === 'number') {
                    const timerIdAndTimerType = unrespondedRequests.get(idOrFunc);
                    if (timerIdAndTimerType === undefined ||
                        timerIdAndTimerType.timerId !== timerId ||
                        timerIdAndTimerType.timerType !== timerType) {
                        throw new Error('The timer is in an undefined state.');
                    }
                }
                else if (typeof idOrFunc === 'function') {
                    idOrFunc();
                    // A timeout can be savely deleted because it is only called once.
                    scheduledTimeoutFunctions.delete(timerId);
                }
            }
        }
        else if (isClearResponse(data)) {
            const { id } = data;
            const timerIdAndTimerType = unrespondedRequests.get(id);
            if (timerIdAndTimerType === undefined) {
                throw new Error('The timer is in an undefined state.');
            }
            const { timerId, timerType } = timerIdAndTimerType;
            unrespondedRequests.delete(id);
            if (timerType === 'interval') {
                scheduledIntervalFunctions.delete(timerId);
            }
            else {
                scheduledTimeoutFunctions.delete(timerId);
            }
        }
        else {
            const { error: { message } } = data;
            throw new Error(message);
        }
    });
    const clearInterval = (timerId) => {
        if (typeof scheduledIntervalFunctions.get(timerId) === 'function') {
            const id = bundle.exports.generateUniqueNumber(unrespondedRequests);
            unrespondedRequests.set(id, { timerId, timerType: 'interval' });
            scheduledIntervalFunctions.set(timerId, id);
            worker.postMessage({
                id,
                method: 'clear',
                params: { timerId, timerType: 'interval' }
            });
        }
    };
    const clearTimeout = (timerId) => {
        if (typeof scheduledTimeoutFunctions.get(timerId) === 'function') {
            const id = bundle.exports.generateUniqueNumber(unrespondedRequests);
            unrespondedRequests.set(id, { timerId, timerType: 'timeout' });
            scheduledTimeoutFunctions.set(timerId, id);
            worker.postMessage({
                id,
                method: 'clear',
                params: { timerId, timerType: 'timeout' }
            });
        }
    };
    const setInterval = (func, delay = 0) => {
        const timerId = bundle.exports.generateUniqueNumber(scheduledIntervalFunctions);
        scheduledIntervalFunctions.set(timerId, () => {
            func();
            // Doublecheck if the interval should still be rescheduled because it could have been cleared inside of func().
            if (typeof scheduledIntervalFunctions.get(timerId) === 'function') {
                worker.postMessage({
                    id: null,
                    method: 'set',
                    params: {
                        delay,
                        now: performance.timeOrigin + performance.now(),
                        timerId,
                        timerType: 'interval'
                    }
                });
            }
        });
        worker.postMessage({
            id: null,
            method: 'set',
            params: {
                delay,
                now: performance.timeOrigin + performance.now(),
                timerId,
                timerType: 'interval'
            }
        });
        return timerId;
    };
    const setTimeout = (func, delay = 0) => {
        const timerId = bundle.exports.generateUniqueNumber(scheduledTimeoutFunctions);
        scheduledTimeoutFunctions.set(timerId, func);
        worker.postMessage({
            id: null,
            method: 'set',
            params: {
                delay,
                now: performance.timeOrigin + performance.now(),
                timerId,
                timerType: 'timeout'
            }
        });
        return timerId;
    };
    return {
        clearInterval,
        clearTimeout,
        setInterval,
        setTimeout
    };
};

const createLoadOrReturnBroker = (loadBroker, worker) => {
    let broker = null;
    return () => {
        if (broker !== null) {
            return broker;
        }
        const blob = new Blob([worker], { type: 'application/javascript; charset=utf-8' });
        const url = URL.createObjectURL(blob);
        broker = loadBroker(url);
        // Bug #1: Edge up until v18 didn't like the URL to be revoked directly.
        setTimeout(() => URL.revokeObjectURL(url));
        return broker;
    };
};

// This is the minified and stringified code of the worker-timers-worker package.
const worker = `(()=>{"use strict";const e=new Map,t=new Map,r=t=>{const r=e.get(t);return void 0!==r&&(clearTimeout(r),e.delete(t),!0)},s=e=>{const r=t.get(e);return void 0!==r&&(clearTimeout(r),t.delete(e),!0)},o=(e,t)=>{const r=performance.now(),s=e+t-r-performance.timeOrigin;return{expected:r+s,remainingDelay:s}},i=(e,t,r,s)=>{const o=r-performance.now();o>0?e.set(t,setTimeout(i,o,e,t,r,s)):(e.delete(t),postMessage({id:null,method:"call",params:{timerId:t,timerType:s}}))};addEventListener("message",(n=>{let{data:a}=n;try{if("clear"===a.method){const{id:e,params:{timerId:t,timerType:o}}=a;if("interval"===o)postMessage({id:e,result:r(t)});else{if("timeout"!==o)throw new Error('The given type "'.concat(o,'" is not supported'));postMessage({id:e,result:s(t)})}}else{if("set"!==a.method)throw new Error('The given method "'.concat(a.method,'" is not supported'));{const{params:{delay:r,now:s,timerId:n,timerType:m}}=a;if("interval"===m)((t,r,s)=>{const{expected:n,remainingDelay:a}=o(t,s);e.set(r,setTimeout(i,a,e,r,n,"interval"))})(r,n,s);else{if("timeout"!==m)throw new Error('The given type "'.concat(m,'" is not supported'));((e,r,s)=>{const{expected:n,remainingDelay:a}=o(e,s);t.set(r,setTimeout(i,a,t,r,n,"timeout"))})(r,n,s)}}}}catch(e){postMessage({error:{message:e.message},id:a.id,result:null})}}))})();`; // tslint:disable-line:max-line-length

const loadOrReturnBroker = createLoadOrReturnBroker(load, worker);
const clearTimeout = (timerId) => loadOrReturnBroker().clearTimeout(timerId);
const setTimeout$1 = (...args) => loadOrReturnBroker().setTimeout(...args);

class PluginManager {
    constructor() {
        this.plugins = new Map();
        this.effect = null;
    }
    register(name, plugin) {
        if (this.plugins.has(name)) {
            logger.warn(`plugin manager: plugin with name ${name} already registered.`);
            return;
        }
        this.plugins.set(name, plugin);
    }
    initialize(effect) {
        logger.info('plugin manager: initializing plugins');
        this.effect = effect;
        this.plugins.forEach((plugin, name) => {
            if (plugin.isInitialized) {
                logger.warn(`plugin manager: "${name}" plugin already initialized.`);
                return;
            }
            plugin.initialize(effect);
        });
    }
    dispose() {
        if (!this.effect) {
            logger.warn('plugin manager: dispose called before effect is initialized.');
            return;
        }
        this.getPlugins().forEach((plugin) => plugin.dispose(this.effect));
        this.plugins.clear();
        this.effect = null;
    }
    getPlugin(name) {
        return this.plugins.get(name);
    }
    getPlugins() {
        return this.plugins;
    }
}

const generateUuid = () => String(Math.random() * 1e17);
const injectStyles = () => {
    const styleId = 'web-media-effects-styles';
    let styleEl = document.getElementById(styleId);
    if (!styleEl) {
        styleEl = document.createElement('style');
        styleEl.id = styleId;
        styleEl.textContent = `
      .web-media-effects-hidden {
        bottom: 0;
        opacity: 0;
        position: fixed;
        z-index: -2147483647;
        height: 0px;
        width: 0px;
      }
    `;
        document.head.appendChild(styleEl);
    }
};
const getOrCreateEl = (kind, height, width, uniqueId = generateUuid(), addToDom = false) => {
    injectStyles();
    const id = `web-media-effects-${kind}-${uniqueId}`;
    let el = document.getElementById(id);
    if (!el) {
        el = document.createElement(kind);
        el.id = id;
        el.classList.add('web-media-effects-hidden');
        el.setAttribute('height', height.toString());
        el.setAttribute('width', width.toString());
        if (addToDom) {
            document.body.appendChild(el);
        }
    }
    return el;
};
const getCanvasEl = (height, width, uniqueId, showInDom) => getOrCreateEl('canvas', height, width, uniqueId, showInDom);
const getVideoEl = (height, width, uniqueId) => getOrCreateEl('video', height, width, uniqueId);

const isIos = () => {
    var _a, _b, _c;
    return Boolean(['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.platform) ||
        (((_c = (_b = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _b === void 0 ? void 0 : _b.userAgent) === null || _c === void 0 ? void 0 : _c.includes('Mac')) && 'ontouchend' in (globalThis === null || globalThis === void 0 ? void 0 : globalThis.document)));
};
const portraitMql = () => { var _a; return (_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.matchMedia) === null || _a === void 0 ? void 0 : _a.call(globalThis, '(orientation: portrait)'); };

const drawImage = (srcEl, destEl) => {
    const { height: sh, width: sw } = srcEl;
    const { height: dh, width: dw } = destEl;
    const ctx = destEl.getContext('2d');
    if (!ctx)
        return;
    ctx.clearRect(0, 0, dw, dh);
    ctx.drawImage(srcEl, 0, 0, sw, sh, 0, 0, dw, dh);
};

const getBackgroundConfig = (backgroundEl, video = false, mirror = false) => ({
    type: 'replacement',
    horizontalMirror: mirror,
    background: backgroundEl,
    static: !video,
});

const loadImageFromUrl = (url) => new Promise((resolve, reject) => {
    const image = new Image();
    image.onload = () => {
        resolve(image);
    };
    image.onerror = (e) => reject(e);
    image.src = url;
    image.crossOrigin = 'anonymous';
});
const loadVideoFromUrl = (url) => new Promise((resolve, reject) => {
    const video = getOrCreateEl('video', 0, 0, undefined, true);
    video.onloadeddata = () => {
        video.height = video.videoHeight;
        video.width = video.videoWidth;
        resolve(video);
    };
    video.onerror = () => reject();
    video.autoplay = true;
    video.playsInline = true;
    video.loop = true;
    video.muted = true;
    video.src = url;
    video.crossOrigin = 'anonymous';
});

exports.VirtualBackgroundMode = void 0;
(function (VirtualBackgroundMode) {
    VirtualBackgroundMode["Blur"] = "BLUR";
    VirtualBackgroundMode["Image"] = "IMAGE";
    VirtualBackgroundMode["Video"] = "VIDEO";
    VirtualBackgroundMode["Passthrough"] = "PASSTHROUGH";
})(exports.VirtualBackgroundMode || (exports.VirtualBackgroundMode = {}));

const defaultOptions = Object.freeze({
    mode: exports.VirtualBackgroundMode.Blur,
    blurStrength: R$1.STRONG,
    generator: 'worker',
    quality: E.LOW,
    authToken: '',
    mirror: false,
    canvasResolutionScaling: 1,
});

const DEFAULT_FRAME_RATE = 24;
const omitAuthToken = (obj) => omitKey('authToken', obj);
class VirtualBackgroundEffect extends BaseCameraEffect {
    constructor(options) {
        super();
        this.defaultOptions = defaultOptions;
        this.uniqueId = Date.now();
        this.lastFrameTime = 0;
        this.frameInterval = 1000 / DEFAULT_FRAME_RATE;
        this.restoreEffectOnTrackEnable = false;
        this.pluginManager = new PluginManager();
        this.beforeInferenceCallbacks = [];
        this.afterInferenceCallbacks = [];
        this.configBuilder = new a();
        this.handleOrientationChange = (mql) => {
            const isPortrait = mql.matches;
            if (!this.trackSettings) {
                throw new Error(`virtual background: unable to determine input track settings`);
            }
            let { height, width } = this.trackSettings;
            if (!height || !width) {
                logger.log(`virtual background: orientation change detected but unknown height or width`, {
                    height,
                    width,
                });
                return;
            }
            logger.log(`virtual background: orientation change detected`, {
                height,
                width,
            });
            if ((isPortrait && height < width) || (!isPortrait && height > width)) {
                [height, width] = [width, height];
            }
            logger.log(`virtual background: orientation changed to ${isPortrait ? 'portrait' : 'landscape'}`, {
                height,
                width,
            });
            [this.videoEl, this.inputEl, this.outputEl, this.backgroundEl].forEach((el) => {
                if (height) {
                    el === null || el === void 0 ? void 0 : el.setAttribute('height', height.toString());
                }
                if (width) {
                    el === null || el === void 0 ? void 0 : el.setAttribute('width', width.toString());
                }
            });
        };
        this.registerPlugin = (name, plugin) => {
            logger.log('virtual background: registering plugin', name, plugin);
            this.pluginManager.register(name, plugin);
        };
        this.initializePlugins = () => {
            logger.log('virtual background: initializing plugins');
            this.pluginManager.initialize(this);
        };
        this.getPlugin = (name) => {
            return this.pluginManager.getPlugin(name);
        };
        this.getPluginManager = () => {
            return this.pluginManager;
        };
        this.options = Object.assign(Object.assign({}, defaultOptions), options);
        logger.log('virtual background: init effect', omitAuthToken(this.options));
        this.loadModel = this.loadModel.bind(this);
        this.handleFrame = this.handleFrame.bind(this);
        this.handleOrientationChange = this.handleOrientationChange.bind(this);
        this.handleVideoLoadedMetadata = this.handleVideoLoadedMetadata.bind(this);
        this.handleVideoResize = this.handleVideoResize.bind(this);
        this.handleAssetUrlResolver = this.handleAssetUrlResolver.bind(this);
        this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
    }
    get isReady() {
        var _a;
        return !!((_a = this.model) === null || _a === void 0 ? void 0 : _a.isLoaded());
    }
    get isLoaded() {
        return !!this.loadFuture;
    }
    get frameRate() {
        var _a, _b, _c;
        return (_c = (_a = this.options.frameRate) !== null && _a !== void 0 ? _a : (_b = this.trackSettings) === null || _b === void 0 ? void 0 : _b.frameRate) !== null && _c !== void 0 ? _c : DEFAULT_FRAME_RATE;
    }
    preloadAssets() {
        return __awaiter(this, void 0, void 0, function* () {
            const start = performance.now();
            if (this.preloadFuture) {
                yield this.preloadFuture.promise;
                return;
            }
            this.preloadFuture = new Future();
            logger.log('virtual background: preloading assets');
            try {
                this.configureBuilder();
                const preloadConfig = this.configBuilder.build(false);
                logger.log('virtual background: preload configuration', preloadConfig);
                yield e(preloadConfig);
                const end = performance.now();
                const duration = Math.round(end - start) / 1000;
                logger.log(`virtual background: preload completed in ${duration} seconds`);
                this.preloadFuture.resolve();
            }
            catch (error) {
                this.preloadFuture.reject(error);
                this.preloadFuture = undefined;
                throw error;
            }
        });
    }
    loadMediaStream(input) {
        const _super = Object.create(null, {
            loadMedia: { get: () => super.loadMedia }
        });
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('virtual background: load stream', input);
            const [videoTrack] = input.getVideoTracks();
            if (!videoTrack) {
                throw new Error('virtual background: load stream failed, no video track found');
            }
            yield _super.loadMedia.call(this, videoTrack, input);
            yield this.loadDomAndModel();
            if (!this.outputStream) {
                throw new Error('virtual background: failed to create output stream');
            }
            logger.log('virtual background: setting new track enabled state', videoTrack.enabled);
            this.outputStream.getVideoTracks()[0].enabled = videoTrack.enabled;
            return this.outputStream;
        });
    }
    loadMediaStreamTrack(input) {
        const _super = Object.create(null, {
            loadMedia: { get: () => super.loadMedia }
        });
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('virtual background: load track', input);
            _super.loadMedia.call(this, input);
            yield this.loadDomAndModel();
            if (!this.outputTrack) {
                throw new Error('virtual background: failed to create output track');
            }
            return this.outputTrack;
        });
    }
    loadDomAndModel() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.inputStream) {
                throw new Error('virtual background: failed to create input stream');
            }
            if (!this.loadFuture) {
                this.loadFuture = new Future();
                yield ((_a = this.disposeFuture) === null || _a === void 0 ? void 0 : _a.promise);
                this.disposeFuture = new Future();
                this.trackSettings = (_b = this.inputTrack) === null || _b === void 0 ? void 0 : _b.getSettings();
                if (!this.trackSettings) {
                    throw new Error('virtual background: unable to determine input track settings');
                }
                this.setupDom(this.trackSettings.height, this.trackSettings.width);
                this.detectQuirks();
                yield this.loadModel();
                if (!this.videoEl) {
                    throw new Error('virtual background: unable to create input video element');
                }
                this.videoEl.srcObject = this.inputStream;
                logger.log(`virtual background: capturing output stream at frameRate = ${this.frameRate}`);
                const effectStream = (_c = this.outputEl) === null || _c === void 0 ? void 0 : _c.captureStream(this.frameRate);
                this.effectTrack = effectStream === null || effectStream === void 0 ? void 0 : effectStream.getVideoTracks()[0];
                this.frameInterval = 1000 / this.frameRate;
                this.requestFrame =
                    document.visibilityState === 'visible'
                        ? this.requestAnimationFrameWrapper
                        : this.setTimeoutWrapper;
                this.setupVisibilityChange();
                try {
                    this.lastFrameTime = performance.now();
                    (_d = this.requestFrame) === null || _d === void 0 ? void 0 : _d.call(this);
                    this.loadFuture.resolve();
                }
                catch (error) {
                    this.loadFuture.reject(error);
                    throw error;
                }
            }
            return this.loadFuture.promise;
        });
    }
    setupVisibilityChange() {
        if (this.options.preventBackgroundThrottling) {
            logger.log('virtual background: adding visibility change listener to prevent throttling');
            document.addEventListener('visibilitychange', this.handleVisibilityChange);
        }
    }
    handleVisibilityChange() {
        this.clearTimers();
        this.requestFrame =
            document.visibilityState === 'visible'
                ? this.requestAnimationFrameWrapper
                : this.setTimeoutWrapper;
        this.requestFrame();
    }
    requestAnimationFrameWrapper() {
        if (this.timerId) {
            cancelAnimationFrame(this.timerId);
        }
        this.timerId = requestAnimationFrame(this.handleFrame);
    }
    setTimeoutWrapper() {
        if (this.timerId) {
            clearTimeout(this.timerId);
        }
        this.timerId = setTimeout$1(this.handleFrame, this.frameInterval);
    }
    clearTimers() {
        if (this.timerId) {
            cancelAnimationFrame(this.timerId);
            clearTimeout(this.timerId);
        }
    }
    configureBuilder() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const env = this.options.env === exports.EffectEnv.Int ? 'int' : 'prod';
        this.configBuilder = new a(env);
        this.configBuilder
            .setMaskQuality(this.options.quality)
            .setMaskGenerator(this.options.generator)
            .setAssetUrlResolver(this.handleAssetUrlResolver);
        if (this.options.baseUrl) {
            this.configBuilder.setBaseUrl(this.options.baseUrl);
        }
        const overrides = this.options.modelOverrides;
        if (overrides) {
            if (((_a = overrides.inputSize) === null || _a === void 0 ? void 0 : _a.height) && ((_b = overrides.inputSize) === null || _b === void 0 ? void 0 : _b.width)) {
                const { height, width } = overrides.inputSize;
                this.configBuilder.setMaskInputSize(height, width);
            }
            if (((_c = overrides.outputSize) === null || _c === void 0 ? void 0 : _c.height) && ((_d = overrides.outputSize) === null || _d === void 0 ? void 0 : _d.width)) {
                const { height, width } = overrides.outputSize;
                this.configBuilder.setMaskOutputSize(height, width);
            }
            if (((_e = overrides.upscaleSize) === null || _e === void 0 ? void 0 : _e.height) && ((_f = overrides.upscaleSize) === null || _f === void 0 ? void 0 : _f.width)) {
                const { height, width } = overrides.upscaleSize;
                this.configBuilder.setMaskUpscaleSize(height, width);
            }
            if (overrides.modelRank) {
                this.configBuilder.setMaskModelRank(overrides.modelRank);
            }
            if (overrides.workerUri) {
                this.configBuilder.setMaskWorkerUri(overrides.workerUri);
            }
            if (overrides.executionProviders) {
                this.configBuilder.setExecutionProviders(overrides.executionProviders);
            }
            if (overrides.modelUri) {
                this.configBuilder.setMaskModelUri(overrides.modelUri);
            }
        }
        if (((_g = this.trackSettings) === null || _g === void 0 ? void 0 : _g.height) && ((_h = this.trackSettings) === null || _h === void 0 ? void 0 : _h.width)) {
            this.configBuilder.setInputSize(this.trackSettings.height, this.trackSettings.width);
        }
        logger.log('virtual background: configuration builder set', this.configBuilder);
    }
    createPipeline(renderConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('virtual background: creating pipeline', renderConfig);
            return new Promise((resolve) => {
                if (!this.outputEl || !this.inputEl) {
                    throw new Error('virtual background: unable to create pipeline');
                }
                this.configureBuilder();
                this.configBuilder.setRenderConfig(renderConfig);
                const pipelineConfig = this.configBuilder.build();
                logger.log('virtual background: pipeline created', pipelineConfig);
                resolve(new k(this.inputEl, this.outputEl, pipelineConfig, this.videoEl));
            });
        });
    }
    loadModel() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            let config;
            logger.log('virtual background: loading model with mode:', this.options.mode);
            switch (this.options.mode) {
                case exports.VirtualBackgroundMode.Blur: {
                    if (!this.options.blurStrength) {
                        throw new Error('virtual background: missing `blurStrength` option');
                    }
                    config = a.getBlurConfig(this.options.blurStrength, this.options.mirror);
                    break;
                }
                case exports.VirtualBackgroundMode.Image: {
                    if (!this.options.bgImageUrl) {
                        throw new Error('virtual background: missing `bgImageUrl` option');
                    }
                    if (!this.backgroundEl) {
                        throw new Error('virtual background: missing hidden background element');
                    }
                    const image = yield loadImageFromUrl(this.options.bgImageUrl);
                    config = getBackgroundConfig(this.backgroundEl, false, this.options.mirror);
                    drawImage(image, this.backgroundEl);
                    break;
                }
                case exports.VirtualBackgroundMode.Video: {
                    if (!this.options.bgVideoUrl) {
                        throw new Error('virtual background: missing `bgVideoUrl` option');
                    }
                    if (!this.backgroundEl) {
                        throw new Error('virtual background: missing hidden background element');
                    }
                    config = getBackgroundConfig(this.backgroundEl, true, this.options.mirror);
                    this.virtualVideoEl = yield loadVideoFromUrl(this.options.bgVideoUrl);
                    break;
                }
                case exports.VirtualBackgroundMode.Passthrough:
                    config = a.getPassthroughConfig(this.options.mirror);
                    break;
                default:
                    throw new Error('virtual background: invalid options supplied to the effect');
            }
            yield ((_a = this.model) === null || _a === void 0 ? void 0 : _a.destroy());
            this.model = yield this.createPipeline(config);
            return (_b = this.model) === null || _b === void 0 ? void 0 : _b.load();
        });
    }
    handleFrame(timestamp = performance.now()) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const elapsedSinceLastFrame = timestamp - this.lastFrameTime;
            const frameTimestamp = Date.now();
            if (elapsedSinceLastFrame < this.frameInterval) {
                (_a = this.requestFrame) === null || _a === void 0 ? void 0 : _a.call(this);
                return;
            }
            this.lastFrameTime += this.frameInterval;
            try {
                if (!this.isReady) {
                    return;
                }
                yield this.manageEffectRestoration();
                if (!this.isEnabled) {
                    return;
                }
                const { canvasToProcess, shouldInfer } = yield this.executeBeforeInferenceCallbacks(frameTimestamp);
                if (canvasToProcess && shouldInfer) {
                    this.prepareInputCanvas(canvasToProcess);
                }
                this.lastFrame = yield ((_b = this.model) === null || _b === void 0 ? void 0 : _b.onFrame(frameTimestamp, shouldInfer));
                yield this.executeAfterInferenceCallbacks(frameTimestamp);
            }
            catch (e) {
                logger.log('virtual background: issue rendering frame', e);
            }
            (_c = this.requestFrame) === null || _c === void 0 ? void 0 : _c.call(this);
        });
    }
    manageEffectRestoration() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            const inputTrackEnabled = ((_a = this.inputTrack) === null || _a === void 0 ? void 0 : _a.enabled) && !((_b = this.inputTrack) === null || _b === void 0 ? void 0 : _b.muted);
            if (this.restoreEffectOnTrackEnable && !inputTrackEnabled) {
                (_c = this.requestFrame) === null || _c === void 0 ? void 0 : _c.call(this);
                return;
            }
            if (this.restoreEffectOnTrackEnable && inputTrackEnabled) {
                logger.log('virtual background: re-enabling effect as the track is now enabled');
                this.restoreEffectOnTrackEnable = false;
                yield this.enable();
                return;
            }
            if (this.isEnabled && !inputTrackEnabled) {
                logger.log('virtual background: input track disabled; disabling effect');
                this.restoreEffectOnTrackEnable = true;
                yield this.disable();
                (_d = this.requestFrame) === null || _d === void 0 ? void 0 : _d.call(this);
            }
        });
    }
    prepareInputCanvas(canvasToProcess) {
        var _a;
        if (!this.videoEl) {
            throw new Error('virtual background: missing hidden video element');
        }
        if (!this.inputEl) {
            throw new Error('virtual background: missing input canvas element');
        }
        if (!this.offscreenCanvas) {
            throw new Error('virtual background: missing offscreen canvas element');
        }
        drawImage(this.videoEl, this.offscreenCanvas);
        if (this.options.mode === exports.VirtualBackgroundMode.Video) {
            if (!this.virtualVideoEl) {
                throw new Error('virtual background: no background video element');
            }
            if (!this.backgroundEl) {
                throw new Error('virtual background: no background element');
            }
            drawImage(this.virtualVideoEl, this.backgroundEl);
        }
        (_a = this.inputCanvasContext) === null || _a === void 0 ? void 0 : _a.drawImage(canvasToProcess, 0, 0, this.inputEl.width, this.inputEl.height);
    }
    executeBeforeInferenceCallbacks(frameTimestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            let canvasToProcess = this.offscreenCanvas;
            let shouldInfer = true;
            if (this.beforeInferenceCallbacks.length) {
                try {
                    yield this.beforeInferenceCallbacks.reduce((prevPromise, cb) => __awaiter(this, void 0, void 0, function* () {
                        yield prevPromise;
                        if (this.lastFrame) {
                            const result = yield cb(frameTimestamp, this.lastFrame, canvasToProcess);
                            shouldInfer && (shouldInfer = result.shouldInfer);
                            canvasToProcess = result.modifiedCanvas || canvasToProcess;
                        }
                    }), Promise.resolve());
                }
                catch (e) {
                    logger.log('virtual background: issue invoking before inference callbacks', e);
                }
            }
            return { canvasToProcess, shouldInfer };
        });
    }
    executeAfterInferenceCallbacks(frameTimestamp) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.afterInferenceCallbacks.forEach((cb) => cb(frameTimestamp, this.lastFrame));
            }
            catch (e) {
                logger.log('virtual background: issue invoking after inference callbacks', e);
            }
        });
    }
    setupDom(height, width) {
        var _a;
        logger.log('virtual background: setting up dom with dimension', { height, width });
        if (!height || !width) {
            throw new Error(`virtual background: missing dimensions: height=${height}, width=${width})`);
        }
        const scaleFactor = (_a = this.options.canvasResolutionScaling) !== null && _a !== void 0 ? _a : 1;
        const scaledHeight = Math.floor(Number(height) * scaleFactor);
        const scaledWidth = Math.floor(Number(width) * scaleFactor);
        this.uniqueId = Date.now();
        this.videoEl = getVideoEl(height, width, this.uniqueId.toString());
        this.inputEl = getCanvasEl(height, width, `input-${this.uniqueId}`);
        this.outputEl = getCanvasEl(height, width, `output-${this.uniqueId}`, true);
        this.backgroundEl = getCanvasEl(height, width, `background-${this.uniqueId}`);
        this.offscreenCanvas = getCanvasEl(scaledHeight, scaledWidth, `offscreen-${this.uniqueId}`);
        this.inputCanvasContext = this.inputEl.getContext('2d', { willReadFrequently: true });
        this.videoEl.setAttribute('autoplay', '');
        this.videoEl.setAttribute('playsinline', '');
        this.videoEl.setAttribute('muted', '');
        this.videoEl.addEventListener('loadedmetadata', this.handleVideoLoadedMetadata);
        this.videoEl.addEventListener('resize', this.handleVideoResize, false);
    }
    detectQuirks() {
        var _a, _b;
        (_a = this.inputEl) === null || _a === void 0 ? void 0 : _a.getContext('2d', { willReadFrequently: true });
        (_b = this.outputEl) === null || _b === void 0 ? void 0 : _b.getContext('webgl2', { antialias: true });
        if (isIos()) {
            const mql = portraitMql();
            this.handleOrientationChange(mql);
            mql === null || mql === void 0 ? void 0 : mql.addEventListener('change', this.handleOrientationChange);
        }
    }
    handleVideoLoadedMetadata() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = this.videoEl) === null || _a === void 0 ? void 0 : _a.play());
        });
    }
    handleVideoResize() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = this.loadFuture) === null || _a === void 0 ? void 0 : _a.promise);
            const oldSettings = this.trackSettings;
            const newSettings = (_b = this.inputTrack) === null || _b === void 0 ? void 0 : _b.getSettings();
            if (((newSettings === null || newSettings === void 0 ? void 0 : newSettings.width) && (oldSettings === null || oldSettings === void 0 ? void 0 : oldSettings.width) && (newSettings === null || newSettings === void 0 ? void 0 : newSettings.width) !== (oldSettings === null || oldSettings === void 0 ? void 0 : oldSettings.width)) ||
                ((newSettings === null || newSettings === void 0 ? void 0 : newSettings.height) && (oldSettings === null || oldSettings === void 0 ? void 0 : oldSettings.height) && (newSettings === null || newSettings === void 0 ? void 0 : newSettings.height) !== (oldSettings === null || oldSettings === void 0 ? void 0 : oldSettings.height))) {
                logger.log('virtual background: video resize detected', { oldSettings, newSettings });
                yield this.updateSize(newSettings.width, newSettings.height);
            }
        });
    }
    handleAssetUrlResolver(assetUri, config) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('virtual background: resolving asset url', assetUri, config);
            if (config.baseUrl) {
                const assetUrl = `${config.baseUrl}/${assetUri}`;
                logger.log('virtual background: using base url override as asset url', assetUrl);
                return assetUrl;
            }
            if (!this.options.authToken) {
                throw new Error('virtual background: missing `authToken` for fetching signed model url');
            }
            return memoizedFetchSignedUrl(assetUri, this.options.authToken, this.options.env);
        });
    }
    enable() {
        const _super = Object.create(null, {
            enable: { get: () => super.enable }
        });
        var _a, _b, _c, _d, _e, _f, _g;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = this.loadFuture) === null || _a === void 0 ? void 0 : _a.state) === FutureState.Rejected) {
                logger.warn('virtual background: model load failed, cannot enable effect');
                return false;
            }
            if (((_b = this.loadFuture) === null || _b === void 0 ? void 0 : _b.state) === FutureState.Pending) {
                yield ((_c = this.loadFuture) === null || _c === void 0 ? void 0 : _c.promise);
            }
            logger.log('virtual background: enabling effect');
            if (this.isReady && this.effectTrack && this.inputTrack) {
                try {
                    yield _super.enable.call(this);
                    (_d = this.model) === null || _d === void 0 ? void 0 : _d.reset();
                    (_e = this.outputStream) === null || _e === void 0 ? void 0 : _e.removeTrack(this.inputTrack);
                    (_f = this.outputStream) === null || _f === void 0 ? void 0 : _f.addTrack(this.effectTrack);
                    (_g = this.requestFrame) === null || _g === void 0 ? void 0 : _g.call(this);
                    return true;
                }
                catch (e) {
                    this.isEnabled = false;
                    throw e;
                }
            }
            return false;
        });
    }
    disable() {
        const _super = Object.create(null, {
            disable: { get: () => super.disable }
        });
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = this.loadFuture) === null || _a === void 0 ? void 0 : _a.state) === FutureState.Rejected) {
                logger.warn('virtual background: model load failed, disabling effect anyway');
            }
            if (((_b = this.loadFuture) === null || _b === void 0 ? void 0 : _b.state) === FutureState.Pending) {
                yield ((_c = this.loadFuture) === null || _c === void 0 ? void 0 : _c.promise);
            }
            logger.log('virtual background: disabling effect');
            if (this.isReady && this.effectTrack && this.inputTrack) {
                try {
                    yield _super.disable.call(this);
                    this.clearTimers();
                    (_d = this.model) === null || _d === void 0 ? void 0 : _d.reset();
                    (_e = this.outputStream) === null || _e === void 0 ? void 0 : _e.removeTrack(this.effectTrack);
                    (_f = this.outputStream) === null || _f === void 0 ? void 0 : _f.addTrack(this.inputTrack);
                    return true;
                }
                catch (e) {
                    this.isEnabled = true;
                    throw e;
                }
            }
            return false;
        });
    }
    dispose() {
        const _super = Object.create(null, {
            dispose: { get: () => super.dispose }
        });
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('virtual background: disposing effect');
            if (((_a = this.loadFuture) === null || _a === void 0 ? void 0 : _a.state) === FutureState.Rejected) {
                logger.warn('virtual background: model load failed, cleaning up resources');
            }
            else if (((_b = this.loadFuture) === null || _b === void 0 ? void 0 : _b.state) === FutureState.Pending) {
                this.loadFuture.reject(new Error('virtual background: loading interrupted by dispose'));
            }
            else if (((_c = this.loadFuture) === null || _c === void 0 ? void 0 : _c.state) === FutureState.Resolved) {
                yield this.loadFuture.promise;
                this.emit(exports.EffectEvent.Disposed);
            }
            yield this.disable();
            yield ((_d = this.model) === null || _d === void 0 ? void 0 : _d.destroy());
            this.getPluginManager().dispose();
            (_e = portraitMql()) === null || _e === void 0 ? void 0 : _e.removeEventListener('change', this.handleOrientationChange);
            (_f = this.videoEl) === null || _f === void 0 ? void 0 : _f.removeEventListener('loadedmetadata', this.handleVideoLoadedMetadata);
            (_g = this.videoEl) === null || _g === void 0 ? void 0 : _g.removeEventListener('resize', this.handleVideoResize);
            document.removeEventListener('visibilitychange', this.handleVisibilityChange);
            (_h = this.inputEl) === null || _h === void 0 ? void 0 : _h.remove();
            (_j = this.outputEl) === null || _j === void 0 ? void 0 : _j.remove();
            (_k = this.videoEl) === null || _k === void 0 ? void 0 : _k.remove();
            (_l = this.backgroundEl) === null || _l === void 0 ? void 0 : _l.remove();
            (_m = this.virtualVideoEl) === null || _m === void 0 ? void 0 : _m.remove();
            delete this.requestFrame;
            delete this.model;
            delete this.inputEl;
            delete this.outputEl;
            delete this.videoEl;
            delete this.backgroundEl;
            delete this.virtualVideoEl;
            try {
                yield _super.dispose.call(this);
                (_o = this.disposeFuture) === null || _o === void 0 ? void 0 : _o.resolve();
            }
            catch (error) {
                (_p = this.disposeFuture) === null || _p === void 0 ? void 0 : _p.reject(error);
                throw error;
            }
            this.loadFuture = undefined;
        });
    }
    addBeforeInferenceCallback(callback) {
        this.beforeInferenceCallbacks.push(callback);
    }
    addAfterInferenceCallback(callback) {
        this.afterInferenceCallbacks.push(callback);
    }
    removeBeforeInferenceCallback(callback) {
        this.beforeInferenceCallbacks = this.beforeInferenceCallbacks.filter((cb) => cb !== callback);
    }
    removeAfterInferenceCallback(callback) {
        this.afterInferenceCallbacks = this.afterInferenceCallbacks.filter((cb) => cb !== callback);
    }
    setOnFrameProcessedCallback(callback) {
        logger.warn('virtual background: deprecated method, use addBeforeInferenceCallback instead');
        this.addAfterInferenceCallback(callback);
    }
    updateOptions(options) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = this.loadFuture) === null || _a === void 0 ? void 0 : _a.state) === FutureState.Pending) {
                try {
                    yield this.loadFuture.promise;
                }
                catch (error) {
                    logger.warn('virtual background: previous loading failed, continuing with update', error);
                }
            }
            Object.keys(options).forEach((key) => {
                var _a;
                this.options[key] = (_a = options[key]) !== null && _a !== void 0 ? _a : this.options[key];
            });
            if (typeof this.options.preventBackgroundThrottling !== 'undefined') {
                document.removeEventListener('visibilitychange', this.handleVisibilityChange);
                this.setupVisibilityChange();
            }
            logger.log('virtual background: reloading effect with options', omitAuthToken(this.options));
            this.loadFuture = new Future();
            try {
                this.configureBuilder();
                yield this.loadModel();
                this.loadFuture.resolve();
                (_b = this.requestFrame) === null || _b === void 0 ? void 0 : _b.call(this);
            }
            catch (error) {
                this.loadFuture.reject(error);
                throw error;
            }
        });
    }
    updateSize(width, height) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (((_a = this.loadFuture) === null || _a === void 0 ? void 0 : _a.state) === FutureState.Pending) {
                try {
                    yield this.loadFuture.promise;
                }
                catch (error) {
                    logger.warn('virtual background: previous loading failed, continuing with size update', error);
                }
            }
            if (this.videoEl) {
                this.videoEl.width = width;
                this.videoEl.height = height;
            }
            if (this.inputEl) {
                this.inputEl.width = width;
                this.inputEl.height = height;
            }
            if (this.outputEl) {
                this.outputEl.width = width;
                this.outputEl.height = height;
            }
            if (this.backgroundEl) {
                this.backgroundEl.width = width;
                this.backgroundEl.height = height;
            }
            if (this.trackSettings) {
                this.trackSettings.width = width;
                this.trackSettings.height = height;
            }
            logger.log('virtual background: updating size', { width, height });
            this.loadFuture = new Future();
            try {
                yield this.loadModel();
                this.loadFuture.resolve();
                (_b = this.requestFrame) === null || _b === void 0 ? void 0 : _b.call(this);
            }
            catch (error) {
                this.loadFuture.reject(error);
                throw error;
            }
        });
    }
}
VirtualBackgroundEffect.kind = 'virtual-background-effect';
VirtualBackgroundEffect.BlurStrength = R$1;
VirtualBackgroundEffect.Quality = E;
const createVirtualBackgroundEffect = (options, preloadAssets) => createEffect(VirtualBackgroundEffect, options, preloadAssets);

exports.AdaptiveFrameSkipper = AdaptiveFrameSkipper;
exports.BaseCameraEffect = BaseCameraEffect;
exports.BaseEffect = BaseEffect;
exports.BaseMicrophoneEffect = BaseMicrophoneEffect;
exports.BeRightBack = BeRightBack;
exports.BeRightBackPlugin = BeRightBackPlugin;
exports.BlurStrength = R$1;
exports.DEFAULT_FRAME_RATE = DEFAULT_FRAME_RATE;
exports.FrameSkipperPlugin = FrameSkipperPlugin;
exports.GainEffect = GainEffect;
exports.Logger = Logger;
exports.NoiseReductionEffect = NoiseReductionEffect;
exports.Quality = E;
exports.RateEstimationPlugin = RateEstimationPlugin;
exports.RateEstimator = RateEstimator;
exports.SkippedFrameRatePlugin = SkippedFrameRatePlugin;
exports.VirtualBackgroundEffect = VirtualBackgroundEffect;
exports.createEffect = createEffect;
exports.createNoiseReductionEffect = createNoiseReductionEffect;
exports.createVirtualBackgroundEffect = createVirtualBackgroundEffect;
exports.getOptionsByMode = getOptionsByMode;
exports.logger = logger;
exports.makeBeRightBackOptions = makeBeRightBackOptions;
exports.makeFrameSkipperOptions = makeFrameSkipperOptions;
//# sourceMappingURL=index.js.map
