export var InterpolationMethod;
(function (InterpolationMethod) {
    InterpolationMethod["Nearest"] = "nearest";
})(InterpolationMethod || (InterpolationMethod = {}));
/**
 * Resizes an image from the source dimensions to target dimensions.
 *
 * @param {Uint8ClampedArray} imageData The source image data in Uint8ClampedArray format.
 * @param {number} srcWidth The width of the source image.
 * @param {number} srcHeight The height of the source image.
 * @param {number} targetWidth The width of the target image.
 * @param {number} targetHeight The height of the target image.
 *
 * @returns {Uint8ClampedArray} The target image data in Uint8ClampedArray format.
 *
 * @example
 * const targetData = resizeImage(sourceData, 800, 600, 400, 300);
 *
 * @note The function uses a "nearest neighbor" algorithm for resizing,
 * which is fast but might not provide the best quality for all images.
 */
export const resizeImage = (imageData, srcWidth, srcHeight, targetWidth, targetHeight) => {
    const targetData = new Uint8ClampedArray(targetWidth * targetHeight * 4);
    const xRatio = srcWidth / targetWidth;
    const yRatio = srcHeight / targetHeight;
    const scaledSrcWidth = srcWidth * 4;
    let offset = 0;
    for (let y = 0; y < targetHeight; y++) {
        const srcY = Math.floor(y * yRatio) * scaledSrcWidth;
        for (let x = 0; x < targetWidth; x++) {
            const srcOffset = srcY + Math.floor(x * xRatio) * 4;
            targetData[offset++] = imageData[srcOffset];
            targetData[offset++] = imageData[srcOffset + 1];
            targetData[offset++] = imageData[srcOffset + 2];
            targetData[offset++] = imageData[srcOffset + 3];
        }
    }
    return targetData;
};
/**
 * Upsamples an image using the bilinear interpolation method. The input image is expected to be in
 * Float32Array format. The output image is in Uint8ClampedArray format. The input image is expected
 * to be in the [0, 1] range. The output image is in the [0, 255] range.
 *
 * @param {Float32Array} input The input image data in Float32Array format.
 * @param {number} srcWidth The width of the source image.
 * @param {number} srcHeight The height of the source image.
 * @param {number} targetWidth The width of the target image.
 * @param {number} targetHeight The height of the target image.
 *
 * @returns {Uint8ClampedArray} The upsampled image data in Uint8ClampedArray format.
 *
 */
export function bilinearUpsample(input, srcWidth, srcHeight, targetWidth, targetHeight) {
    const output = new Uint8ClampedArray(targetWidth * targetHeight);
    // If the source and target dimensions are the same, just copy the input to the output.
    // The output is expected to be in the [0, 255] range
    if (srcWidth === targetWidth && srcHeight === targetHeight) {
        for (let i = 0; i < input.length; i++) {
            output[i] = Math.min(Math.max(input[i], 0), 255);
        }
        return output;
    }
    const xRatio = (srcWidth - 1) / (targetWidth - 1);
    const yRatio = (srcHeight - 1) / (targetHeight - 1);
    for (let i = 0; i < targetHeight; i++) {
        for (let j = 0; j < targetWidth; j++) {
            const x = xRatio * j;
            const y = yRatio * i;
            const xL = Math.floor(x);
            const yL = Math.floor(y);
            const xH = Math.min(Math.ceil(x), srcWidth - 1);
            const yH = Math.min(Math.ceil(y), srcHeight - 1);
            const xWeight = x - xL;
            const yWeight = y - yL;
            const a = input[yL * srcWidth + xL];
            const b = input[yL * srcWidth + xH];
            const c = input[yH * srcWidth + xL];
            const d = input[yH * srcWidth + xH];
            const value = a * (1 - xWeight) * (1 - yWeight) +
                b * xWeight * (1 - yWeight) +
                c * (1 - xWeight) * yWeight +
                d * xWeight * yWeight;
            output[i * targetWidth + j] = Math.min(Math.max(value, 0), 255);
        }
    }
    return output;
}
/**
 * Upsamples an image using the Lanczos3 interpolation method. The input image is expected to be in
 * Float32Array format. The output image is in Uint8ClampedArray format. The input image is expected
 * to be in the [0, 1] range. The output image is in the [0, 255] range.
 *
 * @param {Float32Array} input The input image data in Float32Array format.
 * @param {number} srcWidth The width of the source image.
 * @param {number} srcHeight The height of the source image.
 * @param {number} targetWidth The width of the target image.
 * @param {number} targetHeight The height of the target image.
 *
 * @returns {Uint8ClampedArray} The upsampled image data in Uint8ClampedArray format.
 */
export function lanczos3Upsample(input, srcWidth, srcHeight, targetWidth, targetHeight) {
    const output = new Uint8ClampedArray(targetWidth * targetHeight);
    const xRatio = srcWidth / targetWidth;
    const yRatio = srcHeight / targetHeight;
    const lanczos = (x, a) => {
        if (x === 0)
            return 1;
        if (x < 0)
            x = -x;
        if (x < a) {
            const piX = Math.PI * x;
            return (a * Math.sin(piX) * Math.sin(piX / a)) / (piX * piX);
        }
        return 0;
    };
    const a = 3; // Lanczos parameter
    for (let i = 0; i < targetHeight; i++) {
        for (let j = 0; j < targetWidth; j++) {
            const x = j * xRatio;
            const y = i * yRatio;
            const xL = Math.floor(x);
            const yL = Math.floor(y);
            let value = 0;
            let weightSum = 0;
            for (let ky = yL - a + 1; ky <= yL + a; ky++) {
                for (let kx = xL - a + 1; kx <= xL + a; kx++) {
                    if (kx >= 0 && kx < srcWidth && ky >= 0 && ky < srcHeight) {
                        const pixel = input[ky * srcWidth + kx];
                        const weight = lanczos(x - kx, a) * lanczos(y - ky, a);
                        value += pixel * weight;
                        weightSum += weight;
                    }
                }
            }
            output[i * targetWidth + j] = weightSum !== 0 ? Math.round(value / weightSum) : 0;
        }
    }
    return output;
}
export const toAbsoluteURI = (relativeURL, baseURL) => {
    // adapted from - https://github.com/axios/axios/blob/fe7d09bb08fa1c0e414956b7fc760c80459b0a43/lib/helpers/combineURLs.js
    if (!baseURL || relativeURL.startsWith('http')) {
        return new URL(relativeURL).href;
    }
    return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
};
export function compileShader(gl, shader_type, source) {
    var _a;
    const shader = gl.createShader(shader_type);
    if (!shader) {
        throw new Error('[ladon-ts] - error creating shader');
    }
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const error = (_a = gl.getShaderInfoLog(shader)) !== null && _a !== void 0 ? _a : 'unknown error compiling shader.';
        throw new Error('[ladon-ts] - ' + error);
    }
    return shader;
}
export function linkProgram(gl, vertex_shader, fragment_shader) {
    var _a;
    const program = gl.createProgram();
    if (!program) {
        throw new Error('[ladon-ts] - error creating GPU program');
    }
    gl.attachShader(program, vertex_shader);
    gl.attachShader(program, fragment_shader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        const error = (_a = gl.getProgramInfoLog(program)) !== null && _a !== void 0 ? _a : 'unknown error linking program.';
        throw new Error('[ladon-ts] - ' + error);
    }
    return program;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9saWIvdXRpbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxNQUFNLENBQU4sSUFBWSxtQkFFWDtBQUZELFdBQVksbUJBQW1CO0lBQzNCLDBDQUFtQixDQUFBO0FBQ3ZCLENBQUMsRUFGVyxtQkFBbUIsS0FBbkIsbUJBQW1CLFFBRTlCO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSCxNQUFNLENBQUMsTUFBTSxXQUFXLEdBQUcsQ0FDdkIsU0FBNEIsRUFDNUIsUUFBZ0IsRUFDaEIsU0FBaUIsRUFDakIsV0FBbUIsRUFDbkIsWUFBb0IsRUFDSCxFQUFFO0lBQ25CLE1BQU0sVUFBVSxHQUFHLElBQUksaUJBQWlCLENBQUMsV0FBVyxHQUFHLFlBQVksR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN6RSxNQUFNLE1BQU0sR0FBRyxRQUFRLEdBQUcsV0FBVyxDQUFDO0lBQ3RDLE1BQU0sTUFBTSxHQUFHLFNBQVMsR0FBRyxZQUFZLENBQUM7SUFDeEMsTUFBTSxjQUFjLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNwQyxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFFZixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxFQUFFLENBQUMsRUFBRSxFQUFFO1FBQ25DLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLGNBQWMsQ0FBQztRQUNyRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2xDLE1BQU0sU0FBUyxHQUFHLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFFcEQsVUFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDLEdB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