var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as ort from 'onnxruntime-web';
import { toAbsoluteURI } from './util';
/**
 * Shared resource manager used to preload and share resources across different pipelines.
 * This is useful when multiple pipelines are using the same model or when the model needs
 * to be preloaded before the pipeline is created.
 */
class SharedResourceManager {
    constructor() {
        this.modelSessions = {};
    }
    /**
     * Initialize the worker using the provided configuration.
     *
     * @param {PreloadConfig} config The configuration object.
     * @returns {Promise<Worker>} A promise that resolves when the worker is initialized.
     * @example
     * await initializeWorker(config);
     */
    initializeWorker(config) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof Worker === 'undefined') {
                throw new Error('[ladon-ts] web workers are not supported in this environment');
            }
            const crossOriginScriptUrl = config.mask.worker_uri;
            const content = yield (yield fetch(crossOriginScriptUrl, { cache: 'force-cache' })).text();
            this.workerUrl = URL.createObjectURL(new Blob([content], { type: 'text/javascript' }));
            this.worker = new Worker(this.workerUrl, { type: 'module' });
            return this.worker;
        });
    }
    /**
     * Terminate the worker.
     */
    terminateWorker() {
        if (this.worker) {
            this.worker.terminate();
            this.worker = undefined;
        }
    }
    /**
     * Preload the model using the provided configuration.
     *
     * @param {PreloadConfig} config The configuration object.
     * @returns {Promise<void>} A promise that resolves when the model is preloaded.
     * @example
     * await preloadModel(config);
     */
    preloadModel(config) {
        var _a;
        var _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (config.wasm_uri) {
                ort.env.wasm.wasmPaths = toAbsoluteURI(config.wasm_uri, config.base_url);
            }
            ort.env.wasm.numThreads = 0;
            // Resolve the model URL based on the configuration.
            const modelUrl = yield this.getModelUrl(config);
            // Use the model session cache to avoid creating multiple sessions for the same model.
            (_a = (_b = this.modelSessions)[modelUrl]) !== null && _a !== void 0 ? _a : (_b[modelUrl] = yield ort.InferenceSession.create(modelUrl, {
                executionProviders: ['wasm'],
            }));
            // Warmup the model with a dummy input to avoid latency when running the model for the first time.
            yield this.warmupModel(this.modelSessions[modelUrl], config.mask.input_size, config.mask.model_rank);
            return this.modelSessions[modelUrl];
        });
    }
    /**
     * Preload the worker using the provided configuration.
     *
     * @param {PreloadConfig} config The configuration object.
     * @returns {Promise<void>} A promise that resolves when the worker is preloaded.
     * @example
     * await preloadWorker(config);
     */
    preloadWorker(config) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            // If the model URL resolver is a function, We can't send the function to the worker so
            // we resolve the model URL here and send the resolved URL to the worker.
            const modelUrl = yield this.getModelUrl(config);
            const newConfig = Object.assign(Object.assign({}, config), { mask: Object.assign(Object.assign({}, config.mask), { model_url_resolver: modelUrl }) });
            // Initialize the worker.
            yield this.initializeWorker(newConfig);
            // Send the preload message to the worker.
            (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage({ type: 'preload', config: newConfig });
        });
    }
    /**
     * Warmup the model session with a dummy input to avoid latency when running the model for the first time.
     *
     * @param {ort.InferenceSession} session The model session.
     * @param {SizeConfig} inputSize The input size of the model.
     * @param {number} inputChannels The number of input channels (e.g., RGB is 3).
     * @param {ort.Tensor.Type} inputType The input tensor type.
     * @returns {Promise<void>} A promise that resolves when the model is warmed up.
     * @example
     * await warmupModel(session, inputSize, inputChannels, inputType);
     */
    warmupModel(session, inputSize = { width: 1280, height: 720 }, inputChannels = 3, inputType = 'float32') {
        return __awaiter(this, void 0, void 0, function* () {
            const numPixels = inputSize.height * inputSize.width;
            const dummyInputData = new Float32Array(inputChannels * numPixels).fill(0);
            const dummyInput = new ort.Tensor(inputType, dummyInputData, [
                1,
                inputChannels,
                inputSize.height,
                inputSize.width,
            ]);
            const feed = { [session.inputNames[0]]: dummyInput };
            // Use an additional dummy tensor if the model expects a previous mask.
            if (inputChannels === 3) {
                const dummyMaskData = new Float32Array(numPixels).fill(0);
                const prevMaskTensor = new ort.Tensor(inputType, dummyMaskData, [
                    1,
                    1,
                    inputSize.height,
                    inputSize.width,
                ]);
                feed[session.inputNames[1]] = prevMaskTensor;
            }
            // Run the model with the dummy input to warm it up.
            yield session.run(feed);
        });
    }
    /**
     * Get the model session for the provided model URL.
     *
     * @param {string} modelUrl The model URL.
     * @returns {ort.InferenceSession} The model session.
     * @example
     * const session = getModelSession(modelUrl);
     */
    getModelSession(modelUrl) {
        return this.modelSessions[modelUrl];
    }
    /**
     * Resolves the model URL based on the configuration.
     *
     * @param {PipelineConfig} config The configuration object.
     * @returns {Promise<string>} The resolved model URL.
     * @example
     * const modelUrl = await getModelUrl(config);
     */
    getModelUrl({ mask: { model_url_resolver, model_uri } }) {
        return __awaiter(this, void 0, void 0, function* () {
            let modelUrl;
            if (typeof model_url_resolver === 'string') {
                modelUrl = model_url_resolver;
            }
            else {
                modelUrl = yield model_url_resolver(model_uri);
            }
            return modelUrl;
        });
    }
    getWorker() {
        return this.worker;
    }
    getWorkerUrl() {
        return this.workerUrl;
    }
}
// Global instance of the shared resource manager.
export const sharedResourceManager = new SharedResourceManager();
/**
 * Preload the resources using the provided configuration. This function is used to preload the model
 * and the worker before creating the pipeline.
 *
 * @param config - The configuration object.
 */
export const preload = (config) => __awaiter(void 0, void 0, void 0, function* () {
    if (config.mask.generator === 'worker') {
        yield sharedResourceManager.preloadWorker(config);
    }
    else {
        yield sharedResourceManager.preloadModel(config);
    }
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2hhcmVkLXJlc291cmNlLW1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvbGliL3NoYXJlZC1yZXNvdXJjZS1tYW5hZ2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLE9BQU8sS0FBSyxHQUFHLE1BQU0saUJBQWlCLENBQUM7QUFHdkMsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLFFBQVEsQ0FBQztBQUV2Qzs7OztHQUlHO0FBQ0gsTUFBTSxxQkFBcUI7SUFBM0I7UUFDWSxrQkFBYSxHQUF5QyxFQUFFLENBQUM7SUE0S3JFLENBQUM7SUF4S0c7Ozs7Ozs7T0FPRztJQUNHLGdCQUFnQixDQUFDLE1BQXFCOztZQUN4QyxJQUFJLE9BQU8sTUFBTSxLQUFLLFdBQVcsRUFBRTtnQkFDL0IsTUFBTSxJQUFJLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO2FBQ25GO1lBRUQsTUFBTSxvQkFBb0IsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUNwRCxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsb0JBQW9CLEVBQUUsRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1lBRTNGLElBQUksQ0FBQyxTQUFTLEdBQUcsR0FBRyxDQUFDLGVBQWUsQ0FBQyxJQUFJLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUUsSUFBSSxFQUFFLGlCQUFpQixFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ3ZGLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsRUFBRSxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO1lBRTdELE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUN2QixDQUFDO0tBQUE7SUFFRDs7T0FFRztJQUNILGVBQWU7UUFDWCxJQUFJLElB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