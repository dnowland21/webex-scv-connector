import { TypedEvent, WithEventsDummyType } from '@webex/ts-events';
import { BaseEffect } from '@webex/web-media-effects';
import { Stream } from './stream';
export type TrackEffect = BaseEffect;
export declare enum LocalStreamEventNames {
    UserMuteStateChange = "user-mute-state-change",
    SystemMuteStateChange = "system-mute-state-change",
    ConstraintsChange = "constraints-change",
    OutputTrackChange = "output-track-change",
    EffectAdded = "effect-added"
}
interface LocalStreamEvents {
    [LocalStreamEventNames.UserMuteStateChange]: TypedEvent<(muted: boolean) => void>;
    [LocalStreamEventNames.SystemMuteStateChange]: TypedEvent<(muted: boolean) => void>;
    [LocalStreamEventNames.ConstraintsChange]: TypedEvent<() => void>;
    [LocalStreamEventNames.OutputTrackChange]: TypedEvent<(track: MediaStreamTrack) => void>;
    [LocalStreamEventNames.EffectAdded]: TypedEvent<(effect: TrackEffect) => void>;
}
/**
 * A stream which originates on the local device.
 */
declare abstract class _LocalStream extends Stream {
    [LocalStreamEventNames.UserMuteStateChange]: TypedEvent<(muted: boolean) => void>;
    [LocalStreamEventNames.SystemMuteStateChange]: TypedEvent<(muted: boolean) => void>;
    [LocalStreamEventNames.ConstraintsChange]: TypedEvent<() => void>;
    [LocalStreamEventNames.OutputTrackChange]: TypedEvent<(track: MediaStreamTrack) => void>;
    [LocalStreamEventNames.EffectAdded]: TypedEvent<(effect: TrackEffect) => void>;
    private effects;
    private loadingEffects;
    protected inputStream: MediaStream;
    /**
     * Create a LocalStream from the given values.
     *
     * @param stream - The initial output MediaStream for this Stream.
     */
    constructor(stream: MediaStream);
    /**
     * Handler which is called when a track's mute event fires.
     */
    private handleTrackMutedBySystem;
    /**
     * Handler which is called when a track's unmute event fires.
     */
    private handleTrackUnmutedBySystem;
    /**
     * Helper function to add event handlers to a MediaStreamTrack. See
     * {@link Stream.addTrackHandlersForStreamEvents} for why this is useful.
     *
     * @param track - The MediaStreamTrack.
     */
    private addTrackHandlersForLocalStreamEvents;
    /**
     * @inheritdoc
     */
    protected addTrackHandlers(track: MediaStreamTrack): void;
    /**
     * @inheritdoc
     */
    protected removeTrackHandlers(track: MediaStreamTrack): void;
    /**
     * Get the track within the MediaStream with which this LocalStream was created.
     *
     * @returns The track within the MediaStream with which this LocalStream
     * was created.
     */
    protected get inputTrack(): MediaStreamTrack;
    /**
     * Check whether or not this stream is muted. This considers both whether the stream has been
     * muted by the user (see {@link userMuted}) and whether the stream has been muted by the system
     * (see {@link systemMuted}).
     *
     * @returns True if the stream is muted, false otherwise.
     */
    get muted(): boolean;
    /**
     * Check whether or not this stream has been muted by the user. This is equivalent to checking the
     * MediaStreamTrack "enabled" state.
     *
     * @returns True if the stream has been muted by the user, false otherwise.
     */
    get userMuted(): boolean;
    /**
     * Check whether or not this stream has been muted by the user. This is equivalent to checking the
     * MediaStreamTrack "muted" state.
     *
     * @returns True if the stream has been muted by the system, false otherwise.
     */
    get systemMuted(): boolean;
    /**
     * Set the user mute state of this stream.
     *
     * Note: This sets the user-toggled mute state, equivalent to changing the "enabled" state of the
     * track. It is separate from the system-toggled mute state.
     *
     * @param isMuted - True to mute, false to unmute.
     */
    setUserMuted(isMuted: boolean): void;
    /**
     * @inheritdoc
     */
    getSettings(): MediaTrackSettings;
    /**
     * Get the label of the input track on this stream.
     *
     * @returns The label of the track.
     */
    get label(): string;
    /**
     * Get the readyState of the input track on this stream.
     *
     * @returns The readyState of the track.
     */
    get readyState(): string;
    /**
     * Change the track of the output stream to a different track.
     *
     * Note: this method assumes and enforces that if both input and output streams have the same
     * track, then they must also be the same stream.
     *
     * @param newTrack - The track to be used in the output stream.
     */
    private changeOutputTrack;
    /**
     * @inheritdoc
     */
    stop(): void;
    /**
     * Adds an effect to a local stream.
     *
     * @param effect - The effect to add.
     */
    addEffect(effect: TrackEffect): Promise<void>;
    /**
     * Get an effect from the effects list by ID.
     *
     * @param id - The id of the effect you want to get.
     * @returns The effect or undefined.
     */
    getEffectById(id: string): TrackEffect | undefined;
    /**
     * Get an effect from the effects list by kind.
     *
     * @param kind - The kind of the effect you want to get.
     * @returns The effect or undefined.
     */
    getEffectByKind(kind: string): TrackEffect | undefined;
    /**
     * Get all the effects from the effects list.
     *
     * @returns A list of effects.
     */
    getEffects(): TrackEffect[];
    /**
     * Method to serialize data about input, output streams
     * and also effects from LocalStream.
     *
     * @returns - A JSON-compatible object representation with data from LocalStream.
     */
    toJSON(): {
        muted: boolean;
        label: string;
        readyState: string;
        inputStream: {
            active: boolean;
            id: string;
            enabled: boolean;
            muted: boolean;
        };
        outputStream: {
            active: boolean;
            id: string;
        };
        effects: {
            id: string;
            kind: string;
            isEnabled: boolean;
        }[];
    };
    /**
     * Cleanup the local effects.
     */
    disposeEffects(): Promise<void>;
}
export declare const LocalStream: (new (...args: any[]) => {
    on<K extends keyof LocalStreamEvents, E extends LocalStreamEvents[K] extends infer T ? T extends LocalStreamEvents[K] ? T extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K, handler: E): void;
    once<K_1 extends keyof LocalStreamEvents, E_1 extends LocalStreamEvents[K_1] extends infer T ? T extends LocalStreamEvents[K_1] ? T extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K_1, handler: E_1): void;
    off<K_2 extends keyof LocalStreamEvents, E_2 extends LocalStreamEvents[K_2] extends infer T ? T extends LocalStreamEvents[K_2] ? T extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K_2, handler: E_2): void;
}) & typeof _LocalStream;
export type LocalStream = _LocalStream & WithEventsDummyType<LocalStreamEvents>;
export {};
//# sourceMappingURL=local-stream.d.ts.map