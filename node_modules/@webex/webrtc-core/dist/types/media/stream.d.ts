import { TypedEvent, WithEventsDummyType } from '@webex/ts-events';
export declare enum StreamEventNames {
    Ended = "stream-ended"
}
interface StreamEvents {
    [StreamEventNames.Ended]: TypedEvent<() => void>;
}
/**
 * Base stream class.
 */
declare abstract class _Stream {
    readonly outputStream: MediaStream;
    [StreamEventNames.Ended]: TypedEvent<() => void>;
    /**
     * Create a Stream from the given values.
     *
     * @param stream - The initial output MediaStream for this Stream.
     */
    constructor(stream: MediaStream);
    /**
     * Handler which is called when a track's ended event fires.
     */
    private handleTrackEnded;
    /**
     * Helper function to add event handlers to a MediaStreamTrack. Unlike the virtual
     * {@link addTrackHandlers} function, which can be overridden, this function is internal to this
     * class and will only add the event handlers relevant to this class. It prevents, for example,
     * accidentally adding the same event handlers multiple times, which could happen if the virtual
     * `addTrackHandlers` method was called from a subclass's constructor.
     *
     * @param track - The MediaStreamTrack.
     */
    private addTrackHandlersForStreamEvents;
    /**
     * Add event handlers to a MediaStreamTrack.
     *
     * @param track - The MediaStreamTrack.
     */
    protected addTrackHandlers(track: MediaStreamTrack): void;
    /**
     * Remove event handlers from a MediaStreamTrack.
     *
     * @param track - The MediaStreamTrack.
     */
    protected removeTrackHandlers(track: MediaStreamTrack): void;
    /**
     * Get the ID of the output stream.
     *
     * @returns The ID of the output stream.
     */
    get id(): string;
    /**
     * Get the track of the output stream.
     *
     * @returns The output track.
     */
    protected get outputTrack(): MediaStreamTrack;
    /**
     * Get the settings of this stream.
     *
     * @returns The settings.
     */
    abstract getSettings(): MediaTrackSettings;
    /**
     * Stop this stream.
     */
    abstract stop(): void;
}
export declare const Stream: (new (...args: any[]) => {
    on<K extends StreamEventNames.Ended, E extends StreamEvents[K] extends infer T ? T extends StreamEvents[K] ? T extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K, handler: E): void;
    once<K_1 extends StreamEventNames.Ended, E_1 extends StreamEvents[K_1] extends infer T ? T extends StreamEvents[K_1] ? T extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K_1, handler: E_1): void;
    off<K_2 extends StreamEventNames.Ended, E_2 extends StreamEvents[K_2] extends infer T ? T extends StreamEvents[K_2] ? T extends TypedEvent<infer X extends (...args: any[]) => void> ? X : never : never : never>(eventName: K_2, handler: E_2): void;
}) & typeof _Stream;
export type Stream = _Stream & WithEventsDummyType<StreamEvents>;
export {};
//# sourceMappingURL=stream.d.ts.map