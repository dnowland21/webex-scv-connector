"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _webexCore = require("@webex/webex-core");
/*!
 * Copyright (c) 2015-2023 Cisco Systems, Inc. See LICENSE file.
 */

var STATE = {
  INITIAL: 'initial',
  IN_PROGRESS: 'in-progress',
  IDLE: 'idle'
};

/**
 * @class
 */
var IpNetworkDetector = _webexCore.WebexPlugin.extend({
  idAttribute: 'IpNetworkDetectorId',
  namespace: 'Device',
  props: {
    firstIpV4: ['number', true, -1],
    // time [ms] it took to receive first IPv4 candidate
    firstIpV6: ['number', true, -1],
    // time [ms] it took to receive first IPv6 candidate
    firstMdns: ['number', true, -1],
    // time [ms] it took to receive first mDNS candidate
    totalTime: ['number', true, -1],
    // total time [ms] it took to do the last IP network detection
    state: ['string', true, STATE.INITIAL],
    pendingDetection: ['object', false, undefined]
  },
  derived: {
    /**
     * True if we know we're on an IPv4 network,
     * False if we know that we are not on an IPv4 network,
     * undefined if we are not sure
     */
    supportsIpV4: {
      deps: ['firstIpV4', 'firstIpV6', 'firstMdns', 'totalTime'],
      /**
       * Function for calculating the value of supportsIpV4 prop
       * @returns {boolean | undefined}
       */
      fn: function fn() {
        if (this.firstIpV4 >= 0) {
          return true;
        }
        if (this.totalTime < 0) {
          // we haven't completed the detection, yet
          return undefined;
        }
        if (this.receivedOnlyMDnsCandidates()) {
          return undefined;
        }
        return false;
      }
    },
    /**
     * True if we know we're on an IPv6 network,
     * False if we know that we are not on an IPv6 network,
     * undefined if we are not sure
     */
    supportsIpV6: {
      deps: ['firstIpV4', 'firstIpV6', 'firstMdns', 'totalTime'],
      /**
       * Function for calculating the value of supportsIpV6 prop
       * @returns {boolean | undefined}
       */
      fn: function fn() {
        if (this.firstIpV6 >= 0) {
          return true;
        }
        if (this.totalTime < 0) {
          // we haven't completed the detection, yet
          return undefined;
        }
        if (this.receivedOnlyMDnsCandidates()) {
          return undefined;
        }
        return false;
      }
    }
  },
  /**
   * Returns true if we have received only mDNS candidates - browsers usually do that if we don't have any user media permissions
   *
   * @private
   * @returns {boolean}
   */
  receivedOnlyMDnsCandidates: function receivedOnlyMDnsCandidates() {
    return this.totalTime >= 0 && this.firstMdns >= 0 && this.firstIpV4 < 0 && this.firstIpV6 < 0;
  },
  /**
   *
   * @param {RTCPeerConnection} pc Peer connection to use
   * @private
   * @returns {Promise<void>}
   */
  gatherLocalCandidates: function gatherLocalCandidates(pc) {
    var _this = this;
    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            return _context.abrupt("return", new _promise.default(function (resolve, reject) {
              var done = false;
              _this.firstIpV4 = -1;
              _this.firstIpV6 = -1;
              _this.firstMdns = -1;
              _this.totalTime = -1;
              var startTime = performance.now();
              var doneGatheringIceCandidates = function doneGatheringIceCandidates() {
                if (done) {
                  return;
                }
                done = true;
                _this.totalTime = performance.now() - startTime;
                resolve();
              };
              pc.onicecandidate = function (event) {
                var _event$candidate;
                if ((_event$candidate = event.candidate) !== null && _event$candidate !== void 0 && _event$candidate.address) {
                  if (event.candidate.address.endsWith('.local')) {
                    // if we don't have camera/mic permissions, browser just gives us mDNS candidates
                    if (_this.firstMdns === -1) {
                      _this.firstMdns = performance.now() - startTime;
                    }
                  } else if (event.candidate.address.includes(':')) {
                    if (_this.firstIpV6 === -1) {
                      _this.firstIpV6 = performance.now() - startTime;
                    }
                  } else if (_this.firstIpV4 === -1) {
                    _this.firstIpV4 = performance.now() - startTime;
                  }
                  if (_this.firstIpV4 >= 0 && _this.firstIpV6 >= 0) {
                    // if we've got both ipv4 and ipv6 candidates, there is no need to wait for any more candidates, we can resolve now
                    resolve();
                  }
                } else if (event.candidate === null) {
                  doneGatheringIceCandidates();
                }
              };
              pc.onicegatheringstatechange = function () {
                if (pc.iceGatheringState === 'complete') {
                  doneGatheringIceCandidates();
                }
              };
              pc.createDataChannel('data');
              pc.createOffer().then(function (offer) {
                return pc.setLocalDescription(offer);
              }).catch(function (e) {
                _this.webex.logger.error('Failed to detect ip network version:', e);
                reject(e);
              });
            }));
          case 1:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }))();
  },
  /**
   * Detects if we are on IPv4 and/or IPv6 network. Once it resolves, read the
   * supportsIpV4 and supportsIpV6 props to find out the result.
   *
   * @param {boolean} force - if false, the detection will only be done if we haven't managed to get any meaningful results yet
   * @returns {Promise<void>}
   */
  detect: function detect() {
    var _arguments = arguments,
      _this2 = this;
    return (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
      var force, results, pc, forceParam;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            force = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : false;
            if (!(_this2.state === STATE.IN_PROGRESS)) {
              _context2.next = 4;
              break;
            }
            _this2.pendingDetection = {
              force: force
            };
            return _context2.abrupt("return");
          case 4:
            if (!(!force && _this2.state !== STATE.INITIAL && !_this2.receivedOnlyMDnsCandidates())) {
              _context2.next = 6;
              break;
            }
            return _context2.abrupt("return");
          case 6:
            _context2.prev = 6;
            _this2.state = STATE.IN_PROGRESS;
            pc = new RTCPeerConnection();
            _context2.next = 11;
            return _this2.gatherLocalCandidates(pc);
          case 11:
            results = _context2.sent;
          case 12:
            _context2.prev = 12;
            pc.close();
            _this2.state = STATE.IDLE;
            return _context2.finish(12);
          case 16:
            if (_this2.pendingDetection) {
              forceParam = _this2.pendingDetection.force;
              _this2.pendingDetection = undefined;
              _this2.detect(forceParam);
            }
          case 17:
          case "end":
            return _context2.stop();
        }
      }, _callee2, null, [[6,, 12, 16]]);
    }))();
  },
  version: "3.8.1"
});
var _default = exports.default = IpNetworkDetector;
//# sourceMappingURL=ipNetworkDetector.js.map
