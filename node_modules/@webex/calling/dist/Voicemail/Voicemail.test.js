"use strict";

var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _testUtil = require("../common/testUtil");
var _Voicemail = require("./Voicemail");
var _types = require("../Logger/types");
var _constants = require("../common/constants");
var _types2 = require("../common/types");
var _UcmBackendConnector = require("./UcmBackendConnector");
var _BroadworksBackendConnector = require("./BroadworksBackendConnector");
var _WxCallBackendConnector = require("./WxCallBackendConnector");
var _types3 = require("../Metrics/types");
var _voicemailFixture = require("./voicemailFixture");
var _Logger = _interopRequireDefault(require("../Logger"));
var _constants2 = require("./constants");
describe('Voicemail Client tests', function () {
  var webex = (0, _testUtil.getTestUtilsWebex)();
  var infoSpy;
  var logSpy;
  var errorSpy;
  beforeEach(function () {
    infoSpy = jest.spyOn(_Logger.default, 'info');
    logSpy = jest.spyOn(_Logger.default, 'log');
    errorSpy = jest.spyOn(_Logger.default, 'error');
  });
  afterEach(function () {
    jest.clearAllMocks();
  });
  describe('createVoicemailClient tests', function () {
    /**
     * TestCase inputs
     * name: TestCase name
     * callingBehavior: Calling profile
     * entitlement: Entitlement
     * valid: expected result for vm client creation with given inputs.
     */
    var testData = [{
      name: 'verify valid ucm voicemail client',
      callingBehavior: _constants.NATIVE_SIP_CALL_TO_UCM,
      entitlement: 'none',
      valid: true
    }, {
      name: 'verify valid wxc voicemail client with basic entitlement',
      callingBehavior: _constants.NATIVE_WEBEX_TEAMS_CALLING,
      entitlement: _constants.ENTITLEMENT_BASIC,
      valid: true
    }, {
      name: 'verify valid wxc voicemail client with standard entitlement',
      callingBehavior: _constants.NATIVE_WEBEX_TEAMS_CALLING,
      entitlement: _constants.ENTITLEMENT_STANDARD,
      valid: true
    }, {
      name: 'verify valid wxc voicemail client with broadworks entitlement',
      callingBehavior: _constants.NATIVE_WEBEX_TEAMS_CALLING,
      entitlement: _constants.ENTITLEMENT_BROADWORKS_CONN,
      valid: true
    }, {
      name: 'verify invalid callingBehavior',
      callingBehavior: 'INVALID',
      entitlement: _constants.ENTITLEMENT_BASIC,
      valid: false
    }, {
      name: 'verify invalid entitlement for wxc voicemail client',
      callingBehavior: _constants.NATIVE_WEBEX_TEAMS_CALLING,
      entitlement: 'invalid',
      valid: false
    }].map(function (stat) {
      return (0, _assign.default)(stat, {
        toString: function toString() {
          /* eslint-disable dot-notation */
          return this['name'];
        }
      });
    });
    it.each(testData)('%s', /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(data) {
        var voicemailClient, connectorResponse, contactResponse;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              webex.internal.device.callingBehavior = data.callingBehavior;
              webex.internal.device.features.entitlement.models = [{
                _values: {
                  key: data.entitlement
                }
              }];
              if (!data.valid) {
                _context.next = 27;
                break;
              }
              voicemailClient = (0, _Voicemail.createVoicemailClient)(webex, {
                level: _types.LOGGER.INFO
              });
              voicemailClient['backendConnector'].init = jest.fn(function () {
                return _promise.default.resolve({});
              });
              voicemailClient['backendConnector'].resolveContact = jest.fn(function () {
                return _promise.default.resolve({});
              });
              connectorResponse = voicemailClient.init();
              contactResponse = voicemailClient.resolveContact(_voicemailFixture.resolveContactArgs);
              expect(voicemailClient).toBeTruthy();
              expect(voicemailClient.getSDKConnector().getWebex()).toBeTruthy();
              expect(connectorResponse).toBeTruthy();
              expect(contactResponse).toBeTruthy();
              expect(infoSpy).toHaveBeenCalledWith(_constants.METHOD_START_MESSAGE, {
                file: 'VoicemailClient',
                method: _constants2.METHODS.INIT
              });
              expect(logSpy).toHaveBeenCalledWith('Voicemail connector initialized successfully', {
                file: 'VoicemailClient',
                method: _constants2.METHODS.INIT
              });
              expect(infoSpy).toHaveBeenCalledWith(_constants.METHOD_START_MESSAGE, {
                file: 'VoicemailClient',
                method: _constants2.METHODS.RESOLVE_CONTACT
              });
              expect(logSpy).toHaveBeenCalledWith('Contact resolution completed successfully', {
                file: 'VoicemailClient',
                method: _constants2.METHODS.RESOLVE_CONTACT
              });
              _context.t0 = data.callingBehavior;
              _context.next = _context.t0 === _constants.NATIVE_SIP_CALL_TO_UCM ? 19 : _context.t0 === _constants.NATIVE_WEBEX_TEAMS_CALLING ? 22 : 24;
              break;
            case 19:
              expect(voicemailClient['callingBackend']).toStrictEqual(_types2.CALLING_BACKEND.UCM);
              expect(voicemailClient['backendConnector']).toBeInstanceOf(_UcmBackendConnector.UcmBackendConnector);
              return _context.abrupt("break", 25);
            case 22:
              if (data.entitlement === _constants.ENTITLEMENT_BROADWORKS_CONN) {
                expect(voicemailClient['callingBackend']).toStrictEqual(_types2.CALLING_BACKEND.BWRKS);
                expect(voicemailClient['backendConnector']).toBeInstanceOf(_BroadworksBackendConnector.BroadworksBackendConnector);
              } else {
                /* entitlement basic and standard */
                expect(voicemailClient['callingBackend']).toStrictEqual(_types2.CALLING_BACKEND.WXC);
                expect(voicemailClient['backendConnector']).toBeInstanceOf(_WxCallBackendConnector.WxCallBackendConnector);
              }
              return _context.abrupt("break", 25);
            case 24:
              fail('Unknown calling backend type.');
            case 25:
              _context.next = 28;
              break;
            case 27:
              expect(function () {
                (0, _Voicemail.createVoicemailClient)(webex, {
                  level: _types.LOGGER.INFO
                });
              }).toThrowError('Calling backend is not identified, exiting....');
            case 28:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
  });
  describe('voicemail metrics test', function () {
    webex.internal.device.callingBehavior = _constants.NATIVE_WEBEX_TEAMS_CALLING;
    webex.internal.device.features.entitlement.models = [{
      _values: {
        key: _constants.ENTITLEMENT_STANDARD
      }
    }];
    var voicemailClient = (0, _Voicemail.createVoicemailClient)(webex, {
      level: _types.LOGGER.INFO
    });
    var messageId = '/v2.0/user/08cedee9-296f-4aaf-bd4b-e14f2399abdf/VoiceMessagingMessages/ec8c3baf-afe4-4cef-b02f-19026b9e039c';
    var metricSpy = jest.spyOn(voicemailClient['metricManager'], 'submitVoicemailMetric');
    voicemailClient['backendConnector'] = {
      getVoicemailList: jest.fn(),
      getVoicemailContent: jest.fn(),
      getVoicemailSummary: jest.fn(),
      voicemailMarkAsRead: jest.fn(),
      voicemailMarkAsUnread: jest.fn(),
      deleteVoicemail: jest.fn(),
      getVMTranscript: jest.fn(),
      resolveContact: jest.fn()
    };
    var testData = [{
      metricAction: _types3.VOICEMAIL_ACTION.GET_VOICEMAILS,
      method: 'getVoicemailList'
    }, {
      metricAction: _types3.VOICEMAIL_ACTION.GET_VOICEMAIL_CONTENT,
      method: 'getVoicemailContent'
    }, {
      metricAction: _types3.VOICEMAIL_ACTION.MARK_READ,
      method: 'voicemailMarkAsRead'
    }, {
      metricAction: _types3.VOICEMAIL_ACTION.MARK_UNREAD,
      method: 'voicemailMarkAsUnread'
    }, {
      metricAction: _types3.VOICEMAIL_ACTION.DELETE,
      method: 'deleteVoicemail'
    }, {
      metricAction: _types3.VOICEMAIL_ACTION.TRANSCRIPT,
      method: 'getVMTranscript'
    }, {
      metricAction: _types3.VOICEMAIL_ACTION.GET_VOICEMAIL_SUMMARY,
      method: 'getVoicemailSummary'
    }].map(function (stat) {
      return (0, _assign.default)(stat, {
        toString: function toString() {
          return "test ".concat(this['method'], " with metrics");
        }
      });
    });
    it.each(testData)('%s', /*#__PURE__*/function () {
      var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(data) {
        var response, args, errorMessage, errorCode;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              response = {
                statusCode: 204,
                message: 'SUCCESS',
                data: {}
              };
              args = data.metricAction === _types3.VOICEMAIL_ACTION.GET_VOICEMAIL_SUMMARY && [] || data.metricAction === _types3.VOICEMAIL_ACTION.GET_VOICEMAILS ? [0, 0, _types2.SORT.ASC] : [messageId];
              voicemailClient['backendConnector'][data.method].mockResolvedValue(response);
              _context2.next = 5;
              return voicemailClient[data.method].apply(voicemailClient, args);
            case 5:
              // Check logging for success case
              // Check for specific log messages based on method called
              if (data.method === 'getVoicemailList') {
                expect(infoSpy).toHaveBeenCalledWith(expect.stringContaining('invoking with: offset='), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_LIST
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining('Successfully retrieved voicemail list'), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_LIST
                }));
              } else if (data.method === 'getVoicemailSummary') {
                expect(infoSpy).toHaveBeenCalledWith(_constants.METHOD_START_MESSAGE, expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_SUMMARY
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining('Successfully retrieved voicemail summary'), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_SUMMARY
                }));
              } else if (data.method === 'getVoicemailContent') {
                expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with: messageId=").concat(messageId), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_CONTENT
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Successfully retrieved voicemail content for messageId=".concat(messageId)), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_CONTENT
                }));
              } else if (data.method === 'voicemailMarkAsRead') {
                expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with: messageId=").concat(messageId), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.VOICEMAIL_MARK_AS_READ
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Successfully marked voicemail as read: messageId=".concat(messageId)), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.VOICEMAIL_MARK_AS_READ
                }));
              } else if (data.method === 'voicemailMarkAsUnread') {
                expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with: messageId=").concat(messageId), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.VOICEMAIL_MARK_AS_UNREAD
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Successfully marked voicemail as unread: messageId=".concat(messageId)), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.VOICEMAIL_MARK_AS_UNREAD
                }));
              } else if (data.method === 'deleteVoicemail') {
                expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with: messageId=").concat(messageId), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.DELETE_VOICEMAIL
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Successfully deleted voicemail: messageId=".concat(messageId)), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.DELETE_VOICEMAIL
                }));
              } else if (data.method === 'getVMTranscript') {
                expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with: messageId=").concat(messageId), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VM_TRANSCRIPT
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Successfully retrieved voicemail transcript: messageId=".concat(messageId)), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VM_TRANSCRIPT
                }));
              }
              expect(errorSpy).not.toHaveBeenCalled();
              expect(metricSpy).toHaveBeenCalledWith(_types3.METRIC_EVENT.VOICEMAIL, data.metricAction, _types3.METRIC_TYPE.BEHAVIORAL, [_types3.VOICEMAIL_ACTION.GET_VOICEMAILS, _types3.VOICEMAIL_ACTION.GET_VOICEMAIL_SUMMARY].includes(data.metricAction) ? undefined : messageId);
              metricSpy.mockClear();
              errorMessage = 'User is unauthorised';
              errorCode = 401;
              response.statusCode = errorCode;
              response.data = {
                error: errorMessage
              };
              infoSpy.mockClear();
              logSpy.mockClear();
              errorSpy.mockClear();
              _context2.next = 18;
              return voicemailClient[data.method].apply(voicemailClient, args);
            case 18:
              // Check for error case logging with specific message checks
              if (data.method === 'getVoicemailList') {
                expect(infoSpy).toHaveBeenCalledWith(expect.stringContaining('invoking with: offset='), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_LIST
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining('Successfully retrieved voicemail list'), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_LIST
                }));
              } else if (data.method === 'getVoicemailSummary') {
                expect(infoSpy).toHaveBeenCalledWith(_constants.METHOD_START_MESSAGE, expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_SUMMARY
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining('Successfully retrieved voicemail summary'), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_SUMMARY
                }));
              } else if (data.method === 'getVoicemailContent') {
                expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with: messageId=").concat(messageId), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_CONTENT
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Successfully retrieved voicemail content for messageId=".concat(messageId)), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VOICEMAIL_CONTENT
                }));
              } else if (data.method === 'voicemailMarkAsRead') {
                expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with: messageId=").concat(messageId), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.VOICEMAIL_MARK_AS_READ
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Successfully marked voicemail as read: messageId=".concat(messageId)), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.VOICEMAIL_MARK_AS_READ
                }));
              } else if (data.method === 'voicemailMarkAsUnread') {
                expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with: messageId=").concat(messageId), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.VOICEMAIL_MARK_AS_UNREAD
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Successfully marked voicemail as unread: messageId=".concat(messageId)), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.VOICEMAIL_MARK_AS_UNREAD
                }));
              } else if (data.method === 'deleteVoicemail') {
                expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with: messageId=").concat(messageId), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.DELETE_VOICEMAIL
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Successfully deleted voicemail: messageId=".concat(messageId)), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.DELETE_VOICEMAIL
                }));
              } else if (data.method === 'getVMTranscript') {
                expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with: messageId=").concat(messageId), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VM_TRANSCRIPT
                }));
                expect(logSpy).toHaveBeenCalledWith(expect.stringContaining("Successfully retrieved voicemail transcript: messageId=".concat(messageId)), expect.objectContaining({
                  file: 'VoicemailClient',
                  method: _constants2.METHODS.GET_VM_TRANSCRIPT
                }));
              }
              expect(errorSpy).not.toHaveBeenCalled();
              expect(metricSpy).toHaveBeenCalledWith(_types3.METRIC_EVENT.VOICEMAIL_ERROR, data.metricAction, _types3.METRIC_TYPE.BEHAVIORAL, [_types3.VOICEMAIL_ACTION.GET_VOICEMAILS, _types3.VOICEMAIL_ACTION.GET_VOICEMAIL_SUMMARY].includes(data.metricAction) ? undefined : messageId, errorMessage, errorCode);
            case 21:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());
  });
});
//# sourceMappingURL=Voicemail.test.js.map
