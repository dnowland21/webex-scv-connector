"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.UcmBackendConnector = void 0;
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _SDKConnector = _interopRequireDefault(require("../SDKConnector"));
var _types = require("../common/types");
var _Utils = require("../common/Utils");
var _constants = require("../common/constants");
var _Logger = _interopRequireDefault(require("../Logger"));
var _constants2 = require("./constants");
/* eslint-disable no-underscore-dangle */
/* eslint-disable valid-jsdoc */
/* eslint-disable @typescript-eslint/no-shadow */
/**
 *
 */
var UcmBackendConnector = exports.UcmBackendConnector = /*#__PURE__*/function () {
  /**
   * @param webex - Webex object to get the userid, service urls, etc...
   * @param logger - Logger to set logger level.
   */
  function UcmBackendConnector(webex, logger) {
    (0, _classCallCheck2.default)(this, UcmBackendConnector);
    (0, _defineProperty2.default)(this, "vgEndpoint", void 0);
    (0, _defineProperty2.default)(this, "userId", void 0);
    (0, _defineProperty2.default)(this, "orgId", void 0);
    (0, _defineProperty2.default)(this, "sdkConnector", void 0);
    (0, _defineProperty2.default)(this, "webex", void 0);
    (0, _defineProperty2.default)(this, "vgVoiceMessageURI", void 0);
    this.sdkConnector = _SDKConnector.default;
    /* istanbul ignore else */
    if (!this.sdkConnector.getWebex()) {
      _SDKConnector.default.setWebex(webex);
    }
    this.webex = this.sdkConnector.getWebex();
    this.userId = this.webex.internal.device.userId;
    this.orgId = this.webex.internal.device.orgId;
    _Logger.default.setLogger(logger.level, _constants.UCM_CONNECTOR_FILE);
  }

  /**
   *
   */
  (0, _createClass2.default)(UcmBackendConnector, [{
    key: "init",
    value: function init() {
      var loggerContext = {
        file: _constants.UCM_CONNECTOR_FILE,
        method: _constants2.METHODS.INIT
      };
      _Logger.default.info(_constants.METHOD_START_MESSAGE, loggerContext);
      var response = this.setUcmVoiceMessageBaseURI();
      _Logger.default.log('UCM calling voicemail connector initialized successfully', loggerContext);
      return response;
    }

    /**
     *
     */
  }, {
    key: "getSDKConnector",
    value: function getSDKConnector() {
      return this.sdkConnector;
    }

    /**
     *
     */
  }, {
    key: "setUcmVoiceMessageBaseURI",
    value: function setUcmVoiceMessageBaseURI() {
      var loggerContext = {
        file: _constants.UCM_CONNECTOR_FILE,
        method: _constants2.METHODS.SET_UCM_VOICE_MESSAGE_BASE_URI
      };
      _Logger.default.info(_constants.METHOD_START_MESSAGE, loggerContext);
      this.vgEndpoint = (0, _Utils.getVgActionEndpoint)(this.webex, _types.CALLING_BACKEND.UCM);
      this.vgVoiceMessageURI = "".concat(this.vgEndpoint, "/").concat(_constants2.VMGATEWAY, "/").concat(_constants2.API_V1, "/").concat(_constants.USERS, "/").concat(this.userId, "/");
      return this.vgVoiceMessageURI;
    }

    /**
     * Fetch voicemail list for UCM users.
     *
     * @param offset - Number of records to skip.  TODO: Once we start implementing pagination.
     * @param offsetLimit - Number of voicemail list to fetch. TODO: Once we start implementing pagination.
     * @param sort - Sort voicemail list (ASC | DESC). TODO: Once we start implementing sorting.
     * @returns Promise.
     */
  }, {
    key: "getVoicemailList",
    value: (function () {
      var _getVoicemailList = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(offset, offsetLimit, sort) {
        var _this = this;
        var loggerContext, urlVg, response, msgInfo, messageinfoArray, ucmVmMsgInfo, responseDetails, extendedError, errorInfo, errorStatus;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              loggerContext = {
                file: _constants.UCM_CONNECTOR_FILE,
                method: _constants2.METHODS.GET_VOICEMAIL_LIST
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with Offset: ").concat(offset, " Offset limit: ").concat(offsetLimit, " Sort type:").concat(sort), loggerContext);
              urlVg = "".concat(this.vgVoiceMessageURI).concat(_constants2.VOICEMAILS, "/").concat(_constants2.OFFSET, "=").concat(offset).concat(_constants2.LIMIT, "=").concat(offsetLimit).concat(_constants2.SORT_ORDER, "=").concat(sort);
              _context.prev = 3;
              _context.next = 6;
              return this.webex.request({
                uri: "".concat(urlVg),
                method: _types.HTTP_METHODS.GET,
                headers: {
                  orgId: this.orgId
                }
              });
            case 6:
              response = _context.sent;
              msgInfo = response.body;
              messageinfoArray = [];
              ucmVmMsgInfo = msgInfo.Message;
              ucmVmMsgInfo.forEach(function (msgInfoObj) {
                var message = {};
                var stringObj = {};
                var numberObj = {};
                stringObj.$ = msgInfoObj.Duration;
                message.duration = stringObj;
                numberObj.$ = Number(msgInfoObj.ArrivalTime);
                message.time = numberObj;
                stringObj = {
                  $: ''
                };
                stringObj.$ = msgInfoObj.MsgId;
                message.messageId = stringObj;
                /* istanbul ignore else */
                if (msgInfoObj.Read === 'true') {
                  message.read = {};
                }
                var callerIdObj = msgInfoObj.CallerId;
                var callingParty = {};
                stringObj = {
                  $: ''
                };
                stringObj.$ = callerIdObj.CallerName;
                callingParty.name = stringObj;
                stringObj = {
                  $: ''
                };
                stringObj.$ = _this.userId;
                callingParty.userId = stringObj;
                stringObj = {
                  $: ''
                };
                stringObj.$ = callerIdObj.CallerNumber;
                callingParty.address = stringObj;
                message.callingPartyInfo = callingParty;
                messageinfoArray.push(message);
              });
              responseDetails = {
                statusCode: Number(response.statusCode),
                data: {
                  voicemailList: messageinfoArray
                },
                message: _constants.SUCCESS_MESSAGE
              };
              _Logger.default.log('Successfully retrieved voicemail list', loggerContext);
              return _context.abrupt("return", responseDetails);
            case 16:
              _context.prev = 16;
              _context.t0 = _context["catch"](3);
              extendedError = new Error("Failed to get voicemail list: ".concat(_context.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context.next = 22;
              return (0, _Utils.uploadLogs)();
            case 22:
              errorInfo = _context.t0;
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context.abrupt("return", errorStatus);
            case 25:
            case "end":
              return _context.stop();
          }
        }, _callee, this, [[3, 16]]);
      }));
      function getVoicemailList(_x, _x2, _x3) {
        return _getVoicemailList.apply(this, arguments);
      }
      return getVoicemailList;
    }()
    /**
     * @param messageId - MessageId from voicemail list api to get voicemail content.
     */
    )
  }, {
    key: "getVoicemailContent",
    value: (function () {
      var _getVoicemailContent = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(messageId) {
        var loggerContext, response, extendedError, errorInfo, errorStatus;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              loggerContext = {
                file: _constants.UCM_CONNECTOR_FILE,
                method: _constants2.METHODS.GET_VOICEMAIL_CONTENT
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), loggerContext);
              _context2.prev = 2;
              _context2.next = 5;
              return this.getVoicemailContentUcm(messageId);
            case 5:
              response = _context2.sent;
              _Logger.default.log("Successfully retrieved voicemail content with  Message ID: ".concat(messageId), loggerContext);
              return _context2.abrupt("return", response);
            case 10:
              _context2.prev = 10;
              _context2.t0 = _context2["catch"](2);
              extendedError = new Error("Failed to get voicemail content: ".concat(_context2.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context2.next = 16;
              return (0, _Utils.uploadLogs)();
            case 16:
              errorInfo = _context2.t0;
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              _Logger.default.info("Voice mail content error is ".concat(errorStatus), loggerContext);
              return _context2.abrupt("return", errorStatus);
            case 20:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[2, 10]]);
      }));
      function getVoicemailContent(_x4) {
        return _getVoicemailContent.apply(this, arguments);
      }
      return getVoicemailContent;
    }()
    /**
     * Fetches a quantitative summary of voicemails for a user.
     * Not implemented for this connector.
     */
    )
  }, {
    key: "getVoicemailSummary",
    value: (function () {
      var _getVoicemailSummary = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", _promise.default.resolve(null));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      function getVoicemailSummary() {
        return _getVoicemailSummary.apply(this, arguments);
      }
      return getVoicemailSummary;
    }()
    /**
     * @param messageId - MessageId from voicemail list api to get voicemail content.
     */
    )
  }, {
    key: "getVoicemailContentUcm",
    value: (function () {
      var _getVoicemailContentUcm = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(messageId) {
        var _this2 = this;
        var loggerContext;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              loggerContext = {
                file: _constants.UCM_CONNECTOR_FILE,
                method: _constants2.METHODS.GET_VOICEMAIL_CONTENT_UCM
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), loggerContext);
              return _context5.abrupt("return", new _promise.default(function (resolve, reject) {
                var voicemailContentUrl = "".concat(_this2.vgVoiceMessageURI).concat(_constants2.VOICEMAILS, "/").concat(messageId, "/").concat(_constants.CONTENT);
                var mercuryApi = "".concat(_this2.webex.internal.services._serviceUrls.mercuryApi);
                _this2.returnUcmPromise(voicemailContentUrl, mercuryApi).then(function (response) {
                  if (response.statusCode === 200) {
                    resolve(response);
                  } else if (response.statusCode === 202) {
                    _this2.sdkConnector.registerListener('event:ucm.voicemail_download_complete', /*#__PURE__*/function () {
                      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(event) {
                        var _responseEvent$data;
                        var responseEvent, voicemailContentUrl, response;
                        return _regenerator.default.wrap(function _callee4$(_context4) {
                          while (1) switch (_context4.prev = _context4.next) {
                            case 0:
                              responseEvent = event;
                              voicemailContentUrl = "".concat(_this2.vgVoiceMessageURI).concat(_constants2.VOICEMAILS, "/").concat(responseEvent === null || responseEvent === void 0 ? void 0 : (_responseEvent$data = responseEvent.data) === null || _responseEvent$data === void 0 ? void 0 : _responseEvent$data.messageId, "/").concat(_constants.CONTENT);
                              _context4.next = 4;
                              return _this2.returnUcmPromise(voicemailContentUrl, mercuryApi);
                            case 4:
                              response = _context4.sent;
                              if (response.statusCode === 200) {
                                _this2.sdkConnector.unregisterListener('event:ucm.voicemail_download_complete');
                                resolve(response);
                              } else {
                                _this2.sdkConnector.unregisterListener('event:ucm.voicemail_download_complete');
                                reject(response);
                              }
                            case 6:
                            case "end":
                              return _context4.stop();
                          }
                        }, _callee4);
                      }));
                      return function (_x6) {
                        return _ref.apply(this, arguments);
                      };
                    }());
                  } else {
                    reject(response);
                  }
                }).catch(function (err) {
                  reject(err);
                });
              }));
            case 3:
            case "end":
              return _context5.stop();
          }
        }, _callee5);
      }));
      function getVoicemailContentUcm(_x5) {
        return _getVoicemailContentUcm.apply(this, arguments);
      }
      return getVoicemailContentUcm;
    }()
    /**
     * @param voicemailContentUrl - Voicemail Content Url to get voicemail content.
     * @param mercuryApi - MercuryApi from webex serviceUrls.
     */
    )
  }, {
    key: "returnUcmPromise",
    value: (function () {
      var _returnUcmPromise = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(voicemailContentUrl, mercuryApi) {
        var loggerContext, response, contentInfo, respHeaders, statusCode, mediaType, mediaContent, responseDetails;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              loggerContext = {
                file: _constants.UCM_CONNECTOR_FILE,
                method: _constants2.METHODS.RETURN_UCM_PROMISE
              };
              _Logger.default.info(_constants.METHOD_START_MESSAGE, loggerContext);
              _context6.next = 4;
              return this.webex.request({
                uri: "".concat(voicemailContentUrl),
                method: _types.HTTP_METHODS.GET,
                headers: {
                  orgId: this.orgId,
                  deviceUrl: this.webex.internal.device.url,
                  mercuryHostname: mercuryApi
                }
              });
            case 4:
              response = _context6.sent;
              contentInfo = response === null || response === void 0 ? void 0 : response.body;
              respHeaders = response.headers;
              statusCode = response.statusCode;
              mediaType = respHeaders === null || respHeaders === void 0 ? void 0 : respHeaders.mediatype;
              mediaContent = contentInfo;
              responseDetails = {
                statusCode: Number(statusCode),
                data: {
                  voicemailContent: {
                    type: mediaType,
                    content: mediaContent
                  }
                },
                message: _constants.SUCCESS_MESSAGE
              };
              /* istanbul ignore else */
              if (statusCode !== 200 && statusCode !== 202) {
                responseDetails.message = _constants.FAILURE_MESSAGE;
              }
              return _context6.abrupt("return", responseDetails);
            case 13:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this);
      }));
      function returnUcmPromise(_x7, _x8) {
        return _returnUcmPromise.apply(this, arguments);
      }
      return returnUcmPromise;
    }()
    /**
     * @param messageId - MessageId from voicemail list api to get voicemail mark as read.
     */
    )
  }, {
    key: "voicemailMarkAsRead",
    value: (function () {
      var _voicemailMarkAsRead = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(messageId) {
        var loggerContext, voicemailContentUrl, response, responseDetails, extendedError, errorInfo, errorStatus;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              loggerContext = {
                file: _constants.UCM_CONNECTOR_FILE,
                method: _constants2.METHODS.VOICEMAIL_MARK_AS_READ
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), loggerContext);
              _context7.prev = 2;
              voicemailContentUrl = "".concat(this.vgVoiceMessageURI).concat(_constants2.VOICEMAILS, "/").concat(messageId);
              _context7.next = 6;
              return this.webex.request({
                uri: voicemailContentUrl,
                method: _types.HTTP_METHODS.PUT,
                headers: {
                  orgId: this.orgId
                },
                body: {
                  read: 'true'
                }
              });
            case 6:
              response = _context7.sent;
              responseDetails = {
                statusCode: Number(response.statusCode),
                data: {},
                message: _constants.SUCCESS_MESSAGE
              };
              _Logger.default.log('Successfully marked voicemail as read', loggerContext);
              return _context7.abrupt("return", responseDetails);
            case 12:
              _context7.prev = 12;
              _context7.t0 = _context7["catch"](2);
              extendedError = new Error("Failed to mark voicemail as read: ".concat(_context7.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context7.next = 18;
              return (0, _Utils.uploadLogs)();
            case 18:
              errorInfo = _context7.t0;
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context7.abrupt("return", errorStatus);
            case 21:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[2, 12]]);
      }));
      function voicemailMarkAsRead(_x9) {
        return _voicemailMarkAsRead.apply(this, arguments);
      }
      return voicemailMarkAsRead;
    }()
    /**
     *  @param messageId - MessageId from voicemail list api to get voicemail mark as unread.
     */
    )
  }, {
    key: "voicemailMarkAsUnread",
    value: (function () {
      var _voicemailMarkAsUnread = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(messageId) {
        var loggerContext, voicemailContentUrl, response, responseDetails, extendedError, errorInfo, errorStatus;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              loggerContext = {
                file: _constants.UCM_CONNECTOR_FILE,
                method: _constants2.METHODS.VOICEMAIL_MARK_AS_UNREAD
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), loggerContext);
              _context8.prev = 2;
              voicemailContentUrl = "".concat(this.vgVoiceMessageURI).concat(_constants2.VOICEMAILS, "/").concat(messageId);
              _context8.next = 6;
              return this.webex.request({
                uri: voicemailContentUrl,
                method: _types.HTTP_METHODS.PUT,
                headers: {
                  orgId: this.orgId
                },
                body: {
                  read: 'false'
                }
              });
            case 6:
              response = _context8.sent;
              responseDetails = {
                statusCode: Number(response.statusCode),
                data: {},
                message: _constants.SUCCESS_MESSAGE
              };
              _Logger.default.log('Successfully marked voicemail as unread', loggerContext);
              return _context8.abrupt("return", responseDetails);
            case 12:
              _context8.prev = 12;
              _context8.t0 = _context8["catch"](2);
              extendedError = new Error("Failed to mark voicemail as unread: ".concat(_context8.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context8.next = 18;
              return (0, _Utils.uploadLogs)();
            case 18:
              errorInfo = _context8.t0;
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context8.abrupt("return", errorStatus);
            case 21:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[2, 12]]);
      }));
      function voicemailMarkAsUnread(_x10) {
        return _voicemailMarkAsUnread.apply(this, arguments);
      }
      return voicemailMarkAsUnread;
    }()
    /**
     * @param messageId - MessageId from voicemail list api to delete voicemail.
     */
    )
  }, {
    key: "deleteVoicemail",
    value: (function () {
      var _deleteVoicemail = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9(messageId) {
        var loggerContext, voicemailContentUrl, response, responseDetails, extendedError, errorInfo, errorStatus;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              loggerContext = {
                file: _constants.UCM_CONNECTOR_FILE,
                method: _constants2.METHODS.DELETE_VOICEMAIL
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), loggerContext);
              _context9.prev = 2;
              voicemailContentUrl = "".concat(this.vgVoiceMessageURI).concat(_constants2.VOICEMAILS, "/").concat(messageId);
              _context9.next = 6;
              return this.webex.request({
                uri: voicemailContentUrl,
                method: _types.HTTP_METHODS.DELETE,
                headers: {
                  orgId: this.orgId
                }
              });
            case 6:
              response = _context9.sent;
              responseDetails = {
                statusCode: Number(response.statusCode),
                data: {},
                message: _constants.SUCCESS_MESSAGE
              };
              _Logger.default.log('Successfully deleted voicemail', loggerContext);
              return _context9.abrupt("return", responseDetails);
            case 12:
              _context9.prev = 12;
              _context9.t0 = _context9["catch"](2);
              extendedError = new Error("Failed to delete voicemail: ".concat(_context9.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context9.next = 18;
              return (0, _Utils.uploadLogs)();
            case 18:
              errorInfo = _context9.t0;
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context9.abrupt("return", errorStatus);
            case 21:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[2, 12]]);
      }));
      function deleteVoicemail(_x11) {
        return _deleteVoicemail.apply(this, arguments);
      }
      return deleteVoicemail;
    }()
    /**
     * Fetch voicemail transcripts for given messageId
     * Not implemented for this connector.
     *
     * @param messageId - MessageId to fetch voicemail transcript.
     */
    )
  }, {
    key: "getVMTranscript",
    value: (function () {
      var _getVMTranscript = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10(messageId) {
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _Logger.default.info("Message Id: ".concat(messageId), {});
              return _context10.abrupt("return", _promise.default.resolve(null));
            case 2:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
      function getVMTranscript(_x12) {
        return _getVMTranscript.apply(this, arguments);
      }
      return getVMTranscript;
    }()
    /**
     * Resolve the Contact from userId or display name.
     * Not implemented for this connector.
     *
     * @param callingPartyInfo - Calling Party Info.
     */
    )
  }, {
    key: "resolveContact",
    value: function resolveContact(callingPartyInfo) {
      _Logger.default.info("Calling Party Info: ".concat(callingPartyInfo), {});
      return _promise.default.resolve(null);
    }
  }]);
  return UcmBackendConnector;
}();
//# sourceMappingURL=UcmBackendConnector.js.map
