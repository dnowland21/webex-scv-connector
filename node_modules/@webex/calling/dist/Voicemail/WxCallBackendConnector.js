"use strict";

var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.WxCallBackendConnector = void 0;
var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));
var _isArray = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/array/is-array"));
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _SDKConnector = _interopRequireDefault(require("../SDKConnector"));
var _constants = require("../common/constants");
var _Utils = require("../common/Utils");
var _types = require("../common/types");
var _Logger = _interopRequireDefault(require("../Logger"));
var _constants2 = require("./constants");
function ownKeys(e, r) { var t = _Object$keys2(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; } /* eslint-disable dot-notation */ /* eslint-disable no-underscore-dangle */
/**
 *
 */
var WxCallBackendConnector = exports.WxCallBackendConnector = /*#__PURE__*/function () {
  /**
   * @param webex - An object of the webex-js-sdk type.
   * @param logger - Logger interface.
   */
  function WxCallBackendConnector(webex, logger) {
    (0, _classCallCheck2.default)(this, WxCallBackendConnector);
    (0, _defineProperty2.default)(this, "xsiEndpoint", void 0);
    (0, _defineProperty2.default)(this, "userId", void 0);
    (0, _defineProperty2.default)(this, "context", void 0);
    (0, _defineProperty2.default)(this, "sdkConnector", void 0);
    (0, _defineProperty2.default)(this, "xsiVoiceMessageURI", void 0);
    (0, _defineProperty2.default)(this, "webex", void 0);
    (0, _defineProperty2.default)(this, "authHeaders", null);
    this.sdkConnector = _SDKConnector.default;
    if (!this.sdkConnector.getWebex()) {
      _SDKConnector.default.setWebex(webex);
    }
    this.context = Math.random().toString(_constants2.RADIX_RAND).substring(_constants2.PREFIX);
    this.webex = this.sdkConnector.getWebex();
    this.userId = this.webex.internal.device.userId;
    _Logger.default.setLogger(logger.level, _constants.WEBEX_CALLING_CONNECTOR_FILE);
  }

  /**
   * Initializing Webex calling voicemail connector.
   *
   * @returns Response.
   */
  (0, _createClass2.default)(WxCallBackendConnector, [{
    key: "init",
    value: (function () {
      var _init = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
        var loggerContext, response;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return this.getAuthHeaders();
            case 2:
              this.authHeaders = _context.sent;
              loggerContext = {
                file: _constants.WEBEX_CALLING_CONNECTOR_FILE,
                method: _constants2.METHODS.INIT
              };
              _Logger.default.info(_constants.METHOD_START_MESSAGE, loggerContext);
              response = this.setXsiVoiceMessageURI();
              return _context.abrupt("return", response);
            case 7:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }()
    /**
     * @ignore
     * SDK connector function.
     * @returns SdkConnector.
     */
    )
  }, {
    key: "getSDKConnector",
    value: function getSDKConnector() {
      return this.sdkConnector;
    }

    /**
     * Register XSI URL.
     */
  }, {
    key: "setXsiVoiceMessageURI",
    value: (function () {
      var _setXsiVoiceMessageURI = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
        var responseDetails, loggerContext;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              loggerContext = {
                file: _constants.WEBEX_CALLING_CONNECTOR_FILE,
                method: _constants2.METHODS.SET_XSI_VOICE_MESSAGE_URI
              };
              _Logger.default.info(_constants.METHOD_START_MESSAGE, loggerContext);
              _context2.next = 4;
              return (0, _Utils.getXsiActionEndpoint)(this.webex, loggerContext, _types.CALLING_BACKEND.WXC);
            case 4:
              this.xsiEndpoint = _context2.sent;
              _Logger.default.log("XsiEndpoint is ".concat(this.xsiEndpoint), loggerContext);
              if (this.userId) {
                this.xsiVoiceMessageURI = "".concat(this.xsiEndpoint, "/").concat(_constants.BW_XSI_ENDPOINT_VERSION, "/").concat(_constants.USER, "/").concat(this.userId, "/").concat(_constants2.VOICE_MESSAGING_MESSAGES);
                responseDetails = {
                  statusCode: _constants.SUCCESS_STATUS_CODE,
                  data: {},
                  message: _constants.SUCCESS_MESSAGE
                };
              }
              return _context2.abrupt("return", responseDetails);
            case 8:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function setXsiVoiceMessageURI() {
        return _setXsiVoiceMessageURI.apply(this, arguments);
      }
      return setXsiVoiceMessageURI;
    }()
    /**
     * Fetch voicemail list for Webex users.
     *
     * @param sort - Sort voicemail list (ASC | DESC).
     * @param offset - Number of records to skip.
     * @param offsetLimit - Number of voicemail list to fetch from the offset.
     * @param refresh - Refresh the list of voicemails from backend.
     * @returns Promise.
     */
    )
  }, {
    key: "getVoicemailList",
    value: (function () {
      var _getVoicemailList = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(offset, offsetLimit, sort, refresh) {
        var loggerContext, messageinfo, urlXsi, sortParam, _voicemailListRespons, _voicemailListRespons2, _voicemailListRespons3, response, voicemailListResponse, _voicemailListRespons4, _voicemailListRespons5, _voicemailListRespons6, _voicemailListRespons7, errorInfo, extendedError, errorStatus, _fetchVoicemailList, messages, moreVMAvailable, responseDetails;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              loggerContext = {
                file: _constants.WEBEX_CALLING_CONNECTOR_FILE,
                method: _constants2.METHODS.GET_VOICEMAIL_LIST
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with Offset: ").concat(offset, " Offset limit: ").concat(offsetLimit, " Sort type:").concat(sort), loggerContext);
              if (!refresh) {
                _context3.next = 23;
                break;
              }
              urlXsi = "".concat(this.xsiVoiceMessageURI).concat(_constants2.JSON_FORMAT);
              sortParam = (0, _values.default)(_types.SORT).includes(sort) ? sort : _types.SORT.DEFAULT;
              _context3.prev = 5;
              _context3.next = 8;
              return this.webex.request({
                uri: "".concat(urlXsi),
                method: _types.HTTP_METHODS.GET,
                headers: _objectSpread({}, this.authHeaders)
              });
            case 8:
              response = _context3.sent;
              voicemailListResponse = response.body;
              if ((0, _keys.default)(voicemailListResponse === null || voicemailListResponse === void 0 ? void 0 : (_voicemailListRespons = voicemailListResponse.VoiceMessagingMessages) === null || _voicemailListRespons === void 0 ? void 0 : _voicemailListRespons.messageInfoList).length === 0) {
                messageinfo = [];
              } else if (!(0, _isArray.default)(voicemailListResponse === null || voicemailListResponse === void 0 ? void 0 : (_voicemailListRespons2 = voicemailListResponse.VoiceMessagingMessages) === null || _voicemailListRespons2 === void 0 ? void 0 : (_voicemailListRespons3 = _voicemailListRespons2.messageInfoList) === null || _voicemailListRespons3 === void 0 ? void 0 : _voicemailListRespons3.messageInfo)) {
                messageinfo = Array(voicemailListResponse === null || voicemailListResponse === void 0 ? void 0 : (_voicemailListRespons4 = voicemailListResponse.VoiceMessagingMessages) === null || _voicemailListRespons4 === void 0 ? void 0 : (_voicemailListRespons5 = _voicemailListRespons4.messageInfoList) === null || _voicemailListRespons5 === void 0 ? void 0 : _voicemailListRespons5.messageInfo);
              } else {
                messageinfo = voicemailListResponse === null || voicemailListResponse === void 0 ? void 0 : (_voicemailListRespons6 = voicemailListResponse.VoiceMessagingMessages) === null || _voicemailListRespons6 === void 0 ? void 0 : (_voicemailListRespons7 = _voicemailListRespons6.messageInfoList) === null || _voicemailListRespons7 === void 0 ? void 0 : _voicemailListRespons7.messageInfo;
                messageinfo = (0, _Utils.getSortedVoicemailList)(messageinfo, sortParam);
              }
              (0, _Utils.storeVoicemailList)(this.context, messageinfo);
              _context3.next = 23;
              break;
            case 14:
              _context3.prev = 14;
              _context3.t0 = _context3["catch"](5);
              errorInfo = _context3.t0;
              extendedError = new Error("Failed to get voicemail list: ".concat(_context3.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context3.next = 21;
              return (0, _Utils.uploadLogs)();
            case 21:
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context3.abrupt("return", errorStatus);
            case 23:
              _fetchVoicemailList = (0, _Utils.fetchVoicemailList)(this.context, offset, offsetLimit, loggerContext), messages = _fetchVoicemailList.messages, moreVMAvailable = _fetchVoicemailList.moreVMAvailable;
              responseDetails = {
                statusCode: moreVMAvailable ? _constants.SUCCESS_STATUS_CODE : _constants2.NO_VOICEMAIL_STATUS_CODE,
                data: {
                  voicemailList: messages
                },
                message: moreVMAvailable ? _constants.SUCCESS_MESSAGE : _constants2.NO_VOICEMAIL_MSG
              };
              _Logger.default.log('Successfully fetched voicemail list', loggerContext);
              return _context3.abrupt("return", responseDetails);
            case 27:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this, [[5, 14]]);
      }));
      function getVoicemailList(_x, _x2, _x3, _x4) {
        return _getVoicemailList.apply(this, arguments);
      }
      return getVoicemailList;
    }()
    /**
     * Fetch the voicemail contents for the messageId.
     *
     * @param messageId -string result from the voicemail list.
     * @returns Promise.
     */
    )
  }, {
    key: "getVoicemailContent",
    value: (function () {
      var _getVoicemailContent = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(messageId) {
        var loggerContext, _mediaDetails$childNo, _mediaDetails$childNo2, voicemailContentUrl, response, parser, xmlDOM, mediaDetails, mediaType, mediaContent, responseDetails, errorInfo, extendedError, errorStatus;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              loggerContext = {
                file: _constants.WEBEX_CALLING_CONNECTOR_FILE,
                method: _constants2.METHODS.GET_VOICEMAIL_CONTENT
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with messageId: ").concat(messageId), loggerContext);
              _context4.prev = 2;
              voicemailContentUrl = "".concat(this.xsiEndpoint).concat(messageId);
              _context4.next = 6;
              return this.webex.request({
                uri: "".concat(voicemailContentUrl),
                method: _types.HTTP_METHODS.GET,
                headers: _objectSpread({}, this.authHeaders)
              });
            case 6:
              response = _context4.sent;
              parser = new DOMParser();
              xmlDOM = parser.parseFromString(response[_constants.RAW_REQUEST].response, _constants.XML_TYPE);
              mediaDetails = xmlDOM.getElementsByTagName(_constants2.MESSAGE_MEDIA_CONTENT)[0];
              mediaType = (_mediaDetails$childNo = mediaDetails.childNodes[1]) === null || _mediaDetails$childNo === void 0 ? void 0 : _mediaDetails$childNo.textContent;
              mediaContent = (_mediaDetails$childNo2 = mediaDetails.childNodes[2]) === null || _mediaDetails$childNo2 === void 0 ? void 0 : _mediaDetails$childNo2.textContent;
              _Logger.default.info("Media type is  ".concat(mediaType), loggerContext);
              responseDetails = {
                statusCode: Number(response.statusCode),
                data: {
                  voicemailContent: {
                    type: mediaType,
                    content: mediaContent
                  }
                },
                message: _constants.SUCCESS_MESSAGE
              };
              _Logger.default.log('Successfully fetched voicemail content', loggerContext);
              return _context4.abrupt("return", responseDetails);
            case 18:
              _context4.prev = 18;
              _context4.t0 = _context4["catch"](2);
              errorInfo = _context4.t0;
              extendedError = new Error("Failed to get voicemail content: ".concat(_context4.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context4.next = 25;
              return (0, _Utils.uploadLogs)();
            case 25:
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context4.abrupt("return", errorStatus);
            case 27:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[2, 18]]);
      }));
      function getVoicemailContent(_x5) {
        return _getVoicemailContent.apply(this, arguments);
      }
      return getVoicemailContent;
    }()
    /**
     * Fetches a quantitative summary of voicemails for a user.
     *
     * @returns - A Promise that resolves with the data containing counters for newMessages, oldMessage, newUrgentMessages, oldUrgentMessages.
     */
    )
  }, {
    key: "getVoicemailSummary",
    value: (function () {
      var _getVoicemailSummary = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
        var loggerContext, voicemailSummaryUrl, response, parser, xmlDOM, voicemailSummary, newMessages, newUrgentMessages, oldMessages, oldUrgentMessages, responseDetails, errorInfo, extendedError, errorStatus;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              loggerContext = {
                file: _constants.WEBEX_CALLING_CONNECTOR_FILE,
                method: _constants2.METHODS.GET_VOICEMAIL_SUMMARY
              };
              _Logger.default.info(_constants.METHOD_START_MESSAGE, loggerContext);
              _context5.prev = 2;
              voicemailSummaryUrl = "".concat(this.xsiEndpoint, "/").concat(_constants.BW_XSI_ENDPOINT_VERSION, "/").concat(_constants.USER, "/").concat(this.userId, "/").concat(_constants2.CALLS, "/").concat(_constants2.MESSAGE_SUMMARY);
              _context5.next = 6;
              return this.webex.request({
                uri: "".concat(voicemailSummaryUrl),
                method: _types.HTTP_METHODS.GET,
                headers: _objectSpread({}, this.authHeaders)
              });
            case 6:
              response = _context5.sent;
              parser = new DOMParser();
              xmlDOM = parser.parseFromString(response[_constants.RAW_REQUEST].response, _constants.XML_TYPE);
              voicemailSummary = xmlDOM.getElementsByTagName(_constants2.SUMMARY)[0];
              newMessages = voicemailSummary.getElementsByTagName(_constants2.NEW_MESSAGES)[0];
              newUrgentMessages = voicemailSummary.getElementsByTagName(_constants2.NEW_URGENT_MESSAGES)[0];
              oldMessages = voicemailSummary.getElementsByTagName(_constants2.OLD_MESSAGES)[0];
              oldUrgentMessages = voicemailSummary.getElementsByTagName(_constants2.OLD_URGENT_MESSAGES)[0];
              responseDetails = {
                statusCode: Number(response.statusCode),
                data: {
                  voicemailSummary: {
                    newMessages: newMessages ? Number(newMessages.textContent) : 0,
                    newUrgentMessages: newUrgentMessages ? Number(newUrgentMessages.textContent) : 0,
                    oldMessages: oldMessages ? Number(oldMessages.textContent) : 0,
                    oldUrgentMessages: oldUrgentMessages ? Number(oldUrgentMessages.textContent) : 0
                  }
                },
                message: _constants.SUCCESS_MESSAGE
              };
              _Logger.default.log('Successfully fetched voicemail summary', loggerContext);
              return _context5.abrupt("return", responseDetails);
            case 19:
              _context5.prev = 19;
              _context5.t0 = _context5["catch"](2);
              errorInfo = _context5.t0;
              extendedError = new Error("Failed to get voicemail summary: ".concat(_context5.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context5.next = 26;
              return (0, _Utils.uploadLogs)();
            case 26:
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context5.abrupt("return", errorStatus);
            case 28:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[2, 19]]);
      }));
      function getVoicemailSummary() {
        return _getVoicemailSummary.apply(this, arguments);
      }
      return getVoicemailSummary;
    }()
    /**
     * Fetch voicemail read message status for the messageId.
     *
     * @param messageId -string result from the voicemail list.
     * @returns Promise.
     */
    )
  }, {
    key: "voicemailMarkAsRead",
    value: (function () {
      var _voicemailMarkAsRead = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(messageId) {
        var loggerContext, voicemailContentUrl, response, responseDetails, errorInfo, extendedError, errorStatus;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              loggerContext = {
                file: _constants.WEBEX_CALLING_CONNECTOR_FILE,
                method: _constants2.METHODS.VOICEMAIL_MARK_AS_READ
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with messageId: ").concat(messageId), loggerContext);
              _context6.prev = 2;
              voicemailContentUrl = "".concat(this.xsiEndpoint).concat(messageId, "/").concat(_constants2.MARK_AS_READ);
              _context6.next = 6;
              return this.webex.request({
                uri: voicemailContentUrl,
                method: _types.HTTP_METHODS.PUT,
                headers: _objectSpread({}, this.authHeaders)
              });
            case 6:
              response = _context6.sent;
              responseDetails = {
                statusCode: Number(response.statusCode),
                data: {},
                message: _constants.SUCCESS_MESSAGE
              };
              _Logger.default.log('Successfully marked voicemail as read', loggerContext);
              return _context6.abrupt("return", responseDetails);
            case 12:
              _context6.prev = 12;
              _context6.t0 = _context6["catch"](2);
              errorInfo = _context6.t0;
              extendedError = new Error("Failed to mark voicemail as read: ".concat(_context6.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context6.next = 19;
              return (0, _Utils.uploadLogs)();
            case 19:
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context6.abrupt("return", errorStatus);
            case 21:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[2, 12]]);
      }));
      function voicemailMarkAsRead(_x6) {
        return _voicemailMarkAsRead.apply(this, arguments);
      }
      return voicemailMarkAsRead;
    }()
    /**
     * Fetch voicemail unread message status for the messageId.
     *
     * @param messageId -string result from the voicemail list.
     * @returns Promise.
     */
    )
  }, {
    key: "voicemailMarkAsUnread",
    value: (function () {
      var _voicemailMarkAsUnread = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(messageId) {
        var loggerContext, voicemailContentUrl, response, responseDetails, errorInfo, extendedError, errorStatus;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              loggerContext = {
                file: _constants.WEBEX_CALLING_CONNECTOR_FILE,
                method: _constants2.METHODS.VOICEMAIL_MARK_AS_UNREAD
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with messageId: ").concat(messageId), loggerContext);
              _context7.prev = 2;
              voicemailContentUrl = "".concat(this.xsiEndpoint).concat(messageId, "/").concat(_constants2.MARK_AS_UNREAD);
              _context7.next = 6;
              return this.webex.request({
                uri: voicemailContentUrl,
                method: _types.HTTP_METHODS.PUT,
                headers: _objectSpread({}, this.authHeaders)
              });
            case 6:
              response = _context7.sent;
              responseDetails = {
                statusCode: Number(response.statusCode),
                data: {},
                message: _constants.SUCCESS_MESSAGE
              };
              _Logger.default.log('Successfully marked voicemail as unread', loggerContext);
              return _context7.abrupt("return", responseDetails);
            case 12:
              _context7.prev = 12;
              _context7.t0 = _context7["catch"](2);
              errorInfo = _context7.t0;
              extendedError = new Error("Failed to mark voicemail as unread: ".concat(_context7.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context7.next = 19;
              return (0, _Utils.uploadLogs)();
            case 19:
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context7.abrupt("return", errorStatus);
            case 21:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[2, 12]]);
      }));
      function voicemailMarkAsUnread(_x7) {
        return _voicemailMarkAsUnread.apply(this, arguments);
      }
      return voicemailMarkAsUnread;
    }()
    /**
     * Fetch voicemail delete status for the messageId.
     *
     * @param messageId -string result from the voicemail list.
     * @returns Promise.
     */
    )
  }, {
    key: "deleteVoicemail",
    value: (function () {
      var _deleteVoicemail = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(messageId) {
        var loggerContext, voicemailContentUrl, response, responseDetails, errorInfo, extendedError, errorStatus;
        return _regenerator.default.wrap(function _callee8$(_context8) {
          while (1) switch (_context8.prev = _context8.next) {
            case 0:
              loggerContext = {
                file: _constants.WEBEX_CALLING_CONNECTOR_FILE,
                method: _constants2.METHODS.DELETE_VOICEMAIL
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with messageId: ").concat(messageId), loggerContext);
              _context8.prev = 2;
              voicemailContentUrl = "".concat(this.xsiEndpoint).concat(messageId);
              _context8.next = 6;
              return this.webex.request({
                uri: voicemailContentUrl,
                method: _types.HTTP_METHODS.DELETE,
                headers: _objectSpread({}, this.authHeaders)
              });
            case 6:
              response = _context8.sent;
              responseDetails = {
                statusCode: Number(response.statusCode),
                data: {},
                message: _constants.SUCCESS_MESSAGE
              };
              _Logger.default.log('Successfully deleted voicemail', loggerContext);
              return _context8.abrupt("return", responseDetails);
            case 12:
              _context8.prev = 12;
              _context8.t0 = _context8["catch"](2);
              errorInfo = _context8.t0;
              extendedError = new Error("Failed to delete voicemail: ".concat(_context8.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context8.next = 19;
              return (0, _Utils.uploadLogs)();
            case 19:
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context8.abrupt("return", errorStatus);
            case 21:
            case "end":
              return _context8.stop();
          }
        }, _callee8, this, [[2, 12]]);
      }));
      function deleteVoicemail(_x8) {
        return _deleteVoicemail.apply(this, arguments);
      }
      return deleteVoicemail;
    }()
    /**
     * Fetch voicemail transcript for the messageId.
     *
     * @param messageId - MessageId to fetch voicemail transcript.
     * @returns Promise.
     */
    )
  }, {
    key: "getVMTranscript",
    value: (function () {
      var _getVMTranscript = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9(messageId) {
        var loggerContext, voicemailContentUrl, response, parser, xmlDOM, status, transcript, responseDetails, errorInfo, extendedError, errorStatus;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              loggerContext = {
                file: _constants.WEBEX_CALLING_CONNECTOR_FILE,
                method: _constants2.METHODS.GET_VM_TRANSCRIPT
              };
              _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with messageId: ").concat(messageId), loggerContext);
              _context9.prev = 2;
              voicemailContentUrl = "".concat(this.xsiEndpoint).concat(messageId, "/").concat(_constants.TRANSCRIPT);
              _context9.next = 6;
              return this.webex.request({
                uri: voicemailContentUrl,
                method: _types.HTTP_METHODS.GET,
                headers: _objectSpread({}, this.authHeaders)
              });
            case 6:
              response = _context9.sent;
              parser = new DOMParser();
              xmlDOM = parser.parseFromString(response[_constants.RAW_REQUEST].response, _constants.XML_TYPE);
              status = xmlDOM.getElementsByTagName(_constants2.TRANSCRIPT_STATUS)[0];
              transcript = xmlDOM.getElementsByTagName(_constants2.TRANSCRIPT_CONTENT)[0];
              responseDetails = {
                statusCode: Number(response.statusCode),
                data: {
                  voicemailTranscript: transcript === null || transcript === void 0 ? void 0 : transcript.textContent
                },
                message: status.textContent
              };
              _Logger.default.log('Successfully fetched voicemail transcript', loggerContext);
              return _context9.abrupt("return", responseDetails);
            case 16:
              _context9.prev = 16;
              _context9.t0 = _context9["catch"](2);
              errorInfo = _context9.t0;
              extendedError = new Error("Failed to get voicemail transcript: ".concat(_context9.t0));
              _Logger.default.error(extendedError, loggerContext);
              _context9.next = 23;
              return (0, _Utils.uploadLogs)();
            case 23:
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context9.abrupt("return", errorStatus);
            case 25:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this, [[2, 16]]);
      }));
      function getVMTranscript(_x9) {
        return _getVMTranscript.apply(this, arguments);
      }
      return getVMTranscript;
    }()
    /**
     * Resolve the Contact from userId or display name.
     *
     * @param callingPartyInfo - Calling Party Info.
     */
    )
  }, {
    key: "resolveContact",
    value: function resolveContact(callingPartyInfo) {
      return (0, _Utils.resolveContact)(callingPartyInfo);
    }

    /**
     * Generates authorization headers based on the current Webex configuration.
     *
     * @returns A promise that resolves to a headers object containing the
     */
  }, {
    key: "getAuthHeaders",
    value: (function () {
      var _getAuthHeaders = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
        var _this$webex, _this$webex$config;
        var headers;
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              headers = {};
              if (!((_this$webex = this.webex) !== null && _this$webex !== void 0 && (_this$webex$config = _this$webex.config) !== null && _this$webex$config !== void 0 && _this$webex$config.fedramp)) {
                _context10.next = 5;
                break;
              }
              _context10.next = 4;
              return this.webex.credentials.getUserToken();
            case 4:
              headers.Authorization = _context10.sent;
            case 5:
              return _context10.abrupt("return", headers);
            case 6:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function getAuthHeaders() {
        return _getAuthHeaders.apply(this, arguments);
      }
      return getAuthHeaders;
    }())
  }]);
  return WxCallBackendConnector;
}();
//# sourceMappingURL=WxCallBackendConnector.js.map
