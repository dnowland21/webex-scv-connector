"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _types = require("../Logger/types");
var _testUtil = require("../common/testUtil");
var _types2 = require("../common/types");
var _voicemailFixture = require("./voicemailFixture");
var _UcmBackendConnector = require("./UcmBackendConnector");
var utils = _interopRequireWildcard(require("../common/Utils"));
var _constants = require("../common/constants");
var _Logger = _interopRequireDefault(require("../Logger"));
var _constants2 = require("./constants");
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; } /* eslint-disable dot-notation */
var ucmBackendConnector;
var webex = (0, _testUtil.getTestUtilsWebex)();
var voicemailPayload;
var serviceErrorCodeHandlerSpy;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
var sdkConnector;
var messageId = _voicemailFixture.mockUCMVoicemailBody.body.items['messageId'];
var logSpy;
var infoSpy;
var warnSpy;
var errorSpy;
jest.spyOn(utils, 'uploadLogs').mockResolvedValue(undefined);
describe('Voicemail UCM Backend Connector Test case', function () {
  var responseDetails = {
    statusCode: 200,
    message: _constants.SUCCESS_MESSAGE,
    data: {}
  };
  var voicemailResponseInfo = _voicemailFixture.getDescVoiceMailListJsonUCM.body.Message;
  var listResponseDetails = {
    statusCode: 200,
    data: voicemailResponseInfo,
    message: _constants.SUCCESS_MESSAGE
  };
  beforeAll(function () {
    webex.version = '2.31.1';
    webex.internal.device.version = '2.31.1';
    webex.internal.device.features.entitlement.models = [{
      _values: {
        key: 'ucm-calling'
      }
    }];
    webex.internal.device.callingBehavior = 'NATIVE_SIP_CALL_TO_UCM';
    ucmBackendConnector = new _UcmBackendConnector.UcmBackendConnector(webex, {
      level: _types.LOGGER.INFO
    });
    ucmBackendConnector.init();
    sdkConnector = ucmBackendConnector.getSDKConnector();
    voicemailPayload = _voicemailFixture.getVoiceMailListJsonUCM;
  });
  beforeEach(function () {
    logSpy = jest.spyOn(_Logger.default, 'log');
    infoSpy = jest.spyOn(_Logger.default, 'info');
    warnSpy = jest.spyOn(_Logger.default, 'warn');
    errorSpy = jest.spyOn(_Logger.default, 'error');
  });
  afterEach(function () {
    jest.clearAllMocks();
  });
  it('verify UCM Backend Connector object', function () {
    expect(ucmBackendConnector.getSDKConnector().getWebex()).toBeTruthy();
    expect(ucmBackendConnector.getSDKConnector().getWebex().internal.device.userId).toBe('8a67806f-fc4d-446b-a131-31e71ea5b0e9');
  });
  it('verify fetching transcript returned null', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
    var response;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return ucmBackendConnector.getVMTranscript('98099432-9d81-4224-bd04-00def73cd262');
        case 2:
          response = _context.sent;
          expect(response).toBeNull();
          expect(infoSpy).toHaveBeenCalledWith('Message Id: 98099432-9d81-4224-bd04-00def73cd262', {});
        case 5:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })));
  it('verify successful voicemail list', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
    var response;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          webex.request.mockResolvedValueOnce(voicemailPayload);
          _context2.next = 3;
          return ucmBackendConnector.getVoicemailList(0, 20, _types2.SORT.DESC);
        case 3:
          response = _context2.sent;
          expect(response).toStrictEqual(listResponseDetails);
          expect(webex.request).toBeCalledOnceWith({
            headers: {
              orgId: _voicemailFixture.orgId
            },
            method: _types2.HTTP_METHODS.GET,
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl + _voicemailFixture.voicemailContent)
          });
          expect(infoSpy).toHaveBeenCalledWith('invoking with Offset: 0 Offset limit: 20 Sort type:DESC', {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.GET_VOICEMAIL_LIST
          });
          expect(logSpy).toHaveBeenCalledWith('Successfully retrieved voicemail list', {
            file: 'UcmBackendConnector',
            method: 'getVoicemailList'
          });
          expect(warnSpy).not.toHaveBeenCalled();
          expect(errorSpy).not.toHaveBeenCalled();
        case 10:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  })));
  it('verify successful voicemailContent', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
    var voiceMailPayload, response, voicemailContentResponse, vmResponseDetails;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          voiceMailPayload = _voicemailFixture.mockVoicemailContentResponse;
          webex.request.mockResolvedValueOnce(voiceMailPayload);
          _context3.next = 4;
          return ucmBackendConnector.getVoicemailContent(messageId);
        case 4:
          response = _context3.sent.data;
          voicemailContentResponse = _voicemailFixture.voicemailContent;
          vmResponseDetails = {
            voicemailContent: {
              type: 'audio/wav',
              content: voicemailContentResponse
            }
          };
          expect(response).toStrictEqual(vmResponseDetails);
          expect(webex.request).toBeCalledOnceWith({
            headers: {
              orgId: _voicemailFixture.orgId,
              deviceUrl: webex.internal.device.url,
              mercuryHostname: webex.internal.services._serviceUrls.mercuryApi
            },
            method: _types2.HTTP_METHODS.GET,
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId, "/").concat(_constants.CONTENT)
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.GET_VOICEMAIL_CONTENT
          });
          expect(logSpy).toHaveBeenCalledWith("Successfully retrieved voicemail content with  Message ID: ".concat(messageId), {
            file: 'UcmBackendConnector',
            method: 'getVoicemailContent'
          });
        case 11:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  })));
  it('verify successful voicemailMarkAsRead', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
    var response;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          webex.request.mockResolvedValueOnce(voicemailPayload);
          _context4.next = 3;
          return ucmBackendConnector.voicemailMarkAsRead(messageId);
        case 3:
          response = _context4.sent;
          expect(response).toStrictEqual(responseDetails);
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId),
            method: _types2.HTTP_METHODS.PUT,
            headers: {
              orgId: _voicemailFixture.orgId
            },
            body: {
              read: 'true'
            }
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.VOICEMAIL_MARK_AS_READ
          });
          expect(logSpy).toHaveBeenCalledWith('Successfully marked voicemail as read', {
            file: 'UcmBackendConnector',
            method: 'voicemailMarkAsRead'
          });
        case 8:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  })));
  it('verify successful voicemailMarkAsUnread', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
    var response;
    return _regenerator.default.wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          webex.request.mockResolvedValueOnce(voicemailPayload);
          _context5.next = 3;
          return ucmBackendConnector.voicemailMarkAsUnread(messageId);
        case 3:
          response = _context5.sent;
          expect(response).toStrictEqual(responseDetails);
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId),
            method: _types2.HTTP_METHODS.PUT,
            headers: {
              orgId: _voicemailFixture.orgId
            },
            body: {
              read: 'false'
            }
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.VOICEMAIL_MARK_AS_UNREAD
          });
          expect(logSpy).toHaveBeenCalledWith('Successfully marked voicemail as unread', {
            file: 'UcmBackendConnector',
            method: 'voicemailMarkAsUnread'
          });
        case 8:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  })));
  it('verify successful deleteVoicemail', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
    var response;
    return _regenerator.default.wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          webex.request.mockResolvedValueOnce(voicemailPayload);
          _context6.next = 3;
          return ucmBackendConnector.deleteVoicemail(messageId);
        case 3:
          response = _context6.sent;
          expect(response).toStrictEqual(responseDetails);
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId),
            method: _types2.HTTP_METHODS.DELETE,
            headers: {
              orgId: _voicemailFixture.orgId
            }
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.DELETE_VOICEMAIL
          });
          expect(logSpy).toHaveBeenCalledWith('Successfully deleted voicemail', {
            file: 'UcmBackendConnector',
            method: 'deleteVoicemail'
          });
        case 8:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  })));
  it('verify resolution of contact to null', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
    var response;
    return _regenerator.default.wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          _context7.next = 2;
          return ucmBackendConnector.resolveContact(_voicemailFixture.resolveContactArgs);
        case 2:
          response = _context7.sent;
          expect(response).toBeNull();
          expect(infoSpy).toHaveBeenCalledWith("Calling Party Info: ".concat(_voicemailFixture.resolveContactArgs), {});
        case 5:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  })));
});
describe('Voicemail failure tests for UCM', function () {
  var responseDetails = {
    statusCode: 400,
    data: {
      error: '400 Bad request'
    },
    message: _constants.FAILURE_MESSAGE
  };
  var responseDetails401 = {
    statusCode: 401,
    data: {
      error: 'User is unauthorised, possible token expiry'
    },
    message: _constants.FAILURE_MESSAGE
  };
  var failurePayload = {
    statusCode: 400
  };
  var failurePayload401 = {
    statusCode: 401
  };
  beforeAll(function () {
    webex.version = '2.31.1';
    webex.internal.device.version = '2.31.1';
    webex.internal.device.features.entitlement.models = [{
      _values: {
        key: 'ucm-calling'
      }
    }];
    webex.internal.device.callingBehavior = 'NATIVE_SIP_CALL_TO_UCM';
    ucmBackendConnector = new _UcmBackendConnector.UcmBackendConnector(webex, {
      level: _types.LOGGER.INFO
    });
    ucmBackendConnector.init();
    voicemailPayload = _voicemailFixture.getVoiceMailListJsonUCM;
  });
  beforeEach(function () {
    serviceErrorCodeHandlerSpy = jest.spyOn(utils, 'serviceErrorCodeHandler');
    logSpy = jest.spyOn(_Logger.default, 'log');
    infoSpy = jest.spyOn(_Logger.default, 'info');
    warnSpy = jest.spyOn(_Logger.default, 'warn');
    errorSpy = jest.spyOn(_Logger.default, 'error');
  });
  afterEach(function () {
    jest.clearAllMocks();
  });
  it('verify failure voicemail listing when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
    var response;
    return _regenerator.default.wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          webex.request.mockRejectedValueOnce(failurePayload);
          _context8.next = 3;
          return ucmBackendConnector.getVoicemailList(0, 20, _types2.SORT.DESC);
        case 3:
          response = _context8.sent;
          expect(response).toStrictEqual(responseDetails);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
            statusCode: 400
          }, {
            file: 'UcmBackendConnector',
            method: 'getVoicemailList'
          });
          expect(webex.request).toBeCalledOnceWith({
            headers: {
              orgId: _voicemailFixture.orgId
            },
            method: _types2.HTTP_METHODS.GET,
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl + _voicemailFixture.voicemailContent)
          });
          expect(infoSpy).toHaveBeenCalledWith('invoking with Offset: 0 Offset limit: 20 Sort type:DESC', {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.GET_VOICEMAIL_LIST
          });
          expect(errorSpy).toHaveBeenCalled();
        case 9:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  })));
  it('verify failure voicemailContent when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
    var vmContentSpy, failurePayload422, response;
    return _regenerator.default.wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          vmContentSpy = jest.spyOn(ucmBackendConnector, 'getVoicemailContent');
          failurePayload422 = {
            statusCode: _constants.UNPROCESSABLE_CONTENT_CODE
          };
          webex.request.mockRejectedValue(failurePayload422);
          _context9.next = 5;
          return ucmBackendConnector.getVoicemailContent(messageId);
        case 5:
          response = _context9.sent;
          expect(vmContentSpy).toBeCalledTimes(1);
          expect(response).toStrictEqual(_voicemailFixture.responseDetails422);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
            statusCode: _constants.UNPROCESSABLE_CONTENT_CODE
          }, {
            file: 'UcmBackendConnector',
            method: 'getVoicemailContent'
          });
          expect(webex.request).toBeCalledOnceWith({
            headers: {
              orgId: _voicemailFixture.orgId,
              deviceUrl: webex.internal.device.url,
              mercuryHostname: webex.internal.services._serviceUrls.mercuryApi
            },
            method: _types2.HTTP_METHODS.GET,
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId, "/").concat(_constants.CONTENT)
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.GET_VOICEMAIL_CONTENT
          });
          expect(errorSpy).toHaveBeenCalled();
        case 12:
        case "end":
          return _context9.stop();
      }
    }, _callee9);
  })));
  it('verify failure voicemailContent when failure voicemail api response received', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
    var vmContentSpy, failureVoicemailResponse, response, failureVmResponseDetails;
    return _regenerator.default.wrap(function _callee10$(_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          vmContentSpy = jest.spyOn(ucmBackendConnector, 'getVoicemailContent');
          failureVoicemailResponse = {
            statusCode: 204
          };
          webex.request.mockResolvedValueOnce(failureVoicemailResponse);
          _context10.next = 5;
          return ucmBackendConnector.getVoicemailContent(messageId);
        case 5:
          response = _context10.sent;
          failureVmResponseDetails = _objectSpread({
            data: {
              voicemailContent: {
                type: undefined,
                content: undefined
              }
            },
            message: _constants.FAILURE_MESSAGE
          }, failureVoicemailResponse);
          expect(vmContentSpy).toBeCalledTimes(1);
          expect(response).toStrictEqual(_voicemailFixture.responseDetails204);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith(failureVmResponseDetails, {
            file: 'UcmBackendConnector',
            method: 'getVoicemailContent'
          });
          expect(webex.request).toBeCalledOnceWith({
            headers: {
              orgId: _voicemailFixture.orgId,
              deviceUrl: webex.internal.device.url,
              mercuryHostname: webex.internal.services._serviceUrls.mercuryApi
            },
            method: _types2.HTTP_METHODS.GET,
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId, "/").concat(_constants.CONTENT)
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.GET_VOICEMAIL_CONTENT
          });
        case 12:
        case "end":
          return _context10.stop();
      }
    }, _callee10);
  })));
  it('verify failure voicemailMarkAsRead when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
    var response;
    return _regenerator.default.wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          webex.request.mockRejectedValue(failurePayload);
          _context11.next = 3;
          return ucmBackendConnector.voicemailMarkAsRead(messageId);
        case 3:
          response = _context11.sent;
          expect(response).toStrictEqual(responseDetails);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
            statusCode: 400
          }, {
            file: 'UcmBackendConnector',
            method: 'voicemailMarkAsRead'
          });
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId),
            method: _types2.HTTP_METHODS.PUT,
            headers: {
              orgId: _voicemailFixture.orgId
            },
            body: {
              read: 'true'
            }
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.VOICEMAIL_MARK_AS_READ
          });
          expect(errorSpy).toHaveBeenCalled();
        case 9:
        case "end":
          return _context11.stop();
      }
    }, _callee11);
  })));
  it('verify failure voicemailMarkAsUnread when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
    var response;
    return _regenerator.default.wrap(function _callee12$(_context12) {
      while (1) switch (_context12.prev = _context12.next) {
        case 0:
          webex.request.mockRejectedValue(failurePayload);
          _context12.next = 3;
          return ucmBackendConnector.voicemailMarkAsUnread(messageId);
        case 3:
          response = _context12.sent;
          expect(response).toStrictEqual(responseDetails);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
            statusCode: 400
          }, {
            file: 'UcmBackendConnector',
            method: 'voicemailMarkAsUnread'
          });
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId),
            method: _types2.HTTP_METHODS.PUT,
            headers: {
              orgId: _voicemailFixture.orgId
            },
            body: {
              read: 'false'
            }
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.VOICEMAIL_MARK_AS_UNREAD
          });
          expect(errorSpy).toHaveBeenCalled();
        case 9:
        case "end":
          return _context12.stop();
      }
    }, _callee12);
  })));
  it('verify failure delete voicemail when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
    var response;
    return _regenerator.default.wrap(function _callee13$(_context13) {
      while (1) switch (_context13.prev = _context13.next) {
        case 0:
          webex.request.mockRejectedValue(failurePayload);
          _context13.next = 3;
          return ucmBackendConnector.deleteVoicemail(messageId);
        case 3:
          response = _context13.sent;
          expect(response).toStrictEqual(responseDetails);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
            statusCode: 400
          }, {
            file: 'UcmBackendConnector',
            method: 'deleteVoicemail'
          });
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId),
            method: _types2.HTTP_METHODS.DELETE,
            headers: {
              orgId: _voicemailFixture.orgId
            }
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.DELETE_VOICEMAIL
          });
          expect(errorSpy).toHaveBeenCalled();
        case 9:
        case "end":
          return _context13.stop();
      }
    }, _callee13);
  })));
  it('verify failure voicemail listing when user is unauthorised, possible token expiry', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14() {
    var response;
    return _regenerator.default.wrap(function _callee14$(_context14) {
      while (1) switch (_context14.prev = _context14.next) {
        case 0:
          webex.request.mockRejectedValue(failurePayload401);
          _context14.next = 3;
          return ucmBackendConnector.getVoicemailList(0, 20, _types2.SORT.DESC);
        case 3:
          response = _context14.sent;
          expect(response).toStrictEqual(responseDetails401);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
            statusCode: 401
          }, {
            file: 'UcmBackendConnector',
            method: 'getVoicemailList'
          });
          expect(webex.request).toBeCalledOnceWith({
            headers: {
              orgId: _voicemailFixture.orgId
            },
            method: _types2.HTTP_METHODS.GET,
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl + _voicemailFixture.voicemailContent)
          });
          expect(infoSpy).toHaveBeenCalledWith('invoking with Offset: 0 Offset limit: 20 Sort type:DESC', {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.GET_VOICEMAIL_LIST
          });
          expect(errorSpy).toHaveBeenCalled();
        case 9:
        case "end":
          return _context14.stop();
      }
    }, _callee14);
  })));
  it('verify failure voicemailMarkAsRead when user is unauthorised, possible token expiry', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15() {
    var response;
    return _regenerator.default.wrap(function _callee15$(_context15) {
      while (1) switch (_context15.prev = _context15.next) {
        case 0:
          webex.request.mockRejectedValue(failurePayload401);
          _context15.next = 3;
          return ucmBackendConnector.voicemailMarkAsRead(messageId);
        case 3:
          response = _context15.sent;
          expect(response).toStrictEqual(responseDetails401);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
            statusCode: 401
          }, {
            file: 'UcmBackendConnector',
            method: 'voicemailMarkAsRead'
          });
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId),
            method: _types2.HTTP_METHODS.PUT,
            headers: {
              orgId: _voicemailFixture.orgId
            },
            body: {
              read: 'true'
            }
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.VOICEMAIL_MARK_AS_READ
          });
          expect(errorSpy).toHaveBeenCalled();
        case 9:
        case "end":
          return _context15.stop();
      }
    }, _callee15);
  })));
  it('verify failure voicemailMarkAsUnread when user is unauthorised, possible token expiry', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16() {
    var response;
    return _regenerator.default.wrap(function _callee16$(_context16) {
      while (1) switch (_context16.prev = _context16.next) {
        case 0:
          webex.request.mockRejectedValue(failurePayload401);
          _context16.next = 3;
          return ucmBackendConnector.voicemailMarkAsUnread(messageId);
        case 3:
          response = _context16.sent;
          expect(response).toStrictEqual(responseDetails401);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
            statusCode: 401
          }, {
            file: 'UcmBackendConnector',
            method: 'voicemailMarkAsUnread'
          });
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId),
            method: _types2.HTTP_METHODS.PUT,
            headers: {
              orgId: _voicemailFixture.orgId
            },
            body: {
              read: 'false'
            }
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.VOICEMAIL_MARK_AS_UNREAD
          });
          expect(errorSpy).toHaveBeenCalled();
        case 9:
        case "end":
          return _context16.stop();
      }
    }, _callee16);
  })));
  it('verify failure delete voicemail when user is unauthorised, possible token expiry', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17() {
    var response;
    return _regenerator.default.wrap(function _callee17$(_context17) {
      while (1) switch (_context17.prev = _context17.next) {
        case 0:
          webex.request.mockRejectedValue(failurePayload401);
          _context17.next = 3;
          return ucmBackendConnector.deleteVoicemail(messageId);
        case 3:
          response = _context17.sent;
          expect(response).toStrictEqual(responseDetails401);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
            statusCode: 401
          }, {
            file: 'UcmBackendConnector',
            method: 'deleteVoicemail'
          });
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(_voicemailFixture.ucmBackendInfoUrl, "/").concat(messageId),
            method: _types2.HTTP_METHODS.DELETE,
            headers: {
              orgId: _voicemailFixture.orgId
            }
          });
          expect(infoSpy).toHaveBeenCalledWith("".concat(_constants.METHOD_START_MESSAGE, " with Message ID: ").concat(messageId), {
            file: 'UcmBackendConnector',
            method: _constants2.METHODS.DELETE_VOICEMAIL
          });
          expect(errorSpy).toHaveBeenCalled();
        case 9:
        case "end":
          return _context17.stop();
      }
    }, _callee17);
  })));
  it('verify fetching voicemail summary returned to be null', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18() {
    var response;
    return _regenerator.default.wrap(function _callee18$(_context18) {
      while (1) switch (_context18.prev = _context18.next) {
        case 0:
          _context18.next = 2;
          return ucmBackendConnector.getVoicemailSummary();
        case 2:
          response = _context18.sent;
          expect(response).toBeNull();
        case 4:
        case "end":
          return _context18.stop();
      }
    }, _callee18);
  })));
});
//# sourceMappingURL=UcmBackendConnector.test.js.map
