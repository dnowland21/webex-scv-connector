"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _types = require("../Logger/types");
var _testUtil = require("../common/testUtil");
var _types2 = require("../common/types");
var _constants = require("./constants");
var _Logger = _interopRequireDefault(require("../Logger"));
var _voicemailFixture = require("./voicemailFixture");
var _WxCallBackendConnector = require("./WxCallBackendConnector");
var utils = _interopRequireWildcard(require("../common/Utils"));
var _constants2 = require("../common/constants");
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; } /* eslint-disable dot-notation */
jest.spyOn(utils, 'uploadLogs').mockResolvedValue(undefined);
describe('Voicemail webex call Backend Connector Test case', function () {
  var wxCallBackendConnector;
  var webex = (0, _testUtil.getTestUtilsWebex)();
  var CONTEXT = 'context';
  var getSortedVoicemailListSpy;
  var storeVoicemailListSpy;
  var fetchVoicemailListSpy;
  var infoSpy;
  var errorSpy;
  var logSpy;
  var messageId = _voicemailFixture.mockVoicemailBody.body.items[0].messageId;
  beforeAll(function () {
    wxCallBackendConnector = new _WxCallBackendConnector.WxCallBackendConnector(webex, {
      level: _types.LOGGER.INFO
    });
    wxCallBackendConnector.init();
    wxCallBackendConnector['context'] = CONTEXT;
    wxCallBackendConnector.getSDKConnector();
  });
  beforeEach(function () {
    getSortedVoicemailListSpy = jest.spyOn(utils, 'getSortedVoicemailList');
    storeVoicemailListSpy = jest.spyOn(utils, 'storeVoicemailList');
    fetchVoicemailListSpy = jest.spyOn(utils, 'fetchVoicemailList');
    infoSpy = jest.spyOn(_Logger.default, 'info');
    errorSpy = jest.spyOn(_Logger.default, 'error');
    logSpy = jest.spyOn(_Logger.default, 'log');
  });
  describe('Voicemail failure tests for webex call', function () {
    var FAILURE = 'FAILURE';
    var serviceErrorCodeHandlerSpy;
    beforeAll(function () {
      var voiceMailPayload = _voicemailFixture.mockWXCData;
      webex.request.mockResolvedValueOnce(voiceMailPayload);
      wxCallBackendConnector.init();
    });
    beforeEach(function () {
      serviceErrorCodeHandlerSpy = jest.spyOn(utils, 'serviceErrorCodeHandler');
    });
    afterEach(function () {
      expect(getSortedVoicemailListSpy).not.toBeCalled();
      expect(storeVoicemailListSpy).not.toBeCalled();
      expect(fetchVoicemailListSpy).not.toBeCalled();
    });
    it('verify failure voicemail listing when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
      var failurePayload, response, responseDetails;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            failurePayload = {
              statusCode: 400
            };
            webex.request.mockRejectedValueOnce(failurePayload);
            _context.next = 4;
            return wxCallBackendConnector.getVoicemailList(0, 20, _types2.SORT.DESC, true);
          case 4:
            response = _context.sent;
            responseDetails = {
              statusCode: 400,
              data: {
                error: '400 Bad request'
              },
              message: FAILURE
            };
            expect(response).toStrictEqual(responseDetails);
            expect(response.message).toBe(FAILURE);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            });
            expect(infoSpy).toHaveBeenCalledWith('invoking with Offset: 0 Offset limit: 20 Sort type:DESC', expect.objectContaining({
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            }));
            expect(errorSpy).toHaveBeenCalledWith(expect.any(Error), expect.objectContaining({
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            }));
          case 11:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })));
    it('verify failure voicemailMarkAsRead when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
      var failurePayload, responseDetails, response;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            failurePayload = {
              statusCode: 400
            };
            webex.request.mockRejectedValue(failurePayload);
            responseDetails = {
              statusCode: 400,
              data: {
                error: '400 Bad request'
              },
              message: FAILURE
            };
            _context2.next = 5;
            return wxCallBackendConnector.voicemailMarkAsRead(messageId.$);
          case 5:
            response = _context2.sent;
            expect(response).toStrictEqual(responseDetails);
            expect(response.message).toBe(FAILURE);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, {
              file: 'WxCallBackendConnector',
              method: 'voicemailMarkAsRead'
            });
            expect(infoSpy).toHaveBeenCalledWith("".concat(_constants2.METHOD_START_MESSAGE, " with messageId: ").concat(messageId.$), {
              file: 'WxCallBackendConnector',
              method: 'voicemailMarkAsRead'
            });
            expect(errorSpy).toHaveBeenNthCalledWith(1, expect.objectContaining({
              message: expect.stringContaining('Failed to mark voicemail as read')
            }), {
              file: 'WxCallBackendConnector',
              method: 'voicemailMarkAsRead'
            });
          case 11:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    })));
    it('verify failure voicemailMarkAsUnread when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
      var failurePayload, responseDetails, response;
      return _regenerator.default.wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            failurePayload = {
              statusCode: 400
            };
            webex.request.mockRejectedValue(failurePayload);
            responseDetails = {
              statusCode: 400,
              data: {
                error: '400 Bad request'
              },
              message: FAILURE
            };
            _context3.next = 5;
            return wxCallBackendConnector.voicemailMarkAsUnread(messageId.$);
          case 5:
            response = _context3.sent;
            expect(response).toStrictEqual(responseDetails);
            expect(response.message).toBe(FAILURE);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, {
              file: 'WxCallBackendConnector',
              method: 'voicemailMarkAsUnread'
            });
            expect(infoSpy).toHaveBeenCalledWith("".concat(_constants2.METHOD_START_MESSAGE, " with messageId: ").concat(messageId.$), {
              file: 'WxCallBackendConnector',
              method: 'voicemailMarkAsUnread'
            });
            expect(errorSpy).toHaveBeenNthCalledWith(1, expect.objectContaining({
              message: expect.stringContaining('Failed to mark voicemail as unread')
            }), {
              file: 'WxCallBackendConnector',
              method: 'voicemailMarkAsUnread'
            });
          case 11:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    })));
    it('verify failure delete Voicemail when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
      var failurePayload, responseDetails, response;
      return _regenerator.default.wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            failurePayload = {
              statusCode: 400
            };
            webex.request.mockRejectedValue(failurePayload);
            responseDetails = {
              statusCode: 400,
              data: {
                error: '400 Bad request'
              },
              message: FAILURE
            };
            _context4.next = 5;
            return wxCallBackendConnector.deleteVoicemail(messageId.$);
          case 5:
            response = _context4.sent;
            expect(response).toStrictEqual(responseDetails);
            expect(response.message).toBe(FAILURE);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, {
              file: 'WxCallBackendConnector',
              method: 'deleteVoicemail'
            });
            expect(infoSpy).toHaveBeenCalledWith("".concat(_constants2.METHOD_START_MESSAGE, " with messageId: ").concat(messageId.$), {
              file: 'WxCallBackendConnector',
              method: 'deleteVoicemail'
            });
            expect(errorSpy).toHaveBeenCalledWith(expect.objectContaining({
              message: expect.stringContaining('Failed to delete voicemail')
            }), {
              file: 'WxCallBackendConnector',
              method: 'deleteVoicemail'
            });
          case 11:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    })));
    it('verify failure for get transcript when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
      var failurePayload, responseDetails, response;
      return _regenerator.default.wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            failurePayload = {
              statusCode: 400
            };
            webex.request.mockRejectedValue(failurePayload);
            responseDetails = {
              statusCode: 400,
              data: {
                error: '400 Bad request'
              },
              message: FAILURE
            };
            _context5.next = 5;
            return wxCallBackendConnector.getVMTranscript(messageId.$);
          case 5:
            response = _context5.sent;
            expect(response).toStrictEqual(responseDetails);
            expect(response === null || response === void 0 ? void 0 : response.message).toBe(FAILURE);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, {
              file: 'WxCallBackendConnector',
              method: 'getVMTranscript'
            });
          case 9:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    })));
    it('verify failure voicemail listing when user is unauthorised, possible token expiry', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
      var failurePayload, response, responseDetails;
      return _regenerator.default.wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            failurePayload = {
              statusCode: 401
            };
            webex.request.mockRejectedValue(failurePayload);
            _context6.next = 4;
            return wxCallBackendConnector.getVoicemailList(0, 20, _types2.SORT.DESC, true);
          case 4:
            response = _context6.sent;
            responseDetails = {
              statusCode: 401,
              data: {
                error: 'User is unauthorised, possible token expiry'
              },
              message: FAILURE
            };
            expect(response).toStrictEqual(responseDetails);
            expect(response.message).toBe(FAILURE);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 401
            }, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            });
          case 9:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    })));
    it('verify failure voicemailMarkAsRead when user is unauthorised, possible token expiry', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
      var failurePayload, responseDetails, response;
      return _regenerator.default.wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            failurePayload = {
              statusCode: 401
            };
            webex.request.mockRejectedValue(failurePayload);
            responseDetails = {
              statusCode: 401,
              data: {
                error: 'User is unauthorised, possible token expiry'
              },
              message: FAILURE
            };
            _context7.next = 5;
            return wxCallBackendConnector.voicemailMarkAsRead(messageId.$);
          case 5:
            response = _context7.sent;
            expect(response).toStrictEqual(responseDetails);
            expect(response.message).toBe(FAILURE);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 401
            }, {
              file: 'WxCallBackendConnector',
              method: 'voicemailMarkAsRead'
            });
          case 9:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    })));
    it('verify failure voicemailMarkAsUnread when user is unauthorised, possible token expiry', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
      var failurePayload, responseDetails, response;
      return _regenerator.default.wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            failurePayload = {
              statusCode: 401
            };
            webex.request.mockRejectedValue(failurePayload);
            responseDetails = {
              statusCode: 401,
              data: {
                error: 'User is unauthorised, possible token expiry'
              },
              message: FAILURE
            };
            _context8.next = 5;
            return wxCallBackendConnector.voicemailMarkAsUnread(messageId.$);
          case 5:
            response = _context8.sent;
            expect(response).toStrictEqual(responseDetails);
            expect(response.message).toBe(FAILURE);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 401
            }, {
              file: 'WxCallBackendConnector',
              method: 'voicemailMarkAsUnread'
            });
          case 9:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    })));
    it('verify failure delete Voicemail when user is unauthorised, possible token expiry', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
      var failurePayload, responseDetails, response;
      return _regenerator.default.wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            failurePayload = {
              statusCode: 401
            };
            webex.request.mockRejectedValue(failurePayload);
            responseDetails = {
              statusCode: 401,
              data: {
                error: 'User is unauthorised, possible token expiry'
              },
              message: FAILURE
            };
            _context9.next = 5;
            return wxCallBackendConnector.deleteVoicemail(messageId.$);
          case 5:
            response = _context9.sent;
            expect(response).toStrictEqual(responseDetails);
            expect(response.message).toBe(FAILURE);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 401
            }, {
              file: 'WxCallBackendConnector',
              method: 'deleteVoicemail'
            });
          case 9:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    })));
    it('verify failure for get transcript when user is unauthorised, possible token expiry', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
      var failurePayload, responseDetails, response;
      return _regenerator.default.wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            failurePayload = {
              statusCode: 401
            };
            webex.request.mockRejectedValue(failurePayload);
            responseDetails = {
              statusCode: 401,
              data: {
                error: 'User is unauthorised, possible token expiry'
              },
              message: FAILURE
            };
            _context10.next = 5;
            return wxCallBackendConnector.getVMTranscript(messageId.$);
          case 5:
            response = _context10.sent;
            expect(response).toStrictEqual(responseDetails);
            expect(response === null || response === void 0 ? void 0 : response.message).toBe(FAILURE);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 401
            }, {
              file: 'WxCallBackendConnector',
              method: 'getVMTranscript'
            });
          case 9:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    })));
    it('verify failure voicemail summary when bad request occur', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
      var failurePayload, response, responseDetails;
      return _regenerator.default.wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            failurePayload = {
              statusCode: 400
            };
            webex.request.mockRejectedValueOnce(failurePayload);
            _context11.next = 4;
            return wxCallBackendConnector.getVoicemailSummary();
          case 4:
            response = _context11.sent;
            responseDetails = {
              statusCode: 400,
              data: {
                error: '400 Bad request'
              },
              message: FAILURE
            };
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: _voicemailFixture.voicemailSummaryUrl,
              headers: {}
            });
            expect(response).toStrictEqual(responseDetails);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailSummary'
            });
            expect(infoSpy).toHaveBeenCalledWith(_constants2.METHOD_START_MESSAGE, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailSummary'
            });
            expect(errorSpy).toHaveBeenCalledWith(expect.any(Error), expect.objectContaining({
              file: 'WxCallBackendConnector',
              method: 'getVoicemailSummary'
            }));
          case 11:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    })));
    it('verify failure case for the voicemail content when api response is invalid', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
      var xsiActionsEndpointUrl, response;
      return _regenerator.default.wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            webex.request.mockResolvedValueOnce({});
            xsiActionsEndpointUrl = _voicemailFixture.mockWXCData.body.items[0].xsiActionsEndpoint;
            _context12.next = 4;
            return wxCallBackendConnector.getVoicemailContent(messageId);
          case 4:
            response = _context12.sent;
            expect(response).toStrictEqual(_voicemailFixture.responseDetails422);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: "".concat(xsiActionsEndpointUrl).concat(messageId),
              headers: {}
            });
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith(expect.anything(), {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailContent'
            });
          case 8:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    })));
  });
  describe('Voicemail success tests for webex call', function () {
    var SUCCESS = 'SUCCESS';
    var EMPTY_SUCCESS_RESPONSE = {
      data: {},
      message: SUCCESS,
      statusCode: 200
    };
    afterEach(function () {
      jest.clearAllMocks();
    });
    it('verify successfully fetching voicemail summary with newMessages and newUrgentMessage', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
      var mockRawRequest, mockVoicemailSummary, voicemailSummary, response, voicemailSummaryResponseInfo, responseDetails;
      return _regenerator.default.wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            mockRawRequest = {
              response: "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VoiceMailMessageSummary xmlns=\"http://schema.broadsoft.com/xsi\"><summary><newMessages>2</newMessages><newUrgentMessages>1</newUrgentMessages></summary></VoiceMailMessageSummary>"
            };
            mockVoicemailSummary = {
              statusCode: 200,
              rawRequest: mockRawRequest
            };
            voicemailSummary = mockVoicemailSummary;
            webex.request.mockResolvedValueOnce(voicemailSummary);
            _context13.next = 6;
            return wxCallBackendConnector.getVoicemailSummary();
          case 6:
            response = _context13.sent;
            voicemailSummaryResponseInfo = {
              voicemailSummary: {
                newMessages: 2,
                newUrgentMessages: 1,
                oldMessages: 0,
                oldUrgentMessages: 0
              }
            };
            responseDetails = {
              data: voicemailSummaryResponseInfo,
              message: SUCCESS,
              statusCode: 200
            };
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: _voicemailFixture.voicemailSummaryUrl,
              headers: {}
            });
            expect(response).toStrictEqual(responseDetails);
            expect(infoSpy).toHaveBeenCalledWith(_constants2.METHOD_START_MESSAGE, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailSummary'
            });
            expect(logSpy).toHaveBeenCalledWith('Successfully fetched voicemail summary', {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailSummary'
            });
          case 13:
          case "end":
            return _context13.stop();
        }
      }, _callee13);
    })));
    it('verify successfully fetching voicemail summary with oldMessages and oldUrgentMessage', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14() {
      var mockRawRequest, mockVoicemailSummary, voicemailSummary, response, voicemailSummaryResponseInfo, responseDetails;
      return _regenerator.default.wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            mockRawRequest = {
              response: "<?xml version=\"1.0\" encoding=\"UTF-8\"?><VoiceMailMessageSummary xmlns=\"http://schema.broadsoft.com/xsi\"><summary><oldMessages>2</oldMessages><oldUrgentMessages>1</oldUrgentMessages></summary></VoiceMailMessageSummary>"
            };
            mockVoicemailSummary = {
              statusCode: 200,
              rawRequest: mockRawRequest
            };
            voicemailSummary = mockVoicemailSummary;
            webex.request.mockResolvedValueOnce(voicemailSummary);
            _context14.next = 6;
            return wxCallBackendConnector.getVoicemailSummary();
          case 6:
            response = _context14.sent;
            voicemailSummaryResponseInfo = {
              voicemailSummary: {
                newMessages: 0,
                newUrgentMessages: 0,
                oldMessages: 2,
                oldUrgentMessages: 1
              }
            };
            responseDetails = {
              data: voicemailSummaryResponseInfo,
              message: SUCCESS,
              statusCode: 200
            };
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: _voicemailFixture.voicemailSummaryUrl,
              headers: {}
            });
            expect(response).toStrictEqual(responseDetails);
          case 11:
          case "end":
            return _context14.stop();
        }
      }, _callee14);
    })));
    it('verify that PENDING transcription status is passed while transcribing is in progress in the backend', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15() {
      var pending, mockPendingResponse, mockVoicemailTranscript, voicemailTranscript, response, responseDetails;
      return _regenerator.default.wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            pending = 'PENDING';
            mockPendingResponse = {
              response: '<?xml version="1.0" encoding="UTF-8"?><VoiceMessageTranscript xmlns="http://schema.broadsoft.com/xsi"><status>PENDING</status></VoiceMessageTranscript>'
            };
            mockVoicemailTranscript = _objectSpread(_objectSpread({}, _voicemailFixture.mockVoicemailTranscriptResponse), {}, {
              rawRequest: mockPendingResponse
            });
            voicemailTranscript = mockVoicemailTranscript;
            webex.request.mockResolvedValueOnce(voicemailTranscript);
            _context15.next = 7;
            return wxCallBackendConnector.getVMTranscript('98099432-9d81-4224-bd04-00def73cd262');
          case 7:
            response = _context15.sent;
            responseDetails = {
              data: {
                voicemailTranscript: undefined
              },
              message: pending,
              statusCode: 200
            };
            expect(response === null || response === void 0 ? void 0 : response.message).toBe(pending);
            expect(response).toStrictEqual(responseDetails);
          case 11:
          case "end":
            return _context15.stop();
        }
      }, _callee15);
    })));
    it('verify successfully fetching voicemail transcript', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16() {
      var ready, mockRawRequest, mockVoicemailTranscript, voicemailTranscript, response, voicemailResponseInfo, responseDetails;
      return _regenerator.default.wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            ready = 'READY';
            mockRawRequest = {
              response: '<?xml version="1.0" encoding="UTF-8"?><VoiceMessageTranscript xmlns="http://schema.broadsoft.com/xsi"><status>READY</status><content lang="EN">Hi, uh, testing, voice mail script, so dropping this message to be able to fetch it later.</content></VoiceMessageTranscript>'
            };
            mockVoicemailTranscript = _objectSpread(_objectSpread({}, _voicemailFixture.mockVoicemailTranscriptResponse), {}, {
              rawRequest: mockRawRequest
            });
            voicemailTranscript = mockVoicemailTranscript;
            webex.request.mockResolvedValueOnce(voicemailTranscript);
            _context16.next = 7;
            return wxCallBackendConnector.getVMTranscript('98099432-9d81-4224-bd04-00def73cd262');
          case 7:
            response = _context16.sent;
            voicemailResponseInfo = {
              voicemailTranscript: 'Hi, uh, testing, voice mail script, so dropping this message to be able to fetch it later.'
            };
            responseDetails = {
              data: voicemailResponseInfo,
              message: ready,
              statusCode: 200
            };
            expect(response === null || response === void 0 ? void 0 : response.message).toBe(ready);
            expect(response).toStrictEqual(responseDetails);
          case 12:
          case "end":
            return _context16.stop();
        }
      }, _callee16);
    })));
    it('verify successful voicemail listing in descending order with offset 0 and limit 20', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17() {
      var voiceMailPayload, response, voicemailResponseInfo, responseDetails;
      return _regenerator.default.wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context17.next = 4;
            return wxCallBackendConnector.getVoicemailList(0, 20, _types2.SORT.DESC, true);
          case 4:
            response = _context17.sent;
            voicemailResponseInfo = {
              voicemailList: _voicemailFixture.getDescVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo
            };
            responseDetails = {
              data: voicemailResponseInfo,
              message: _constants.NO_VOICEMAIL_MSG,
              statusCode: _constants.NO_VOICEMAIL_STATUS_CODE
            };
            expect(response.message).toBe(_constants.NO_VOICEMAIL_MSG);
            expect(response).toStrictEqual(responseDetails);
            expect(getSortedVoicemailListSpy).toBeCalledOnceWith(voicemailResponseInfo.voicemailList, 'DESC');
            expect(storeVoicemailListSpy).toBeCalledOnceWith(CONTEXT, voicemailResponseInfo.voicemailList);
            expect(fetchVoicemailListSpy).toBeCalledOnceWith(CONTEXT, 0, 20, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            });
          case 12:
          case "end":
            return _context17.stop();
        }
      }, _callee17);
    })));
    it('verify successful voicemail listing in ascending order with offset 0 and limit 20', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18() {
      var voiceMailPayload, response, voicemailResponseInfo, responseDetails;
      return _regenerator.default.wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context18.next = 4;
            return wxCallBackendConnector.getVoicemailList(0, 20, _types2.SORT.ASC, true);
          case 4:
            response = _context18.sent;
            voicemailResponseInfo = {
              voicemailList: _voicemailFixture.getAscVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo
            };
            responseDetails = {
              data: voicemailResponseInfo,
              message: _constants.NO_VOICEMAIL_MSG,
              statusCode: _constants.NO_VOICEMAIL_STATUS_CODE
            };
            expect(response.message).toBe(_constants.NO_VOICEMAIL_MSG);
            expect(response).toStrictEqual(responseDetails);
            expect(getSortedVoicemailListSpy).toBeCalledOnceWith(voicemailResponseInfo.voicemailList, 'ASC');
            expect(storeVoicemailListSpy).toBeCalledOnceWith(CONTEXT, voicemailResponseInfo.voicemailList);
            expect(fetchVoicemailListSpy).toBeCalledOnceWith(CONTEXT, 0, 20, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            });
          case 12:
          case "end":
            return _context18.stop();
        }
      }, _callee18);
    })));
    it('verify successful voicemail listing in descending order with offset 0 and limit 2 with incorrect SORT param', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee19() {
      var voiceMailPayload, response, voicemailResponseInfo, responseDetails;
      return _regenerator.default.wrap(function _callee19$(_context19) {
        while (1) switch (_context19.prev = _context19.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context19.next = 4;
            return wxCallBackendConnector.getVoicemailList(0, 2, 'abcd', true);
          case 4:
            response = _context19.sent;
            voicemailResponseInfo = {
              voicemailList: _voicemailFixture.getDescVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo.slice(0, 2)
            };
            responseDetails = {
              data: voicemailResponseInfo,
              message: SUCCESS,
              statusCode: 200
            };
            expect(response.message).toBe(SUCCESS);
            expect(response).toStrictEqual(responseDetails);
            expect(getSortedVoicemailListSpy).toBeCalledOnceWith(_voicemailFixture.getDescVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo, 'DESC');
            expect(storeVoicemailListSpy).toBeCalledOnceWith(CONTEXT, _voicemailFixture.getDescVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo);
            expect(fetchVoicemailListSpy).toBeCalledOnceWith(CONTEXT, 0, 2, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            });
          case 12:
          case "end":
            return _context19.stop();
        }
      }, _callee19);
    })));
    it('verify successful voicemail listing in ascending order with offset 0 and limit 4', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee20() {
      var voiceMailPayload, response, voicemailResponseInfo, responseDetails;
      return _regenerator.default.wrap(function _callee20$(_context20) {
        while (1) switch (_context20.prev = _context20.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context20.next = 4;
            return wxCallBackendConnector.getVoicemailList(0, 4, _types2.SORT.ASC, true);
          case 4:
            response = _context20.sent;
            voicemailResponseInfo = {
              voicemailList: _voicemailFixture.getAscVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo.slice(0, 4)
            };
            responseDetails = {
              data: voicemailResponseInfo,
              message: SUCCESS,
              statusCode: 200
            };
            expect(response.message).toBe(SUCCESS);
            expect(response).toStrictEqual(responseDetails);
            expect(getSortedVoicemailListSpy).toBeCalledOnceWith(_voicemailFixture.getAscVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo, 'ASC');
            expect(storeVoicemailListSpy).toBeCalledOnceWith(CONTEXT, _voicemailFixture.getAscVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo);
            expect(fetchVoicemailListSpy).toBeCalledOnceWith(CONTEXT, 0, 4, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            });
          case 12:
          case "end":
            return _context20.stop();
        }
      }, _callee20);
    })));
    it('verify empty voicemail list data', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee21() {
      var response, voicemailResponseInfo, responseDetails;
      return _regenerator.default.wrap(function _callee21$(_context21) {
        while (1) switch (_context21.prev = _context21.next) {
          case 0:
            webex.request.mockResolvedValueOnce(_voicemailFixture.getEmptyVoicemailListJsonWxC);
            _context21.next = 3;
            return wxCallBackendConnector.getVoicemailList(0, 20, _types2.SORT.DESC, true);
          case 3:
            response = _context21.sent;
            voicemailResponseInfo = {
              voicemailList: []
            };
            responseDetails = {
              data: voicemailResponseInfo,
              message: _constants.NO_VOICEMAIL_MSG,
              statusCode: _constants.NO_VOICEMAIL_STATUS_CODE
            };
            expect(response).toStrictEqual(responseDetails);
            expect(response.message).toBe(_constants.NO_VOICEMAIL_MSG);
            expect(storeVoicemailListSpy).toBeCalledOnceWith(CONTEXT, voicemailResponseInfo.voicemailList);
            expect(fetchVoicemailListSpy).toBeCalledOnceWith(CONTEXT, 0, 20, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            });
          case 10:
          case "end":
            return _context21.stop();
        }
      }, _callee21);
    })));
    it('verify empty voicemail list data when response data is in invalid format', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee22() {
      var response, voicemailResponseInfo, responseDetails;
      return _regenerator.default.wrap(function _callee22$(_context22) {
        while (1) switch (_context22.prev = _context22.next) {
          case 0:
            webex.request.mockResolvedValueOnce(_voicemailFixture.getInvalidVoicemailListJsonWxC);
            _context22.next = 3;
            return wxCallBackendConnector.getVoicemailList(0, 20, _types2.SORT.DESC, true);
          case 3:
            response = _context22.sent;
            voicemailResponseInfo = {
              voicemailList: [{}]
            };
            responseDetails = {
              data: voicemailResponseInfo,
              message: _constants.NO_VOICEMAIL_MSG,
              statusCode: _constants.NO_VOICEMAIL_STATUS_CODE
            };
            expect(response).toStrictEqual(responseDetails);
            expect(response.message).toBe(_constants.NO_VOICEMAIL_MSG);
            expect(storeVoicemailListSpy).toBeCalledOnceWith(CONTEXT, voicemailResponseInfo.voicemailList);
            expect(fetchVoicemailListSpy).toBeCalledOnceWith(CONTEXT, 0, 20, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            });
          case 10:
          case "end":
            return _context22.stop();
        }
      }, _callee22);
    })));
    it('verify successful fetching of voicemail list without refresh', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee23() {
      var voiceMailPayload, vmEncodedList, response, voicemailResponseInfo, responseDetails;
      return _regenerator.default.wrap(function _callee23$(_context23) {
        while (1) switch (_context23.prev = _context23.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            vmEncodedList = Buffer.from((0, _stringify.default)(_voicemailFixture.getAscVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo), 'utf8').toString('base64');
            sessionStorage.setItem(CONTEXT, vmEncodedList.toString());
            _context23.next = 6;
            return wxCallBackendConnector.getVoicemailList(0, 4, _types2.SORT.ASC, false);
          case 6:
            response = _context23.sent;
            voicemailResponseInfo = {
              voicemailList: _voicemailFixture.getAscVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo.slice(0, 4)
            };
            responseDetails = {
              data: voicemailResponseInfo,
              message: SUCCESS,
              statusCode: 200
            };
            expect(response.message).toBe(SUCCESS);
            expect(response).toStrictEqual(responseDetails);
            expect(getSortedVoicemailListSpy).not.toBeCalled();
            expect(storeVoicemailListSpy).not.toBeCalled();
            expect(fetchVoicemailListSpy).toBeCalledOnceWith(CONTEXT, 0, 4, {
              file: 'WxCallBackendConnector',
              method: 'getVoicemailList'
            });
            sessionStorage.removeItem(CONTEXT);
          case 15:
          case "end":
            return _context23.stop();
        }
      }, _callee23);
    })));
    it('verify successful voicemailMarkAsRead', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee24() {
      var voiceMailPayload, response;
      return _regenerator.default.wrap(function _callee24$(_context24) {
        while (1) switch (_context24.prev = _context24.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context24.next = 4;
            return wxCallBackendConnector.voicemailMarkAsRead(messageId.$);
          case 4:
            response = _context24.sent;
            expect(response).toStrictEqual(EMPTY_SUCCESS_RESPONSE);
          case 6:
          case "end":
            return _context24.stop();
        }
      }, _callee24);
    })));
    it('verify successful voicemailMarkAsUnread', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee25() {
      var voiceMailPayload, response;
      return _regenerator.default.wrap(function _callee25$(_context25) {
        while (1) switch (_context25.prev = _context25.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context25.next = 4;
            return wxCallBackendConnector.voicemailMarkAsUnread(messageId.$);
          case 4:
            response = _context25.sent;
            expect(response).toStrictEqual(EMPTY_SUCCESS_RESPONSE);
          case 6:
          case "end":
            return _context25.stop();
        }
      }, _callee25);
    })));
    it('verify successful deleteVoicemail', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee26() {
      var voiceMailPayload, response;
      return _regenerator.default.wrap(function _callee26$(_context26) {
        while (1) switch (_context26.prev = _context26.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context26.next = 4;
            return wxCallBackendConnector.deleteVoicemail(messageId.$);
          case 4:
            response = _context26.sent;
            expect(response).toStrictEqual(EMPTY_SUCCESS_RESPONSE);
          case 6:
          case "end":
            return _context26.stop();
        }
      }, _callee26);
    })));
    it('verify resolveContact', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee27() {
      var voiceMailPayload, samplePeopleListResponse, displayInfo;
      return _regenerator.default.wrap(function _callee27$(_context27) {
        while (1) switch (_context27.prev = _context27.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            samplePeopleListResponse = (0, _testUtil.getSamplePeopleListResponse)();
            webex.people.list.mockResolvedValue(samplePeopleListResponse);
            _context27.next = 6;
            return wxCallBackendConnector.resolveContact({
              name: {
                $: 'Name'
              }
            });
          case 6:
            displayInfo = _context27.sent;
            expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.id).toStrictEqual(Buffer.from(samplePeopleListResponse.items[0].id, 'base64').toString('binary').split('/').pop());
            expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.name).toStrictEqual(samplePeopleListResponse.items[0].displayName);
            expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.num).toStrictEqual(samplePeopleListResponse.items[0].phoneNumbers[0].value);
            expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.avatarSrc).toStrictEqual(samplePeopleListResponse.items[0].avatar);
          case 11:
          case "end":
            return _context27.stop();
        }
      }, _callee27);
    })));
  });
  describe('Voicemail Fedramp webex call Backend Connector Test case', function () {
    webex.config.fedramp = true;
    var MOCK_FEDRAMP_URL = 'https://mock-fedramp-url/com.broadsoft.xsi-actions';
    beforeAll( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee28() {
      return _regenerator.default.wrap(function _callee28$(_context28) {
        while (1) switch (_context28.prev = _context28.next) {
          case 0:
            webex.credentials.getUserToken.mockResolvedValue('mockAuthToken');
            jest.spyOn(utils, 'getXsiActionEndpoint').mockResolvedValue(MOCK_FEDRAMP_URL);
            wxCallBackendConnector = new _WxCallBackendConnector.WxCallBackendConnector(webex, {
              level: _types.LOGGER.INFO
            });
            jest.spyOn(webex, 'request');
            _context28.next = 6;
            return wxCallBackendConnector.init();
          case 6:
            wxCallBackendConnector['context'] = CONTEXT;
            wxCallBackendConnector.getSDKConnector();
          case 8:
          case "end":
            return _context28.stop();
        }
      }, _callee28);
    })));
    beforeEach(function () {
      getSortedVoicemailListSpy = jest.spyOn(utils, 'getSortedVoicemailList');
      storeVoicemailListSpy = jest.spyOn(utils, 'storeVoicemailList');
      fetchVoicemailListSpy = jest.spyOn(utils, 'fetchVoicemailList');
    });
    it('getVoicemailList: adds the authorization header when in fedramp', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee29() {
      var voiceMailPayload;
      return _regenerator.default.wrap(function _callee29$(_context29) {
        while (1) switch (_context29.prev = _context29.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context29.next = 4;
            return wxCallBackendConnector.getVoicemailList(0, 4, _types2.SORT.ASC, true);
          case 4:
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: "".concat(MOCK_FEDRAMP_URL, "/v2.0/user/").concat(_voicemailFixture.userId, "/VoiceMessagingMessages?format=json"),
              headers: {
                Authorization: 'mockAuthToken'
              }
            });
          case 5:
          case "end":
            return _context29.stop();
        }
      }, _callee29);
    })));
    it('getVoicemailContent: adds the authorization header when in fedramp', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee30() {
      var voiceMailPayload;
      return _regenerator.default.wrap(function _callee30$(_context30) {
        while (1) switch (_context30.prev = _context30.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context30.next = 4;
            return wxCallBackendConnector.getVoicemailContent(messageId.$);
          case 4:
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: "".concat(MOCK_FEDRAMP_URL).concat(_voicemailFixture.braodworksUserMessageInfo, "/").concat(_voicemailFixture.broadworksUserMessageId),
              headers: {
                Authorization: 'mockAuthToken'
              }
            });
          case 5:
          case "end":
            return _context30.stop();
        }
      }, _callee30);
    })));
    it('getVoicemailSummary: adds the authorization header when in fedramp', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee31() {
      var voiceMailPayload;
      return _regenerator.default.wrap(function _callee31$(_context31) {
        while (1) switch (_context31.prev = _context31.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context31.next = 4;
            return wxCallBackendConnector.getVoicemailSummary();
          case 4:
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: "".concat(MOCK_FEDRAMP_URL, "/v2.0/user/").concat(_voicemailFixture.userId, "/calls/MessageSummary"),
              headers: {
                Authorization: 'mockAuthToken'
              }
            });
          case 5:
          case "end":
            return _context31.stop();
        }
      }, _callee31);
    })));
    it('voicemailMarkAsRead: adds the authorization header when in fedramp', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee32() {
      var voiceMailPayload;
      return _regenerator.default.wrap(function _callee32$(_context32) {
        while (1) switch (_context32.prev = _context32.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context32.next = 4;
            return wxCallBackendConnector.voicemailMarkAsRead(messageId.$);
          case 4:
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.PUT,
              uri: "".concat(MOCK_FEDRAMP_URL).concat(messageId.$, "/MarkAsRead"),
              headers: {
                Authorization: 'mockAuthToken'
              }
            });
          case 5:
          case "end":
            return _context32.stop();
        }
      }, _callee32);
    })));
    it('voicemailMarkAsUnread: adds the authorization header when in fedramp', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee33() {
      var voiceMailPayload;
      return _regenerator.default.wrap(function _callee33$(_context33) {
        while (1) switch (_context33.prev = _context33.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context33.next = 4;
            return wxCallBackendConnector.voicemailMarkAsUnread(messageId.$);
          case 4:
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.PUT,
              uri: "".concat(MOCK_FEDRAMP_URL).concat(messageId.$, "/MarkAsUnread"),
              headers: {
                Authorization: 'mockAuthToken'
              }
            });
          case 5:
          case "end":
            return _context33.stop();
        }
      }, _callee33);
    })));
    it('deleteVoicemail: adds the authorization header when in fedramp', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee34() {
      var voiceMailPayload;
      return _regenerator.default.wrap(function _callee34$(_context34) {
        while (1) switch (_context34.prev = _context34.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context34.next = 4;
            return wxCallBackendConnector.deleteVoicemail(messageId.$);
          case 4:
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.DELETE,
              uri: "".concat(MOCK_FEDRAMP_URL).concat(messageId.$),
              headers: {
                Authorization: 'mockAuthToken'
              }
            });
          case 5:
          case "end":
            return _context34.stop();
        }
      }, _callee34);
    })));
    it('getVMTranscript: adds the authorization header when in fedramp', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee35() {
      var voiceMailPayload;
      return _regenerator.default.wrap(function _callee35$(_context35) {
        while (1) switch (_context35.prev = _context35.next) {
          case 0:
            voiceMailPayload = _voicemailFixture.getVoicemailListJsonWXC;
            webex.request.mockResolvedValueOnce(voiceMailPayload);
            _context35.next = 4;
            return wxCallBackendConnector.getVMTranscript(messageId.$);
          case 4:
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: "".concat(MOCK_FEDRAMP_URL).concat(messageId.$, "/transcript"),
              headers: {
                Authorization: 'mockAuthToken'
              }
            });
          case 5:
          case "end":
            return _context35.stop();
        }
      }, _callee35);
    })));
  });
});
//# sourceMappingURL=WxCallBackendConnector.test.js.map
