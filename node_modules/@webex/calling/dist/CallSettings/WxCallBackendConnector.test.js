"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _testUtil = require("../common/testUtil");
var _types = require("../Logger/types");
var _types2 = require("../common/types");
var _constants = require("../common/constants");
var _constants2 = require("./constants");
var utils = _interopRequireWildcard(require("../common/Utils"));
var _WxCallBackendConnector = require("./WxCallBackendConnector");
var _Logger = _interopRequireDefault(require("../Logger"));
var _testFixtures = require("./testFixtures");
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/* eslint-disable dot-notation */

describe('Call Settings Client Tests for WxCallBackendConnector', function () {
  var warnSpy = jest.spyOn(_Logger.default, 'warn');
  var webex = (0, _testUtil.getTestUtilsWebex)();
  var serviceErrorCodeHandlerSpy;
  var hydraEndpoint = 'https://hydra-a.wbx2.com/v1/';
  var personId = 'Y2lzY29zcGFyazovL3VzL1BFT1BMRS84YTY3ODA2Zi1mYzRkLTQ0NmItYTEzMS0zMWU3MWVhNWIwZTk=';
  var orgId = 'Y2lzY29zcGFyazovL3VzL09SR0FOSVpBVElPTi8xNzA0ZDMwZC1hMTMxLTRiYzctOTQ0OS05NDg0ODc2NDM3OTM=';
  var responsePayload403 = {
    statusCode: 403
  };
  var responsePayload400 = {
    statusCode: 400
  };
  var responsePayload204 = {
    statusCode: 204
  };
  beforeEach(function () {
    serviceErrorCodeHandlerSpy = jest.spyOn(utils, 'serviceErrorCodeHandler');
    warnSpy.mockClear();
  });
  describe('Call Waiting Test', function () {
    var callSettingsClient;
    var webexUri = "".concat(hydraEndpoint, "/").concat(_constants.XSI_ACTION_ENDPOINT_ORG_URL_PARAM);
    var xsiEndpoint = 'https://api-proxy-si.broadcloudpbx.net/com.broadsoft.xsi-actions';
    var userId = '8a67806f-fc4d-446b-a131-31e71ea5b0e9';
    var callWaitingUrl = "".concat(xsiEndpoint, "/").concat(_constants2.XSI_VERSION, "/").concat(_constants2.USER_ENDPOINT, "/").concat(userId, "/").concat(_constants.SERVICES_ENDPOINT, "/").concat(_constants2.CALL_WAITING_ENDPOINT);
    beforeAll( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
      var urlResponsePayload;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            callSettingsClient = new _WxCallBackendConnector.WxCallBackendConnector(webex, {
              level: _types.LOGGER.INFO
            });
            urlResponsePayload = {
              statusCode: 200,
              body: _testFixtures.xsiEndpointUrlResponse
            };
            webex.request.mockResolvedValue(urlResponsePayload);
            _context.next = 5;
            return callSettingsClient.getCallWaitingSetting();
          case 5:
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: webexUri
            });
            expect(callSettingsClient['xsiEndpoint']).toEqual(xsiEndpoint);
            webex.request.mockClear();
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })));
    it('Success: Get Call Waiting setting enabled', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
      var callWaitingMockedResponse, response, toggleSetting;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            callWaitingMockedResponse = '<CallWaiting><active>true</active></CallWaiting>';
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                status: 200,
                ok: true,
                text: function text() {
                  return _promise.default.resolve(callWaitingMockedResponse);
                }
              });
            });
            _context2.next = 4;
            return callSettingsClient.getCallWaitingSetting();
          case 4:
            response = _context2.sent;
            toggleSetting = response.data.callSetting;
            expect(webex.request).not.toBeCalled();
            expect(response.statusCode).toBe(200);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(toggleSetting.enabled).toStrictEqual(true);
            _context2.t0 = expect(global.fetch);
            _context2.t1 = callWaitingUrl;
            _context2.t2 = _types2.HTTP_METHODS.GET;
            _context2.next = 15;
            return webex.credentials.getUserToken();
          case 15:
            _context2.t3 = _context2.sent;
            _context2.t4 = {
              Authorization: _context2.t3
            };
            _context2.t5 = {
              method: _context2.t2,
              headers: _context2.t4
            };
            _context2.t0.toBeCalledOnceWith.call(_context2.t0, _context2.t1, _context2.t5);
          case 19:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    })));
    it('Success: Get Call Waiting setting disabled', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
      var callWaitingMockedResponse, response, toggleSetting;
      return _regenerator.default.wrap(function _callee3$(_context3) {
        while (1) switch (_context3.prev = _context3.next) {
          case 0:
            callWaitingMockedResponse = '<CallWaiting><active>false</active></CallWaiting>';
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                status: 200,
                ok: true,
                text: function text() {
                  return _promise.default.resolve(callWaitingMockedResponse);
                }
              });
            });
            _context3.next = 4;
            return callSettingsClient.getCallWaitingSetting();
          case 4:
            response = _context3.sent;
            toggleSetting = response.data.callSetting;
            expect(webex.request).not.toBeCalled();
            expect(response.statusCode).toBe(200);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(toggleSetting.enabled).toStrictEqual(false);
            _context3.t0 = expect(global.fetch);
            _context3.t1 = callWaitingUrl;
            _context3.t2 = _types2.HTTP_METHODS.GET;
            _context3.next = 15;
            return webex.credentials.getUserToken();
          case 15:
            _context3.t3 = _context3.sent;
            _context3.t4 = {
              Authorization: _context3.t3
            };
            _context3.t5 = {
              method: _context3.t2,
              headers: _context3.t4
            };
            _context3.t0.toBeCalledOnceWith.call(_context3.t0, _context3.t1, _context3.t5);
          case 19:
          case "end":
            return _context3.stop();
        }
      }, _callee3);
    })));
    it('Error: Get Call Waiting setting throw 403 error', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
      var response;
      return _regenerator.default.wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                status: 403,
                ok: false
              });
            });
            _context4.next = 3;
            return callSettingsClient.getCallWaitingSetting();
          case 3:
            response = _context4.sent;
            expect(response.statusCode).toBe(403);
            expect(response.message).toBe(_constants.FAILURE_MESSAGE);
            _context4.t0 = expect(global.fetch);
            _context4.t1 = callWaitingUrl;
            _context4.t2 = _types2.HTTP_METHODS.GET;
            _context4.next = 11;
            return webex.credentials.getUserToken();
          case 11:
            _context4.t3 = _context4.sent;
            _context4.t4 = {
              Authorization: _context4.t3
            };
            _context4.t5 = {
              method: _context4.t2,
              headers: _context4.t4
            };
            _context4.t0.toBeCalledOnceWith.call(_context4.t0, _context4.t1, _context4.t5);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 403
            }, {
              file: _constants2.CALL_SETTINGS_FILE,
              method: 'getCallWaitingSetting'
            });
          case 16:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    })));
    it('Error: Get Call Waiting settings throw URI error', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
      var response;
      return _regenerator.default.wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            global.fetch = jest.fn().mockImplementation(function () {
              throw new URIError('422');
            });
            _context5.next = 3;
            return callSettingsClient.getCallWaitingSetting();
          case 3:
            response = _context5.sent;
            expect(response.statusCode).toBe(422);
            expect(response.message).toBe(_constants.FAILURE_MESSAGE);
            _context5.t0 = expect(global.fetch);
            _context5.t1 = callWaitingUrl;
            _context5.t2 = _types2.HTTP_METHODS.GET;
            _context5.next = 11;
            return webex.credentials.getUserToken();
          case 11:
            _context5.t3 = _context5.sent;
            _context5.t4 = {
              Authorization: _context5.t3
            };
            _context5.t5 = {
              method: _context5.t2,
              headers: _context5.t4
            };
            _context5.t0.toBeCalledOnceWith.call(_context5.t0, _context5.t1, _context5.t5);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 422
            }, {
              file: _constants2.CALL_SETTINGS_FILE,
              method: 'getCallWaitingSetting'
            });
          case 16:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    })));
  });
  describe('DND Test', function () {
    var callSettingsClient;
    var uri = "".concat(hydraEndpoint, "/").concat(_constants2.PEOPLE_ENDPOINT, "/").concat(personId, "/").concat(_constants2.DND_ENDPOINT, "?").concat(_constants2.ORG_ENDPOINT, "=").concat(orgId);
    beforeAll(function () {
      callSettingsClient = new _WxCallBackendConnector.WxCallBackendConnector(webex, {
        level: _types.LOGGER.INFO
      });
    });
    it('Success: Set DND settings', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
      var dndRequestBody, response;
      return _regenerator.default.wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            dndRequestBody = {
              enabled: false,
              ringSplashEnabled: false
            };
            webex.request.mockResolvedValueOnce(responsePayload204);
            _context6.next = 4;
            return callSettingsClient.setDoNotDisturbSetting(false);
          case 4:
            response = _context6.sent;
            expect(response.statusCode).toBe(204);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.PUT,
              uri: uri,
              body: dndRequestBody
            });
          case 8:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    })));
    it('Success: Get DND setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
      var dndResponsePayload, response, toggleSetting;
      return _regenerator.default.wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            dndResponsePayload = {
              statusCode: 200,
              body: {
                enabled: true
              }
            };
            webex.request.mockResolvedValueOnce(dndResponsePayload);
            _context7.next = 4;
            return callSettingsClient.getDoNotDisturbSetting();
          case 4:
            response = _context7.sent;
            toggleSetting = response.data.callSetting;
            expect(response.statusCode).toBe(200);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(toggleSetting.enabled).toBe(true);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: uri
            });
          case 10:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    })));
    it('Error: Set DND setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
      var dndRequestBody, response;
      return _regenerator.default.wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            dndRequestBody = {
              enabled: false,
              ringSplashEnabled: false
            };
            webex.request.mockRejectedValueOnce(responsePayload400);
            _context8.next = 4;
            return callSettingsClient.setDoNotDisturbSetting(false);
          case 4:
            response = _context8.sent;
            expect(response.statusCode).toBe(400);
            expect(response.message).toBe(_constants.FAILURE_MESSAGE);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.PUT,
              uri: uri,
              body: dndRequestBody
            });
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, {
              file: _constants2.CALL_SETTINGS_FILE,
              method: 'setDoNotDisturbSetting'
            });
          case 9:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    })));
    it('Error: Get DND setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
      var response;
      return _regenerator.default.wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            webex.request.mockRejectedValueOnce(responsePayload403);
            _context9.next = 3;
            return callSettingsClient.getDoNotDisturbSetting();
          case 3:
            response = _context9.sent;
            expect(response.statusCode).toBe(403);
            expect(response.message).toBe(_constants.FAILURE_MESSAGE);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: uri
            });
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 403
            }, {
              file: _constants2.CALL_SETTINGS_FILE,
              method: 'getDoNotDisturbSetting'
            });
          case 8:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    })));
  });
  describe('Call Forward Test', function () {
    var callSettingsClient;
    var uri = "".concat(hydraEndpoint, "/").concat(_constants2.PEOPLE_ENDPOINT, "/").concat(personId, "/").concat(_constants2.CF_ENDPOINT, "?").concat(_constants2.ORG_ENDPOINT, "=").concat(orgId);
    beforeAll(function () {
      callSettingsClient = new _WxCallBackendConnector.WxCallBackendConnector(webex, {
        level: _types.LOGGER.INFO
      });
    });
    it('Success: Set Call Forward setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
      var response;
      return _regenerator.default.wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            webex.request.mockResolvedValueOnce(responsePayload204);
            _context10.next = 3;
            return callSettingsClient.setCallForwardSetting(_testFixtures.callForwardPayload);
          case 3:
            response = _context10.sent;
            expect(response.statusCode).toBe(204);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.PUT,
              uri: uri,
              body: _testFixtures.callForwardPayload
            });
          case 7:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    })));
    it('Success: Get Call Forward setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
      var responsePayload, response, callForwardSetting;
      return _regenerator.default.wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            responsePayload = {
              statusCode: 200,
              body: _testFixtures.callForwardPayload
            };
            webex.request.mockResolvedValueOnce(responsePayload);
            _context11.next = 4;
            return callSettingsClient.getCallForwardSetting();
          case 4:
            response = _context11.sent;
            callForwardSetting = response.data.callSetting;
            expect(response.statusCode).toBe(200);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(callForwardSetting).toEqual(_testFixtures.callForwardPayload);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: uri
            });
          case 10:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    })));
    it('Error: Set Call Forwarding setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
      var response;
      return _regenerator.default.wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            webex.request.mockRejectedValueOnce(responsePayload400);
            _context12.next = 3;
            return callSettingsClient.setCallForwardSetting(_testFixtures.callForwardPayload);
          case 3:
            response = _context12.sent;
            expect(response.statusCode).toBe(400);
            expect(response.message).toBe(_constants.FAILURE_MESSAGE);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.PUT,
              uri: uri,
              body: _testFixtures.callForwardPayload
            });
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, {
              file: _constants2.CALL_SETTINGS_FILE,
              method: 'setCallForwardingSetting'
            });
          case 8:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    })));
    it('Error: Get Call Forwarding setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
      var response;
      return _regenerator.default.wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            webex.request.mockRejectedValueOnce(responsePayload403);
            _context13.next = 3;
            return callSettingsClient.getCallForwardSetting();
          case 3:
            response = _context13.sent;
            expect(response.statusCode).toBe(403);
            expect(response.message).toBe(_constants.FAILURE_MESSAGE);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: uri
            });
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 403
            }, {
              file: _constants2.CALL_SETTINGS_FILE,
              method: 'getCallForwardingSetting'
            });
          case 8:
          case "end":
            return _context13.stop();
        }
      }, _callee13);
    })));
  });
  describe('Voicemail Test', function () {
    var callSettingsClient;
    var uri = "".concat(hydraEndpoint, "/").concat(_constants2.PEOPLE_ENDPOINT, "/").concat(personId, "/").concat(_constants2.VM_ENDPOINT, "?").concat(_constants2.ORG_ENDPOINT, "=").concat(orgId);
    beforeAll(function () {
      callSettingsClient = new _WxCallBackendConnector.WxCallBackendConnector(webex, {
        level: _types.LOGGER.INFO
      });
    });
    it('Success: Set Voicemail setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14() {
      var response;
      return _regenerator.default.wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            webex.request.mockResolvedValueOnce(responsePayload204);
            _context14.next = 3;
            return callSettingsClient.setVoicemailSetting(_testFixtures.voicemailPayload);
          case 3:
            response = _context14.sent;
            expect(response.statusCode).toBe(204);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.PUT,
              uri: uri,
              body: _testFixtures.voicemailPayload
            });
          case 7:
          case "end":
            return _context14.stop();
        }
      }, _callee14);
    })));
    it('Success: Get Voicemail setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15() {
      var responsePayload, response, voicemailSetting;
      return _regenerator.default.wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            responsePayload = {
              statusCode: 200,
              body: _testFixtures.voicemailPayload
            };
            webex.request.mockResolvedValueOnce(responsePayload);
            _context15.next = 4;
            return callSettingsClient.getVoicemailSetting();
          case 4:
            response = _context15.sent;
            voicemailSetting = response.data.callSetting;
            expect(response.statusCode).toBe(200);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(voicemailSetting).toBe(_testFixtures.voicemailPayload);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: uri
            });
          case 10:
          case "end":
            return _context15.stop();
        }
      }, _callee15);
    })));
    it('Error: Set Voicemail setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16() {
      var response;
      return _regenerator.default.wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            webex.request.mockRejectedValueOnce(responsePayload400);
            _context16.next = 3;
            return callSettingsClient.setVoicemailSetting(_testFixtures.voicemailPayload);
          case 3:
            response = _context16.sent;
            expect(response.statusCode).toBe(400);
            expect(response.message).toBe(_constants.FAILURE_MESSAGE);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.PUT,
              uri: uri,
              body: _testFixtures.voicemailPayload
            });
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, {
              file: _constants2.CALL_SETTINGS_FILE,
              method: 'setVoicemailSetting'
            });
          case 8:
          case "end":
            return _context16.stop();
        }
      }, _callee16);
    })));
    it('Error: Get Voicemail setting', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17() {
      var response;
      return _regenerator.default.wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            webex.request.mockRejectedValueOnce(responsePayload403);
            _context17.next = 3;
            return callSettingsClient.getVoicemailSetting();
          case 3:
            response = _context17.sent;
            expect(response.statusCode).toBe(403);
            expect(response.message).toBe(_constants.FAILURE_MESSAGE);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: uri
            });
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 403
            }, {
              file: _constants2.CALL_SETTINGS_FILE,
              method: 'getVoicemailSetting'
            });
          case 8:
          case "end":
            return _context17.stop();
        }
      }, _callee17);
    })));
  });
  describe('Call Forward Always test', function () {
    var callSettingsClient;
    var callForwardingUri = "".concat(hydraEndpoint, "/").concat(_constants2.PEOPLE_ENDPOINT, "/").concat(personId, "/").concat(_constants2.CF_ENDPOINT, "?").concat(_constants2.ORG_ENDPOINT, "=").concat(orgId);
    var voicemailUri = "".concat(hydraEndpoint, "/").concat(_constants2.PEOPLE_ENDPOINT, "/").concat(personId, "/").concat(_constants2.VM_ENDPOINT, "?").concat(_constants2.ORG_ENDPOINT, "=").concat(orgId);
    beforeAll(function () {
      callSettingsClient = new _WxCallBackendConnector.WxCallBackendConnector(webex, {
        level: _types.LOGGER.INFO
      });
    });
    it('Success: Get Call Forward Always setting when set to destination', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18() {
      var responsePayload, response, callForwardSetting;
      return _regenerator.default.wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            responsePayload = {
              statusCode: 200,
              body: _testFixtures.callForwardPayload
            };
            webex.request.mockResolvedValueOnce(responsePayload);
            _context18.next = 4;
            return callSettingsClient.getCallForwardAlwaysSetting();
          case 4:
            response = _context18.sent;
            callForwardSetting = response.data.callSetting;
            expect(response.statusCode).toBe(200);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(callForwardSetting.enabled).toBe(true);
            expect(callForwardSetting.destination).toBe('123456789');
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: callForwardingUri
            });
          case 11:
          case "end":
            return _context18.stop();
        }
      }, _callee18);
    })));
    it('Success: Get Call Forward Always setting when set to disabled and voicemail request fails', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee19() {
      var responsePayload, response;
      return _regenerator.default.wrap(function _callee19$(_context19) {
        while (1) switch (_context19.prev = _context19.next) {
          case 0:
            _testFixtures.callForwardPayload.callForwarding.always.enabled = false;
            responsePayload = {
              statusCode: 200,
              body: _testFixtures.callForwardPayload
            };
            webex.request.mockResolvedValueOnce(responsePayload).mockRejectedValueOnce({
              statusCode: 503
            });
            _context19.next = 5;
            return callSettingsClient.getCallForwardAlwaysSetting();
          case 5:
            response = _context19.sent;
            expect(response.statusCode).toBe(503);
            expect(response.message).toBe(_constants.FAILURE_MESSAGE);
            expect(response.data.error).toBe('Unable to retrieve voicemail settings.');
            expect(webex.request).toBeCalledTimes(2);
            expect(webex.request).toBeCalledWith({
              method: _types2.HTTP_METHODS.GET,
              uri: callForwardingUri
            });
            expect(webex.request).toBeCalledWith({
              method: _types2.HTTP_METHODS.GET,
              uri: voicemailUri
            });
            expect(warnSpy).toBeCalledTimes(2);
            expect(warnSpy).toBeCalledWith('503 Unable to establish a connection with the server', {
              file: _constants2.CALL_SETTINGS_FILE,
              method: callSettingsClient.getVoicemailSetting.name
            });
            expect(warnSpy).toBeCalledWith('Unable to retrieve voicemail settings.', {
              file: _constants.WEBEX_CALLING_CONNECTOR_FILE,
              method: callSettingsClient.getCallForwardAlwaysSetting.name
            });
          case 15:
          case "end":
            return _context19.stop();
        }
      }, _callee19);
    })));
    it('Success: Get Call Forward Always setting when set to voicemail', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee20() {
      var responsePayload, response, callForwardSetting;
      return _regenerator.default.wrap(function _callee20$(_context20) {
        while (1) switch (_context20.prev = _context20.next) {
          case 0:
            _testFixtures.callForwardPayload.callForwarding.always.enabled = false;
            responsePayload = {
              statusCode: 200,
              body: _testFixtures.callForwardPayload
            };
            webex.request.mockResolvedValueOnce(responsePayload).mockResolvedValueOnce({
              statusCode: 200,
              body: _testFixtures.voicemailPayload
            });
            _context20.next = 5;
            return callSettingsClient.getCallForwardAlwaysSetting();
          case 5:
            response = _context20.sent;
            callForwardSetting = response.data.callSetting;
            expect(response.statusCode).toBe(200);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(callForwardSetting.enabled).toBe(true);
            expect(callForwardSetting.destination).toBe('VOICEMAIL');
            expect(webex.request).toBeCalledTimes(2);
            expect(webex.request).toBeCalledWith({
              method: _types2.HTTP_METHODS.GET,
              uri: callForwardingUri
            });
            expect(webex.request).toBeCalledWith({
              method: _types2.HTTP_METHODS.GET,
              uri: voicemailUri
            });
          case 14:
          case "end":
            return _context20.stop();
        }
      }, _callee20);
    })));
    it('Success: Get Call Forward Always setting when not set', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee21() {
      var responsePayload, response, callForwardSetting;
      return _regenerator.default.wrap(function _callee21$(_context21) {
        while (1) switch (_context21.prev = _context21.next) {
          case 0:
            _testFixtures.callForwardPayload.callForwarding.always.enabled = false;
            _testFixtures.callForwardPayload.callForwarding.always.destination = '';
            responsePayload = {
              statusCode: 200,
              body: _testFixtures.callForwardPayload
            };
            _testFixtures.voicemailPayload.sendAllCalls.enabled = false;
            webex.request.mockResolvedValueOnce(responsePayload).mockResolvedValueOnce({
              statusCode: 200,
              body: _testFixtures.voicemailPayload
            });
            _context21.next = 7;
            return callSettingsClient.getCallForwardAlwaysSetting();
          case 7:
            response = _context21.sent;
            callForwardSetting = response.data.callSetting;
            expect(response.statusCode).toBe(200);
            expect(response.message).toBe(_constants.SUCCESS_MESSAGE);
            expect(callForwardSetting.enabled).toBe(false);
            expect(callForwardSetting.destination).toBeFalsy();
            expect(webex.request).toBeCalledTimes(2);
            expect(webex.request).toBeCalledWith({
              method: _types2.HTTP_METHODS.GET,
              uri: callForwardingUri
            });
            expect(webex.request).toBeCalledWith({
              method: _types2.HTTP_METHODS.GET,
              uri: voicemailUri
            });
          case 16:
          case "end":
            return _context21.stop();
        }
      }, _callee21);
    })));
    it('Failure: Get Call Forward Always setting fails', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee22() {
      var responsePayload, response;
      return _regenerator.default.wrap(function _callee22$(_context22) {
        while (1) switch (_context22.prev = _context22.next) {
          case 0:
            responsePayload = {
              statusCode: 503
            };
            webex.request.mockRejectedValueOnce(responsePayload);
            _context22.next = 4;
            return callSettingsClient.getCallForwardAlwaysSetting();
          case 4:
            response = _context22.sent;
            expect(response.statusCode).toBe(503);
            expect(response.message).toBe(_constants.FAILURE_MESSAGE);
            expect(webex.request).toBeCalledOnceWith({
              method: _types2.HTTP_METHODS.GET,
              uri: callForwardingUri
            });
          case 8:
          case "end":
            return _context22.stop();
        }
      }, _callee22);
    })));
  });
});
//# sourceMappingURL=WxCallBackendConnector.test.js.map
