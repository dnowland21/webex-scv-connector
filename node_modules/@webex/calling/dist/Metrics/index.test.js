"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _testUtil = require("../common/testUtil");
var _index = require("./index");
var _types = require("./types");
var _constants = require("../CallingClient/constants");
var _CallingDeviceError = require("../Errors/catalog/CallingDeviceError");
var _types2 = require("../Errors/types");
var _types3 = require("../common/types");
var _Logger = _interopRequireDefault(require("../Logger"));
var _CallError = require("../Errors/catalog/CallError");
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; } /* eslint-disable dot-notation */
var webex = (0, _testUtil.getTestUtilsWebex)();
describe('CALLING: Metric tests', function () {
  var metricManager = (0, _index.getMetricManager)(webex, _types3.ServiceIndicator.CALLING);
  var mockDeviceInfo = (0, _testUtil.getMockDeviceInfo)();
  var mockSubmitClientMetric = jest.fn();
  var MOCK_VERSION_NUMBER = '1.0.0';
  var originalEnv = process.env;
  webex.internal.metrics.submitClientMetrics = mockSubmitClientMetric;
  var mockCallId = '123456';
  var mockCorrelationId = '0931237';
  var mockCallAction = 'S_SEND_CALL_SETUP';
  var mockMediaAction = 'S_SEND_ROAP_OFFER';
  beforeEach(function () {
    mockSubmitClientMetric.mockClear();
    process.env = _objectSpread(_objectSpread({}, originalEnv), {}, {
      CALLING_SDK_VERSION: MOCK_VERSION_NUMBER
    });
  });
  it('initialize metric manager', function () {
    expect(metricManager).not.toBeNull();
    expect(metricManager['deviceInfo']).toBeUndefined();
  });
  it('update deviceInfo in metric manager', function () {
    expect(metricManager['deviceInfo']).toBeUndefined();
    metricManager.setDeviceInfo(mockDeviceInfo);
    expect(metricManager['deviceInfo']).toEqual(mockDeviceInfo);
  });
  describe('CallingClient metric tests', function () {
    it('submit registration success metric', function () {
      metricManager.setDeviceInfo(mockDeviceInfo);
      var expectedData = {
        tags: {
          action: _types.REG_ACTION.REGISTER,
          device_id: mockDeviceInfo.device.deviceId,
          service_indicator: _types3.ServiceIndicator.CALLING
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          mobius_url: mockDeviceInfo.device.uri,
          calling_sdk_version: MOCK_VERSION_NUMBER
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitRegistrationMetric(_types.METRIC_EVENT.REGISTRATION, _types.REG_ACTION.REGISTER, _types.METRIC_TYPE.BEHAVIORAL, undefined);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.REGISTRATION, expectedData);
    });
    it('submit registration failure metric', function () {
      metricManager.setDeviceInfo(mockDeviceInfo);
      var clientError = (0, _CallingDeviceError.createClientError)('', {}, _types2.ERROR_TYPE.DEFAULT, _types3.RegistrationStatus.INACTIVE);
      var err = {};
      err.context = {};
      err.message = 'Unknown Error';
      err.type = _types2.ERROR_TYPE.SERVICE_UNAVAILABLE;
      clientError.setError(err);
      var expectedData = {
        tags: {
          action: _types.REG_ACTION.REGISTER,
          device_id: mockDeviceInfo.device.deviceId,
          service_indicator: _types3.ServiceIndicator.CALLING
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          mobius_url: mockDeviceInfo.device.uri,
          calling_sdk_version: MOCK_VERSION_NUMBER,
          error: clientError.getError().message,
          error_type: clientError.getError().type
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitRegistrationMetric(_types.METRIC_EVENT.REGISTRATION_ERROR, _types.REG_ACTION.REGISTER, _types.METRIC_TYPE.BEHAVIORAL, clientError);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.REGISTRATION_ERROR, expectedData);
    });
    it('submit unknown registration metric', function () {
      var logSpy = jest.spyOn(_Logger.default, 'warn');
      metricManager.submitRegistrationMetric('invalidMetricName', _types.REG_ACTION.REGISTER, _types.METRIC_TYPE.OPERATIONAL, undefined);
      expect(mockSubmitClientMetric).not.toBeCalled();
      expect(logSpy).toBeCalledOnceWith('Invalid metric name received. Rejecting request to submit metric.', {
        file: 'metric',
        method: 'submitRegistrationMetric'
      });
    });
  });
  describe('Call Metric tests', function () {
    beforeAll(function () {
      metricManager.setDeviceInfo(mockDeviceInfo);
    });
    it('submit call success metric', function () {
      var expectedData = {
        tags: {
          action: mockCallAction,
          device_id: mockDeviceInfo.device.deviceId,
          service_indicator: _types3.ServiceIndicator.CALLING
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          mobius_url: mockDeviceInfo.device.uri,
          calling_sdk_version: MOCK_VERSION_NUMBER,
          call_id: mockCallId,
          correlation_id: mockCorrelationId
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitCallMetric(_types.METRIC_EVENT.CALL, mockCallAction, _types.METRIC_TYPE.BEHAVIORAL, mockCallId, mockCorrelationId);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.CALL, expectedData);
    });
    it('submit call failure metric', function () {
      var callError = (0, _CallError.createCallError)('', {}, _types2.ERROR_TYPE.DEFAULT, mockCorrelationId, _types2.ERROR_LAYER.CALL_CONTROL);
      var err = {};
      err.context = {};
      err.message = 'An invalid status update has been received for the call. Wait a moment and try again.';
      err.type = _types2.ERROR_TYPE.FORBIDDEN_ERROR;
      callError.setCallError(err);
      var expectedData = {
        tags: {
          action: mockCallAction,
          device_id: mockDeviceInfo.device.deviceId,
          service_indicator: _types3.ServiceIndicator.CALLING
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          mobius_url: mockDeviceInfo.device.uri,
          calling_sdk_version: MOCK_VERSION_NUMBER,
          call_id: mockCallId,
          correlation_id: mockCorrelationId,
          error: callError.getCallError().message,
          error_type: callError.getCallError().type
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitCallMetric(_types.METRIC_EVENT.CALL_ERROR, mockCallAction, _types.METRIC_TYPE.BEHAVIORAL, mockCallId, mockCorrelationId, callError);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.CALL_ERROR, expectedData);
    });
    it('submit unknown call metric', function () {
      var logSpy = jest.spyOn(_Logger.default, 'warn');
      metricManager.submitCallMetric('invalidMetricName', mockCallAction, _types.METRIC_TYPE.OPERATIONAL, mockCallId, mockCorrelationId);
      expect(mockSubmitClientMetric).not.toBeCalled();
      expect(logSpy).toBeCalledOnceWith('Invalid metric name received. Rejecting request to submit metric.', {
        file: 'metric',
        method: 'submitCallMetric'
      });
    });
  });
  describe('Media Metric tests', function () {
    var mockSdp = 'sdpInformation';
    beforeAll(function () {
      metricManager.setDeviceInfo(mockDeviceInfo);
    });
    it('submit media success metric', function () {
      var expectedData = {
        tags: {
          action: mockMediaAction,
          device_id: mockDeviceInfo.device.deviceId,
          service_indicator: _types3.ServiceIndicator.CALLING
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          mobius_url: mockDeviceInfo.device.uri,
          calling_sdk_version: MOCK_VERSION_NUMBER,
          call_id: mockCallId,
          correlation_id: mockCorrelationId,
          local_media_details: mockSdp,
          remote_media_details: mockSdp
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitMediaMetric(_types.METRIC_EVENT.MEDIA, mockMediaAction, _types.METRIC_TYPE.BEHAVIORAL, mockCallId, mockCorrelationId, mockSdp, mockSdp);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.MEDIA, expectedData);
    });
    it('submit media failure metric', function () {
      var callError = (0, _CallError.createCallError)('', {}, _types2.ERROR_TYPE.DEFAULT, mockCorrelationId, _types2.ERROR_LAYER.MEDIA);
      var err = {};
      err.context = {};
      err.message = 'An error occurred while parsing the provided information. Wait a moment and try again.';
      err.type = _types2.ERROR_TYPE.SERVICE_UNAVAILABLE;
      callError.setCallError(err);
      var expectedData = {
        tags: {
          action: mockMediaAction,
          device_id: mockDeviceInfo.device.deviceId,
          service_indicator: _types3.ServiceIndicator.CALLING
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          mobius_url: mockDeviceInfo.device.uri,
          calling_sdk_version: MOCK_VERSION_NUMBER,
          call_id: mockCallId,
          correlation_id: mockCorrelationId,
          local_media_details: mockSdp,
          remote_media_details: mockSdp,
          error: callError.getCallError().message,
          error_type: callError.getCallError().type
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitMediaMetric(_types.METRIC_EVENT.MEDIA_ERROR, mockMediaAction, _types.METRIC_TYPE.BEHAVIORAL, mockCallId, mockCorrelationId, mockSdp, mockSdp, callError);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.MEDIA_ERROR, expectedData);
    });
    it('submit unknown media metric', function () {
      var logSpy = jest.spyOn(_Logger.default, 'warn');
      metricManager.submitMediaMetric('invalidMetricName', mockMediaAction, _types.METRIC_TYPE.OPERATIONAL, mockCallId, mockCorrelationId, mockSdp, mockSdp);
      expect(mockSubmitClientMetric).not.toBeCalled();
      expect(logSpy).toBeCalledOnceWith('Invalid metric name received. Rejecting request to submit metric.', {
        file: 'metric',
        method: 'submitMediaMetric'
      });
    });
  });
  describe('BNR metric tests', function () {
    beforeAll(function () {
      metricManager.setDeviceInfo(mockDeviceInfo);
    });
    it('submit bnr enabled metric', function () {
      var expectedData = {
        tags: {
          device_id: mockDeviceInfo.device.deviceId,
          service_indicator: _types3.ServiceIndicator.CALLING
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          mobius_url: mockDeviceInfo.device.uri,
          calling_sdk_version: MOCK_VERSION_NUMBER,
          call_id: mockCallId,
          correlation_id: mockCorrelationId
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitBNRMetric(_types.METRIC_EVENT.BNR_ENABLED, _types.METRIC_TYPE.BEHAVIORAL, mockCallId, mockCorrelationId);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.BNR_ENABLED, expectedData);
    });
    it('submit bnr disabled metric', function () {
      var expectedData = {
        tags: {
          device_id: mockDeviceInfo.device.deviceId,
          service_indicator: _types3.ServiceIndicator.CALLING
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          mobius_url: mockDeviceInfo.device.uri,
          calling_sdk_version: MOCK_VERSION_NUMBER,
          call_id: mockCallId,
          correlation_id: mockCorrelationId
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitBNRMetric(_types.METRIC_EVENT.BNR_DISABLED, _types.METRIC_TYPE.BEHAVIORAL, mockCallId, mockCorrelationId);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.BNR_DISABLED, expectedData);
    });
    it('submit unknown bnr metric', function () {
      var logSpy = jest.spyOn(_Logger.default, 'warn');
      metricManager.submitBNRMetric('invalidMetricName', _types.METRIC_TYPE.BEHAVIORAL, mockCallId, mockCorrelationId);
      expect(mockSubmitClientMetric).not.toBeCalled();
      expect(logSpy).toBeCalledOnceWith('Invalid metric name received. Rejecting request to submit metric.', {
        file: 'metric',
        method: 'submitBNRMetric'
      });
    });
  });
  describe('Voicemail metric tests', function () {
    beforeAll(function () {
      return metricManager.setDeviceInfo(mockDeviceInfo);
    });
    it('submit voicemail success metric', function () {
      var expectedData1 = {
        tags: {
          action: _types.VOICEMAIL_ACTION.GET_VOICEMAILS,
          device_id: mockDeviceInfo.device.deviceId
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          calling_sdk_version: MOCK_VERSION_NUMBER
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitVoicemailMetric(_types.METRIC_EVENT.VOICEMAIL, _types.VOICEMAIL_ACTION.GET_VOICEMAILS, _types.METRIC_TYPE.BEHAVIORAL);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.VOICEMAIL, expectedData1);
      mockSubmitClientMetric.mockClear();
      var expectedData2 = _objectSpread(_objectSpread({}, expectedData1), {}, {
        tags: _objectSpread(_objectSpread({}, expectedData1.tags), {}, {
          message_id: 'messageId',
          action: _types.VOICEMAIL_ACTION.DELETE
        })
      });
      metricManager.submitVoicemailMetric(_types.METRIC_EVENT.VOICEMAIL, _types.VOICEMAIL_ACTION.DELETE, _types.METRIC_TYPE.BEHAVIORAL, 'messageId');
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.VOICEMAIL, expectedData2);
    });
    it('submit voicemail failure metric', function () {
      var errorMessage = 'User is not authenticated';
      var expectedData1 = {
        tags: {
          action: _types.VOICEMAIL_ACTION.GET_VOICEMAILS,
          device_id: mockDeviceInfo.device.deviceId,
          message_id: undefined,
          error: errorMessage,
          status_code: 401
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          calling_sdk_version: MOCK_VERSION_NUMBER
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitVoicemailMetric(_types.METRIC_EVENT.VOICEMAIL_ERROR, _types.VOICEMAIL_ACTION.GET_VOICEMAILS, _types.METRIC_TYPE.BEHAVIORAL, undefined, errorMessage, 401);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.VOICEMAIL_ERROR, expectedData1);
      mockSubmitClientMetric.mockClear();
      var expectedData2 = _objectSpread(_objectSpread({}, expectedData1), {}, {
        tags: _objectSpread(_objectSpread({}, expectedData1.tags), {}, {
          message_id: 'messageId',
          action: _types.VOICEMAIL_ACTION.DELETE
        })
      });
      metricManager.submitVoicemailMetric(_types.METRIC_EVENT.VOICEMAIL_ERROR, _types.VOICEMAIL_ACTION.DELETE, _types.METRIC_TYPE.BEHAVIORAL, 'messageId', errorMessage, 401);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.VOICEMAIL_ERROR, expectedData2);
    });
    it('submit unknown voicemail metric', function () {
      var logSpy = jest.spyOn(_Logger.default, 'warn');
      metricManager.submitVoicemailMetric('invalidMetricName', _types.VOICEMAIL_ACTION.GET_VOICEMAILS, _types.METRIC_TYPE.BEHAVIORAL);
      expect(mockSubmitClientMetric).not.toBeCalled();
      expect(logSpy).toBeCalledOnceWith('Invalid metric name received. Rejecting request to submit metric.', {
        file: 'metric',
        method: 'submitVoicemailMetric'
      });
    });
  });
  describe('Calling_Sdk_Version fallback test', function () {
    it('submit metric with fallback version', function () {
      process.env = {};
      metricManager.setDeviceInfo(mockDeviceInfo);
      var expectedData = {
        tags: {
          device_id: mockDeviceInfo.device.deviceId,
          service_indicator: _types3.ServiceIndicator.CALLING
        },
        fields: {
          device_url: mockDeviceInfo.device.clientDeviceUri,
          mobius_url: mockDeviceInfo.device.uri,
          calling_sdk_version: _constants.VERSION,
          call_id: mockCallId,
          correlation_id: mockCorrelationId
        },
        type: _types.METRIC_TYPE.BEHAVIORAL
      };
      metricManager.submitBNRMetric(_types.METRIC_EVENT.BNR_ENABLED, _types.METRIC_TYPE.BEHAVIORAL, mockCallId, mockCorrelationId);
      expect(mockSubmitClientMetric).toBeCalledOnceWith(_types.METRIC_EVENT.BNR_ENABLED, expectedData);
    });
  });
});
//# sourceMappingURL=index.test.js.map
