"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");
var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.createCallHistoryClient = exports.CallHistory = void 0;
var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
var _isNan = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/number/is-nan"));
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _SDKConnector = _interopRequireDefault(require("../SDKConnector"));
var _types = require("../common/types");
var _Logger = _interopRequireDefault(require("../Logger"));
var _Utils = require("../common/Utils");
var _constants = require("./constants");
var _constants2 = require("../common/constants");
var _types2 = require("../Events/types");
var _impl = require("../Events/impl");
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /* eslint-disable dot-notation */ /* eslint-disable no-underscore-dangle */
/**
 * `CallHistory` module is designed to facilitate the retrieval of Call History Records by providing a set of APIs.
 *
 * This code snippet demonstrates how to create an instance of `CallHistory` using webex and logger.
 *
 * @example
 * ```javascript
 * const callHistory = createCallHistoryClient(webex, logger);
 * ```
 */
var CallHistory = exports.CallHistory = /*#__PURE__*/function (_Eventing) {
  (0, _inherits2.default)(CallHistory, _Eventing);
  var _super = _createSuper(CallHistory);
  /**
   * @ignore
   */
  function CallHistory(webex, logger) {
    var _this;
    (0, _classCallCheck2.default)(this, CallHistory);
    _this = _super.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sdkConnector", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "webex", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "janusUrl", '');
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "fromDate", '');
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "loggerContext", {
      file: _constants.CALL_HISTORY_FILE,
      method: _constants.METHODS.GET_CALL_HISTORY_DATA
    });
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "userSessions", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleSessionEvents", /*#__PURE__*/function () {
      var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(event) {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              if (event && event.data.userSessions.userSessions) {
                _this.emit(_types2.COMMON_EVENT_KEYS.CALL_HISTORY_USER_SESSION_INFO, event);
              }
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function (_x) {
        return _ref.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleUserReadSessionEvents", /*#__PURE__*/function () {
      var _ref2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(event) {
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (event && event.data.userReadSessions.userReadSessions) {
                _this.emit(_types2.COMMON_EVENT_KEYS.CALL_HISTORY_USER_VIEWED_SESSIONS, event);
              }
            case 1:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return function (_x2) {
        return _ref2.apply(this, arguments);
      };
    }());
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "handleUserSessionsDeletedEvents", /*#__PURE__*/function () {
      var _ref3 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(event) {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              if (event && event.data.deletedSessions) {
                _this.emit(_types2.COMMON_EVENT_KEYS.CALL_HISTORY_USER_SESSIONS_DELETED, event);
              }
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      return function (_x3) {
        return _ref3.apply(this, arguments);
      };
    }());
    _this.sdkConnector = _SDKConnector.default;
    if (!_this.sdkConnector.getWebex()) {
      _SDKConnector.default.setWebex(webex);
    }
    _this.webex = _this.sdkConnector.getWebex();
    _this.janusUrl = _this.webex.internal.services._serviceUrls.janus;
    _this.registerSessionsListener();
    _Logger.default.setLogger(logger.level, _constants.CALL_HISTORY_FILE);
    return _this;
  }

  /**
   * Function to display the Janus API response.
   * @param days - Number of days to fetch the call history data.
   * @param limit - Number of records to be fetched.
   * @param sort - Sort the records in ascending or descending order.
   * @param sortBy - Sort the records by start time or end time.
   */
  (0, _createClass2.default)(CallHistory, [{
    key: "getCallHistoryData",
    value: (function () {
      var _getCallHistoryData = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
        var days,
          limit,
          sort,
          sortBy,
          date,
          sortByParam,
          sortParam,
          url,
          janusResponse,
          callingBackend,
          hasCucmDN,
          _ucmLinesResponse$dat,
          ucmLinesResponse,
          ucmLinesData,
          responseDetails,
          extendedError,
          errorInfo,
          errorStatus,
          _args4 = arguments;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              days = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : _constants.NUMBER_OF_DAYS;
              limit = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : _constants.LIMIT;
              sort = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : _types.SORT.DEFAULT;
              sortBy = _args4.length > 3 && _args4[3] !== undefined ? _args4[3] : _types.SORT_BY.DEFAULT;
              /*
                1. Mandatory field for Janus API - fromDate
                2. Calculating the fromDate by deducting the NUMBER_OF_DAYS with the current date
               */
              date = new Date();
              date.setDate(date.getDate() - days);
              this.fromDate = date.toISOString();
              sortByParam = (0, _values.default)(_types.SORT_BY).includes(sortBy) ? sortBy : _types.SORT_BY.DEFAULT;
              sortParam = (0, _values.default)(_types.SORT).includes(sort) ? sort : _types.SORT.DEFAULT;
              _Logger.default.info("".concat(_constants2.METHOD_START_MESSAGE, " with days=").concat(days, ", limit=").concat(limit, ", sort=").concat(sortParam, ", sortBy=").concat(sortByParam), this.loggerContext);
              _Logger.default.info("Janus API URL: ".concat(this.janusUrl), this.loggerContext);
              _Logger.default.info("Call history from date : ".concat(this.fromDate), this.loggerContext);
              url = "".concat(this.janusUrl, "/").concat(_constants.HISTORY, "/").concat(_constants2.USER_SESSIONS).concat(_constants.FROM_DATE, "=").concat(this.fromDate, "&limit=").concat(limit, "&includeNewSessionTypes=true&sort=").concat(sortParam);
              _context4.prev = 13;
              _context4.next = 16;
              return this.webex.request({
                uri: "".concat(url),
                method: _types.HTTP_METHODS.GET,
                service: _types.ALLOWED_SERVICES.JANUS
              });
            case 16:
              janusResponse = _context4.sent;
              this.userSessions = janusResponse.body;
              if (sortByParam === _types.SORT_BY.START_TIME) {
                if (sortParam === _types.SORT.DESC) {
                  this.userSessions[_constants2.USER_SESSIONS].sort(function (element, compareElement) {
                    return new Date(compareElement[sortByParam]).getTime() - new Date(element[sortByParam]).getTime();
                  });
                } else if (sortParam === _types.SORT.ASC) {
                  this.userSessions[_constants2.USER_SESSIONS].sort(function (element, compareElement) {
                    return new Date(element[sortByParam]).getTime() - new Date(compareElement[sortByParam]).getTime();
                  });
                }
              }
              // Check the calling backend
              callingBackend = (0, _Utils.getCallingBackEnd)(this.webex);
              if (!(callingBackend === _types.CALLING_BACKEND.UCM)) {
                _context4.next = 28;
                break;
              }
              if (!(this.userSessions[_constants2.USER_SESSIONS] && this.userSessions[_constants2.USER_SESSIONS].length > 0)) {
                _context4.next = 28;
                break;
              }
              // Check if cucmDN exists and is valid in any of the userSessions
              hasCucmDN = this.userSessions[_constants2.USER_SESSIONS].some(function (session) {
                return session.self.cucmDN && session.self.cucmDN.length > 0;
              }); // If any user session has cucmDN, proceed to fetch line data
              if (!hasCucmDN) {
                _context4.next = 28;
                break;
              }
              _context4.next = 26;
              return this.fetchUCMLinesData();
            case 26:
              ucmLinesResponse = _context4.sent;
              // Check if the Lines API response was successful
              if (ucmLinesResponse.statusCode === 200 && (_ucmLinesResponse$dat = ucmLinesResponse.data.lines) !== null && _ucmLinesResponse$dat !== void 0 && _ucmLinesResponse$dat.devices) {
                ucmLinesData = ucmLinesResponse.data.lines.devices; // Iterate over user sessions and match with Lines data
                this.userSessions[_constants2.USER_SESSIONS].forEach(function (session) {
                  var cucmDN = session.self.cucmDN;
                  if (cucmDN) {
                    ucmLinesData.forEach(function (device) {
                      device.lines.forEach(function (line) {
                        if (line.dnorpattern === cucmDN) {
                          session.self.ucmLineNumber = line.index; // Assign the ucmLineNumber
                        }
                      });
                    });
                  }
                });
              }
            case 28:
              responseDetails = {
                statusCode: this.userSessions[_constants2.STATUS_CODE],
                data: {
                  userSessions: this.userSessions[_constants2.USER_SESSIONS]
                },
                message: _constants2.SUCCESS_MESSAGE
              };
              _Logger.default.log("Successfully retrieved call history data with ".concat(this.userSessions[_constants2.USER_SESSIONS].length, " records"), this.loggerContext);
              return _context4.abrupt("return", responseDetails);
            case 33:
              _context4.prev = 33;
              _context4.t0 = _context4["catch"](13);
              extendedError = new Error("Failed to get call history: ".concat(_context4.t0));
              _Logger.default.error(extendedError, {
                file: _constants.CALL_HISTORY_FILE,
                method: _constants.METHODS.GET_CALL_HISTORY_DATA
              });
              _context4.next = 39;
              return (0, _Utils.uploadLogs)();
            case 39:
              errorInfo = _context4.t0;
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, this.loggerContext);
              return _context4.abrupt("return", errorStatus);
            case 42:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this, [[13, 33]]);
      }));
      function getCallHistoryData() {
        return _getCallHistoryData.apply(this, arguments);
      }
      return getCallHistoryData;
    }()
    /**
     * Function to update the missed call status in the call history using sessionId and time.
     * @param endTimeSessionIds - An array of objects containing endTime and sessionId of the missed call history records
     * @returns {Promise} Resolves to an object of type  {@link UpdateMissedCallsResponse}.Response details with success or error status.
     */
    )
  }, {
    key: "updateMissedCalls",
    value: (function () {
      var _updateMissedCalls = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(endTimeSessionIds) {
        var loggerContext, santizedSessionIds, requestBody, updateMissedCallContentUrl, response, data, responseDetails, extendedError, errorInfo, errorStatus;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              loggerContext = {
                file: _constants.CALL_HISTORY_FILE,
                method: _constants.METHODS.UPDATE_MISSED_CALLS
              }; // Convert endTime to milliseconds for each session
              santizedSessionIds = endTimeSessionIds.map(function (session) {
                return _objectSpread(_objectSpread({}, session), {}, {
                  endTime: new Date(session.endTime).getTime()
                });
              });
              requestBody = {
                endTimeSessionIds: santizedSessionIds
              };
              _Logger.default.info("".concat(_constants2.METHOD_START_MESSAGE, " with sessions: ").concat((0, _stringify.default)(santizedSessionIds)), loggerContext);
              _context5.prev = 4;
              updateMissedCallContentUrl = "".concat(this.janusUrl, "/").concat(_constants.HISTORY, "/").concat(_constants2.USER_SESSIONS, "/").concat(_constants.UPDATE_MISSED_CALLS_ENDPOINT); // Make a POST request to update missed calls
              _context5.t0 = fetch;
              _context5.t1 = updateMissedCallContentUrl;
              _context5.t2 = _types.HTTP_METHODS.POST;
              _context5.t3 = _defineProperty2.default;
              _context5.t4 = (0, _defineProperty2.default)({}, _constants.CONTENT_TYPE, _constants.APPLICATION_JSON);
              _context5.next = 13;
              return this.webex.credentials.getUserToken();
            case 13:
              _context5.t5 = _context5.sent;
              _context5.t6 = (0, _context5.t3)(_context5.t4, "Authorization", _context5.t5);
              _context5.t7 = (0, _stringify.default)(requestBody);
              _context5.t8 = {
                method: _context5.t2,
                headers: _context5.t6,
                body: _context5.t7
              };
              _context5.next = 19;
              return (0, _context5.t0)(_context5.t1, _context5.t8);
            case 19:
              response = _context5.sent;
              if (response.ok) {
                _context5.next = 22;
                break;
              }
              throw new Error("".concat(response.status));
            case 22:
              _context5.next = 24;
              return response.json();
            case 24:
              data = _context5.sent;
              _Logger.default.log("Missed calls are successfully read by the user", loggerContext);
              responseDetails = {
                statusCode: data.statusCode,
                data: {
                  readStatusMessage: _constants.SET_READ_STATE_SUCCESS_MESSAGE
                },
                message: _constants2.SUCCESS_MESSAGE
              };
              _Logger.default.log("Successfully updated ".concat(santizedSessionIds === null || santizedSessionIds === void 0 ? void 0 : santizedSessionIds.length, " missed calls"), loggerContext);
              return _context5.abrupt("return", responseDetails);
            case 31:
              _context5.prev = 31;
              _context5.t9 = _context5["catch"](4);
              extendedError = new Error("Failed to update missed calls: ".concat(_context5.t9));
              _Logger.default.error(extendedError, {
                file: _constants.CALL_HISTORY_FILE,
                method: _constants.METHODS.UPDATE_MISSED_CALLS
              });
              _context5.next = 37;
              return (0, _Utils.uploadLogs)();
            case 37:
              // Catch the 401 error from try block, return the error object to user
              errorInfo = {
                statusCode: _context5.t9 instanceof Error ? Number(_context5.t9.message) : ''
              };
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context5.abrupt("return", errorStatus);
            case 40:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this, [[4, 31]]);
      }));
      function updateMissedCalls(_x4) {
        return _updateMissedCalls.apply(this, arguments);
      }
      return updateMissedCalls;
    }()
    /**
     * Function to display the UCM Lines API response.
     * @returns {Promise} Resolves to an object of type  {@link UCMLinesResponse}.Response details with success or error status.
     */
    )
  }, {
    key: "fetchUCMLinesData",
    value: (function () {
      var _fetchUCMLinesData = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
        var loggerContext, vgEndpoint, userId, orgId, linesURIForUCM, response, ucmLineDetails, extendedError, errorInfo, errorStatus;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              loggerContext = {
                file: _constants.CALL_HISTORY_FILE,
                method: _constants.METHODS.FETCH_UCM_LINES_DATA
              };
              vgEndpoint = (0, _Utils.getVgActionEndpoint)(this.webex, _types.CALLING_BACKEND.UCM);
              userId = this.webex.internal.device.userId;
              orgId = this.webex.internal.device.orgId;
              linesURIForUCM = "".concat(vgEndpoint, "/").concat(_constants.VERSION_1, "/").concat(_constants.UNIFIED_COMMUNICATIONS, "/").concat(_constants.CONFIG, "/").concat(_constants.PEOPLE, "/").concat(userId, "/").concat(_constants.LINES, "?").concat(_constants.ORG_ID, "=").concat(orgId);
              _Logger.default.info("".concat(_constants2.METHOD_START_MESSAGE, " with URL: ").concat(linesURIForUCM), loggerContext);
              _context6.prev = 6;
              _context6.next = 9;
              return this.webex.request({
                uri: "".concat(linesURIForUCM),
                method: _types.HTTP_METHODS.GET
              });
            case 9:
              response = _context6.sent;
              ucmLineDetails = {
                statusCode: Number(response.statusCode),
                data: {
                  lines: response.body
                },
                message: _constants2.SUCCESS_MESSAGE
              };
              _Logger.default.log("Line details fetched successfully", loggerContext);
              return _context6.abrupt("return", ucmLineDetails);
            case 15:
              _context6.prev = 15;
              _context6.t0 = _context6["catch"](6);
              extendedError = new Error("Failed to fetch UCM lines data: ".concat(_context6.t0));
              _Logger.default.error(extendedError, {
                file: _constants.CALL_HISTORY_FILE,
                method: _constants.METHODS.FETCH_UCM_LINES_DATA
              });
              _context6.next = 21;
              return (0, _Utils.uploadLogs)();
            case 21:
              errorInfo = _context6.t0;
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context6.abrupt("return", errorStatus);
            case 24:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[6, 15]]);
      }));
      function fetchUCMLinesData() {
        return _fetchUCMLinesData.apply(this, arguments);
      }
      return fetchUCMLinesData;
    }()
    /**
     * Function to delete the call history records using sessionId and endTime.
     * @param deleteSessionIds - An array of objects containing endTime and sessionId of the call history records
     * @returns {Promise} Resolves to an object of type  {@link DeleteCallHistoryRecordsResponse}.Response details with success or error status.
     */
    )
  }, {
    key: "deleteCallHistoryRecords",
    value: (function () {
      var _deleteCallHistoryRecords = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(deleteSessionIds) {
        var loggerContext, invalidSessions, invalidSessionIds, santizedSessionIds, deleteRequestBody, deleteCallHistoryRecordContentUrl, response, data, responseDetails, extendedError, errorInfo, errorStatus;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              loggerContext = {
                file: _constants.CALL_HISTORY_FILE,
                method: _constants.METHODS.DELETE_CALL_HISTORY_RECORDS
              }; // Collect all sessions with invalid dates (endTime) in an array
              invalidSessions = deleteSessionIds.filter(function (session) {
                return (0, _isNan.default)(new Date(session.endTime).getTime());
              });
              _Logger.default.info("".concat(_constants2.METHOD_START_MESSAGE, " with sessions: ").concat((0, _stringify.default)(deleteSessionIds)), loggerContext);
              if (!(invalidSessions.length > 0)) {
                _context7.next = 7;
                break;
              }
              // If there are invalid sessions, return an error with details
              invalidSessionIds = invalidSessions.map(function (session) {
                return session.sessionId;
              }).join(', ');
              _Logger.default.info("The provided date is malformed or invalid for session IDs: ".concat(invalidSessionIds), loggerContext);
              return _context7.abrupt("return", {
                statusCode: 400,
                data: {
                  deleteStatusMessage: _constants.SET_DELETE_CALL_RECORDS_INVALID_DATE_FORMAT_MESSAGE
                },
                message: _constants2.FAILURE_MESSAGE
              });
            case 7:
              // Convert endTime to milliseconds for each sessionId
              santizedSessionIds = deleteSessionIds.map(function (session) {
                return _objectSpread(_objectSpread({}, session), {}, {
                  endTime: new Date(session.endTime).getTime()
                });
              });
              deleteRequestBody = {
                deleteSessionIds: santizedSessionIds
              };
              _context7.prev = 9;
              deleteCallHistoryRecordContentUrl = "".concat(this.janusUrl, "/").concat(_constants.HISTORY, "/").concat(_constants2.USER_SESSIONS, "/").concat(_constants.DELETE_CALL_HISTORY_RECORDS_ENDPOINT); // Make a POST request to delete call history records
              _context7.t0 = fetch;
              _context7.t1 = deleteCallHistoryRecordContentUrl;
              _context7.t2 = _types.HTTP_METHODS.POST;
              _context7.t3 = _defineProperty2.default;
              _context7.t4 = (0, _defineProperty2.default)({}, _constants.CONTENT_TYPE, _constants.APPLICATION_JSON);
              _context7.next = 18;
              return this.webex.credentials.getUserToken();
            case 18:
              _context7.t5 = _context7.sent;
              _context7.t6 = (0, _context7.t3)(_context7.t4, "Authorization", _context7.t5);
              _context7.t7 = (0, _stringify.default)(deleteRequestBody);
              _context7.t8 = {
                method: _context7.t2,
                headers: _context7.t6,
                body: _context7.t7
              };
              _context7.next = 24;
              return (0, _context7.t0)(_context7.t1, _context7.t8);
            case 24:
              response = _context7.sent;
              if (response.ok) {
                _context7.next = 27;
                break;
              }
              throw new Error("".concat(response.status));
            case 27:
              _context7.next = 29;
              return response.json();
            case 29:
              data = _context7.sent;
              _Logger.default.log("Successfully deleted ".concat(santizedSessionIds === null || santizedSessionIds === void 0 ? void 0 : santizedSessionIds.length, " call history records"), loggerContext);
              responseDetails = {
                statusCode: data.statusCode,
                data: {
                  deleteStatusMessage: _constants.SET_DELETE_CALL_RECORDS_SUCCESS_MESSAGE
                },
                message: _constants2.SUCCESS_MESSAGE
              };
              return _context7.abrupt("return", responseDetails);
            case 35:
              _context7.prev = 35;
              _context7.t9 = _context7["catch"](9);
              extendedError = new Error("Failed to delete call history records: ".concat(_context7.t9));
              _Logger.default.error(extendedError, {
                file: _constants.CALL_HISTORY_FILE,
                method: _constants.METHODS.DELETE_CALL_HISTORY_RECORDS
              });
              _context7.next = 41;
              return (0, _Utils.uploadLogs)();
            case 41:
              // Catch the 401 error from try block, return the error object to user
              errorInfo = {
                statusCode: _context7.t9 instanceof Error ? Number(_context7.t9.message) : ''
              };
              errorStatus = (0, _Utils.serviceErrorCodeHandler)(errorInfo, loggerContext);
              return _context7.abrupt("return", errorStatus);
            case 44:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[9, 35]]);
      }));
      function deleteCallHistoryRecords(_x5) {
        return _deleteCallHistoryRecords.apply(this, arguments);
      }
      return deleteCallHistoryRecords;
    }())
  }, {
    key: "registerSessionsListener",
    value:
    /**
     *
     */
    function registerSessionsListener() {
      this.sdkConnector.registerListener(_types2.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_INCLUSIVE, this.handleSessionEvents);
      this.sdkConnector.registerListener(_types2.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_LEGACY, this.handleSessionEvents);
      this.sdkConnector.registerListener(_types2.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_VIEWED, this.handleUserReadSessionEvents);
      this.sdkConnector.registerListener(_types2.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_DELETED, this.handleUserSessionsDeletedEvents);
    }
  }]);
  return CallHistory;
}(_impl.Eventing);
/**
 * Creates a `CallHistory` client instance for accessing Call History APIs.
 *
 * @param {WebexSDK} webex - `Webex SDK` instance.
 * @param {LoggerInterface} logger - An instance implementing LoggerInterface used to set the log level for the module.
 */
var createCallHistoryClient = exports.createCallHistoryClient = function createCallHistoryClient(webex, logger) {
  return new CallHistory(webex, logger);
};
//# sourceMappingURL=CallHistory.js.map
