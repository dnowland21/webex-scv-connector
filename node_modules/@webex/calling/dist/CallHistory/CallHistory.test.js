"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _types = require("../Logger/types");
var _testUtil = require("../common/testUtil");
var _types2 = require("../common/types");
var _CallHistory = require("./CallHistory");
var _callHistoryFixtures = require("./callHistoryFixtures");
var _types3 = require("../Events/types");
var _constants = require("./constants");
var utils = _interopRequireWildcard(require("../common/Utils"));
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; } /* eslint-disable @typescript-eslint/no-unused-vars */ /* eslint-disable dot-notation */ /* eslint-disable @typescript-eslint/no-shadow */
var webex = (0, _testUtil.getTestUtilsWebex)();
var serviceErrorCodeHandlerSpy;
describe('Call history tests', function () {
  var callHistory;
  beforeAll(function () {
    callHistory = new _CallHistory.CallHistory(webex, {
      level: _types.LOGGER.INFO
    });
  });
  it('verify successful call history case', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
    var callHistoryPayload, response;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          callHistoryPayload = _callHistoryFixtures.mockCallHistoryBody;
          webex.request.mockResolvedValue(callHistoryPayload);
          _context.next = 4;
          return callHistory.getCallHistoryData(7, 10, _types2.SORT.DEFAULT, _types2.SORT_BY.DEFAULT);
        case 4:
          response = _context.sent;
          expect(response.statusCode).toBe(200);
          expect(response.message).toBe('SUCCESS');
        case 7:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })));
  it('verify bad request failed call history case', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
    var failurePayload, callHistoryPayload, response;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          failurePayload = {
            statusCode: 400
          };
          callHistoryPayload = failurePayload;
          webex.request.mockRejectedValue(callHistoryPayload);
          _context2.next = 5;
          return callHistory.getCallHistoryData(7, 2000, _types2.SORT.ASC, _types2.SORT_BY.START_TIME);
        case 5:
          response = _context2.sent;
          expect(response.statusCode).toBe(400);
          expect(response.message).toBe('FAILURE');
        case 8:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  })));
  it('verify device not found call history case', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
    var failurePayload, callHistoryPayload, response;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          failurePayload = {
            statusCode: 404
          };
          callHistoryPayload = failurePayload;
          webex.request.mockRejectedValue(callHistoryPayload);
          _context3.next = 5;
          return callHistory.getCallHistoryData(0, 0, _types2.SORT.ASC, _types2.SORT_BY.START_TIME);
        case 5:
          response = _context3.sent;
          expect(response.statusCode).toBe(404);
          expect(response.message).toBe('FAILURE');
        case 8:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  })));
  describe('sorting  user session response data by sortby', function () {
    it('Array should be sort.ASC by START TIME ', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
      var callHistoryPayload, response, responseDetails;
      return _regenerator.default.wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            callHistoryPayload = _callHistoryFixtures.mockCallHistoryBody;
            webex.request.mockResolvedValue(callHistoryPayload);
            _context4.next = 4;
            return callHistory.getCallHistoryData(10, 20, _types2.SORT.ASC, _types2.SORT_BY.START_TIME);
          case 4:
            response = _context4.sent;
            responseDetails = {
              statusCode: _callHistoryFixtures.sortedCallHistory.body.statusCode,
              data: {
                userSessions: _callHistoryFixtures.sortedCallHistory.body.userSessions
              },
              message: 'SUCCESS'
            };
            expect(response).toEqual(responseDetails);
          case 7:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    })));
  });
  describe('Call History Session Event test', function () {
    var mockOn = webex.internal.mercury.on;
    var callHistory;
    beforeEach(function () {
      callHistory = (0, _CallHistory.createCallHistoryClient)(webex, {
        level: _types.LOGGER.INFO
      });
    });
    it('verify the recent user session event ', function (done) {
      callHistory.on(_types3.COMMON_EVENT_KEYS.CALL_HISTORY_USER_SESSION_INFO, function (event) {
        expect(event.data).toEqual(_callHistoryFixtures.MOCK_SESSION_EVENT.data);
        done();
      });
      expect(mockOn.mock.calls[0][0]).toEqual(_types3.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_INCLUSIVE);
      var callSessionCallback = mockOn.mock.calls[0][1];
      callSessionCallback(_callHistoryFixtures.MOCK_SESSION_EVENT);
    });
    it('verify the user session event received for locus calls', function (done) {
      callHistory.on(_types3.COMMON_EVENT_KEYS.CALL_HISTORY_USER_SESSION_INFO, function (event) {
        expect(event.data).toEqual(_callHistoryFixtures.MOCK_SESSION_EVENT_LEGACY.data);
        done();
      });
      expect(mockOn.mock.calls[1][0]).toEqual(_types3.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_LEGACY);
      var callSessionCallback = mockOn.mock.calls[1][1];
      callSessionCallback(_callHistoryFixtures.MOCK_SESSION_EVENT_LEGACY);
    });
    it('verify the user viewed session event for missed calls update', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
      return _regenerator.default.wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            _context5.next = 2;
            return new _promise.default(function (resolve) {
              callHistory.on(_types3.COMMON_EVENT_KEYS.CALL_HISTORY_USER_VIEWED_SESSIONS, function (event) {
                expect(event.data).toEqual(_callHistoryFixtures.MOCK_SESSION_EVENT_VIEWED.data);
                resolve();
              });
              expect(mockOn.mock.calls[2][0]).toEqual(_types3.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_VIEWED);
              var callSessionCallback = mockOn.mock.calls[2][1];
              callSessionCallback(_callHistoryFixtures.MOCK_SESSION_EVENT_VIEWED);
            });
          case 2:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    })));
    it('verify the user sessions deleted event for deleting the call history records', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
      return _regenerator.default.wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            _context6.next = 2;
            return new _promise.default(function (resolve) {
              callHistory.on(_types3.COMMON_EVENT_KEYS.CALL_HISTORY_USER_SESSIONS_DELETED, function (event) {
                expect(event.data).toEqual(_callHistoryFixtures.MOCK_SESSION_EVENT_DELETED.data);
                resolve();
              });
              expect(mockOn.mock.calls[3][0]).toEqual(_types3.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_DELETED);
              var callSessionCallback = mockOn.mock.calls[3][1];
              callSessionCallback(_callHistoryFixtures.MOCK_SESSION_EVENT_DELETED);
            });
          case 2:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    })));
  });
  describe('Update missed calls test', function () {
    var methodDetails = {
      file: _constants.CALL_HISTORY_FILE,
      method: 'updateMissedCalls'
    };
    afterEach(function () {
      jest.clearAllMocks();
    });
    beforeEach( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
      return _regenerator.default.wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            serviceErrorCodeHandlerSpy = jest.spyOn(utils, 'serviceErrorCodeHandler');
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                status: 200,
                ok: true,
                json: function json() {
                  return _promise.default.resolve(_callHistoryFixtures.MOCK_UPDATE_MISSED_CALL_RESPONSE);
                }
              });
            });
          case 2:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    })));
    it('successfully updates missed calls', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
      var endTimeSessionIds, response, convertedEndTimeSessionIds;
      return _regenerator.default.wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            endTimeSessionIds = [{
              endTime: '1234568',
              sessionId: '123'
            }];
            _context8.next = 3;
            return callHistory.updateMissedCalls(endTimeSessionIds);
          case 3:
            response = _context8.sent;
            convertedEndTimeSessionIds = endTimeSessionIds.map(function (session) {
              return _objectSpread(_objectSpread({}, session), {}, {
                endTime: new Date(session.endTime).getTime()
              });
            });
            expect(response.statusCode).toEqual(200);
            expect(response).toEqual(_callHistoryFixtures.MOCK_UPDATE_MISSED_CALL_RESPONSE);
            _context8.t0 = expect(global.fetch);
            _context8.t1 = _callHistoryFixtures.janusSetReadStateUrl;
            _context8.t2 = _types2.HTTP_METHODS.POST;
            _context8.t3 = _defineProperty2.default;
            _context8.t4 = (0, _defineProperty2.default)({}, _constants.CONTENT_TYPE, _constants.APPLICATION_JSON);
            _context8.next = 14;
            return webex.credentials.getUserToken();
          case 14:
            _context8.t5 = _context8.sent;
            _context8.t6 = (0, _context8.t3)(_context8.t4, "Authorization", _context8.t5);
            _context8.t7 = (0, _stringify.default)({
              endTimeSessionIds: convertedEndTimeSessionIds
            });
            _context8.t8 = {
              method: _context8.t2,
              headers: _context8.t6,
              body: _context8.t7
            };
            _context8.t0.toBeCalledOnceWith.call(_context8.t0, _context8.t1, _context8.t8);
          case 19:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    })));
    it('Error: updateMissedCalls throw 400 error', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
      var endTimeSessionIds, response, convertedEndTimeSessionIds;
      return _regenerator.default.wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            endTimeSessionIds = [];
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                status: 400,
                ok: false
              });
            });
            _context9.next = 4;
            return callHistory.updateMissedCalls(endTimeSessionIds);
          case 4:
            response = _context9.sent;
            convertedEndTimeSessionIds = endTimeSessionIds.map(function (session) {
              return _objectSpread(_objectSpread({}, session), {}, {
                endTime: new Date(session.endTime).getTime()
              });
            });
            expect(response).toStrictEqual(_callHistoryFixtures.ERROR_DETAILS_400);
            expect(response.statusCode).toBe(400);
            _context9.t0 = expect(global.fetch);
            _context9.t1 = _callHistoryFixtures.janusSetReadStateUrl;
            _context9.t2 = _types2.HTTP_METHODS.POST;
            _context9.t3 = _defineProperty2.default;
            _context9.t4 = (0, _defineProperty2.default)({}, _constants.CONTENT_TYPE, _constants.APPLICATION_JSON);
            _context9.next = 15;
            return webex.credentials.getUserToken();
          case 15:
            _context9.t5 = _context9.sent;
            _context9.t6 = (0, _context9.t3)(_context9.t4, "Authorization", _context9.t5);
            _context9.t7 = (0, _stringify.default)({
              endTimeSessionIds: convertedEndTimeSessionIds
            });
            _context9.t8 = {
              method: _context9.t2,
              headers: _context9.t6,
              body: _context9.t7
            };
            _context9.t0.toBeCalledOnceWith.call(_context9.t0, _context9.t1, _context9.t8);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, methodDetails);
          case 21:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    })));
    it('Error: updateMissedCalls throw 401 error', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
      var endTimeSessionIds, response, convertedEndTimeSessionIds;
      return _regenerator.default.wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            endTimeSessionIds = [];
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                status: 401,
                ok: false
              });
            });
            _context10.next = 4;
            return callHistory.updateMissedCalls(endTimeSessionIds);
          case 4:
            response = _context10.sent;
            convertedEndTimeSessionIds = endTimeSessionIds.map(function (session) {
              return _objectSpread(_objectSpread({}, session), {}, {
                endTime: new Date(session.endTime).getTime()
              });
            });
            expect(response).toStrictEqual(_callHistoryFixtures.ERROR_DETAILS_401);
            expect(response.statusCode).toBe(401);
            _context10.t0 = expect(global.fetch);
            _context10.t1 = _callHistoryFixtures.janusSetReadStateUrl;
            _context10.t2 = _types2.HTTP_METHODS.POST;
            _context10.t3 = _defineProperty2.default;
            _context10.t4 = (0, _defineProperty2.default)({}, _constants.CONTENT_TYPE, _constants.APPLICATION_JSON);
            _context10.next = 15;
            return webex.credentials.getUserToken();
          case 15:
            _context10.t5 = _context10.sent;
            _context10.t6 = (0, _context10.t3)(_context10.t4, "Authorization", _context10.t5);
            _context10.t7 = (0, _stringify.default)({
              endTimeSessionIds: convertedEndTimeSessionIds
            });
            _context10.t8 = {
              method: _context10.t2,
              headers: _context10.t6,
              body: _context10.t7
            };
            _context10.t0.toBeCalledOnceWith.call(_context10.t0, _context10.t1, _context10.t8);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 401
            }, methodDetails);
          case 21:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    })));
  });
  describe('fetchUCMLinesData test', function () {
    it('verify successful UCM lines API case', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
      var ucmLinesAPIPayload, response;
      return _regenerator.default.wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            ucmLinesAPIPayload = _callHistoryFixtures.MOCK_LINES_API_CALL_RESPONSE;
            webex.request.mockResolvedValue(ucmLinesAPIPayload);
            _context11.next = 4;
            return callHistory['fetchUCMLinesData']();
          case 4:
            response = _context11.sent;
            expect(response.statusCode).toBe(200);
            expect(response.message).toBe('SUCCESS');
          case 7:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    })));
    it('verify bad request failed UCM lines API case', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
      var failurePayload, ucmLinesAPIPayload, response;
      return _regenerator.default.wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            failurePayload = {
              statusCode: 400
            };
            ucmLinesAPIPayload = failurePayload;
            webex.request.mockRejectedValue(ucmLinesAPIPayload);
            _context12.next = 5;
            return callHistory['fetchUCMLinesData']();
          case 5:
            response = _context12.sent;
            expect(response).toStrictEqual(_callHistoryFixtures.ERROR_DETAILS_400);
            expect(response.data.error).toEqual(_callHistoryFixtures.ERROR_DETAILS_400.data.error);
            expect(response.statusCode).toBe(400);
            expect(response.message).toBe('FAILURE');
            expect(serviceErrorCodeHandlerSpy).toHaveBeenCalledWith({
              statusCode: 400
            }, {
              file: 'CallHistory',
              method: 'fetchLinesData'
            });
          case 11:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    })));
    it('should call fetchUCMLinesData when calling backend is UCM and userSessions contain valid cucmDN', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
      var fetchUCMLinesDataSpy, mockCallHistoryPayload, response;
      return _regenerator.default.wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            jest.spyOn(utils, 'getCallingBackEnd').mockReturnValue(_types2.CALLING_BACKEND.UCM);
            // Since fetchUCMLinesData is a private method, TypeScript restricts direct access to it.
            // To bypass this restriction, we are using 'as any' to access and invoke the method for testing purposes.
            fetchUCMLinesDataSpy = jest.spyOn(callHistory, 'fetchUCMLinesData').mockResolvedValue(_callHistoryFixtures.MOCK_LINES_API_CALL_RESPONSE);
            mockCallHistoryPayload = _callHistoryFixtures.MOCK_CALL_HISTORY_WITH_UCM_LINE_NUMBER;
            webex.request.mockResolvedValue(mockCallHistoryPayload);
            _context13.next = 6;
            return callHistory.getCallHistoryData(7, 10, _types2.SORT.DEFAULT, _types2.SORT_BY.DEFAULT);
          case 6:
            response = _context13.sent;
            expect(fetchUCMLinesDataSpy).toHaveBeenCalledTimes(1);
            expect(response.statusCode).toBe(200);
            expect(response.data.userSessions && response.data.userSessions[0].self.ucmLineNumber).toEqual(1);
          case 10:
          case "end":
            return _context13.stop();
        }
      }, _callee13);
    })));
    it('should fetchUCMLinesData but not assign ucmLineNumber when UCM backend has no line data', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14() {
      var fetchUCMLinesDataSpy, mockCallHistoryPayload, response;
      return _regenerator.default.wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            jest.spyOn(utils, 'getCallingBackEnd').mockReturnValue(_types2.CALLING_BACKEND.UCM);

            // Since fetchUCMLinesData is a private method, TypeScript restricts direct access to it.
            // To bypass this restriction, we are using 'as any' to access and invoke the method for testing purposes.
            fetchUCMLinesDataSpy = jest.spyOn(callHistory, 'fetchUCMLinesData').mockResolvedValue(_callHistoryFixtures.MOCK_LINES_API_CALL_RESPONSE_WITH_NO_LINEDATA);
            mockCallHistoryPayload = _callHistoryFixtures.MOCK_CALL_HISTORY_WITHOUT_UCM_LINE_NUMBER;
            webex.request.mockResolvedValue(mockCallHistoryPayload);
            _context14.next = 6;
            return callHistory.getCallHistoryData(7, 10, _types2.SORT.DEFAULT, _types2.SORT_BY.DEFAULT);
          case 6:
            response = _context14.sent;
            expect(fetchUCMLinesDataSpy).toHaveBeenCalledTimes(1);
            expect(response.statusCode).toBe(200);
            expect(response.data.userSessions && response.data.userSessions[0].self.cucmDN).toBeDefined();
            expect(response.data.userSessions && response.data.userSessions[0].self.ucmLineNumber).toEqual(undefined);
          case 11:
          case "end":
            return _context14.stop();
        }
      }, _callee14);
    })));
    it('should not call fetchUCMLinesData when calling backend is UCM but no valid cucmDN is present', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15() {
      var fetchUCMLinesDataSpy, callHistoryPayload;
      return _regenerator.default.wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            jest.spyOn(utils, 'getCallingBackEnd').mockReturnValue(_types2.CALLING_BACKEND.UCM);
            // Since fetchUCMLinesData is a private method, TypeScript restricts direct access to it.
            // To bypass this restriction, we are using 'as any' to access and invoke the method for testing purposes.
            fetchUCMLinesDataSpy = jest.spyOn(callHistory, 'fetchUCMLinesData').mockResolvedValue({});
            callHistoryPayload = _callHistoryFixtures.mockCallHistoryBody;
            webex.request.mockResolvedValue(callHistoryPayload);
            _context15.next = 6;
            return callHistory.getCallHistoryData(7, 10, _types2.SORT.DEFAULT, _types2.SORT_BY.DEFAULT);
          case 6:
            expect(fetchUCMLinesDataSpy).not.toHaveBeenCalled();
          case 7:
          case "end":
            return _context15.stop();
        }
      }, _callee15);
    })));
    it('should not call fetchUCMLinesData when calling backend is not UCM', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16() {
      var fetchUCMLinesDataSpy, callHistoryPayload;
      return _regenerator.default.wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            jest.spyOn(utils, 'getCallingBackEnd').mockReturnValue(_types2.CALLING_BACKEND.WXC);
            // Since fetchUCMLinesData is a private method, TypeScript restricts direct access to it.
            // To bypass this restriction, we are using 'as any' to access and invoke the method for testing purposes.
            fetchUCMLinesDataSpy = jest.spyOn(callHistory, 'fetchUCMLinesData').mockResolvedValue({});
            callHistoryPayload = _callHistoryFixtures.mockCallHistoryBody;
            webex.request.mockResolvedValue(callHistoryPayload);
            _context16.next = 6;
            return callHistory.getCallHistoryData(7, 10, _types2.SORT.DEFAULT, _types2.SORT_BY.DEFAULT);
          case 6:
            expect(fetchUCMLinesDataSpy).not.toHaveBeenCalled(); // Check that fetchUCMLinesData was not called
          case 7:
          case "end":
            return _context16.stop();
        }
      }, _callee16);
    })));
  });
  describe('Delete call history records test', function () {
    var methodDetails = {
      file: _constants.CALL_HISTORY_FILE,
      method: 'deleteCallHistoryRecords'
    };
    afterEach(function () {
      jest.clearAllMocks();
    });
    beforeEach( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17() {
      return _regenerator.default.wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            serviceErrorCodeHandlerSpy = jest.spyOn(utils, 'serviceErrorCodeHandler');
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                status: 200,
                ok: true,
                json: function json() {
                  return _promise.default.resolve(_callHistoryFixtures.MOCK_DELETE_CALL_HISTORY_RECORDS_RESPONSE);
                }
              });
            });
          case 2:
          case "end":
            return _context17.stop();
        }
      }, _callee17);
    })));
    it('successfully deletes the call history records', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18() {
      var deleteSessionIds, response, convertedEndTimeSessionIds;
      return _regenerator.default.wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            deleteSessionIds = [{
              endTime: '2024-10-22T08:50:48.603Z',
              sessionId: '123'
            }];
            _context18.next = 3;
            return callHistory.deleteCallHistoryRecords(deleteSessionIds);
          case 3:
            response = _context18.sent;
            convertedEndTimeSessionIds = deleteSessionIds.map(function (session) {
              return _objectSpread(_objectSpread({}, session), {}, {
                endTime: new Date(session.endTime).getTime()
              });
            });
            expect(response.statusCode).toEqual(200);
            expect(response).toEqual(_callHistoryFixtures.MOCK_DELETE_CALL_HISTORY_RECORDS_RESPONSE);
            _context18.t0 = expect(global.fetch);
            _context18.t1 = _callHistoryFixtures.janusMarkAsDeletedUrl;
            _context18.t2 = _types2.HTTP_METHODS.POST;
            _context18.t3 = _defineProperty2.default;
            _context18.t4 = (0, _defineProperty2.default)({}, _constants.CONTENT_TYPE, _constants.APPLICATION_JSON);
            _context18.next = 14;
            return webex.credentials.getUserToken();
          case 14:
            _context18.t5 = _context18.sent;
            _context18.t6 = (0, _context18.t3)(_context18.t4, "Authorization", _context18.t5);
            _context18.t7 = (0, _stringify.default)({
              deleteSessionIds: convertedEndTimeSessionIds
            });
            _context18.t8 = {
              method: _context18.t2,
              headers: _context18.t6,
              body: _context18.t7
            };
            _context18.t0.toBeCalledOnceWith.call(_context18.t0, _context18.t1, _context18.t8);
          case 19:
          case "end":
            return _context18.stop();
        }
      }, _callee18);
    })));
    it('Error: deleteCallHistoryRecords throw 400 error', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee19() {
      var deleteSessionIds, response, convertedEndTimeSessionIds;
      return _regenerator.default.wrap(function _callee19$(_context19) {
        while (1) switch (_context19.prev = _context19.next) {
          case 0:
            deleteSessionIds = [];
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                status: 400,
                ok: false
              });
            });
            _context19.next = 4;
            return callHistory.deleteCallHistoryRecords(deleteSessionIds);
          case 4:
            response = _context19.sent;
            convertedEndTimeSessionIds = deleteSessionIds.map(function (session) {
              return _objectSpread(_objectSpread({}, session), {}, {
                endTime: new Date(session.endTime).getTime()
              });
            });
            expect(response).toStrictEqual(_callHistoryFixtures.ERROR_DETAILS_400);
            expect(response.statusCode).toBe(400);
            _context19.t0 = expect(global.fetch);
            _context19.t1 = _callHistoryFixtures.janusMarkAsDeletedUrl;
            _context19.t2 = _types2.HTTP_METHODS.POST;
            _context19.t3 = _defineProperty2.default;
            _context19.t4 = (0, _defineProperty2.default)({}, _constants.CONTENT_TYPE, _constants.APPLICATION_JSON);
            _context19.next = 15;
            return webex.credentials.getUserToken();
          case 15:
            _context19.t5 = _context19.sent;
            _context19.t6 = (0, _context19.t3)(_context19.t4, "Authorization", _context19.t5);
            _context19.t7 = (0, _stringify.default)({
              deleteSessionIds: convertedEndTimeSessionIds
            });
            _context19.t8 = {
              method: _context19.t2,
              headers: _context19.t6,
              body: _context19.t7
            };
            _context19.t0.toBeCalledOnceWith.call(_context19.t0, _context19.t1, _context19.t8);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 400
            }, methodDetails);
          case 21:
          case "end":
            return _context19.stop();
        }
      }, _callee19);
    })));
    it('Error: deleteCallHistoryRecords throw 401 error', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee20() {
      var deleteSessionIds, response, convertedEndTimeSessionIds;
      return _regenerator.default.wrap(function _callee20$(_context20) {
        while (1) switch (_context20.prev = _context20.next) {
          case 0:
            deleteSessionIds = [];
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                status: 401,
                ok: false
              });
            });
            _context20.next = 4;
            return callHistory.deleteCallHistoryRecords(deleteSessionIds);
          case 4:
            response = _context20.sent;
            convertedEndTimeSessionIds = deleteSessionIds.map(function (session) {
              return _objectSpread(_objectSpread({}, session), {}, {
                endTime: new Date(session.endTime).getTime()
              });
            });
            expect(response).toStrictEqual(_callHistoryFixtures.ERROR_DETAILS_401);
            expect(response.statusCode).toBe(401);
            _context20.t0 = expect(global.fetch);
            _context20.t1 = _callHistoryFixtures.janusMarkAsDeletedUrl;
            _context20.t2 = _types2.HTTP_METHODS.POST;
            _context20.t3 = _defineProperty2.default;
            _context20.t4 = (0, _defineProperty2.default)({}, _constants.CONTENT_TYPE, _constants.APPLICATION_JSON);
            _context20.next = 15;
            return webex.credentials.getUserToken();
          case 15:
            _context20.t5 = _context20.sent;
            _context20.t6 = (0, _context20.t3)(_context20.t4, "Authorization", _context20.t5);
            _context20.t7 = (0, _stringify.default)({
              deleteSessionIds: convertedEndTimeSessionIds
            });
            _context20.t8 = {
              method: _context20.t2,
              headers: _context20.t6,
              body: _context20.t7
            };
            _context20.t0.toBeCalledOnceWith.call(_context20.t0, _context20.t1, _context20.t8);
            expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith({
              statusCode: 401
            }, methodDetails);
          case 21:
          case "end":
            return _context20.stop();
        }
      }, _callee20);
    })));
    it('handles invalid date formats gracefully', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee21() {
      var deleteSessionIds, response;
      return _regenerator.default.wrap(function _callee21$(_context21) {
        while (1) switch (_context21.prev = _context21.next) {
          case 0:
            deleteSessionIds = [{
              endTime: 'invalid-date',
              sessionId: '123'
            }]; // Mock the response to be 400 and trigger an error in your function
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                status: 400,
                ok: false
              });
            });
            _context21.next = 4;
            return callHistory.deleteCallHistoryRecords(deleteSessionIds);
          case 4:
            response = _context21.sent;
            expect(response.statusCode).toBe(400);
            expect(response).toEqual(_callHistoryFixtures.MOCK_DELETE_CALL_HISTORY_INVALID_DATE_RESPONSE);
          case 7:
          case "end":
            return _context21.stop();
        }
      }, _callee21);
    })));
  });
});
//# sourceMappingURL=CallHistory.test.js.map
