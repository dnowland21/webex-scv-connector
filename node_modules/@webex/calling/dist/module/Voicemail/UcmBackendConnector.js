import SDKConnector from '../SDKConnector';
import { HTTP_METHODS, CALLING_BACKEND, } from '../common/types';
import { getVgActionEndpoint, serviceErrorCodeHandler, uploadLogs } from '../common/Utils';
import { SUCCESS_MESSAGE, USERS, CONTENT, UCM_CONNECTOR_FILE, FAILURE_MESSAGE, METHOD_START_MESSAGE, } from '../common/constants';
import log from '../Logger';
import { API_V1, LIMIT, METHODS, OFFSET, SORT_ORDER, VMGATEWAY, VOICEMAILS } from './constants';
export class UcmBackendConnector {
    vgEndpoint;
    userId;
    orgId;
    sdkConnector;
    webex;
    vgVoiceMessageURI;
    constructor(webex, logger) {
        this.sdkConnector = SDKConnector;
        if (!this.sdkConnector.getWebex()) {
            SDKConnector.setWebex(webex);
        }
        this.webex = this.sdkConnector.getWebex();
        this.userId = this.webex.internal.device.userId;
        this.orgId = this.webex.internal.device.orgId;
        log.setLogger(logger.level, UCM_CONNECTOR_FILE);
    }
    init() {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.INIT,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        const response = this.setUcmVoiceMessageBaseURI();
        log.log('UCM calling voicemail connector initialized successfully', loggerContext);
        return response;
    }
    getSDKConnector() {
        return this.sdkConnector;
    }
    setUcmVoiceMessageBaseURI() {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.SET_UCM_VOICE_MESSAGE_BASE_URI,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        this.vgEndpoint = getVgActionEndpoint(this.webex, CALLING_BACKEND.UCM);
        this.vgVoiceMessageURI = `${this.vgEndpoint}/${VMGATEWAY}/${API_V1}/${USERS}/${this.userId}/`;
        return this.vgVoiceMessageURI;
    }
    async getVoicemailList(offset, offsetLimit, sort) {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.GET_VOICEMAIL_LIST,
        };
        log.info(`${METHOD_START_MESSAGE} with Offset: ${offset} Offset limit: ${offsetLimit} Sort type:${sort}`, loggerContext);
        const urlVg = `${this.vgVoiceMessageURI}${VOICEMAILS}/${OFFSET}=${offset}${LIMIT}=${offsetLimit}${SORT_ORDER}=${sort}`;
        try {
            const response = await this.webex.request({
                uri: `${urlVg}`,
                method: HTTP_METHODS.GET,
                headers: {
                    orgId: this.orgId,
                },
            });
            const msgInfo = response.body;
            const messageinfoArray = [];
            const ucmVmMsgInfo = msgInfo.Message;
            ucmVmMsgInfo.forEach((msgInfoObj) => {
                const message = {};
                let stringObj = {};
                const numberObj = {};
                stringObj.$ = msgInfoObj.Duration;
                message.duration = stringObj;
                numberObj.$ = Number(msgInfoObj.ArrivalTime);
                message.time = numberObj;
                stringObj = { $: '' };
                stringObj.$ = msgInfoObj.MsgId;
                message.messageId = stringObj;
                if (msgInfoObj.Read === 'true') {
                    message.read = {};
                }
                const callerIdObj = msgInfoObj.CallerId;
                const callingParty = {};
                stringObj = { $: '' };
                stringObj.$ = callerIdObj.CallerName;
                callingParty.name = stringObj;
                stringObj = { $: '' };
                stringObj.$ = this.userId;
                callingParty.userId = stringObj;
                stringObj = { $: '' };
                stringObj.$ = callerIdObj.CallerNumber;
                callingParty.address = stringObj;
                message.callingPartyInfo = callingParty;
                messageinfoArray.push(message);
            });
            const responseDetails = {
                statusCode: Number(response.statusCode),
                data: {
                    voicemailList: messageinfoArray,
                },
                message: SUCCESS_MESSAGE,
            };
            log.log('Successfully retrieved voicemail list', loggerContext);
            return responseDetails;
        }
        catch (err) {
            const extendedError = new Error(`Failed to get voicemail list: ${err}`);
            log.error(extendedError, loggerContext);
            await uploadLogs();
            const errorInfo = err;
            const errorStatus = serviceErrorCodeHandler(errorInfo, loggerContext);
            return errorStatus;
        }
    }
    async getVoicemailContent(messageId) {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.GET_VOICEMAIL_CONTENT,
        };
        log.info(`${METHOD_START_MESSAGE} with Message ID: ${messageId}`, loggerContext);
        try {
            const response = (await this.getVoicemailContentUcm(messageId));
            log.log(`Successfully retrieved voicemail content with  Message ID: ${messageId}`, loggerContext);
            return response;
        }
        catch (err) {
            const extendedError = new Error(`Failed to get voicemail content: ${err}`);
            log.error(extendedError, loggerContext);
            await uploadLogs();
            const errorInfo = err;
            const errorStatus = serviceErrorCodeHandler(errorInfo, loggerContext);
            log.info(`Voice mail content error is ${errorStatus}`, loggerContext);
            return errorStatus;
        }
    }
    async getVoicemailSummary() {
        return Promise.resolve(null);
    }
    async getVoicemailContentUcm(messageId) {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.GET_VOICEMAIL_CONTENT_UCM,
        };
        log.info(`${METHOD_START_MESSAGE} with Message ID: ${messageId}`, loggerContext);
        return new Promise((resolve, reject) => {
            const voicemailContentUrl = `${this.vgVoiceMessageURI}${VOICEMAILS}/${messageId}/${CONTENT}`;
            const mercuryApi = `${this.webex.internal.services._serviceUrls.mercuryApi}`;
            this.returnUcmPromise(voicemailContentUrl, mercuryApi)
                .then((response) => {
                if (response.statusCode === 200) {
                    resolve(response);
                }
                else if (response.statusCode === 202) {
                    this.sdkConnector.registerListener('event:ucm.voicemail_download_complete', async (event) => {
                        const responseEvent = event;
                        const voicemailContentUrl = `${this.vgVoiceMessageURI}${VOICEMAILS}/${responseEvent?.data?.messageId}/${CONTENT}`;
                        const response = await this.returnUcmPromise(voicemailContentUrl, mercuryApi);
                        if (response.statusCode === 200) {
                            this.sdkConnector.unregisterListener('event:ucm.voicemail_download_complete');
                            resolve(response);
                        }
                        else {
                            this.sdkConnector.unregisterListener('event:ucm.voicemail_download_complete');
                            reject(response);
                        }
                    });
                }
                else {
                    reject(response);
                }
            })
                .catch((err) => {
                reject(err);
            });
        });
    }
    async returnUcmPromise(voicemailContentUrl, mercuryApi) {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.RETURN_UCM_PROMISE,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        const response = await this.webex.request({
            uri: `${voicemailContentUrl}`,
            method: HTTP_METHODS.GET,
            headers: {
                orgId: this.orgId,
                deviceUrl: this.webex.internal.device.url,
                mercuryHostname: mercuryApi,
            },
        });
        const contentInfo = response?.body;
        const respHeaders = response.headers;
        const statusCode = response.statusCode;
        const mediaType = respHeaders?.mediatype;
        const mediaContent = contentInfo;
        const responseDetails = {
            statusCode: Number(statusCode),
            data: {
                voicemailContent: {
                    type: mediaType,
                    content: mediaContent,
                },
            },
            message: SUCCESS_MESSAGE,
        };
        if (statusCode !== 200 && statusCode !== 202) {
            responseDetails.message = FAILURE_MESSAGE;
        }
        return responseDetails;
    }
    async voicemailMarkAsRead(messageId) {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.VOICEMAIL_MARK_AS_READ,
        };
        log.info(`${METHOD_START_MESSAGE} with Message ID: ${messageId}`, loggerContext);
        try {
            const voicemailContentUrl = `${this.vgVoiceMessageURI}${VOICEMAILS}/${messageId}`;
            const response = await this.webex.request({
                uri: voicemailContentUrl,
                method: HTTP_METHODS.PUT,
                headers: {
                    orgId: this.orgId,
                },
                body: {
                    read: 'true',
                },
            });
            const responseDetails = {
                statusCode: Number(response.statusCode),
                data: {},
                message: SUCCESS_MESSAGE,
            };
            log.log('Successfully marked voicemail as read', loggerContext);
            return responseDetails;
        }
        catch (err) {
            const extendedError = new Error(`Failed to mark voicemail as read: ${err}`);
            log.error(extendedError, loggerContext);
            await uploadLogs();
            const errorInfo = err;
            const errorStatus = serviceErrorCodeHandler(errorInfo, loggerContext);
            return errorStatus;
        }
    }
    async voicemailMarkAsUnread(messageId) {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.VOICEMAIL_MARK_AS_UNREAD,
        };
        log.info(`${METHOD_START_MESSAGE} with Message ID: ${messageId}`, loggerContext);
        try {
            const voicemailContentUrl = `${this.vgVoiceMessageURI}${VOICEMAILS}/${messageId}`;
            const response = await this.webex.request({
                uri: voicemailContentUrl,
                method: HTTP_METHODS.PUT,
                headers: {
                    orgId: this.orgId,
                },
                body: {
                    read: 'false',
                },
            });
            const responseDetails = {
                statusCode: Number(response.statusCode),
                data: {},
                message: SUCCESS_MESSAGE,
            };
            log.log('Successfully marked voicemail as unread', loggerContext);
            return responseDetails;
        }
        catch (err) {
            const extendedError = new Error(`Failed to mark voicemail as unread: ${err}`);
            log.error(extendedError, loggerContext);
            await uploadLogs();
            const errorInfo = err;
            const errorStatus = serviceErrorCodeHandler(errorInfo, loggerContext);
            return errorStatus;
        }
    }
    async deleteVoicemail(messageId) {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.DELETE_VOICEMAIL,
        };
        log.info(`${METHOD_START_MESSAGE} with Message ID: ${messageId}`, loggerContext);
        try {
            const voicemailContentUrl = `${this.vgVoiceMessageURI}${VOICEMAILS}/${messageId}`;
            const response = await this.webex.request({
                uri: voicemailContentUrl,
                method: HTTP_METHODS.DELETE,
                headers: {
                    orgId: this.orgId,
                },
            });
            const responseDetails = {
                statusCode: Number(response.statusCode),
                data: {},
                message: SUCCESS_MESSAGE,
            };
            log.log('Successfully deleted voicemail', loggerContext);
            return responseDetails;
        }
        catch (err) {
            const extendedError = new Error(`Failed to delete voicemail: ${err}`);
            log.error(extendedError, loggerContext);
            await uploadLogs();
            const errorInfo = err;
            const errorStatus = serviceErrorCodeHandler(errorInfo, loggerContext);
            return errorStatus;
        }
    }
    async getVMTranscript(messageId) {
        log.info(`Message Id: ${messageId}`, {});
        return Promise.resolve(null);
    }
    resolveContact(callingPartyInfo) {
        log.info(`Calling Party Info: ${callingPartyInfo}`, {});
        return Promise.resolve(null);
    }
}
