import { METHOD_START_MESSAGE } from '../common/constants';
import SDKConnector from '../SDKConnector';
import { CALLING_BACKEND } from '../common/types';
import log from '../Logger';
import { getCallingBackEnd, uploadLogs } from '../common/Utils';
import { WxCallBackendConnector } from './WxCallBackendConnector';
import { BroadworksBackendConnector } from './BroadworksBackendConnector';
import { Eventing } from '../Events/impl';
import { UcmBackendConnector } from './UcmBackendConnector';
import { METRIC_EVENT, METRIC_TYPE, VOICEMAIL_ACTION } from '../Metrics/types';
import { getMetricManager } from '../Metrics';
import { VOICEMAIL_FILE, METHODS } from './constants';
export class Voicemail extends Eventing {
    logger;
    sdkConnector;
    webex;
    callingBackend;
    backendConnector;
    metricManager;
    constructor(webex, logger) {
        super();
        this.logger = logger;
        this.sdkConnector = SDKConnector;
        if (!this.sdkConnector.getWebex()) {
            SDKConnector.setWebex(webex);
        }
        this.webex = this.sdkConnector.getWebex();
        this.metricManager = getMetricManager(this.webex, undefined);
        this.callingBackend = getCallingBackEnd(this.webex);
        this.initializeBackendConnector();
        log.setLogger(logger.level, VOICEMAIL_FILE);
    }
    async init() {
        try {
            log.info(METHOD_START_MESSAGE, {
                file: VOICEMAIL_FILE,
                method: METHODS.INIT,
            });
            const response = this.backendConnector.init();
            log.log('Voicemail connector initialized successfully', {
                file: VOICEMAIL_FILE,
                method: METHODS.INIT,
            });
            return response;
        }
        catch (err) {
            const extendedError = new Error(`Failed to initialize voicemail: ${err}`);
            log.error(extendedError, {
                file: VOICEMAIL_FILE,
                method: METHODS.INIT,
            });
            await uploadLogs();
            throw err;
        }
    }
    initializeBackendConnector() {
        log.info(METHOD_START_MESSAGE, {
            file: VOICEMAIL_FILE,
            method: METHODS.INITIALIZE_BACKEND_CONNECTOR,
        });
        switch (this.callingBackend) {
            case CALLING_BACKEND.WXC: {
                this.backendConnector = new WxCallBackendConnector(this.webex, this.logger);
                break;
            }
            case CALLING_BACKEND.BWRKS: {
                this.backendConnector = new BroadworksBackendConnector(this.webex, this.logger);
                break;
            }
            case CALLING_BACKEND.UCM: {
                this.backendConnector = new UcmBackendConnector(this.webex, this.logger);
                break;
            }
            default: {
                throw new Error('Calling backend is not identified, exiting....');
            }
        }
    }
    submitMetric(response, metricAction, messageId) {
        const { statusCode, data: { error: errorMessage }, } = response;
        if (statusCode >= 200 && statusCode < 300) {
            this.metricManager.submitVoicemailMetric(METRIC_EVENT.VOICEMAIL, metricAction, METRIC_TYPE.BEHAVIORAL, messageId);
        }
        else {
            this.metricManager.submitVoicemailMetric(METRIC_EVENT.VOICEMAIL_ERROR, metricAction, METRIC_TYPE.BEHAVIORAL, messageId, errorMessage, statusCode);
        }
    }
    async getVoicemailList(offset, offsetLimit, sort, refresh) {
        try {
            log.info(`${METHOD_START_MESSAGE} with: offset=${offset}, limit=${offsetLimit}, sort=${sort}, refresh=${refresh}`, {
                file: VOICEMAIL_FILE,
                method: METHODS.GET_VOICEMAIL_LIST,
            });
            const response = await this.backendConnector.getVoicemailList(offset, offsetLimit, sort, refresh);
            this.submitMetric(response, VOICEMAIL_ACTION.GET_VOICEMAILS);
            log.log(`Successfully retrieved voicemail list: statusCode=${response.statusCode}`, {
                file: VOICEMAIL_FILE,
                method: METHODS.GET_VOICEMAIL_LIST,
            });
            return response;
        }
        catch (err) {
            const extendedError = new Error(`Failed to get voicemail list: ${err}`);
            log.error(extendedError, {
                file: VOICEMAIL_FILE,
                method: METHODS.GET_VOICEMAIL_LIST,
            });
            await uploadLogs();
            throw err;
        }
    }
    async getVoicemailContent(messageId) {
        log.info(`${METHOD_START_MESSAGE} with: messageId=${messageId}`, {
            file: VOICEMAIL_FILE,
            method: METHODS.GET_VOICEMAIL_CONTENT,
        });
        const response = await this.backendConnector.getVoicemailContent(messageId);
        this.submitMetric(response, VOICEMAIL_ACTION.GET_VOICEMAIL_CONTENT, messageId);
        log.log(`Successfully retrieved voicemail content for messageId=${messageId}, statusCode=${response.statusCode}`, {
            file: VOICEMAIL_FILE,
            method: METHODS.GET_VOICEMAIL_CONTENT,
        });
        return response;
    }
    async getVoicemailSummary() {
        log.info(METHOD_START_MESSAGE, {
            file: VOICEMAIL_FILE,
            method: METHODS.GET_VOICEMAIL_SUMMARY,
        });
        const response = await this.backendConnector.getVoicemailSummary();
        if (response !== null) {
            this.submitMetric(response, VOICEMAIL_ACTION.GET_VOICEMAIL_SUMMARY);
            log.log(`Successfully retrieved voicemail summary: statusCode=${response.statusCode}`, {
                file: VOICEMAIL_FILE,
                method: METHODS.GET_VOICEMAIL_SUMMARY,
            });
        }
        return response;
    }
    async voicemailMarkAsRead(messageId) {
        log.info(`${METHOD_START_MESSAGE} with: messageId=${messageId}`, {
            file: VOICEMAIL_FILE,
            method: METHODS.VOICEMAIL_MARK_AS_READ,
        });
        const response = await this.backendConnector.voicemailMarkAsRead(messageId);
        this.submitMetric(response, VOICEMAIL_ACTION.MARK_READ, messageId);
        log.log(`Successfully marked voicemail as read: messageId=${messageId}, statusCode=${response.statusCode}`, {
            file: VOICEMAIL_FILE,
            method: METHODS.VOICEMAIL_MARK_AS_READ,
        });
        return response;
    }
    async voicemailMarkAsUnread(messageId) {
        log.info(`${METHOD_START_MESSAGE} with: messageId=${messageId}`, {
            file: VOICEMAIL_FILE,
            method: METHODS.VOICEMAIL_MARK_AS_UNREAD,
        });
        const response = await this.backendConnector.voicemailMarkAsUnread(messageId);
        this.submitMetric(response, VOICEMAIL_ACTION.MARK_UNREAD, messageId);
        log.log(`Successfully marked voicemail as unread: messageId=${messageId}, statusCode=${response.statusCode}`, {
            file: VOICEMAIL_FILE,
            method: METHODS.VOICEMAIL_MARK_AS_UNREAD,
        });
        return response;
    }
    async deleteVoicemail(messageId) {
        log.info(`${METHOD_START_MESSAGE} with: messageId=${messageId}`, {
            file: VOICEMAIL_FILE,
            method: METHODS.DELETE_VOICEMAIL,
        });
        const response = await this.backendConnector.deleteVoicemail(messageId);
        this.submitMetric(response, VOICEMAIL_ACTION.DELETE, messageId);
        log.log(`Successfully deleted voicemail: messageId=${messageId}, statusCode=${response.statusCode}`, {
            file: VOICEMAIL_FILE,
            method: METHODS.DELETE_VOICEMAIL,
        });
        return response;
    }
    async getVMTranscript(messageId) {
        log.info(`${METHOD_START_MESSAGE} with: messageId=${messageId}`, {
            file: VOICEMAIL_FILE,
            method: METHODS.GET_VM_TRANSCRIPT,
        });
        const response = await this.backendConnector.getVMTranscript(messageId);
        if (response !== null) {
            this.submitMetric(response, VOICEMAIL_ACTION.TRANSCRIPT, messageId);
            log.log(`Successfully retrieved voicemail transcript: messageId=${messageId}, statusCode=${response.statusCode}`, {
                file: VOICEMAIL_FILE,
                method: METHODS.GET_VM_TRANSCRIPT,
            });
        }
        return response;
    }
    resolveContact(callingPartyInfo) {
        log.info(METHOD_START_MESSAGE, {
            file: VOICEMAIL_FILE,
            method: METHODS.RESOLVE_CONTACT,
        });
        const response = this.backendConnector.resolveContact(callingPartyInfo);
        log.log('Contact resolution completed successfully', {
            file: VOICEMAIL_FILE,
            method: METHODS.RESOLVE_CONTACT,
        });
        return response;
    }
    getSDKConnector() {
        return this.sdkConnector;
    }
}
export const createVoicemailClient = (webex, logger) => new Voicemail(webex, logger);
