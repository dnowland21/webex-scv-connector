import log from '../Logger';
import SDKConnector from '../SDKConnector';
import { serviceErrorCodeHandler, uploadLogs } from '../common/Utils';
import { FAILURE_MESSAGE, METHOD_START_MESSAGE, STATUS_CODE, SUCCESS_MESSAGE, UCM_CONNECTOR_FILE, VOICEMAIL, WEBEX_API_CONFIG_INT_URL, WEBEX_API_CONFIG_PROD_URL, } from '../common/constants';
import { HTTP_METHODS } from '../common/types';
import { CF_ENDPOINT, METHODS, ORG_ENDPOINT, PEOPLE_ENDPOINT } from './constants';
export class UcmBackendConnector {
    sdkConnector;
    webex;
    userId;
    orgId;
    useProdWebexApis;
    constructor(webex, logger, useProdWebexApis = true) {
        this.sdkConnector = SDKConnector;
        if (!this.sdkConnector.getWebex()) {
            SDKConnector.setWebex(webex);
        }
        this.webex = this.sdkConnector.getWebex();
        log.setLogger(logger.level, UCM_CONNECTOR_FILE);
        this.userId = this.webex.internal.device.userId;
        this.orgId = this.webex.internal.device.orgId;
        this.useProdWebexApis = useProdWebexApis;
    }
    getCallWaitingSetting() {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.GET_CALL_WAITING_SETTING,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        return this.getMethodNotSupportedResponse();
    }
    getDoNotDisturbSetting() {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.GET_DO_NOT_DISTURB_SETTING,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        return this.getMethodNotSupportedResponse();
    }
    setDoNotDisturbSetting() {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.SET_DO_NOT_DISTURB_SETTING,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        return this.getMethodNotSupportedResponse();
    }
    getCallForwardSetting() {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.GET_CALL_FORWARD_SETTING,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        return this.getMethodNotSupportedResponse();
    }
    setCallForwardSetting() {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.SET_CALL_FORWARD_SETTING,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        return this.getMethodNotSupportedResponse();
    }
    getVoicemailSetting() {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.GET_VOICEMAIL_SETTING,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        return this.getMethodNotSupportedResponse();
    }
    setVoicemailSetting() {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.SET_VOICEMAIL_SETTING,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        return this.getMethodNotSupportedResponse();
    }
    getMethodNotSupportedResponse() {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.GET_METHOD_NOT_SUPPORTED_RESPONSE,
        };
        log.info(METHOD_START_MESSAGE, loggerContext);
        const response = serviceErrorCodeHandler({ statusCode: 501 }, loggerContext);
        return Promise.resolve(response);
    }
    async getCallForwardAlwaysSetting(directoryNumber) {
        const loggerContext = {
            file: UCM_CONNECTOR_FILE,
            method: METHODS.GET_CALL_FORWARD_ALWAYS_SETTING,
        };
        log.info(directoryNumber ? `${METHOD_START_MESSAGE} with ${directoryNumber}` : METHOD_START_MESSAGE, loggerContext);
        const webexApisUrl = this.useProdWebexApis
            ? WEBEX_API_CONFIG_PROD_URL
            : WEBEX_API_CONFIG_INT_URL;
        try {
            if (directoryNumber) {
                const resp = await this.webex.request({
                    uri: `${webexApisUrl}/${PEOPLE_ENDPOINT}/${this.userId}/${CF_ENDPOINT.toLowerCase()}?${ORG_ENDPOINT}=${this.orgId}`,
                    method: HTTP_METHODS.GET,
                });
                const { callForwarding } = resp.body;
                const cfa = callForwarding.always.find((item) => item.dn.endsWith(directoryNumber) || item.e164Number.endsWith(directoryNumber));
                if (cfa) {
                    const response = {
                        statusCode: Number(resp[STATUS_CODE]),
                        message: SUCCESS_MESSAGE,
                        data: {
                            callSetting: {
                                enabled: cfa.destinationVoicemailEnabled || !!cfa.destination,
                                destination: cfa.destinationVoicemailEnabled ? VOICEMAIL : cfa.destination,
                            },
                        },
                    };
                    log.log(`Successfully retrieved call forward always setting for directory number: ${directoryNumber}`, loggerContext);
                    return response;
                }
                const response = {
                    statusCode: 404,
                    message: FAILURE_MESSAGE,
                    data: {
                        error: 'Directory Number is not assigned to the user',
                    },
                };
                return response;
            }
            const response = {
                statusCode: 400,
                message: FAILURE_MESSAGE,
                data: {
                    error: 'Directory Number is mandatory for UCM backend',
                },
            };
            return response;
        }
        catch (err) {
            const errorInfo = err;
            const extendedError = new Error(`Failed to get call forward always setting: ${err}`);
            log.error(extendedError, loggerContext);
            await uploadLogs();
            const errorStatus = serviceErrorCodeHandler(errorInfo, loggerContext);
            return errorStatus;
        }
    }
}
