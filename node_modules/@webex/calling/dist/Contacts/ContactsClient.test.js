"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));
var _types = require("../common/types");
var _testUtil = require("../common/testUtil");
var _types2 = require("../Logger/types");
var _ContactsClient = require("./ContactsClient");
var _constants = require("../common/constants");
var _Logger = _interopRequireDefault(require("../Logger"));
var _constants2 = require("./constants");
var utils = _interopRequireWildcard(require("../common/Utils"));
var _contactFixtures = require("./contactFixtures");
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
describe('ContactClient Tests', function () {
  var webex = (0, _testUtil.getTestUtilsWebex)();
  var contactClient;

  // eslint-disable-next-line no-underscore-dangle
  var contactServiceUrl = "".concat(webex.internal.services._serviceUrls.contactsService, "/").concat(_constants2.ENCRYPT_FILTER, "/").concat(_constants2.USERS, "/").concat(_constants2.CONTACT_FILTER);
  var scimUrl = "".concat(_constants.WEBEX_API_BTS, "/").concat(_constants.IDENTITY_ENDPOINT_RESOURCE, "/").concat(_constants.SCIM_ENDPOINT_RESOURCE, "/").concat(webex.internal.device.orgId, "/").concat(_constants.SCIM_USER_FILTER, "id%20eq%20%22801bb994-343b-4f6b-97ae-d13c91d4b877%22");
  // eslint-disable-next-line no-underscore-dangle
  var contactServiceGroupUrl = "".concat(webex.internal.services._serviceUrls.contactsService, "/").concat(_constants2.ENCRYPT_FILTER, "/").concat(_constants2.USERS, "/").concat(_constants2.GROUP_FILTER);
  var serviceErrorCodeHandlerSpy = jest.spyOn(utils, 'serviceErrorCodeHandler');
  var failureResponsePayload = {
    statusCode: 503,
    body: {}
  };
  var mockGroupResponse = _contactFixtures.mockContactResponseBodyOne.groups[0];
  beforeEach(function () {
    contactClient = (0, _ContactsClient.createContactsClient)(webex, {
      level: _types2.LOGGER.INFO
    });
    expect(contactClient).toBeTruthy();
    expect(contactClient.getSDKConnector().getWebex()).toBeTruthy();
  });
  afterEach(function () {
    webex.request.mockClear();
    jest.clearAllMocks();
  });

  /**
   * TestCase inputs
   * name: TestCase name
   * payloadData: Response body
   * inputStatusCode: Status code received in response
   * expectedData: Expected data field in ContactResponse after processing
   * expectedMessage: Expected message field in ContactResponse after processing
   * expectedStatusCode: Expected status code field in ContactResponse after processing
   * decryptTextList: Array of decrypted contact list.
   */
  var errorCodes = [{
    name: 'Success case 1: fetch contacts using get contacts api, custom and cloud contact present',
    payloadData: _contactFixtures.mockContactResponseBodyOne,
    inputStatusCode: 200,
    expectedData: {
      contacts: _contactFixtures.mockContactListOne,
      groups: _contactFixtures.mockContactGroupListOne
    },
    expectedMessage: _constants.SUCCESS_MESSAGE,
    expectedStatusCode: 200,
    decryptTextList: [_contactFixtures.mockCity, _contactFixtures.mockCountry, _contactFixtures.mockState, _contactFixtures.mockStreet, _contactFixtures.mockZipCode, _contactFixtures.mockAvatarURL, _contactFixtures.mockCompany, _contactFixtures.mockDisplayNameOne, _contactFixtures.mockEmail, _contactFixtures.mockFirstName, _contactFixtures.mockLastName, _contactFixtures.mockNumber1, _contactFixtures.mockNumber2, _contactFixtures.mockSipAddress, _contactFixtures.mockTitle, _contactFixtures.mockNumber2, _contactFixtures.mockSipAddress, _contactFixtures.mockGroupName],
    cloudContactPresent: true,
    scimResponse: _contactFixtures.mockSCIMListResponse
  }, {
    name: 'Success case 2: fetch contacts using get contacts api, single custom contact with mandatory details present',
    payloadData: _contactFixtures.mockContactResponseBodyTwo,
    inputStatusCode: 200,
    expectedData: {
      contacts: _contactFixtures.mockContactListTwo,
      groups: _contactFixtures.mockContactGroupListTwo
    },
    expectedMessage: _constants.SUCCESS_MESSAGE,
    expectedStatusCode: 200,
    decryptTextList: [_contactFixtures.mockDisplayNameTwo, _contactFixtures.mockGroupName]
  }, {
    name: 'Success case 3: fetch contacts using get contacts api, no contacts returned',
    payloadData: _contactFixtures.mockContactResponseBodyThird,
    inputStatusCode: 200,
    expectedData: {
      contacts: [],
      groups: []
    },
    expectedMessage: _constants.SUCCESS_MESSAGE,
    expectedStatusCode: 200,
    decryptTextList: []
  }, {
    name: 'Failed case: 200 OK with no response body',
    payloadData: undefined,
    inputStatusCode: 200,
    expectedData: {
      error: '422 Exception has occurred'
    },
    expectedMessage: _constants.FAILURE_MESSAGE,
    expectedStatusCode: 422,
    decryptTextList: []
  }, {
    name: 'Failed case 403: fetch contacts using get contacts api',
    payloadData: {
      error: '403 Forbidden'
    },
    inputStatusCode: 403,
    expectedData: {
      error: 'User request is forbidden'
    },
    expectedMessage: _constants.FAILURE_MESSAGE,
    expectedStatusCode: 403,
    decryptTextList: []
  }, {
    name: 'Failed case 408: fetch contacts using get contacts api',
    payloadData: {
      error: '408 Request Timeout'
    },
    inputStatusCode: 408,
    expectedData: {
      error: 'Request to the server timedout'
    },
    expectedMessage: _constants.FAILURE_MESSAGE,
    expectedStatusCode: 408,
    decryptTextList: []
  }, {
    name: 'Failed case 500: fetch contacts using get contacts api',
    payloadData: {
      error: '500 Internal Server Error'
    },
    inputStatusCode: 500,
    expectedData: {
      error: 'Internal server error occurred'
    },
    expectedMessage: _constants.FAILURE_MESSAGE,
    expectedStatusCode: 500,
    decryptTextList: []
  }, {
    name: 'Failed case 503: fetch contacts using get contacts api',
    payloadData: {
      error: '503 Service Unavailable'
    },
    inputStatusCode: 503,
    expectedData: {
      error: 'Unable to establish a connection with the server'
    },
    expectedMessage: _constants.FAILURE_MESSAGE,
    expectedStatusCode: 503,
    decryptTextList: []
  }].map(function (stat) {
    return (0, _assign.default)(stat, {
      toString: function toString() {
        /* eslint-disable dot-notation */
        return this['name'];
      }
    });
  });
  it.each(errorCodes)('%s', /*#__PURE__*/function () {
    var _ref = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(codeObj) {
      var respPayload, contactsResponse;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            respPayload = {
              statusCode: codeObj.inputStatusCode
            };
            if (codeObj.inputStatusCode === 200) {
              respPayload['body'] = codeObj.payloadData;
              webex.request.mockResolvedValueOnce(respPayload);
              codeObj.decryptTextList.forEach(function (text) {
                webex.internal.encryption.decryptText.mockResolvedValueOnce(text);
              });
              if (codeObj.scimResponse) {
                webex.request.mockResolvedValueOnce(_contactFixtures.mockSCIMListResponse);
              }
            } else {
              respPayload['message'] = _constants.FAILURE_MESSAGE;
              respPayload['data'] = codeObj.payloadData;
              webex.request.mockRejectedValueOnce(respPayload);
            }
            _context.next = 4;
            return contactClient.getContacts();
          case 4:
            contactsResponse = _context.sent;
            if (codeObj.inputStatusCode === 200) {
              if (codeObj.cloudContactPresent) {
                expect(webex.request).toBeCalledTimes(2);
              } else {
                expect(webex.request).toBeCalledTimes(1);
              }
              expect(webex.request).toHaveBeenNthCalledWith(1, {
                uri: contactServiceUrl,
                method: _types.HTTP_METHODS.GET
              });
              if (codeObj.cloudContactPresent) {
                expect(webex.request).toHaveBeenNthCalledWith(2, {
                  uri: scimUrl,
                  method: _types.HTTP_METHODS.GET,
                  headers: {
                    'cisco-device-url': 'https://wdm-intb.ciscospark.com/wdm/api/v1/devices/c5ae3b86-1bb7-40f1-a6a9-c296ee7e61d5',
                    'spark-user-agent': 'webex-calling/beta'
                  }
                });
              }
            } else {
              expect(webex.request).toBeCalledOnceWith({
                uri: contactServiceUrl,
                method: _types.HTTP_METHODS.GET
              });
            }
            expect(contactsResponse).toEqual({
              data: expect.any(Object),
              message: codeObj.expectedMessage,
              statusCode: codeObj.expectedStatusCode
            });
            if (codeObj.expectedMessage === _constants.SUCCESS_MESSAGE) {
              expect(serviceErrorCodeHandlerSpy).not.toBeCalled();
            } else {
              expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith(codeObj.payloadData ? respPayload : expect.any(Error), {
                file: _constants2.CONTACTS_FILE,
                method: 'getContacts'
              });
            }
          case 8:
          case "end":
            return _context.stop();
        }
      }, _callee);
    }));
    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
  it('create a contact group without encryptionKey', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
    var _contactsResponse$dat;
    var successResponsePayload, contactsResponse;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          successResponsePayload = {
            statusCode: 201,
            body: mockGroupResponse
          };
          contactClient['groups'] = [];
          contactClient['encryptionKeyUrl'] = '';
          webex.request.mockResolvedValue(successResponsePayload);
          webex.internal.encryption.kms.createUnboundKeys.mockResolvedValue([_contactFixtures.mockKmsKey]);
          webex.internal.encryption.kms.createResource.mockResolvedValue(_contactFixtures.mockKmsKey);
          webex.internal.encryption.encryptText.mockResolvedValueOnce('Encrypted Other').mockResolvedValueOnce('Encrypted Top');
          _context2.next = 9;
          return contactClient.createContactGroup('Top Contacts');
        case 9:
          contactsResponse = _context2.sent;
          expect(contactsResponse.statusCode).toEqual(201);
          expect((_contactsResponse$dat = contactsResponse.data.group) === null || _contactsResponse$dat === void 0 ? void 0 : _contactsResponse$dat.groupId).toBe(mockGroupResponse.groupId);
          expect(webex.internal.encryption.kms.createUnboundKeys).toBeCalledOnceWith({
            count: 1
          });
          expect(webex.internal.encryption.kms.createResource).toBeCalledOnceWith({
            keyUris: [_contactFixtures.mockKmsKey.uri]
          });
          expect(webex.request).toBeCalledTimes(2);
          expect(webex.request).toHaveBeenNthCalledWith(1, {
            uri: contactServiceGroupUrl,
            method: 'POST',
            body: {
              displayName: 'Encrypted Other',
              encryptionKeyUrl: _contactFixtures.mockKmsKey.uri,
              groupType: 'NORMAL',
              schemas: 'urn:cisco:codev:identity:contact:core:1.0'
            }
          });
          expect(webex.request).toHaveBeenNthCalledWith(2, {
            uri: contactServiceGroupUrl,
            method: 'POST',
            body: {
              displayName: 'Encrypted Top',
              encryptionKeyUrl: _contactFixtures.mockKmsKey.uri,
              groupType: 'NORMAL',
              schemas: 'urn:cisco:codev:identity:contact:core:1.0'
            }
          });
          expect(contactClient['groups'].length).toEqual(2);
          expect(contactClient['groups'][1].displayName).toEqual('Top Contacts');
        case 19:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  })));
  it('create a contact group with existing key info', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
    var _contactsResponse$dat2;
    var successResponsePayload, logInfoSpy, contactsResponse;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          successResponsePayload = {
            statusCode: 201,
            body: mockGroupResponse
          };
          contactClient['groups'] = _contactFixtures.mockContactGroupListOne;
          webex.request.mockResolvedValue(successResponsePayload);
          webex.internal.encryption.encryptText.mockResolvedValue('Encrypted Top Contacts');
          logInfoSpy = jest.spyOn(_Logger.default, 'info');
          _context3.next = 7;
          return contactClient.createContactGroup('Top Contacts');
        case 7:
          contactsResponse = _context3.sent;
          expect(contactsResponse.statusCode).toEqual(201);
          expect((_contactsResponse$dat2 = contactsResponse.data.group) === null || _contactsResponse$dat2 === void 0 ? void 0 : _contactsResponse$dat2.groupId).toBe(mockGroupResponse.groupId);
          expect(logInfoSpy).not.toBeCalledWith('Requesting kms for a new KRO and key', {
            file: _constants2.CONTACTS_FILE,
            method: 'createNewEncryptionKeyUrl'
          });
          expect(webex.request).toBeCalledOnceWith({
            uri: contactServiceGroupUrl,
            method: _types.HTTP_METHODS.POST,
            body: {
              displayName: 'Encrypted Top Contacts',
              encryptionKeyUrl: _contactFixtures.mockContactGroupListOne[0].encryptionKeyUrl,
              groupType: 'NORMAL',
              schemas: _constants2.CONTACTS_SCHEMA
            }
          });
          expect(contactClient['groups'].length).toEqual(2);
          expect(contactClient['groups'][1].displayName).toEqual('Top Contacts');
        case 14:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  })));
  it('create a contact group with same displayName', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
    var logSpy, contactsResponse;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          contactClient['groups'] = _contactFixtures.mockContactResponseBodyOne.groups;
          webex.internal.encryption.kms.createUnboundKeys.mockResolvedValue([_contactFixtures.mockKmsKey]);
          webex.internal.encryption.kms.createResource.mockResolvedValue(_contactFixtures.mockKmsKey);
          logSpy = jest.spyOn(_Logger.default, 'warn');
          _context4.next = 6;
          return contactClient.createContactGroup(mockGroupResponse.displayName);
        case 6:
          contactsResponse = _context4.sent;
          expect(webex.request).not.toBeCalled();
          expect(contactsResponse.statusCode).toBe(400);
          expect(logSpy).toBeCalledOnceWith("Group name ".concat(mockGroupResponse.displayName, " already exists."), {
            file: _constants2.CONTACTS_FILE,
            method: 'createContactGroup'
          });
          expect(contactClient['groups']).toEqual(_contactFixtures.mockContactResponseBodyOne.groups);
        case 11:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  })));
  it('create a contact group - service unavailable', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
    var loggerContext, warnSpy, contactsResponse;
    return _regenerator.default.wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          loggerContext = {
            file: _constants2.CONTACTS_FILE,
            method: 'createContactGroup'
          };
          contactClient['groups'] = _contactFixtures.mockContactGroupListOne;
          webex.request.mockRejectedValue(failureResponsePayload);
          webex.internal.encryption.kms.createUnboundKeys.mockResolvedValue([_contactFixtures.mockKmsKey]);
          webex.internal.encryption.kms.createResource.mockResolvedValue(_contactFixtures.mockKmsKey);
          webex.internal.encryption.encryptText.mockResolvedValueOnce('Encrypted group name');
          warnSpy = jest.spyOn(_Logger.default, 'warn');
          _context5.next = 9;
          return contactClient.createContactGroup('New group');
        case 9:
          contactsResponse = _context5.sent;
          expect(contactsResponse.statusCode).toBe(503);
          expect(webex.request).toBeCalledOnceWith({
            uri: contactServiceGroupUrl,
            method: _types.HTTP_METHODS.POST,
            body: {
              displayName: 'Encrypted group name',
              encryptionKeyUrl: 'kms://cisco.com/keys/dcf18f9d-155e-44ff-ad61-c8a69b7103ab',
              groupType: 'NORMAL',
              schemas: 'urn:cisco:codev:identity:contact:core:1.0'
            }
          });
          expect(warnSpy).toBeCalledTimes(2);
          expect(warnSpy).toHaveBeenNthCalledWith(1, 'Unable to create contact group.', loggerContext);
          expect(warnSpy).toHaveBeenNthCalledWith(2, '503 Unable to establish a connection with the server', loggerContext);
          expect(contactClient['groups']).toEqual(_contactFixtures.mockContactGroupListOne);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith(failureResponsePayload, loggerContext);
        case 17:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  })));
  it('delete a contact group - service unavailable', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
    var loggerContext, warnSpy, contactsResponse;
    return _regenerator.default.wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          loggerContext = {
            file: _constants2.CONTACTS_FILE,
            method: 'deleteContactGroup'
          };
          contactClient['groups'] = _contactFixtures.mockContactGroupListOne;
          webex.request.mockRejectedValue(failureResponsePayload);
          webex.internal.encryption.kms.createUnboundKeys.mockResolvedValue([_contactFixtures.mockKmsKey]);
          webex.internal.encryption.kms.createResource.mockResolvedValue(_contactFixtures.mockKmsKey);
          warnSpy = jest.spyOn(_Logger.default, 'warn');
          _context6.next = 8;
          return contactClient.deleteContactGroup(mockGroupResponse.groupId);
        case 8:
          contactsResponse = _context6.sent;
          expect(contactsResponse.statusCode).toBe(503);
          expect(webex.request).toBeCalledOnceWith({
            method: _types.HTTP_METHODS.DELETE,
            uri: "".concat(contactServiceGroupUrl, "/").concat(mockGroupResponse.groupId)
          });
          expect(warnSpy).toBeCalledTimes(2);
          expect(warnSpy).toHaveBeenNthCalledWith(1, "Unable to delete contact group ".concat(mockGroupResponse.groupId), loggerContext);
          expect(warnSpy).toHaveBeenNthCalledWith(2, '503 Unable to establish a connection with the server', loggerContext);
          expect(contactClient['groups']).toEqual(_contactFixtures.mockContactGroupListOne);
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith(failureResponsePayload, loggerContext);
        case 16:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  })));
  it('successful deletion of contact group', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
    var successResponsePayload, response;
    return _regenerator.default.wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          successResponsePayload = {
            statusCode: 204
          };
          contactClient['groups'] = [_contactFixtures.mockContactGroupListOne[0]];
          webex.request.mockResolvedValue(successResponsePayload);
          _context7.next = 5;
          return contactClient.deleteContactGroup(_contactFixtures.mockContactGroupListOne[0].groupId);
        case 5:
          response = _context7.sent;
          expect(response.statusCode).toEqual(204);
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(contactServiceGroupUrl, "/").concat(_contactFixtures.mockContactGroupListOne[0].groupId),
            method: _types.HTTP_METHODS.DELETE
          });
          expect(contactClient['groups']).toEqual([]);
        case 9:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  })));
  it('create a contact with an existing group', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
    var _res$data$contact, _result$data$contact;
    var mockContactResponse, successResponsePayload, logSpy, contact, res, result;
    return _regenerator.default.wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          mockContactResponse = _contactFixtures.mockContactResponseBodyTwo.contacts[0];
          successResponsePayload = {
            statusCode: 201,
            body: mockContactResponse
          };
          webex.request.mockResolvedValue(successResponsePayload);
          webex.internal.encryption.encryptText.mockResolvedValue('Encrypted contact name');
          logSpy = jest.spyOn(_Logger.default, 'info');
          contactClient['groups'] = _contactFixtures.mockContactGroupListOne;
          contactClient['encryptionKeyUrl'] = _contactFixtures.mockContactGroupListOne[0].encryptionKeyUrl;
          contact = _contactFixtures.mockContactListTwo.slice()[0];
          contact.groups = [];
          _context8.next = 11;
          return contactClient.createContact(contact);
        case 11:
          res = _context8.sent;
          expect(res.statusCode).toEqual(201);
          expect((_res$data$contact = res.data.contact) === null || _res$data$contact === void 0 ? void 0 : _res$data$contact.contactId).toBe(mockContactResponse.contactId);
          expect(logSpy).not.toBeCalledWith('Created a KRO and encryptionKeyUrl', {
            file: _constants2.CONTACTS_FILE,
            method: 'createNewEncryptionKeyUrl'
          });
          expect(logSpy).not.toBeCalledWith('Created a KRO and encryptionKeyUrl', {
            file: _constants2.CONTACTS_FILE,
            method: 'createNewEncryptionKeyUrl'
          });
          expect(logSpy).not.toBeCalledWith("Creating a default group: ".concat(_constants2.DEFAULT_GROUP_NAME), {
            file: _constants2.CONTACTS_FILE,
            method: 'fetchEncryptionKeyUrl'
          });
          expect(webex.internal.encryption.encryptText).toBeCalledOnceWith(_contactFixtures.mockContactGroupListOne[0].encryptionKeyUrl, contact.displayName);
          expect(webex.request).toBeCalledOnceWith({
            body: _objectSpread(_objectSpread({}, contact), {}, {
              displayName: 'Encrypted contact name',
              groups: [_contactFixtures.mockContactGroupListOne[0].groupId],
              schemas: _constants2.CONTACTS_SCHEMA
            }),
            uri: contactServiceUrl,
            method: _types.HTTP_METHODS.POST
          });
          logSpy.mockClear();

          /* for coverage */
          _context8.next = 22;
          return contactClient.createContact(contact);
        case 22:
          result = _context8.sent;
          expect((_result$data$contact = result.data.contact) === null || _result$data$contact === void 0 ? void 0 : _result$data$contact.contactId).toBe(mockContactResponse.contactId);
          expect(logSpy).not.toBeCalledWith("Creating a default group: ".concat(_constants2.DEFAULT_GROUP_NAME), {
            file: _constants2.CONTACTS_FILE,
            method: 'fetchEncryptionKeyUrl'
          });
        case 25:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  })));
  it('create a contact without a group and encryptionKey', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
    var _res$data$contact2;
    var mockContactResponse, successContactGroupResponsePayload, successContactResponsePayload, contact, res;
    return _regenerator.default.wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          mockContactResponse = _contactFixtures.mockContactResponseBodyOne.contacts[1];
          contactClient['groups'] = [];
          contactClient['encryptionKey'] = '';
          contactClient['defaultGroupId'] = '';
          successContactGroupResponsePayload = {
            statusCode: 201,
            body: mockGroupResponse
          };
          successContactResponsePayload = {
            statusCode: 201,
            body: mockContactResponse
          };
          webex.request.mockResolvedValueOnce(successContactGroupResponsePayload).mockResolvedValueOnce(successContactResponsePayload);
          webex.internal.encryption.kms.createUnboundKeys.mockResolvedValue([_contactFixtures.mockKmsKey]);
          webex.internal.encryption.kms.createResource.mockResolvedValue(_contactFixtures.mockKmsKey);
          webex.internal.encryption.encryptText.mockResolvedValueOnce('Encrypted group name');
          contact = {
            contactType: 'CUSTOM'
          };
          _context9.next = 13;
          return contactClient.createContact(contact);
        case 13:
          res = _context9.sent;
          expect(res.statusCode).toEqual(201);
          expect(webex.request).toBeCalledTimes(2);
          expect(webex.request).toHaveBeenNthCalledWith(1, {
            body: {
              displayName: 'Encrypted group name',
              encryptionKeyUrl: _contactFixtures.mockKmsKey.uri,
              groupType: 'NORMAL',
              schemas: _constants2.CONTACTS_SCHEMA
            },
            uri: contactServiceGroupUrl,
            method: _types.HTTP_METHODS.POST
          });
          expect(webex.request).toHaveBeenNthCalledWith(2, {
            body: {
              contactType: 'CUSTOM',
              encryptionKeyUrl: _contactFixtures.mockKmsKey.uri,
              groups: ['1561977e-3443-4ccf-a591-69686275d7d2'],
              schemas: _constants2.CONTACTS_SCHEMA
            },
            method: _types.HTTP_METHODS.POST,
            uri: contactServiceUrl
          });
          expect(webex.internal.encryption.kms.createUnboundKeys).toBeCalledOnceWith({
            count: 1
          });
          expect(webex.internal.encryption.kms.createResource).toBeCalledOnceWith({
            keyUris: [_contactFixtures.mockKmsKey.uri]
          });
          expect((_res$data$contact2 = res.data.contact) === null || _res$data$contact2 === void 0 ? void 0 : _res$data$contact2.contactId).toBe(mockContactResponse.contactId);
        case 21:
        case "end":
          return _context9.stop();
      }
    }, _callee9);
  })));
  it('create a cloud contact with no existing groups', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
    var _res$data$contact3;
    var mockContactResponse, successResponsePayload, successResponsePayloadGroup, contact, res;
    return _regenerator.default.wrap(function _callee10$(_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          mockContactResponse = _contactFixtures.mockContactResponseBodyOne.contacts[0];
          successResponsePayload = {
            statusCode: 201,
            body: mockContactResponse
          };
          successResponsePayloadGroup = {
            statusCode: 201,
            body: _contactFixtures.mockContactResponseBodyOne.groups[0]
          };
          webex.request.mockResolvedValueOnce(successResponsePayloadGroup).mockResolvedValueOnce(successResponsePayload).mockResolvedValueOnce(_contactFixtures.mockSCIMListResponse);
          webex.internal.encryption.encryptText.mockResolvedValueOnce('Encrypted group name');
          contactClient['groups'] = [];
          contactClient['encryptionKeyUrl'] = _contactFixtures.mockContactResponseBodyOne.groups[0].encryptionKeyUrl;
          contact = {
            contactType: 'CLOUD'
          };
          contact.groups = [];
          _context10.next = 11;
          return contactClient.createContact(contact);
        case 11:
          res = _context10.sent;
          expect(res.statusCode).toEqual(400);
          expect(res.data.error).toEqual('contactId is required for contactType:CLOUD.');
          contact.contactId = mockContactResponse.contactId;
          _context10.next = 17;
          return contactClient.createContact(contact);
        case 17:
          res = _context10.sent;
          expect(res.statusCode).toEqual(201);
          expect((_res$data$contact3 = res.data.contact) === null || _res$data$contact3 === void 0 ? void 0 : _res$data$contact3.contactId).toBe(mockContactResponse.contactId);
          expect(webex.request).toBeCalledTimes(3);
          expect(webex.request).toHaveBeenNthCalledWith(1, {
            method: _types.HTTP_METHODS.POST,
            uri: contactServiceGroupUrl,
            body: {
              displayName: 'Encrypted group name',
              groupType: 'NORMAL',
              encryptionKeyUrl: _contactFixtures.mockContactResponseBodyOne.groups[0].encryptionKeyUrl,
              schemas: _constants2.CONTACTS_SCHEMA
            }
          });
          expect(webex.request).toHaveBeenNthCalledWith(2, {
            method: _types.HTTP_METHODS.POST,
            uri: contactServiceUrl,
            body: {
              contactId: mockContactResponse.contactId,
              contactType: 'CLOUD',
              encryptionKeyUrl: _contactFixtures.mockContactResponseBodyOne.groups[0].encryptionKeyUrl,
              schemas: _constants2.CONTACTS_SCHEMA,
              groups: ['1561977e-3443-4ccf-a591-69686275d7d2']
            }
          });
          expect(webex.request).toHaveBeenNthCalledWith(3, {
            uri: scimUrl,
            method: _types.HTTP_METHODS.GET,
            headers: {
              'cisco-device-url': 'https://wdm-intb.ciscospark.com/wdm/api/v1/devices/c5ae3b86-1bb7-40f1-a6a9-c296ee7e61d5',
              'spark-user-agent': 'webex-calling/beta'
            }
          });
        case 24:
        case "end":
          return _context10.stop();
      }
    }, _callee10);
  })));
  it('create a contact - service unavailable', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
    var contact, res;
    return _regenerator.default.wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          webex.request.mockRejectedValue(failureResponsePayload);
          contactClient['groups'] = _contactFixtures.mockContactGroupListOne.slice();
          contactClient['encryptionKeyUrl'] = _contactFixtures.mockContactResponseBodyOne.groups[0].encryptionKeyUrl;
          contact = {
            contactType: 'CLOUD',
            contactId: '801bb994-343b-4f6b-97ae-d13c91d4b877'
          };
          _context11.next = 6;
          return contactClient.createContact(contact);
        case 6:
          res = _context11.sent;
          expect(webex.request).toBeCalledOnceWith({
            uri: contactServiceUrl,
            method: _types.HTTP_METHODS.POST,
            body: _objectSpread(_objectSpread({}, contact), {}, {
              encryptionKeyUrl: _contactFixtures.mockContactResponseBodyOne.groups[0].encryptionKeyUrl,
              groups: [_contactFixtures.mockContactGroupListOne[0].groupId],
              schemas: _constants2.CONTACTS_SCHEMA
            })
          });
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith(failureResponsePayload, {
            file: _constants2.CONTACTS_FILE,
            method: 'createContact'
          });
          expect(res.statusCode).toEqual(503);
        case 10:
        case "end":
          return _context11.stop();
      }
    }, _callee11);
  })));
  it('successful deletion of contacts', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
    var successResponsePayload, response;
    return _regenerator.default.wrap(function _callee12$(_context12) {
      while (1) switch (_context12.prev = _context12.next) {
        case 0:
          successResponsePayload = {
            statusCode: 204
          };
          contactClient['contacts'] = [_contactFixtures.mockContactListOne[0]];
          webex.request.mockResolvedValue(successResponsePayload);
          _context12.next = 5;
          return contactClient.deleteContact(_contactFixtures.mockContactListOne[0].contactId);
        case 5:
          response = _context12.sent;
          expect(response.statusCode).toEqual(204);
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(contactServiceUrl, "/").concat(_contactFixtures.mockContactListOne[0].contactId),
            method: _types.HTTP_METHODS.DELETE
          });
          expect(contactClient['contacts']).toEqual([]);
        case 9:
        case "end":
          return _context12.stop();
      }
    }, _callee12);
  })));
  it('delete a contact - service unavailable', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
    var response;
    return _regenerator.default.wrap(function _callee13$(_context13) {
      while (1) switch (_context13.prev = _context13.next) {
        case 0:
          contactClient['contacts'] = _contactFixtures.mockContactListOne;
          webex.request.mockRejectedValue(failureResponsePayload);
          _context13.next = 4;
          return contactClient.deleteContact(_contactFixtures.mockContactListOne[0].contactId);
        case 4:
          response = _context13.sent;
          expect(response.statusCode).toEqual(503);
          expect(webex.request).toBeCalledOnceWith({
            uri: "".concat(contactServiceUrl, "/").concat(_contactFixtures.mockContactListOne[0].contactId),
            method: _types.HTTP_METHODS.DELETE
          });
          expect(serviceErrorCodeHandlerSpy).toBeCalledOnceWith(failureResponsePayload, {
            file: _constants2.CONTACTS_FILE,
            method: 'deleteContact'
          });
          expect(contactClient['contacts']).toEqual(_contactFixtures.mockContactListOne);
        case 9:
        case "end":
          return _context13.stop();
      }
    }, _callee13);
  })));
  it('test resolveContacts function for a minimal contact with few details', function () {
    var contact = contactClient['resolveCloudContacts']({
      userId: _contactFixtures.mockContactMinimum
    }, _contactFixtures.mockSCIMMinListResponse.body);
    expect(contact).toEqual([{
      avatarURL: '',
      avatarUrlDomain: undefined,
      contactId: 'userId',
      contactType: 'CLOUD',
      department: undefined,
      displayName: undefined,
      emails: undefined,
      encryptionKeyUrl: 'kms://cisco.com/keys/dcf18f9d-155e-44ff-ad61-c8a69b7103ab',
      firstName: undefined,
      groups: ['1561977e-3443-4ccf-a591-69686275d7d2'],
      lastName: undefined,
      manager: undefined,
      ownerId: 'ownerId',
      phoneNumbers: undefined,
      sipAddresses: undefined,
      resolved: true
    }]);
  });
  it("test resolveContacts function when contactsDataMap list doesn't match resolved list", function () {
    var mockContact = {
      firstName: 'Jane',
      lastName: 'Doe',
      contactId: 'janeDoe'
    };
    var contact = contactClient['resolveCloudContacts']({
      userId: _contactFixtures.mockContactMinimum,
      janeDoe: mockContact
    }, _contactFixtures.mockSCIMMinListResponse.body);
    expect(contact).toEqual([{
      firstName: 'Jane',
      lastName: 'Doe',
      contactId: 'janeDoe',
      resolved: false
    }, {
      avatarURL: '',
      avatarUrlDomain: undefined,
      contactId: 'userId',
      contactType: 'CLOUD',
      department: undefined,
      displayName: undefined,
      emails: undefined,
      encryptionKeyUrl: 'kms://cisco.com/keys/dcf18f9d-155e-44ff-ad61-c8a69b7103ab',
      firstName: undefined,
      groups: ['1561977e-3443-4ccf-a591-69686275d7d2'],
      lastName: undefined,
      manager: undefined,
      ownerId: 'ownerId',
      phoneNumbers: undefined,
      sipAddresses: undefined,
      resolved: true
    }]);
  });
  it('test resolveContacts function encountering an error', function () {
    var contact = contactClient['resolveCloudContacts']({
      userId: _contactFixtures.mockContactMinimum
    }, _contactFixtures.mockSCIMMinListResponse);
    expect(contact).toEqual(null);
  });
  it('logs error for chunk when scimQuery API call fails in the loop for getContacts', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14() {
    var mockData, respPayload;
    return _regenerator.default.wrap(function _callee14$(_context14) {
      while (1) switch (_context14.prev = _context14.next) {
        case 0:
          mockData = errorCodes[0];
          respPayload = {
            statusCode: mockData.inputStatusCode,
            body: mockData.payloadData
          };
          webex.request.mockResolvedValueOnce(respPayload).mockRejectedValueOnce(_objectSpread(_objectSpread({}, respPayload), {}, {
            statusCode: 503,
            message: _constants.FAILURE_MESSAGE,
            data: mockData.payloadData
          }));
          mockData.decryptTextList.forEach(function (text) {
            webex.internal.encryption.decryptText.mockResolvedValueOnce(text);
          });
          jest.spyOn(_Logger.default, 'warn');
          _context14.next = 7;
          return contactClient.getContacts();
        case 7:
          expect(webex.request).toBeCalledTimes(2);
          expect(_Logger.default.warn).toBeCalledTimes(1);
          expect(_Logger.default.warn).toBeCalledWith('Error processing contact chunk 0-50', {
            file: 'Contacts',
            method: 'getContacts'
          });
        case 10:
        case "end":
          return _context14.stop();
      }
    }, _callee14);
  })));
});
//# sourceMappingURL=ContactsClient.test.js.map
