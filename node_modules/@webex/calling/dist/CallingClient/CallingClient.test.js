"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _asyncMutex = require("async-mutex");
var Media = _interopRequireWildcard(require("@webex/internal-media-core"));
var _types = require("../Logger/types");
var _testUtil = require("../common/testUtil");
var _types2 = require("../common/types");
var _types3 = require("../Events/types");
var _Logger = _interopRequireDefault(require("../Logger"));
var _CallingClient = require("./CallingClient");
var _Utils = _interopRequireWildcard(require("../common/Utils"));
var utils = _Utils;
var _callManager = require("./calling/callManager");
var _constants = require("./constants");
var _callRecordFixtures = require("./callRecordFixtures");
var _callingClientFixtures = require("./callingClientFixtures");
var _line = _interopRequireDefault(require("./line"));
var _registerFixtures = require("./registration/registerFixtures");
var _constants2 = require("../common/constants");
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = _Object$keys2(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; } /* eslint-disable dot-notation */
global.crypto = {
  randomUUID: function randomUUID() {
    return '12345678-1234-5678-1234-567812345678';
  }
};
jest.mock('../common/Utils', function () {
  var originalModule = jest.requireActual('../common/Utils');
  return _objectSpread(_objectSpread({}, originalModule), {}, {
    uploadLogs: jest.fn().mockImplementation(function () {
      return _promise.default.resolve(undefined);
    }),
    handleCallingClientErrors: jest.fn()
  });
});
jest.spyOn(utils, 'uploadLogs').mockResolvedValue(undefined);
describe('CallingClient Tests', function () {
  // Common initializers

  var handleErrorSpy = jest.spyOn(utils, 'handleCallingClientErrors');
  var setLoggerSpy = jest.spyOn(Media, 'setLogger');
  var webex = (0, _testUtil.getTestUtilsWebex)();
  webex.internal.services['_hostCatalog'] = _callingClientFixtures.mockCatalogUS;
  var defaultServiceIndicator = _types2.ServiceIndicator.CALLING;
  var callManager = (0, _callManager.getCallManager)(webex, defaultServiceIndicator);
  var logSpy = jest.spyOn(_Logger.default, 'info');
  var warnSpy = jest.spyOn(_Logger.default, 'warn');
  var originalProcessNextTick = process.nextTick;
  function flushPromises() {
    return new _promise.default(function (resolve) {
      originalProcessNextTick(resolve);
    });
  }
  describe('CallingClient pick Mobius cluster using Service Host Tests', function () {
    afterAll(function () {
      callManager.removeAllListeners();
      webex.internal.services['_serviceUrls']['mobius'] = 'https://mobius.aintgen-a-1.int.infra.webex.com/api/v1';
      webex.internal.services['_hostCatalog'] = _callingClientFixtures.mockCatalogUS;
    });
    it('should set mobiusServiceHost correctly when URL is valid', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
      var urlSpy, callingClient;
      return _regenerator.default.wrap(function _callee$(_context) {
        while (1) switch (_context.prev = _context.next) {
          case 0:
            webex.internal.services._hostCatalog = _callingClientFixtures.mockCatalogEU;
            webex.internal.services['_serviceUrls']['mobius'] = 'https://mobius-eu-central-1.prod.infra.webex.com/api/v1';
            urlSpy = jest.spyOn(window, 'URL').mockImplementation(function (url) {
              return new window.URL(url);
            });
            _context.next = 5;
            return (0, _CallingClient.createClient)(webex, {
              logger: {
                level: _types.LOGGER.INFO
              }
            });
          case 5:
            callingClient = _context.sent;
            expect(urlSpy).toHaveBeenCalledWith('https://mobius-eu-central-1.prod.infra.webex.com/api/v1');
            expect(callingClient['mobiusClusters']).toStrictEqual(_callingClientFixtures.mockEUServiceHosts);
            urlSpy.mockRestore();
          case 9:
          case "end":
            return _context.stop();
        }
      }, _callee);
    })));
    it('should use default mobius service host when Service URL is invalid', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
      var callingClient;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            webex.internal.services._hostCatalog = _callingClientFixtures.mockCatalogUS;
            webex.internal.services._serviceUrls.mobius = 'invalid-url';
            _context2.next = 4;
            return (0, _CallingClient.createClient)(webex, {
              logger: {
                level: _types.LOGGER.INFO
              }
            });
          case 4:
            callingClient = _context2.sent;
            expect(setLoggerSpy).toHaveBeenCalledTimes(1);
            expect(callingClient['mobiusClusters']).toStrictEqual(_callingClientFixtures.mockUSServiceHosts);
          case 7:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    })));
  });
  describe('ServiceData tests', function () {
    var callingClient;
    afterEach(function () {
      callManager.removeAllListeners();
      callingClient = undefined;
    });

    /**
     * No input sdk config to callingClient, it should default to service type
     * calling and empty domain value.
     */
    it('Verify valid calling serviceData with no input sdk config', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
      return _regenerator.default.wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            expect( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
              return _regenerator.default.wrap(function _callee3$(_context3) {
                while (1) switch (_context3.prev = _context3.next) {
                  case 0:
                    _context3.next = 2;
                    return (0, _CallingClient.createClient)(webex);
                  case 2:
                    callingClient = _context3.sent;
                    expect(callingClient).toBeTruthy();
                  case 4:
                  case "end":
                    return _context3.stop();
                }
              }, _callee3);
            }))).not.toThrow(Error);
          case 1:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    })));

    /**
     * Input sdk config to callingClient with serviceData carrying empty string for
     * both indicator and domain in it.
     *
     * It should default to service type calling and empty domain value.
     *
     */
    it('Verify invalid empty service indicator, empty domain', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
      var serviceDataObj;
      return _regenerator.default.wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            /* eslint-disable @typescript-eslint/no-explicit-any */
            serviceDataObj = {
              indicator: '',
              domain: ''
            };
            expect( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
              return _regenerator.default.wrap(function _callee5$(_context5) {
                while (1) switch (_context5.prev = _context5.next) {
                  case 0:
                    _context5.next = 2;
                    return (0, _CallingClient.createClient)(webex, {
                      serviceData: serviceDataObj
                    });
                  case 2:
                    callingClient = _context5.sent;
                    expect(callingClient).toBeTruthy();
                  case 4:
                  case "end":
                    return _context5.stop();
                }
              }, _callee5);
            }))).not.toThrow(Error);
          case 2:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    })));

    /**
     * Input sdk config to callingClient with serviceData carrying invalid value for indicator
     * and valid domain type string for domain field in it.
     *
     * It should throw error and abort execution as indicator value is invalid.
     *
     * INDICATOR value MUST MATCH with one of the values in ServiceIndicator enum.
     */
    it('Verify invalid service indicator, valid domain', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
      var serviceDataObj;
      return _regenerator.default.wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            /* eslint-disable @typescript-eslint/no-explicit-any */
            serviceDataObj = {
              indicator: 'test',
              domain: 'test.example.com'
            };
            _context7.prev = 1;
            _context7.next = 4;
            return (0, _CallingClient.createClient)(webex, {
              serviceData: serviceDataObj
            });
          case 4:
            callingClient = _context7.sent;
            _context7.next = 10;
            break;
          case 7:
            _context7.prev = 7;
            _context7.t0 = _context7["catch"](1);
            expect(_context7.t0.message).toEqual('Invalid service indicator, Allowed values are: calling, contactcenter and guestcalling');
          case 10:
            expect.assertions(1);
          case 11:
          case "end":
            return _context7.stop();
        }
      }, _callee7, null, [[1, 7]]);
    })));

    /**
     * Input sdk config to callingClient with serviceData carrying valid value for indicator
     * 'calling', but an invalid domain type string for domain field in it.
     *
     * It should throw error and abort execution as domain value is invalid.
     *
     * DOMAIN field for service type calling is allowed to be empty but if it carries a non-empty
     * string then it must be of valid domain type.
     */
    it('CALLING: verify invalid service domain', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
      var serviceDataObj;
      return _regenerator.default.wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            serviceDataObj = {
              indicator: _types2.ServiceIndicator.CALLING,
              domain: 'test'
            };
            _context8.prev = 1;
            _context8.next = 4;
            return (0, _CallingClient.createClient)(webex, {
              serviceData: serviceDataObj
            });
          case 4:
            callingClient = _context8.sent;
            _context8.next = 10;
            break;
          case 7:
            _context8.prev = 7;
            _context8.t0 = _context8["catch"](1);
            expect(_context8.t0.message).toEqual('Invalid service domain.');
          case 10:
            expect.assertions(1);
          case 11:
          case "end":
            return _context8.stop();
        }
      }, _callee8, null, [[1, 7]]);
    })));

    /**
     * Input sdk config to callingClient with serviceData carrying valid value for indicator
     * 'calling', and an empty string for domain field in it.
     *
     * Execution should proceed properly and createRegistration should be called with same serviceData.
     *
     * DOMAIN field for service type 'calling' is allowed to be empty.
     */
    it('CALLING: verify valid empty service domain', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
      var serviceDataObj;
      return _regenerator.default.wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            serviceDataObj = {
              indicator: _types2.ServiceIndicator.CALLING,
              domain: ''
            };
            expect( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
              return _regenerator.default.wrap(function _callee9$(_context9) {
                while (1) switch (_context9.prev = _context9.next) {
                  case 0:
                    _context9.next = 2;
                    return (0, _CallingClient.createClient)(webex, {
                      serviceData: serviceDataObj
                    });
                  case 2:
                    callingClient = _context9.sent;
                    expect(callingClient).toBeTruthy();
                  case 4:
                  case "end":
                    return _context9.stop();
                }
              }, _callee9);
            }))).not.toThrow(Error);
          case 2:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    })));

    /**
     * Input sdk config to callingClient with serviceData carrying valid value for indicator
     * 'contactcenter', but an empty string for domain field in it.
     *
     * It should throw error and abort execution as domain value is invalid.
     *
     * DOMAIN field for service type 'contactcenter' must carry a non-empty valid domain type string.
     */
    it('ContactCenter: verify empty invalid service domain', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
      var serviceDataObj;
      return _regenerator.default.wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            serviceDataObj = {
              indicator: _types2.ServiceIndicator.CONTACT_CENTER,
              domain: ''
            };
            _context11.prev = 1;
            _context11.next = 4;
            return (0, _CallingClient.createClient)(webex, {
              serviceData: serviceDataObj
            });
          case 4:
            callingClient = _context11.sent;
            _context11.next = 10;
            break;
          case 7:
            _context11.prev = 7;
            _context11.t0 = _context11["catch"](1);
            expect(_context11.t0.message).toEqual('Invalid service domain.');
          case 10:
            expect.assertions(1);
          case 11:
          case "end":
            return _context11.stop();
        }
      }, _callee11, null, [[1, 7]]);
    })));

    /**
     * Input sdk config to callingClient with serviceData carrying valid value for indicator
     * 'contactcenter' , and a valid domain type string for domain field in it.
     *
     * Execution should proceed properly and createRegistration should be called with same serviceData.
     *
     * DOMAIN field for service type 'contactcenter' must carry a non-empty valid domain type string.
     */
    it('ContactCenter: verify valid service domain', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
      var serviceDataObj;
      return _regenerator.default.wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            serviceDataObj = {
              indicator: _types2.ServiceIndicator.CONTACT_CENTER,
              domain: 'test.example.com'
            };
            expect( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
              return _regenerator.default.wrap(function _callee12$(_context12) {
                while (1) switch (_context12.prev = _context12.next) {
                  case 0:
                    _context12.next = 2;
                    return (0, _CallingClient.createClient)(webex, {
                      serviceData: serviceDataObj
                    });
                  case 2:
                    callingClient = _context12.sent;
                    expect(callingClient).toBeTruthy();
                  case 4:
                  case "end":
                    return _context12.stop();
                }
              }, _callee12);
            }))).not.toThrow(Error);
          case 2:
          case "end":
            return _context13.stop();
        }
      }, _callee13);
    })));
    it('Get current log level', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14() {
      return _regenerator.default.wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            _context14.next = 2;
            return (0, _CallingClient.createClient)(webex, {
              logger: {
                level: _types.LOGGER.INFO
              }
            });
          case 2:
            callingClient = _context14.sent;
            expect(callingClient).toBeTruthy();
            expect(callingClient.getLoggingLevel).toBeTruthy();
            expect(callingClient.getLoggingLevel()).toEqual(_types.LOGGER.INFO);
          case 6:
          case "end":
            return _context14.stop();
        }
      }, _callee14);
    })));
  });
  describe('Mobius Server discovery tests', function () {
    var callingClient;
    afterEach(function () {
      jest.clearAllTimers();
      jest.clearAllMocks();
      callingClient.removeAllListeners();
      callManager.removeAllListeners();
      callingClient = undefined;
      jest.useRealTimers();
    });
    it('verify successful mobius server url discovery', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15() {
      return _regenerator.default.wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            webex.request.mockResolvedValueOnce(_callingClientFixtures.ipPayload).mockResolvedValueOnce(_callingClientFixtures.regionPayload).mockResolvedValueOnce(_callingClientFixtures.discoveryPayload);
            _context15.next = 3;
            return (0, _CallingClient.createClient)(webex, {
              logger: {
                level: _types.LOGGER.INFO
              }
            });
          case 3:
            callingClient = _context15.sent;
            expect(webex.request).toBeCalledTimes(3);
            expect(callingClient.primaryMobiusUris).toEqual([_callingClientFixtures.primaryUrl]);
            expect(handleErrorSpy).not.toBeCalled();
            expect(webex.request).nthCalledWith(1, _objectSpread(_objectSpread({
              method: 'GET'
            }, (0, _testUtil.getMockRequestTemplate)()), {}, {
              uri: "".concat(callingClient['mobiusHost']).concat(_constants.URL_ENDPOINT).concat(_constants.IP_ENDPOINT)
            }));
            expect(webex.request).nthCalledWith(2, {
              method: 'GET',
              uri: "".concat(_constants.DISCOVERY_URL, "/").concat(_callingClientFixtures.myIP),
              addAuthHeader: false,
              headers: (0, _defineProperty2.default)({}, _constants.SPARK_USER_AGENT, null)
            });
            expect(webex.request).nthCalledWith(3, _objectSpread(_objectSpread({
              method: 'GET'
            }, (0, _testUtil.getMockRequestTemplate)()), {}, {
              uri: "".concat(callingClient['mobiusHost']).concat(_constants.URL_ENDPOINT, "?regionCode=").concat(_callingClientFixtures.regionBody.clientRegion, "&countryCode=").concat(_callingClientFixtures.regionBody.countryCode)
            }));
          case 10:
          case "end":
            return _context15.stop();
        }
      }, _callee15);
    })));
    it('case when region discovery fails', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16() {
      var failurePayload;
      return _regenerator.default.wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            failurePayload = {
              statusCode: 500
            };
            webex.request.mockRejectedValueOnce(failurePayload);
            _context16.next = 4;
            return (0, _CallingClient.createClient)(webex, {
              logger: {
                level: _types.LOGGER.INFO
              }
            });
          case 4:
            callingClient = _context16.sent;
            expect(webex.request).nthCalledWith(1, _objectSpread(_objectSpread({}, (0, _testUtil.getMockRequestTemplate)()), {}, {
              uri: 'https://mobius-us-east-1.prod.infra.webex.com/api/v1/calling/web/myip',
              method: 'GET'
            }));
            expect(webex.request).nthCalledWith(2, _objectSpread(_objectSpread({}, (0, _testUtil.getMockRequestTemplate)()), {}, {
              uri: 'https://mobius-ca-central-1.prod.infra.webex.com/api/v1/calling/web/myip',
              method: 'GET'
            }));
            expect(webex.request).nthCalledWith(3, _objectSpread(_objectSpread({}, (0, _testUtil.getMockRequestTemplate)()), {}, {
              uri: 'https://mobius-eu-central-1.prod.infra.webex.com/api/v1/calling/web/myip',
              method: 'GET'
            }));
            expect(webex.request).nthCalledWith(4, _objectSpread(_objectSpread({}, (0, _testUtil.getMockRequestTemplate)()), {}, {
              uri: 'https://mobius-ap-southeast-2.prod.infra.webex.com/api/v1/calling/web/myip',
              method: 'GET'
            }));
            expect(handleErrorSpy).toBeCalledWith(failurePayload, expect.anything(), {
              file: _constants.CALLING_CLIENT_FILE,
              method: 'getMobiusServers'
            });
            expect(callingClient.primaryMobiusUris).toEqual(["".concat(callingClient['mobiusHost']).concat(_constants.URL_ENDPOINT)]);
            expect(warnSpy).toBeCalledWith("Couldn't resolve the region and country code. Defaulting to the catalog entries to discover mobius servers", '');
          case 12:
          case "end":
            return _context16.stop();
        }
      }, _callee16);
    })));
    it('when region discovery succeeds but region based mobius url discovery fails', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17() {
      var failurePayload;
      return _regenerator.default.wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            failurePayload = {
              statusCode: 500
            };
            webex.request.mockResolvedValueOnce(_callingClientFixtures.ipPayload).mockResolvedValueOnce(_callingClientFixtures.regionPayload).mockRejectedValueOnce(failurePayload);
            _context17.next = 4;
            return (0, _CallingClient.createClient)(webex, {
              logger: {
                level: _types.LOGGER.INFO
              }
            });
          case 4:
            callingClient = _context17.sent;
            expect(handleErrorSpy).toBeCalledWith(failurePayload, expect.anything(), {
              file: _constants.CALLING_CLIENT_FILE,
              method: 'getMobiusServers'
            });
            expect(webex.request).toBeCalledTimes(3);
            expect(callingClient.primaryMobiusUris).toEqual(["".concat(callingClient['mobiusHost']).concat(_constants.URL_ENDPOINT)]);
            expect(webex.request).nthCalledWith(1, _objectSpread(_objectSpread({
              method: 'GET'
            }, (0, _testUtil.getMockRequestTemplate)()), {}, {
              uri: "".concat(callingClient['mobiusHost']).concat(_constants.URL_ENDPOINT).concat(_constants.IP_ENDPOINT)
            }));
            expect(webex.request).nthCalledWith(2, {
              method: 'GET',
              uri: "".concat(_constants.DISCOVERY_URL, "/").concat(_callingClientFixtures.myIP),
              addAuthHeader: false,
              headers: (0, _defineProperty2.default)({}, _constants.SPARK_USER_AGENT, null)
            });
            expect(warnSpy).toBeCalledWith("Couldn't resolve the region and country code. Defaulting to the catalog entries to discover mobius servers", '');
          case 11:
          case "end":
            return _context17.stop();
        }
      }, _callee17);
    })));
    it('Verify successful mobius server url discovery after initializing callingClient through a config', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18() {
      var infoSpy;
      return _regenerator.default.wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            infoSpy = jest.spyOn(_Logger.default, 'info');
            infoSpy.mockReset();
            webex.request.mockResolvedValueOnce(_callingClientFixtures.discoveryPayload);
            _context18.next = 5;
            return (0, _CallingClient.createClient)(webex, {
              discovery: {
                region: 'AP-SOUTHEAST',
                country: 'IN'
              },
              logger: {
                level: _types.LOGGER.INFO
              }
            });
          case 5:
            callingClient = _context18.sent;
            expect(callingClient.primaryMobiusUris).toEqual([_callingClientFixtures.primaryUrl]);
            expect(infoSpy).toHaveBeenCalledWith(_constants2.METHOD_START_MESSAGE, {
              file: 'CallingClient',
              method: 'getMobiusServers'
            });
            expect(webex.request).toBeCalledOnceWith(_objectSpread(_objectSpread({}, (0, _testUtil.getMockRequestTemplate)()), {}, {
              uri: "".concat(callingClient['mobiusHost']).concat(_constants.URL_ENDPOINT, "?regionCode=").concat(_callingClientFixtures.regionBody.clientRegion, "&countryCode=").concat(_callingClientFixtures.regionBody.countryCode),
              method: 'GET'
            }));
            expect(handleErrorSpy).not.toHaveBeenCalled();
          case 10:
          case "end":
            return _context18.stop();
        }
      }, _callee18);
    })));
  });
  describe('Testing each cluster present withing host catalog', function () {
    var mobiusCluster = ['mobius-eu-central-1.prod.infra.webex.com', 'mobius-us-east-1.int.infra.webex.com', 'mobius-eu-central-1.int.infra.webex.com'];
    var checkCluster = /*#__PURE__*/function () {
      var _ref19 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee19(mockServiceHosts, mockCatalog) {
        var callingClient;
        return _regenerator.default.wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              webex.internal.services._hostCatalog = mockCatalog;
              _context19.next = 3;
              return (0, _CallingClient.createClient)(webex, {
                logger: {
                  level: _types.LOGGER.INFO
                }
              });
            case 3:
              callingClient = _context19.sent;
              expect(callingClient['mobiusClusters']).toStrictEqual(mockServiceHosts);
            case 5:
            case "end":
              return _context19.stop();
          }
        }, _callee19);
      }));
      return function checkCluster(_x, _x2) {
        return _ref19.apply(this, arguments);
      };
    }();
    it.each(mobiusCluster)('%s', /*#__PURE__*/function () {
      var _ref20 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee20(clusterName) {
        return _regenerator.default.wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              _context20.t0 = clusterName;
              _context20.next = _context20.t0 === 'mobius-eu-central-1.prod.infra.webex.com' ? 3 : _context20.t0 === 'mobius-us-east-1.int.infra.webex.com' ? 5 : _context20.t0 === 'mobius-eu-central-1.int.infra.webex.com' ? 7 : 9;
              break;
            case 3:
              checkCluster(_callingClientFixtures.mockEUServiceHosts, _callingClientFixtures.mockCatalogEU);
              return _context20.abrupt("break", 10);
            case 5:
              checkCluster(_callingClientFixtures.mockIntServiceHosts, _callingClientFixtures.mockCatalogUSInt);
              return _context20.abrupt("break", 10);
            case 7:
              checkCluster(_callingClientFixtures.mockEUIntServiceHosts, _callingClientFixtures.mockCatalogEUInt);
              return _context20.abrupt("break", 10);
            case 9:
              return _context20.abrupt("break", 10);
            case 10:
            case "end":
              return _context20.stop();
          }
        }, _callee20);
      }));
      return function (_x3) {
        return _ref20.apply(this, arguments);
      };
    }());
  });
  describe('Network activity detection tests', function () {
    var callingClient;
    var line;
    var reg;
    var restoreSpy;
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var deRegSpy;
    var restartRegisterSpy;
    var registerSpy;
    beforeEach( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee21() {
      return _regenerator.default.wrap(function _callee21$(_context21) {
        while (1) switch (_context21.prev = _context21.next) {
          case 0:
            jest.useFakeTimers();
            webex.request.mockResolvedValueOnce(_callingClientFixtures.ipPayload).mockResolvedValueOnce(_callingClientFixtures.regionPayload).mockResolvedValueOnce(_callingClientFixtures.discoveryPayload).mockResolvedValueOnce(_callingClientFixtures.registrationPayload);
            _context21.next = 4;
            return (0, _CallingClient.createClient)(webex, {
              logger: {
                level: _types.LOGGER.INFO
              }
            });
          case 4:
            callingClient = _context21.sent;
            line = (0, _values.default)(callingClient.lineDict)[0];
            reg = line.registration;
            _context21.next = 9;
            return line.register();
          case 9:
            deRegSpy = jest.spyOn(line.registration, 'deregister');
            restoreSpy = jest.spyOn(reg, 'restorePreviousRegistration');
            restartRegisterSpy = jest.spyOn(reg, 'restartRegistration');
            registerSpy = jest.spyOn(reg, 'attemptRegistrationWithServers');
          case 13:
          case "end":
            return _context21.stop();
        }
      }, _callee21);
    })));
    afterEach(function () {
      jest.clearAllTimers();
      jest.clearAllMocks();
      callingClient.removeAllListeners();
      callManager.removeAllListeners();
      callingClient = undefined;
      jest.useRealTimers();
    });
    it('detect a network flap in mercury connection', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee22() {
      return _regenerator.default.wrap(function _callee22$(_context22) {
        while (1) switch (_context22.prev = _context22.next) {
          case 0:
            expect(line.getStatus()).toEqual(_types2.RegistrationStatus.ACTIVE);

            /* Set mercury connection to be down and execute a delay of 2.5 seconds */
            webex.internal.mercury.connected = false;
            jest.advanceTimersByTime(_constants.NETWORK_FLAP_TIMEOUT + 500);

            /* We should be detecting the network flap */
            expect(warnSpy).toBeCalledOnceWith('Network has flapped, waiting for mercury connection to be up', {
              file: _constants.CALLING_CLIENT_FILE,
              method: _constants.NETWORK_CHANGE_DETECTION_UTIL
            });

            /* Set mercury connection to be up and execute a delay of 2.5 seconds */
            webex.internal.mercury.connected = true;
            logSpy.mockReset();
            jest.advanceTimersByTime(_constants.NETWORK_FLAP_TIMEOUT + 500);
            _context22.next = 9;
            return flushPromises();
          case 9:
            _Logger.default.info('Mercury connection is up again, re-registering with Webex Calling if needed', {
              file: _constants.REGISTRATION_FILE,
              method: 'handleConnectionRestoration'
            });

            /* We should be detecting the network recovery */
            expect(logSpy).toHaveBeenCalledWith('Mercury connection is up again, re-registering with Webex Calling if needed', {
              file: _constants.REGISTRATION_FILE,
              method: 'handleConnectionRestoration'
            });
            expect(restoreSpy).toHaveBeenCalledWith('handleConnectionRestoration');
            expect(restartRegisterSpy).toHaveBeenCalledWith('handleConnectionRestoration');
            expect(webex.request).toHaveBeenCalledTimes(6);
            expect(registerSpy).toHaveBeenCalledWith('handleConnectionRestoration', [reg.getActiveMobiusUrl()]);
            expect(registerSpy).toHaveBeenCalledWith('handleConnectionRestoration', [_callingClientFixtures.primaryUrl]);
          case 16:
          case "end":
            return _context22.stop();
        }
      }, _callee22);
    })));
    it('Simulate a network flap with no active calls and re-verify registration: Restore Failure', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee23() {
      var failurePayload, mockRegistrationBody, successPayload;
      return _regenerator.default.wrap(function _callee23$(_context23) {
        while (1) switch (_context23.prev = _context23.next) {
          case 0:
            expect(line.getStatus()).toEqual(_types2.RegistrationStatus.ACTIVE);
            failurePayload = {
              statusCode: 500,
              body: ''
            };
            mockRegistrationBody = (0, _testUtil.getMockDeviceInfo)();
            successPayload = {
              statusCode: 200,
              body: mockRegistrationBody
            };
            webex.request.mockRejectedValueOnce(failurePayload).mockResolvedValueOnce(successPayload);

            /* Set mercury connection to be down and execute a delay of 2.5 seconds */
            webex.internal.mercury.connected = false;
            jest.advanceTimersByTime(_constants.NETWORK_FLAP_TIMEOUT + 500);

            /* We should be detecting the network flap */
            expect(warnSpy).toBeCalledWith('Network has flapped, waiting for mercury connection to be up', {
              file: _constants.CALLING_CLIENT_FILE,
              method: _constants.NETWORK_CHANGE_DETECTION_UTIL
            });

            /* Set mercury connection to be up and execute a delay of 2.5 seconds */
            webex.internal.mercury.connected = true;
            logSpy.mockReset();
            jest.advanceTimersByTime(_constants.NETWORK_FLAP_TIMEOUT + 500);
            _context23.next = 13;
            return flushPromises();
          case 13:
            _Logger.default.info('Mercury connection is up again, re-registering with Webex Calling if needed', {
              file: _constants.REGISTRATION_FILE,
              method: 'handleConnectionRestoration'
            });

            /* We should be detecting the network recovery */
            expect(logSpy).toBeCalledWith('Mercury connection is up again, re-registering with Webex Calling if needed', {
              file: _constants.REGISTRATION_FILE,
              method: 'handleConnectionRestoration'
            });
            expect(restoreSpy).toHaveBeenCalledWith('handleConnectionRestoration');
            expect(restartRegisterSpy).toHaveBeenCalledWith('handleConnectionRestoration');
            expect(webex.request).toHaveBeenCalledTimes(6);
            expect(registerSpy).toHaveBeenCalledWith('handleConnectionRestoration', [reg.getActiveMobiusUrl()]);
            expect(registerSpy).toHaveBeenCalledWith('handleConnectionRestoration', [_callingClientFixtures.primaryUrl]);
          case 20:
          case "end":
            return _context23.stop();
        }
      }, _callee23);
    })));
    it('Simulate a network flap before initial registration is done', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee24() {
      var handleConnectionRestoreSpy;
      return _regenerator.default.wrap(function _callee24$(_context24) {
        while (1) switch (_context24.prev = _context24.next) {
          case 0:
            handleConnectionRestoreSpy = jest.spyOn(reg, 'handleConnectionRestoration');
            reg.setStatus(_types2.RegistrationStatus.IDLE);

            /* Set mercury connection to be down and execute a delay of 2.5 seconds */
            webex.internal.mercury.connected = false;
            jest.advanceTimersByTime(_constants.NETWORK_FLAP_TIMEOUT + 500);

            /* We should be detecting the network flap */
            expect(warnSpy).toBeCalledOnceWith('Network has flapped, waiting for mercury connection to be up', {
              file: _constants.CALLING_CLIENT_FILE,
              method: _constants.NETWORK_CHANGE_DETECTION_UTIL
            });

            /* Set mercury connection to be up and execute a delay of 2.5 seconds */
            webex.internal.mercury.connected = true;
            jest.advanceTimersByTime(_constants.NETWORK_FLAP_TIMEOUT + 500);
            _context24.next = 9;
            return flushPromises();
          case 9:
            /* We should be detecting the network recovery */
            expect(logSpy).not.toBeCalledWith('Mercury connection is up again, re-registering with Webex Calling if needed', {
              file: _constants.REGISTRATION_FILE,
              method: 'handleConnectionRestoration'
            });

            /*
             * When initial registration is not done, network flap
             * will not trigger de-registration/registration
             */
            expect(handleConnectionRestoreSpy).not.toBeCalledOnceWith();
          case 11:
          case "end":
            return _context24.stop();
        }
      }, _callee24);
    })));
    it('Simulate a network flap with 1 active call', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee25() {
      return _regenerator.default.wrap(function _callee25$(_context25) {
        while (1) switch (_context25.prev = _context25.next) {
          case 0:
            expect(line.getStatus()).toEqual(_types2.RegistrationStatus.ACTIVE);

            /** create a new call */
            reg.callManager.createCall();
            expect((0, _keys.default)(reg.callManager.getActiveCalls()).length).toBe(1);

            /* Set mercury connection to be down and execute a delay of 2.5 seconds */
            webex.internal.mercury.connected = false;
            jest.advanceTimersByTime(_constants.NETWORK_FLAP_TIMEOUT + 500);
            _context25.next = 7;
            return flushPromises();
          case 7:
            /* We should be detecting the network flap */
            expect(warnSpy).not.toBeCalledOnceWith('Network has flapped, waiting for mercury connection to be up', {
              file: _constants.CALLING_CLIENT_FILE,
              method: 'handleConnectionRestoration'
            });

            /* Set mercury connection to be up and execute a delay of 2.5 seconds */
            webex.internal.mercury.connected = true;
            jest.advanceTimersByTime(_constants.NETWORK_FLAP_TIMEOUT + 500);
            _context25.next = 12;
            return flushPromises();
          case 12:
            /* We should be detecting the network recovery */
            expect(logSpy).not.toBeCalledOnceWith('Mercury connection is up again, re-registering with Webex Calling if needed', {
              file: _constants.REGISTRATION_FILE,
              method: 'handleConnectionRestoration'
            });
            expect(registerSpy).not.toBeCalledWith(true);
          case 14:
          case "end":
            return _context25.stop();
        }
      }, _callee25);
    })));
  });
  describe('Line creation tests', function () {
    var callingClient;
    var line;
    beforeEach( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee26() {
      return _regenerator.default.wrap(function _callee26$(_context26) {
        while (1) switch (_context26.prev = _context26.next) {
          case 0:
            _context26.next = 2;
            return (0, _CallingClient.createClient)(webex);
          case 2:
            callingClient = _context26.sent;
            line = (0, _values.default)(callingClient.lineDict)[0];
          case 4:
          case "end":
            return _context26.stop();
        }
      }, _callee26);
    })));
    afterEach(function () {
      jest.clearAllTimers();
      jest.clearAllMocks();
      callingClient.removeAllListeners();
      callManager.removeAllListeners();
      callingClient = undefined;
      jest.useRealTimers();
    });
    it('verify line dict successfully created', function () {
      expect(callingClient.lineDict).toBeTruthy();
      expect(line).toBeTruthy();
      expect((0, _keys.default)(callingClient.lineDict).length).toEqual(1);
    });
    it('verify getLines response', function () {
      expect(callingClient.getLines).toBeTruthy();
      expect(callingClient.getLines()).toEqual(callingClient.lineDict);
    });
  });

  // Calling related test cases
  describe('Calling tests', function () {
    var mutex = new _asyncMutex.Mutex();
    var userId = webex.internal.device.userId;
    var clientDeviceUri = webex.internal.device.url;
    var mobiusUris = (0, _Utils.filterMobiusUris)((0, _testUtil.getMobiusDiscoveryResponse)(), _registerFixtures.URL);
    var primaryMobiusUris = jest.fn(function () {
      return mobiusUris.primary;
    });
    var backupMobiusUris = jest.fn(function () {
      return mobiusUris.backup;
    });
    var callingClient;
    var line;
    beforeAll( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee27() {
      var calls;
      return _regenerator.default.wrap(function _callee27$(_context27) {
        while (1) switch (_context27.prev = _context27.next) {
          case 0:
            _context27.next = 2;
            return (0, _CallingClient.createClient)(webex);
          case 2:
            callingClient = _context27.sent;
            line = new _line.default(userId, clientDeviceUri, mutex, primaryMobiusUris(), backupMobiusUris(), _types.LOGGER.INFO);
            calls = (0, _values.default)(callManager.getActiveCalls());
            calls.forEach(function (call) {
              call.end();
            });
          case 6:
          case "end":
            return _context27.stop();
        }
      }, _callee27);
    })));
    afterAll(function () {
      callingClient.removeAllListeners();
      callManager.removeAllListeners();
    });
    it('verify calling client object', function () {
      expect(callingClient.getSDKConnector().getWebex().internal.device.userId).toBe('8a67806f-fc4d-446b-a131-31e71ea5b0e9');
    });
    it('returns undefined when there is no connected call', function () {
      line.register();
      line.makeCall({
        address: '123456',
        type: _types2.CallType.URI
      });
      expect(callingClient.getConnectedCall()).toEqual(undefined);
    });
    it('returns the connected call', function () {
      line.register();
      var mockCall = line.makeCall({
        address: '1234',
        type: _types2.CallType.URI
      });
      var mockCall2 = line.makeCall({
        address: '5678',
        type: _types2.CallType.URI
      });
      // Connected call
      mockCall['connected'] = true;
      mockCall['earlyMedia'] = false;
      mockCall['callStateMachine'].state.value = 'S_CALL_ESTABLISHED';

      // Held call
      mockCall2['connected'] = true;
      mockCall2['held'] = true;
      mockCall2['earlyMedia'] = false;
      mockCall2['callStateMachine'].state.value = 'S_CALL_HOLD';
      var mockActiveCalls = {
        mockCorrelationId: mockCall,
        mockCorrelationId2: mockCall2
      };
      jest.spyOn(callManager, 'getActiveCalls').mockReturnValue(mockActiveCalls);
      expect(callingClient.getConnectedCall()).toEqual(mockCall);
    });
    it('returns all active calls', function () {
      callingClient.lineDict = {
        mockDeviceId: {
          lineId: 'mockLineId'
        },
        mockDeviceId2: {
          lineId: 'mockLineId2'
        }
      };
      var mockCall = line.makeCall({
        address: '1234',
        type: _types2.CallType.URI
      });
      var mockCall2 = line.makeCall({
        address: '5678',
        type: _types2.CallType.URI
      });
      var mockCall3 = line.makeCall({
        address: '9101',
        type: _types2.CallType.URI
      });
      mockCall.lineId = 'mockLineId';
      mockCall2.lineId = 'mockLineId2';
      mockCall3.lineId = 'mockLineId2';
      var mockActiveCalls = {
        mockCorrelationId: mockCall,
        mockCorrelationId2: mockCall2,
        mockCorrelationId3: mockCall3
      };
      jest.spyOn(callManager, 'getActiveCalls').mockReturnValue(mockActiveCalls);
      expect(callingClient.getActiveCalls()).toEqual({
        mockLineId: [mockCall],
        mockLineId2: [mockCall2, mockCall3]
      });
    });
  });
  describe('Call Session Event test', function () {
    var mockOn = webex.internal.mercury.on;
    var callingClient;
    beforeEach( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee28() {
      return _regenerator.default.wrap(function _callee28$(_context28) {
        while (1) switch (_context28.prev = _context28.next) {
          case 0:
            _context28.next = 2;
            return (0, _CallingClient.createClient)(webex, {
              logger: {
                level: _types.LOGGER.INFO
              }
            });
          case 2:
            callingClient = _context28.sent;
          case 3:
          case "end":
            return _context28.stop();
        }
      }, _callee28);
    })));
    afterEach(function () {
      callingClient.removeAllListeners();
      callManager.removeAllListeners();
    });
    it('verify the recent user session event ', function (done) {
      expect.assertions(2);
      callingClient.on(_types3.CALLING_CLIENT_EVENT_KEYS.USER_SESSION_INFO, function (event) {
        expect(event.data).toEqual(_callRecordFixtures.MOCK_SESSION_EVENT.data);
        done();
      });
      expect(mockOn.mock.calls[0][0]).toEqual(_types3.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_INCLUSIVE);
      var callSessionCallback = mockOn.mock.calls[0][1];
      callSessionCallback(_callRecordFixtures.MOCK_SESSION_EVENT);
    });
    it('drop the recent user session if there is no webex calling type', function (done) {
      expect.assertions(2);
      callingClient.on(_types3.CALLING_CLIENT_EVENT_KEYS.USER_SESSION_INFO, function (event) {
        expect(event.data.userSessions.userSessions.length).toEqual(1);
        done();
      });
      expect(mockOn.mock.calls[0][0]).toEqual(_types3.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_INCLUSIVE);
      var callSessionCallback = mockOn.mock.calls[0][1];
      callSessionCallback(_callRecordFixtures.MOCK_MULTIPLE_SESSIONS_EVENT);
    });
  });
});
//# sourceMappingURL=CallingClient.test.js.map
