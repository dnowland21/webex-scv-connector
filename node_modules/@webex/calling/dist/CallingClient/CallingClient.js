"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");
var _Array$from = require("@babel/runtime-corejs2/core-js/array/from");
var _Symbol = require("@babel/runtime-corejs2/core-js/symbol");
var _Symbol$iterator = require("@babel/runtime-corejs2/core-js/symbol/iterator");
var _Array$isArray = require("@babel/runtime-corejs2/core-js/array/is-array");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.createClient = exports.CallingClient = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var Media = _interopRequireWildcard(require("@webex/internal-media-core"));
var _asyncMutex = require("async-mutex");
var _constants = require("../common/constants");
var _Utils = require("../common/Utils");
var _types = require("../Logger/types");
var _SDKConnector = _interopRequireDefault(require("../SDKConnector"));
var _impl = require("../Events/impl");
var _types2 = require("../Events/types");
var _types3 = require("../common/types");
var _Logger = _interopRequireDefault(require("../Logger"));
var _callManager = require("./calling/callManager");
var _constants2 = require("./constants");
var _line = _interopRequireDefault(require("./line"));
var _types4 = require("../Metrics/types");
var _Metrics = require("../Metrics");
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof _Symbol !== "undefined" && o[_Symbol$iterator] || o["@@iterator"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return _Array$from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } } /* eslint-disable no-underscore-dangle */ /* eslint-disable valid-jsdoc */ /* eslint-disable @typescript-eslint/no-shadow */
/**
 * The `CallingClient` module provides a set of APIs for line registration and calling functionalities within the SDK.
 *
 * The following code snippet demonstrates how to create an instance of `CallingClient` using a `webex` instance and `callingConfig`:
 *
 * @example
 * ```javascript
 * const callingClient = createClient(webex, callingConfig);
 * ```
 */
var CallingClient = exports.CallingClient = /*#__PURE__*/function (_Eventing) {
  (0, _inherits2.default)(CallingClient, _Eventing);
  var _super = _createSuper(CallingClient);
  /**
   * @ignore
   */
  function CallingClient(webex, config) {
    var _this$sdkConfig, _this$sdkConfig$servi, _this$sdkConfig2, _this$sdkConfig2$logg;
    var _this;
    (0, _classCallCheck2.default)(this, CallingClient);
    _this = _super.call(this);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sdkConnector", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "webex", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "mutex", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "callManager", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "metricManager", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "sdkConfig", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "primaryMobiusUris", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "backupMobiusUris", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "mobiusClusters", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "mobiusHost", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "mediaEngine", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "lineDict", {});
    /**
     * Handler registered for ALL_CALLS_CLEARED event emitted by callManager.
     *
     * If re-register attempt was deferred earlier due to active call(s), then it
     * will be attempted here on receiving a notification from callManager that all
     * calls are cleaned up.
     */
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "callsClearedHandler", /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
      var registration;
      return _regenerator.default.wrap(function _callee2$(_context2) {
        while (1) switch (_context2.prev = _context2.next) {
          case 0:
            _Logger.default.info(_constants.METHOD_START_MESSAGE, {
              file: _constants2.CALLING_CLIENT_FILE,
              method: _constants2.METHODS.CALLS_CLEARED_HANDLER
            });
            // this is a temporary logic to get registration obj
            // it will change once we have proper lineId and multiple lines as well
            registration = (0, _values.default)(_this.lineDict)[0].registration;
            if (registration.isDeviceRegistered()) {
              _context2.next = 5;
              break;
            }
            _context2.next = 5;
            return _this.mutex.runExclusive( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
              return _regenerator.default.wrap(function _callee$(_context) {
                while (1) switch (_context.prev = _context.next) {
                  case 0:
                    if (!registration.isReconnectPending()) {
                      _context.next = 4;
                      break;
                    }
                    _Logger.default.info('All calls cleared, reconnecting', {
                      file: _constants2.CALLING_CLIENT_FILE,
                      method: _constants2.CALLS_CLEARED_HANDLER_UTIL
                    });
                    _context.next = 4;
                    return registration.reconnectOnFailure(_constants2.CALLS_CLEARED_HANDLER_UTIL);
                  case 4:
                  case "end":
                    return _context.stop();
                }
              }, _callee);
            })));
          case 5:
          case "end":
            return _context2.stop();
        }
      }, _callee2);
    })));
    _this.sdkConnector = _SDKConnector.default;
    if (!_this.sdkConnector.getWebex()) {
      var _config$logger;
      _SDKConnector.default.setWebex(webex);
      if (config !== null && config !== void 0 && (_config$logger = config.logger) !== null && _config$logger !== void 0 && _config$logger.level && webex.logger.config) {
        webex.logger.config.level = config.logger.level; // override the webex logger level
      }

      _Logger.default.setWebexLogger(webex.logger);
    }
    _this.mutex = new _asyncMutex.Mutex();
    _this.webex = _this.sdkConnector.getWebex();
    _this.sdkConfig = config;
    var serviceData = (_this$sdkConfig = _this.sdkConfig) !== null && _this$sdkConfig !== void 0 && (_this$sdkConfig$servi = _this$sdkConfig.serviceData) !== null && _this$sdkConfig$servi !== void 0 && _this$sdkConfig$servi.indicator ? _this.sdkConfig.serviceData : {
      indicator: _types3.ServiceIndicator.CALLING,
      domain: ''
    };
    var logLevel = (_this$sdkConfig2 = _this.sdkConfig) !== null && _this$sdkConfig2 !== void 0 && (_this$sdkConfig2$logg = _this$sdkConfig2.logger) !== null && _this$sdkConfig2$logg !== void 0 && _this$sdkConfig2$logg.level ? _this.sdkConfig.logger.level : _types.LOGGER.ERROR;
    _Logger.default.setLogger(logLevel, _constants2.CALLING_CLIENT_FILE);
    (0, _Utils.validateServiceData)(serviceData);
    _this.callManager = (0, _callManager.getCallManager)(_this.webex, serviceData.indicator);
    _this.metricManager = (0, _Metrics.getMetricManager)(_this.webex, serviceData.indicator);
    _this.mediaEngine = Media;
    var adaptedLogger = {
      log: function log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return webex.logger.log(args.join(' : '));
      },
      error: function error() {
        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }
        return webex.logger.error(args.join(' : '));
      },
      warn: function warn() {
        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }
        return webex.logger.warn(args.join(' : '));
      },
      info: function info() {
        for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
          args[_key4] = arguments[_key4];
        }
        return webex.logger.info(args.join(' : '));
      },
      trace: function trace() {
        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
          args[_key5] = arguments[_key5];
        }
        return webex.logger.trace(args.join(' : '));
      },
      debug: function debug() {
        for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          args[_key6] = arguments[_key6];
        }
        return webex.logger.debug(args.join(' : '));
      }
    };
    _this.mediaEngine.setLogger(adaptedLogger);
    _this.primaryMobiusUris = [];
    _this.backupMobiusUris = [];
    var mobiusServiceHost = '';
    try {
      mobiusServiceHost = new URL(_this.webex.internal.services._serviceUrls.mobius).host;
    } catch (error) {
      _Logger.default.warn("Failed to parse mobius service URL", {
        file: _constants2.CALLING_CLIENT_FILE,
        method: _this.constructor.name
      });
    }
    _this.mobiusClusters = mobiusServiceHost && _this.webex.internal.services._hostCatalog[mobiusServiceHost] || _this.webex.internal.services._hostCatalog[_constants2.MOBIUS_US_PROD] || _this.webex.internal.services._hostCatalog[_constants2.MOBIUS_EU_PROD] || _this.webex.internal.services._hostCatalog[_constants2.MOBIUS_US_INT] || _this.webex.internal.services._hostCatalog[_constants2.MOBIUS_EU_INT];
    _this.mobiusHost = '';
    _this.registerSessionsListener();
    _this.registerCallsClearedListener();
    return _this;
  }

  // async calls required to run after constructor

  /**
   * Initializes the `CallingClient` by performing the following steps:
   *
   * 1. Retrieves list of servers.
   * 2. Creates a line.
   * 3. Sets up network change detection.
   *
   * This method should be called once to initialize the `callingClient`.
   *
   * @returns A promise that resolves when the initialization is complete.
   * @ignore
   */
  (0, _createClass2.default)(CallingClient, [{
    key: "init",
    value: function () {
      var _init = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              _context3.next = 2;
              return this.getMobiusServers();
            case 2:
              _context3.next = 4;
              return this.createLine();
            case 4:
              /* Better to run the timer once rather than after every registration */
              this.detectNetworkChange();
            case 5:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function init() {
        return _init.apply(this, arguments);
      }
      return init;
    }()
    /**
     * Register callbacks for network changes.
     */
  }, {
    key: "detectNetworkChange",
    value: (function () {
      var _detectNetworkChange = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
        var _this2 = this;
        var retry, line;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              _Logger.default.info(_constants.METHOD_START_MESSAGE, {
                file: _constants2.CALLING_CLIENT_FILE,
                method: _constants2.METHODS.DETECT_NETWORK_CHANGE
              });
              retry = false; // this is a temporary logic to get registration obj
              // it will change once we have proper lineId and multiple lines as well
              line = (0, _values.default)(this.lineDict)[0];
              setInterval( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
                return _regenerator.default.wrap(function _callee4$(_context4) {
                  while (1) switch (_context4.prev = _context4.next) {
                    case 0:
                      if (!_this2.webex.internal.mercury.connected && !retry && !(0, _keys.default)(_this2.callManager.getActiveCalls()).length) {
                        _Logger.default.warn("Network has flapped, waiting for mercury connection to be up", {
                          file: _constants2.CALLING_CLIENT_FILE,
                          method: _constants2.METHODS.DETECT_NETWORK_CHANGE
                        });
                        line.registration.clearKeepaliveTimer();
                        retry = true;
                      }
                      if (!(retry && _this2.webex.internal.mercury.connected)) {
                        _context4.next = 9;
                        break;
                      }
                      if (!(line.getStatus() !== _types3.RegistrationStatus.IDLE)) {
                        _context4.next = 8;
                        break;
                      }
                      _context4.next = 5;
                      return line.registration.handleConnectionRestoration(retry);
                    case 5:
                      retry = _context4.sent;
                      _context4.next = 9;
                      break;
                    case 8:
                      retry = false;
                    case 9:
                    case "end":
                      return _context4.stop();
                  }
                }, _callee4);
              })), _constants2.NETWORK_FLAP_TIMEOUT);
            case 4:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function detectNetworkChange() {
        return _detectNetworkChange.apply(this, arguments);
      }
      return detectNetworkChange;
    }()
    /**
     * Fetches countryCode and region of the client.
     */
    )
  }, {
    key: "getClientRegionInfo",
    value: (function () {
      var _getClientRegionInfo = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
        var _this3 = this;
        var regionInfo, _iterator, _step, mobius, temp, myIP, response, clientRegionInfo, extendedError;
        return _regenerator.default.wrap(function _callee6$(_context6) {
          while (1) switch (_context6.prev = _context6.next) {
            case 0:
              _Logger.default.info(_constants.METHOD_START_MESSAGE, {
                file: _constants2.CALLING_CLIENT_FILE,
                method: _constants2.METHODS.GET_CLIENT_REGION_INFO
              });
              regionInfo = {};
              _iterator = _createForOfIteratorHelper(this.mobiusClusters);
              _context6.prev = 3;
              _iterator.s();
            case 5:
              if ((_step = _iterator.n()).done) {
                _context6.next = 31;
                break;
              }
              mobius = _step.value;
              this.mobiusHost = "https://".concat(mobius.host).concat(_constants2.API_V1);
              _context6.prev = 8;
              _context6.next = 11;
              return this.webex.request({
                uri: "".concat(this.mobiusHost).concat(_constants2.URL_ENDPOINT).concat(_constants2.IP_ENDPOINT),
                method: _types3.HTTP_METHODS.GET,
                headers: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _constants2.CISCO_DEVICE_URL, this.webex.internal.device.url), _constants2.SPARK_USER_AGENT, _constants2.CALLING_USER_AGENT),
                service: _types3.ALLOWED_SERVICES.MOBIUS
              });
            case 11:
              temp = _context6.sent;
              myIP = temp.body.ipv4; // eslint-disable-next-line no-await-in-loop
              _context6.next = 15;
              return this.webex.request({
                uri: "".concat(_constants2.DISCOVERY_URL, "/").concat(myIP),
                method: _types3.HTTP_METHODS.GET,
                addAuthHeader: false,
                headers: (0, _defineProperty2.default)({}, _constants2.SPARK_USER_AGENT, null)
              });
            case 15:
              response = _context6.sent;
              clientRegionInfo = response.body;
              regionInfo.clientRegion = clientRegionInfo !== null && clientRegionInfo !== void 0 && clientRegionInfo.clientRegion ? clientRegionInfo.clientRegion : '';
              regionInfo.countryCode = clientRegionInfo !== null && clientRegionInfo !== void 0 && clientRegionInfo.countryCode ? clientRegionInfo.countryCode : '';
              return _context6.abrupt("break", 31);
            case 22:
              _context6.prev = 22;
              _context6.t0 = _context6["catch"](8);
              extendedError = new Error("Failed to get client region info: ".concat(_context6.t0));
              _Logger.default.error(extendedError, {
                method: _constants2.METHODS.GET_CLIENT_REGION_INFO,
                file: _constants2.CALLING_CLIENT_FILE
              });
              (0, _Utils.handleCallingClientErrors)(_context6.t0, function (clientError) {
                _this3.metricManager.submitRegistrationMetric(_types4.METRIC_EVENT.REGISTRATION_ERROR, _types4.REG_ACTION.REGISTER, _types4.METRIC_TYPE.BEHAVIORAL, clientError);
                _this3.emit(_types2.CALLING_CLIENT_EVENT_KEYS.ERROR, clientError);
              }, {
                method: _constants2.GET_MOBIUS_SERVERS_UTIL,
                file: _constants2.CALLING_CLIENT_FILE
              });
              regionInfo.clientRegion = '';
              regionInfo.countryCode = '';
            case 29:
              _context6.next = 5;
              break;
            case 31:
              _context6.next = 36;
              break;
            case 33:
              _context6.prev = 33;
              _context6.t1 = _context6["catch"](3);
              _iterator.e(_context6.t1);
            case 36:
              _context6.prev = 36;
              _iterator.f();
              return _context6.finish(36);
            case 39:
              return _context6.abrupt("return", regionInfo);
            case 40:
            case "end":
              return _context6.stop();
          }
        }, _callee6, this, [[3, 33, 36, 39], [8, 22]]);
      }));
      function getClientRegionInfo() {
        return _getClientRegionInfo.apply(this, arguments);
      }
      return getClientRegionInfo;
    }()
    /**
     * Local method for finding the mobius servers.
     */
    )
  }, {
    key: "getMobiusServers",
    value: (function () {
      var _getMobiusServers = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
        var _this$sdkConfig3,
          _this$sdkConfig3$disc,
          _this$sdkConfig4,
          _this$sdkConfig4$disc,
          _this4 = this;
        var useDefault, clientRegion, countryCode, _this$sdkConfig5, _this$sdkConfig5$disc, _this$sdkConfig6, _this$sdkConfig6$disc, regionInfo, temp, mobiusServers, mobiusUris, extendedError;
        return _regenerator.default.wrap(function _callee7$(_context7) {
          while (1) switch (_context7.prev = _context7.next) {
            case 0:
              _Logger.default.info(_constants.METHOD_START_MESSAGE, {
                file: _constants2.CALLING_CLIENT_FILE,
                method: _constants2.METHODS.GET_MOBIUS_SERVERS
              });
              /* Following operations are performed in a synchronous way ->
                   1. Get RegionInfo
                  2. Get Mobius Server with that RegionInfo
                  3. Check whether Mobius server was found without any error
                  4. If there is error , we don't need to send registration
                  5. Otherwise send registration
                  */
              useDefault = false;
              if (!((_this$sdkConfig3 = this.sdkConfig) !== null && _this$sdkConfig3 !== void 0 && (_this$sdkConfig3$disc = _this$sdkConfig3.discovery) !== null && _this$sdkConfig3$disc !== void 0 && _this$sdkConfig3$disc.country && (_this$sdkConfig4 = this.sdkConfig) !== null && _this$sdkConfig4 !== void 0 && (_this$sdkConfig4$disc = _this$sdkConfig4.discovery) !== null && _this$sdkConfig4$disc !== void 0 && _this$sdkConfig4$disc.region)) {
                _context7.next = 9;
                break;
              }
              _Logger.default.log('Updating region and country from the SDK config', {
                file: _constants2.CALLING_CLIENT_FILE,
                method: _constants2.GET_MOBIUS_SERVERS_UTIL
              });
              clientRegion = (_this$sdkConfig5 = this.sdkConfig) === null || _this$sdkConfig5 === void 0 ? void 0 : (_this$sdkConfig5$disc = _this$sdkConfig5.discovery) === null || _this$sdkConfig5$disc === void 0 ? void 0 : _this$sdkConfig5$disc.region;
              countryCode = (_this$sdkConfig6 = this.sdkConfig) === null || _this$sdkConfig6 === void 0 ? void 0 : (_this$sdkConfig6$disc = _this$sdkConfig6.discovery) === null || _this$sdkConfig6$disc === void 0 ? void 0 : _this$sdkConfig6$disc.country;
              this.mobiusHost = this.webex.internal.services._serviceUrls.mobius;
              _context7.next = 15;
              break;
            case 9:
              _Logger.default.log('Updating region and country through Region discovery', {
                file: _constants2.CALLING_CLIENT_FILE,
                method: _constants2.GET_MOBIUS_SERVERS_UTIL
              });
              _context7.next = 12;
              return this.getClientRegionInfo();
            case 12:
              regionInfo = _context7.sent;
              clientRegion = regionInfo.clientRegion;
              countryCode = regionInfo.countryCode;
            case 15:
              if (!(clientRegion && countryCode)) {
                _context7.next = 37;
                break;
              }
              _Logger.default.log("Found Region: ".concat(clientRegion, " and country: ").concat(countryCode, ", going to fetch Mobius server"), '');
              _context7.prev = 17;
              _context7.next = 20;
              return this.webex.request({
                uri: "".concat(this.mobiusHost).concat(_constants2.URL_ENDPOINT, "?regionCode=").concat(clientRegion, "&countryCode=").concat(countryCode),
                method: _types3.HTTP_METHODS.GET,
                headers: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _constants2.CISCO_DEVICE_URL, this.webex.internal.device.url), _constants2.SPARK_USER_AGENT, _constants2.CALLING_USER_AGENT),
                service: _types3.ALLOWED_SERVICES.MOBIUS
              });
            case 20:
              temp = _context7.sent;
              _Logger.default.log('Mobius Server found for the region', '');
              mobiusServers = temp.body;
              /* update arrays of Mobius Uris. */
              mobiusUris = (0, _Utils.filterMobiusUris)(mobiusServers, this.mobiusHost);
              this.primaryMobiusUris = mobiusUris.primary;
              this.backupMobiusUris = mobiusUris.backup;
              _Logger.default.info("Final list of Mobius Servers, primary: ".concat(mobiusUris.primary, " and backup: ").concat(mobiusUris.backup), '');
              _context7.next = 35;
              break;
            case 29:
              _context7.prev = 29;
              _context7.t0 = _context7["catch"](17);
              extendedError = new Error("Failed to get Mobius servers: ".concat(_context7.t0));
              _Logger.default.error(extendedError, {
                method: _constants2.METHODS.GET_MOBIUS_SERVERS,
                file: _constants2.CALLING_CLIENT_FILE
              });
              (0, _Utils.handleCallingClientErrors)(_context7.t0, function (clientError) {
                _this4.metricManager.submitRegistrationMetric(_types4.METRIC_EVENT.REGISTRATION_ERROR, _types4.REG_ACTION.REGISTER, _types4.METRIC_TYPE.BEHAVIORAL, clientError);
                _this4.emit(_types2.CALLING_CLIENT_EVENT_KEYS.ERROR, clientError);
              }, {
                method: _constants2.GET_MOBIUS_SERVERS_UTIL,
                file: _constants2.CALLING_CLIENT_FILE
              });
              useDefault = true;
            case 35:
              _context7.next = 38;
              break;
            case 37:
              /* Setting this to true because region info is possibly undefined */
              useDefault = true;
            case 38:
              /* Use a default URL if Mobius discovery fails either because of region info failure
               * or because the discovered Mobius couldn't be reached
               */

              if (useDefault) {
                _Logger.default.warn("Couldn't resolve the region and country code. Defaulting to the catalog entries to discover mobius servers", '');
                this.mobiusHost = "https://".concat(this.mobiusClusters[0].host).concat(_constants2.API_V1);
                this.primaryMobiusUris = ["".concat(this.mobiusHost).concat(_constants2.URL_ENDPOINT)];
              }
            case 39:
            case "end":
              return _context7.stop();
          }
        }, _callee7, this, [[17, 29]]);
      }));
      function getMobiusServers() {
        return _getMobiusServers.apply(this, arguments);
      }
      return getMobiusServers;
    }()
    /**
     * Registers a listener/handler for ALL_CALLS_CLEARED
     * event emitted by callManager when all the calls
     * present on sdk are cleaned up.
     */
    )
  }, {
    key: "registerCallsClearedListener",
    value: function registerCallsClearedListener() {
      _Logger.default.info(_constants.METHOD_START_MESSAGE, {
        file: _constants2.CALLING_CLIENT_FILE,
        method: _constants2.METHODS.REGISTER_CALLS_CLEARED_LISTENER
      });
      this.callManager.on(_types2.CALLING_CLIENT_EVENT_KEYS.ALL_CALLS_CLEARED, this.callsClearedHandler);
    }
  }, {
    key: "getLoggingLevel",
    value:
    /**
     * To get the current log Level.
     * @ignore
     */
    function getLoggingLevel() {
      return _Logger.default.getLogLevel();
    }

    /**
     *  To return the `sdkConnector` instance that was used during sdk initialisation.
     * @ignore
     */
  }, {
    key: "getSDKConnector",
    value: function getSDKConnector() {
      return this.sdkConnector;
    }
  }, {
    key: "registerSessionsListener",
    value: function registerSessionsListener() {
      var _this5 = this;
      _Logger.default.info(_constants.METHOD_START_MESSAGE, {
        file: _constants2.CALLING_CLIENT_FILE,
        method: _constants2.METHODS.REGISTER_SESSIONS_LISTENER
      });
      this.sdkConnector.registerListener(_types2.MOBIUS_EVENT_KEYS.CALL_SESSION_EVENT_INCLUSIVE, /*#__PURE__*/function () {
        var _ref4 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(event) {
          var sessionArr, i;
          return _regenerator.default.wrap(function _callee8$(_context8) {
            while (1) switch (_context8.prev = _context8.next) {
              case 0:
                if (!(event && event.data.userSessions.userSessions)) {
                  _context8.next = 7;
                  break;
                }
                sessionArr = event === null || event === void 0 ? void 0 : event.data.userSessions.userSessions;
                if (!(sessionArr.length === 1)) {
                  _context8.next = 5;
                  break;
                }
                if (!(sessionArr[0].sessionType !== _types2.SessionType.WEBEX_CALLING)) {
                  _context8.next = 5;
                  break;
                }
                return _context8.abrupt("return");
              case 5:
                for (i = 0; i < sessionArr.length; i += 1) {
                  if (sessionArr[i].sessionType !== _types2.SessionType.WEBEX_CALLING) {
                    sessionArr.splice(i, 1);
                  }
                }
                _this5.emit(_types2.CALLING_CLIENT_EVENT_KEYS.USER_SESSION_INFO, event);
              case 7:
              case "end":
                return _context8.stop();
            }
          }, _callee8);
        }));
        return function (_x) {
          return _ref4.apply(this, arguments);
        };
      }());
    }

    /**
     * Creates line object inside calling client per user
     * NOTE: currently multiple lines are not supported
     */
  }, {
    key: "createLine",
    value: (function () {
      var _createLine = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
        var _this$sdkConfig7, _this$sdkConfig8;
        var line;
        return _regenerator.default.wrap(function _callee9$(_context9) {
          while (1) switch (_context9.prev = _context9.next) {
            case 0:
              _Logger.default.info(_constants.METHOD_START_MESSAGE, {
                file: _constants2.CALLING_CLIENT_FILE,
                method: _constants2.METHODS.CREATE_LINE
              });
              line = new _line.default(this.webex.internal.device.userId, this.webex.internal.device.url, this.mutex, this.primaryMobiusUris, this.backupMobiusUris, this.getLoggingLevel(), (_this$sdkConfig7 = this.sdkConfig) === null || _this$sdkConfig7 === void 0 ? void 0 : _this$sdkConfig7.serviceData, (_this$sdkConfig8 = this.sdkConfig) === null || _this$sdkConfig8 === void 0 ? void 0 : _this$sdkConfig8.jwe);
              this.lineDict[line.lineId] = line;
            case 3:
            case "end":
              return _context9.stop();
          }
        }, _callee9, this);
      }));
      function createLine() {
        return _createLine.apply(this, arguments);
      }
      return createLine;
    }()
    /**
     * Retrieves details of all the Line objects belonging to a User
     * NOTE: currently multiple lines are not supported
     */
    )
  }, {
    key: "getLines",
    value: function getLines() {
      return this.lineDict;
    }

    /**
     * Retrieves call objects for all the active calls present in the client
     */
  }, {
    key: "getActiveCalls",
    value: function getActiveCalls() {
      var activeCalls = {};
      var calls = this.callManager.getActiveCalls();
      (0, _keys.default)(calls).forEach(function (correlationId) {
        var call = calls[correlationId];
        if (!activeCalls[call.lineId]) {
          activeCalls[call.lineId] = [];
        }
        activeCalls[call.lineId].push(call);
      });
      return activeCalls;
    }

    /**
     * Retrieves call object for the connected call in the client
     */
  }, {
    key: "getConnectedCall",
    value: function getConnectedCall() {
      var connectCall;
      var calls = this.callManager.getActiveCalls();
      (0, _keys.default)(calls).forEach(function (correlationId) {
        if (calls[correlationId].isConnected() && !calls[correlationId].isHeld()) {
          connectCall = calls[correlationId];
        }
      });
      return connectCall;
    }

    /**
     * Uploads logs to help troubleshoot SDK issues.
     *
     * This method collects the current SDK logs including network requests, WebSocket
     * messages, and client-side events, then securely submits them to Webex's diagnostics
     * service. The returned tracking ID, feedbackID can be provided to Webex support for faster
     * issue resolution.
     * @returns Promise<UploadLogsResponse>
     * @throws Error
     */
  }, {
    key: "uploadLogs",
    value: (function () {
      var _uploadLogs2 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
        var result;
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              _context10.next = 2;
              return (0, _Utils.uploadLogs)({}, true);
            case 2:
              result = _context10.sent;
              if (result) {
                _context10.next = 5;
                break;
              }
              throw new Error('Failed to upload logs: No response received.');
            case 5:
              return _context10.abrupt("return", result);
            case 6:
            case "end":
              return _context10.stop();
          }
        }, _callee10);
      }));
      function uploadLogs() {
        return _uploadLogs2.apply(this, arguments);
      }
      return uploadLogs;
    }())
  }]);
  return CallingClient;
}(_impl.Eventing);
/**
 * Create the `CallingClient` instance using the `webex` object and callingSdk `config`
 * @param webex - A webex instance.
 * @param config - Config to start the CallingClient with.
 */
var createClient = exports.createClient = /*#__PURE__*/function () {
  var _ref5 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11(webex, config) {
    var callingClientInstance;
    return _regenerator.default.wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          callingClientInstance = new CallingClient(webex, config);
          _context11.next = 3;
          return callingClientInstance.init();
        case 3:
          return _context11.abrupt("return", callingClientInstance);
        case 4:
        case "end":
          return _context11.stop();
      }
    }, _callee11);
  }));
  return function createClient(_x2, _x3) {
    return _ref5.apply(this, arguments);
  };
}();
//# sourceMappingURL=CallingClient.js.map
