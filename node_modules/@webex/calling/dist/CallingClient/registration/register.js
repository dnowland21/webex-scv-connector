"use strict";

var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _Array$from = require("@babel/runtime-corejs2/core-js/array/from");
var _Symbol = require("@babel/runtime-corejs2/core-js/symbol");
var _Symbol$iterator = require("@babel/runtime-corejs2/core-js/symbol/iterator");
var _Array$isArray = require("@babel/runtime-corejs2/core-js/array/is-array");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.createRegistration = exports.Registration = void 0;
var _now = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/date/now"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _uuid = require("uuid");
var _constants = require("../../common/constants");
var _common = require("../../common");
var _types = require("../../Metrics/types");
var _Metrics = require("../../Metrics");
var _calling = require("../calling");
var _Logger = _interopRequireDefault(require("../../Logger"));
var _SDKConnector = _interopRequireDefault(require("../../SDKConnector"));
var _types2 = require("../../common/types");
var _constants2 = require("../constants");
var _types3 = require("../line/types");
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof _Symbol !== "undefined" && o[_Symbol$iterator] || o["@@iterator"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return _Array$from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function ownKeys(e, r) { var t = _Object$keys2(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
/**
 *
 */
var Registration = exports.Registration = /*#__PURE__*/function () {
  /**
   */
  function Registration(webex, serviceData, mutex, lineEmitter, logLevel, jwe) {
    (0, _classCallCheck2.default)(this, Registration);
    (0, _defineProperty2.default)(this, "sdkConnector", void 0);
    (0, _defineProperty2.default)(this, "webex", void 0);
    (0, _defineProperty2.default)(this, "userId", '');
    (0, _defineProperty2.default)(this, "serviceData", void 0);
    (0, _defineProperty2.default)(this, "failback429RetryAttempts", void 0);
    (0, _defineProperty2.default)(this, "registrationStatus", void 0);
    (0, _defineProperty2.default)(this, "failbackTimer", void 0);
    (0, _defineProperty2.default)(this, "activeMobiusUrl", void 0);
    (0, _defineProperty2.default)(this, "keepaliveTimer", void 0);
    (0, _defineProperty2.default)(this, "rehomingIntervalMin", void 0);
    (0, _defineProperty2.default)(this, "rehomingIntervalMax", void 0);
    (0, _defineProperty2.default)(this, "mutex", void 0);
    (0, _defineProperty2.default)(this, "metricManager", void 0);
    (0, _defineProperty2.default)(this, "lineEmitter", void 0);
    (0, _defineProperty2.default)(this, "callManager", void 0);
    (0, _defineProperty2.default)(this, "deviceInfo", {});
    (0, _defineProperty2.default)(this, "primaryMobiusUris", void 0);
    (0, _defineProperty2.default)(this, "backupMobiusUris", void 0);
    (0, _defineProperty2.default)(this, "registerRetry", false);
    (0, _defineProperty2.default)(this, "reconnectPending", false);
    (0, _defineProperty2.default)(this, "jwe", void 0);
    (0, _defineProperty2.default)(this, "isCCFlow", false);
    (0, _defineProperty2.default)(this, "failoverImmediately", false);
    (0, _defineProperty2.default)(this, "retryAfter", void 0);
    (0, _defineProperty2.default)(this, "scheduled429Retry", false);
    this.jwe = jwe;
    this.sdkConnector = _SDKConnector.default;
    this.serviceData = serviceData;
    this.isCCFlow = serviceData.indicator === _types2.ServiceIndicator.CONTACT_CENTER;
    if (!this.sdkConnector.getWebex()) {
      _SDKConnector.default.setWebex(webex);
    }
    this.webex = this.sdkConnector.getWebex();
    this.userId = this.webex.internal.device.userId;
    this.registrationStatus = _types2.RegistrationStatus.IDLE;
    this.failback429RetryAttempts = 0;
    _Logger.default.setLogger(logLevel, _constants2.REGISTRATION_FILE);
    this.rehomingIntervalMin = _constants2.DEFAULT_REHOMING_INTERVAL_MIN;
    this.rehomingIntervalMax = _constants2.DEFAULT_REHOMING_INTERVAL_MAX;
    this.mutex = mutex;
    this.callManager = (0, _calling.getCallManager)(this.webex, serviceData.indicator);
    this.metricManager = (0, _Metrics.getMetricManager)(this.webex, serviceData.indicator);
    this.lineEmitter = lineEmitter;
    this.primaryMobiusUris = [];
    this.backupMobiusUris = [];
  }
  (0, _createClass2.default)(Registration, [{
    key: "getActiveMobiusUrl",
    value: function getActiveMobiusUrl() {
      return this.activeMobiusUrl;
    }
  }, {
    key: "setActiveMobiusUrl",
    value: function setActiveMobiusUrl(url) {
      _Logger.default.info("".concat(_constants.METHOD_START_MESSAGE, " with ").concat(url), {
        method: _constants2.METHODS.UPDATE_ACTIVE_MOBIUS,
        file: _constants2.REGISTRATION_FILE
      });
      this.activeMobiusUrl = url;
      this.callManager.updateActiveMobius(url);
    }
  }, {
    key: "setMobiusServers",
    value: function setMobiusServers(primaryMobiusUris, backupMobiusUris) {
      _Logger.default.log(_constants.METHOD_START_MESSAGE, {
        method: _constants2.METHODS.SET_MOBIUS_SERVERS,
        file: _constants2.REGISTRATION_FILE
      });
      this.primaryMobiusUris = primaryMobiusUris;
      this.backupMobiusUris = backupMobiusUris;
    }

    /**
     *  Implementation of sending keepalive.
     *
     */
  }, {
    key: "postKeepAlive",
    value: (function () {
      var _postKeepAlive = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(url) {
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", this.webex.request({
                uri: "".concat(url, "/status"),
                method: _types2.HTTP_METHODS.POST,
                headers: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _constants2.CISCO_DEVICE_URL, this.webex.internal.device.url), _constants2.SPARK_USER_AGENT, _constants2.CALLING_USER_AGENT),
                service: _types2.ALLOWED_SERVICES.MOBIUS
              }));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function postKeepAlive(_x) {
        return _postKeepAlive.apply(this, arguments);
      }
      return postKeepAlive;
    }()
    /**
     * Implementation of delete device.
     *
     */
    )
  }, {
    key: "deleteRegistration",
    value: (function () {
      var _deleteRegistration = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(url, deviceId, deviceUrl) {
        var _response;
        var response;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              _context2.prev = 0;
              _context2.t0 = fetch;
              _context2.t1 = "".concat(url).concat(_constants2.DEVICES_ENDPOINT_RESOURCE, "/").concat(deviceId);
              _context2.t2 = _types2.HTTP_METHODS.DELETE;
              _context2.t3 = _defineProperty2.default;
              _context2.t4 = _defineProperty2.default;
              _context2.t5 = _defineProperty2.default;
              _context2.t6 = (0, _defineProperty2.default)({}, _constants2.CISCO_DEVICE_URL, deviceUrl);
              _context2.next = 10;
              return this.webex.credentials.getUserToken();
            case 10:
              _context2.t7 = _context2.sent;
              _context2.t8 = (0, _context2.t5)(_context2.t6, "Authorization", _context2.t7);
              _context2.t9 = "".concat(_constants2.WEBEX_WEB_CLIENT, "_").concat((0, _uuid.v4)());
              _context2.t10 = (0, _context2.t4)(_context2.t8, "trackingId", _context2.t9);
              _context2.t11 = _constants2.SPARK_USER_AGENT;
              _context2.t12 = _constants2.CALLING_USER_AGENT;
              _context2.t13 = (0, _context2.t3)(_context2.t10, _context2.t11, _context2.t12);
              _context2.t14 = {
                method: _context2.t2,
                headers: _context2.t13
              };
              _context2.next = 20;
              return (0, _context2.t0)(_context2.t1, _context2.t14);
            case 20:
              response = _context2.sent;
              _context2.next = 26;
              break;
            case 23:
              _context2.prev = 23;
              _context2.t15 = _context2["catch"](0);
              _Logger.default.warn("Delete failed with Mobius ".concat(_context2.t15), {
                file: _constants2.REGISTRATION_FILE,
                method: _constants2.METHODS.DEREGISTER
              });
            case 26:
              this.setStatus(_types2.RegistrationStatus.INACTIVE);
              this.lineEmitter(_types3.LINE_EVENTS.UNREGISTERED);
              return _context2.abrupt("return", (_response = response) === null || _response === void 0 ? void 0 : _response.json());
            case 29:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this, [[0, 23]]);
      }));
      function deleteRegistration(_x2, _x3, _x4) {
        return _deleteRegistration.apply(this, arguments);
      }
      return deleteRegistration;
    }()
    /**
     * Implementation of POST request for device registration.
     *
     */
    )
  }, {
    key: "postRegistration",
    value: (function () {
      var _postRegistration = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(url) {
        var deviceInfo;
        return _regenerator.default.wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              deviceInfo = {
                userId: this.userId,
                clientDeviceUri: this.webex.internal.device.url,
                serviceData: this.jwe ? _objectSpread(_objectSpread({}, this.serviceData), {}, {
                  jwe: this.jwe
                }) : this.serviceData
              };
              return _context3.abrupt("return", this.webex.request({
                uri: "".concat(url, "device"),
                method: _types2.HTTP_METHODS.POST,
                headers: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _constants2.CISCO_DEVICE_URL, deviceInfo.clientDeviceUri), _constants2.SPARK_USER_AGENT, _constants2.CALLING_USER_AGENT),
                body: deviceInfo,
                service: _types2.ALLOWED_SERVICES.MOBIUS
              }));
            case 2:
            case "end":
              return _context3.stop();
          }
        }, _callee3, this);
      }));
      function postRegistration(_x5) {
        return _postRegistration.apply(this, arguments);
      }
      return postRegistration;
    }()
    /**
     * Re-attempts registration with the mobius url it was last registered
     * to, that mobius url is expected to be updated already in this.activeMobiusUrl.
     */
    )
  }, {
    key: "restorePreviousRegistration",
    value: (function () {
      var _restorePreviousRegistration = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(caller) {
        var abort;
        return _regenerator.default.wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              abort = false;
              if (!this.activeMobiusUrl) {
                _context4.next = 5;
                break;
              }
              _context4.next = 4;
              return this.attemptRegistrationWithServers(caller, [this.activeMobiusUrl]);
            case 4:
              abort = _context4.sent;
            case 5:
              return _context4.abrupt("return", abort);
            case 6:
            case "end":
              return _context4.stop();
          }
        }, _callee4, this);
      }));
      function restorePreviousRegistration(_x6) {
        return _restorePreviousRegistration.apply(this, arguments);
      }
      return restorePreviousRegistration;
    }()
    /**
     *
     */
    )
  }, {
    key: "handle429Retry",
    value: (function () {
      var _handle429Retry = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(retryAfter, caller) {
        var interval, abort;
        return _regenerator.default.wrap(function _callee5$(_context5) {
          while (1) switch (_context5.prev = _context5.next) {
            case 0:
              if (!(caller === _constants2.FAILBACK_UTIL)) {
                _context5.next = 17;
                break;
              }
              if (!(this.failback429RetryAttempts >= _constants2.REG_FAILBACK_429_MAX_RETRIES)) {
                _context5.next = 3;
                break;
              }
              return _context5.abrupt("return");
            case 3:
              this.clearFailbackTimer();
              this.failback429RetryAttempts += 1;
              _Logger.default.log("Received 429 while rehoming, 429 retry count : ".concat(this.failback429RetryAttempts), {
                file: _constants2.REGISTRATION_FILE,
                method: _constants2.REG_429_RETRY_UTIL
              });
              interval = this.getRegRetryInterval(this.failback429RetryAttempts);
              this.startFailbackTimer(interval);
              this.scheduled429Retry = true;
              _context5.next = 11;
              return this.restorePreviousRegistration(_constants2.REG_429_RETRY_UTIL);
            case 11:
              abort = _context5.sent;
              if (!(!abort && !this.isDeviceRegistered())) {
                _context5.next = 15;
                break;
              }
              _context5.next = 15;
              return this.restartRegistration(_constants2.REG_429_RETRY_UTIL);
            case 15:
              _context5.next = 18;
              break;
            case 17:
              this.retryAfter = retryAfter;
            case 18:
            case "end":
              return _context5.stop();
          }
        }, _callee5, this);
      }));
      function handle429Retry(_x7, _x8) {
        return _handle429Retry.apply(this, arguments);
      }
      return handle429Retry;
    }()
    /**
     * Calculates and returns a random interval value using input argument
     * attempt as the variable factor.
     *
     *                  attempted already.
     */
    )
  }, {
    key: "getRegRetryInterval",
    value: function getRegRetryInterval() {
      var attempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      return _constants2.BASE_REG_RETRY_TIMER_VAL_IN_SEC + Math.pow(_constants2.BASE_REG_TIMER_MFACTOR, attempt) + Math.floor((Math.random() * (_constants2.REG_RANDOM_T_FACTOR_UPPER_LIMIT - _constants2.SEC_TO_MSEC_MFACTOR + 1) + _constants2.SEC_TO_MSEC_MFACTOR) / _constants2.SEC_TO_MSEC_MFACTOR);
    }

    /**
     * Schedules registration retry with primary mobius servers at a random
     * interval calculated based on the number of times registration retry is already done
     * Once the time taken since the beginning of retry attempt exceeds the
     * retry threshold, it switches over to backup mobius servers.
     *
     */
  }, {
    key: "startFailoverTimer",
    value: (function () {
      var _startFailoverTimer = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
        var _this = this;
        var attempt,
          timeElapsed,
          loggerContext,
          interval,
          TIMER_THRESHOLD,
          excessVal,
          abort,
          scheduledTime,
          _args10 = arguments;
        return _regenerator.default.wrap(function _callee10$(_context10) {
          while (1) switch (_context10.prev = _context10.next) {
            case 0:
              attempt = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : 1;
              timeElapsed = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : 0;
              loggerContext = {
                file: _constants2.REGISTRATION_FILE,
                method: _constants2.FAILOVER_UTIL
              };
              interval = this.getRegRetryInterval(attempt);
              TIMER_THRESHOLD = this.isCCFlow ? _constants2.REG_TRY_BACKUP_TIMER_VAL_FOR_CC_IN_SEC : _constants2.REG_TRY_BACKUP_TIMER_VAL_IN_SEC;
              if (timeElapsed + interval > TIMER_THRESHOLD) {
                excessVal = timeElapsed + interval - TIMER_THRESHOLD;
                interval -= excessVal;
              }
              if (this.retryAfter != null && interval < this.retryAfter) {
                this.failoverImmediately = this.retryAfter + timeElapsed > TIMER_THRESHOLD;
              }
              if (!(interval > _constants2.BASE_REG_RETRY_TIMER_VAL_IN_SEC && !this.failoverImmediately)) {
                _context10.next = 14;
                break;
              }
              scheduledTime = Math.floor((0, _now.default)() / 1000);
              if (this.retryAfter != null) {
                interval = Math.max(interval, this.retryAfter);
              }
              setTimeout( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
                return _regenerator.default.wrap(function _callee7$(_context7) {
                  while (1) switch (_context7.prev = _context7.next) {
                    case 0:
                      _context7.next = 2;
                      return _this.mutex.runExclusive( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
                        var currentTime;
                        return _regenerator.default.wrap(function _callee6$(_context6) {
                          while (1) switch (_context6.prev = _context6.next) {
                            case 0:
                              _context6.next = 2;
                              return _this.attemptRegistrationWithServers(_constants2.FAILOVER_UTIL);
                            case 2:
                              abort = _context6.sent;
                              currentTime = Math.floor((0, _now.default)() / 1000);
                              if (!(!abort && !_this.isDeviceRegistered())) {
                                _context6.next = 7;
                                break;
                              }
                              _context6.next = 7;
                              return _this.startFailoverTimer(attempt + 1, timeElapsed + (currentTime - scheduledTime));
                            case 7:
                            case "end":
                              return _context6.stop();
                          }
                        }, _callee6);
                      })));
                    case 2:
                    case "end":
                      return _context7.stop();
                  }
                }, _callee7);
              })), interval * _constants2.SEC_TO_MSEC_MFACTOR);
              _Logger.default.log("Scheduled retry with primary in ".concat(interval, " seconds, number of attempts : ").concat(attempt), loggerContext);
              _context10.next = 26;
              break;
            case 14:
              if (!this.backupMobiusUris.length) {
                _context10.next = 23;
                break;
              }
              _Logger.default.info('Failing over to backup servers.', loggerContext);
              this.failoverImmediately = false;
              _context10.next = 19;
              return this.attemptRegistrationWithServers(_constants2.FAILOVER_UTIL, this.backupMobiusUris);
            case 19:
              abort = _context10.sent;
              if (!abort && !this.isDeviceRegistered()) {
                interval = this.getRegRetryInterval();
                if (this.retryAfter != null && this.retryAfter < _constants2.RETRY_TIMER_UPPER_LIMIT) {
                  interval = interval < this.retryAfter ? this.retryAfter : interval;
                }
                setTimeout( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
                  return _regenerator.default.wrap(function _callee9$(_context9) {
                    while (1) switch (_context9.prev = _context9.next) {
                      case 0:
                        _context9.next = 2;
                        return _this.mutex.runExclusive( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
                          return _regenerator.default.wrap(function _callee8$(_context8) {
                            while (1) switch (_context8.prev = _context8.next) {
                              case 0:
                                _context8.next = 2;
                                return _this.attemptRegistrationWithServers(_constants2.FAILOVER_UTIL, _this.backupMobiusUris);
                              case 2:
                                abort = _context8.sent;
                                if (!(!abort && !_this.isDeviceRegistered())) {
                                  _context8.next = 7;
                                  break;
                                }
                                _context8.next = 6;
                                return (0, _common.uploadLogs)();
                              case 6:
                                (0, _common.emitFinalFailure)(function (clientError) {
                                  _this.lineEmitter(_types3.LINE_EVENTS.ERROR, undefined, clientError);
                                }, loggerContext);
                              case 7:
                              case "end":
                                return _context8.stop();
                            }
                          }, _callee8);
                        })));
                      case 2:
                      case "end":
                        return _context9.stop();
                    }
                  }, _callee9);
                })), interval * _constants2.SEC_TO_MSEC_MFACTOR);
                _Logger.default.log("Scheduled retry with backup servers in ".concat(interval, " seconds."), loggerContext);
              }
              _context10.next = 26;
              break;
            case 23:
              _context10.next = 25;
              return (0, _common.uploadLogs)();
            case 25:
              (0, _common.emitFinalFailure)(function (clientError) {
                _this.lineEmitter(_types3.LINE_EVENTS.ERROR, undefined, clientError);
              }, loggerContext);
            case 26:
            case "end":
              return _context10.stop();
          }
        }, _callee10, this);
      }));
      function startFailoverTimer() {
        return _startFailoverTimer.apply(this, arguments);
      }
      return startFailoverTimer;
    }()
    /**
     * Clears the failback timer if running.
     */
    )
  }, {
    key: "clearFailbackTimer",
    value: function clearFailbackTimer() {
      if (this.failbackTimer) {
        clearTimeout(this.failbackTimer);
        this.failbackTimer = undefined;
      }
    }

    /**
     * Returns true if device is registered with a backup mobius.
     */
  }, {
    key: "isFailbackRequired",
    value: function isFailbackRequired() {
      return this.isDeviceRegistered() && this.primaryMobiusUris.indexOf(this.activeMobiusUrl) === -1;
    }

    /**
     * Calculates and returns a random value between rehomingIntervalMin and
     * rehomingIntervalMax.
     */
  }, {
    key: "getFailbackInterval",
    value: function getFailbackInterval() {
      return Math.floor(Math.random() * (this.rehomingIntervalMax - this.rehomingIntervalMin + 1) + this.rehomingIntervalMin);
    }

    /**
     * Starts failback timer to move to primary mobius if device
     * is registered with a backup mobius.
     */
  }, {
    key: "initiateFailback",
    value: function initiateFailback() {
      if (this.isFailbackRequired()) {
        if (!this.failbackTimer) {
          this.failback429RetryAttempts = 0;
          var intervalInMinutes = this.getFailbackInterval();
          this.startFailbackTimer(intervalInMinutes * _constants2.MINUTES_TO_SEC_MFACTOR);
        }
      } else {
        this.failback429RetryAttempts = 0;
        this.clearFailbackTimer();
      }
    }

    /**
     * Starts failback timer with the interval value received.
     *
     */
  }, {
    key: "startFailbackTimer",
    value: function startFailbackTimer(intervalInSeconds) {
      var _this2 = this;
      this.failbackTimer = setTimeout( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
        return _regenerator.default.wrap(function _callee11$(_context11) {
          while (1) switch (_context11.prev = _context11.next) {
            case 0:
              return _context11.abrupt("return", _this2.executeFailback());
            case 1:
            case "end":
              return _context11.stop();
          }
        }, _callee11);
      })), intervalInSeconds * _constants2.SEC_TO_MSEC_MFACTOR);
      _Logger.default.log("Failback scheduled after ".concat(intervalInSeconds, " seconds."), {
        file: _constants2.REGISTRATION_FILE,
        method: this.startFailbackTimer.name
      });
    }

    /**
     * Core logic for the failback processing, scheduled and executed
     * at failback timer expiry.
     */
  }, {
    key: "executeFailback",
    value: (function () {
      var _executeFailback = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
        var _this3 = this;
        return _regenerator.default.wrap(function _callee13$(_context13) {
          while (1) switch (_context13.prev = _context13.next) {
            case 0:
              _context13.next = 2;
              return this.mutex.runExclusive( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
                var abort, abortNew;
                return _regenerator.default.wrap(function _callee12$(_context12) {
                  while (1) switch (_context12.prev = _context12.next) {
                    case 0:
                      if (!_this3.isFailbackRequired()) {
                        _context12.next = 28;
                        break;
                      }
                      if (!((0, _keys.default)(_this3.callManager.getActiveCalls()).length === 0)) {
                        _context12.next = 25;
                        break;
                      }
                      _Logger.default.info("Attempting failback to primary.", {
                        file: _constants2.REGISTRATION_FILE,
                        method: _this3.executeFailback.name
                      });
                      _context12.next = 5;
                      return _this3.deregister();
                    case 5:
                      _context12.next = 7;
                      return _this3.attemptRegistrationWithServers(_constants2.FAILBACK_UTIL);
                    case 7:
                      abort = _context12.sent;
                      if (!(_this3.scheduled429Retry || abort || _this3.isDeviceRegistered())) {
                        _context12.next = 10;
                        break;
                      }
                      return _context12.abrupt("return");
                    case 10:
                      _context12.next = 12;
                      return _this3.restorePreviousRegistration(_constants2.FAILBACK_UTIL);
                    case 12:
                      abortNew = _context12.sent;
                      if (!abortNew) {
                        _context12.next = 16;
                        break;
                      }
                      _this3.clearFailbackTimer();
                      return _context12.abrupt("return");
                    case 16:
                      if (_this3.isDeviceRegistered()) {
                        _context12.next = 21;
                        break;
                      }
                      _context12.next = 19;
                      return _this3.restartRegistration(_this3.executeFailback.name);
                    case 19:
                      _context12.next = 23;
                      break;
                    case 21:
                      _this3.failbackTimer = undefined;
                      _this3.initiateFailback();
                    case 23:
                      _context12.next = 28;
                      break;
                    case 25:
                      _Logger.default.info('Active calls present, deferring failback to next cycle.', {
                        file: _constants2.REGISTRATION_FILE,
                        method: _this3.executeFailback.name
                      });
                      _this3.failbackTimer = undefined;
                      _this3.initiateFailback();
                    case 28:
                    case "end":
                      return _context12.stop();
                  }
                }, _callee12);
              })));
            case 2:
            case "end":
              return _context13.stop();
          }
        }, _callee13, this);
      }));
      function executeFailback() {
        return _executeFailback.apply(this, arguments);
      }
      return executeFailback;
    }()
    /**
     * Updates rehomingIntervalMin and rehomingIntervalMax values
     * if received in registration response from a primary mobius
     * server.
     *
     */
    )
  }, {
    key: "setIntervalValues",
    value: function setIntervalValues(deviceInfo) {
      if (this.primaryMobiusUris.indexOf(this.activeMobiusUrl) !== -1) {
        this.rehomingIntervalMin = deviceInfo !== null && deviceInfo !== void 0 && deviceInfo.rehomingIntervalMin ? deviceInfo.rehomingIntervalMin : _constants2.DEFAULT_REHOMING_INTERVAL_MIN;
        this.rehomingIntervalMax = deviceInfo !== null && deviceInfo !== void 0 && deviceInfo.rehomingIntervalMax ? deviceInfo.rehomingIntervalMax : _constants2.DEFAULT_REHOMING_INTERVAL_MAX;
      }
    }

    /**
     * Retrieves information about the device as {@link IDeviceInfo}.
     *
     */
  }, {
    key: "getDeviceInfo",
    value: function getDeviceInfo() {
      return this.deviceInfo;
    }

    /**
     * Checks if the device is currently registered.
     *
     *          by checking if isRegistered state is set to
     *          ACTIVE, else false.
     */
  }, {
    key: "isDeviceRegistered",
    value: function isDeviceRegistered() {
      return this.registrationStatus === _types2.RegistrationStatus.ACTIVE;
    }
  }, {
    key: "getStatus",
    value: function getStatus() {
      return this.registrationStatus;
    }
  }, {
    key: "setStatus",
    value: function setStatus(value) {
      this.registrationStatus = value;
    }

    /**
     * Start fresh registration cycle with the mobius
     * server list already present.
     *
     */
  }, {
    key: "restartRegistration",
    value: (function () {
      var _restartRegistration = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14(caller) {
        var abort;
        return _regenerator.default.wrap(function _callee14$(_context14) {
          while (1) switch (_context14.prev = _context14.next) {
            case 0:
              /*
               * Cancel any failback timer running
               * and start fresh registration attempt with retry as true.
               */
              this.clearFailbackTimer();
              this.failback429RetryAttempts = 0;
              _context14.next = 4;
              return this.attemptRegistrationWithServers(caller, this.primaryMobiusUris);
            case 4:
              abort = _context14.sent;
              if (!(!abort && !this.isDeviceRegistered())) {
                _context14.next = 8;
                break;
              }
              _context14.next = 8;
              return this.startFailoverTimer();
            case 8:
            case "end":
              return _context14.stop();
          }
        }, _callee14, this);
      }));
      function restartRegistration(_x9) {
        return _restartRegistration.apply(this, arguments);
      }
      return restartRegistration;
    }()
    /**
     * Restores the connection and attempts refreshing existing registration with server.
     * Allows retry if not restored in the first attempt.
     *
     */
    )
  }, {
    key: "handleConnectionRestoration",
    value: (function () {
      var _handleConnectionRestoration = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16(retry) {
        var _this4 = this;
        return _regenerator.default.wrap(function _callee16$(_context16) {
          while (1) switch (_context16.prev = _context16.next) {
            case 0:
              _Logger.default.info(_constants.METHOD_START_MESSAGE, {
                method: _constants2.METHODS.HANDLE_CONNECTION_RESTORATION,
                file: _constants2.REGISTRATION_FILE
              });
              _context16.next = 3;
              return this.mutex.runExclusive( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15() {
                var abort;
                return _regenerator.default.wrap(function _callee15$(_context15) {
                  while (1) switch (_context15.prev = _context15.next) {
                    case 0:
                      if (!retry) {
                        _context15.next = 14;
                        break;
                      }
                      _Logger.default.log('Mercury connection is up again, re-registering with Webex Calling if needed', {
                        file: _constants2.REGISTRATION_FILE,
                        method: _this4.handleConnectionRestoration.name
                      });
                      _this4.clearKeepaliveTimer();
                      if (!_this4.isDeviceRegistered()) {
                        _context15.next = 6;
                        break;
                      }
                      _context15.next = 6;
                      return _this4.deregister();
                    case 6:
                      if (!_this4.activeMobiusUrl) {
                        _context15.next = 13;
                        break;
                      }
                      _context15.next = 9;
                      return _this4.restorePreviousRegistration(_this4.handleConnectionRestoration.name);
                    case 9:
                      abort = _context15.sent;
                      if (!(!abort && !_this4.isDeviceRegistered())) {
                        _context15.next = 13;
                        break;
                      }
                      _context15.next = 13;
                      return _this4.restartRegistration(_this4.handleConnectionRestoration.name);
                    case 13:
                      retry = false;
                    case 14:
                    case "end":
                      return _context15.stop();
                  }
                }, _callee15);
              })));
            case 3:
              return _context16.abrupt("return", retry);
            case 4:
            case "end":
              return _context16.stop();
          }
        }, _callee16, this);
      }));
      function handleConnectionRestoration(_x10) {
        return _handleConnectionRestoration.apply(this, arguments);
      }
      return handleConnectionRestoration;
    }()
    /**
     * Callback function for restoring registration in case of failure during initial registration
     * due to device registration already exists.
     *
     */
    )
  }, {
    key: "restoreRegistrationCallBack",
    value: function restoreRegistrationCallBack() {
      var _this5 = this;
      return /*#__PURE__*/function () {
        var _ref8 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17(restoreData, caller) {
          var logContext, restore, finalError;
          return _regenerator.default.wrap(function _callee17$(_context17) {
            while (1) switch (_context17.prev = _context17.next) {
              case 0:
                logContext = {
                  file: _constants2.REGISTRATION_FILE,
                  method: caller
                };
                if (_this5.isRegRetry()) {
                  _context17.next = 17;
                  break;
                }
                _Logger.default.info('Registration restoration in progress.', logContext);
                restore = _this5.getExistingDevice(restoreData);
                if (!restore) {
                  _context17.next = 14;
                  break;
                }
                _this5.setRegRetry(true);
                _context17.next = 8;
                return _this5.deregister();
              case 8:
                _context17.next = 10;
                return _this5.restorePreviousRegistration(caller);
              case 10:
                finalError = _context17.sent;
                _this5.setRegRetry(false);
                if (_this5.isDeviceRegistered()) {
                  _Logger.default.info('Registration restored successfully.', logContext);
                }
                return _context17.abrupt("return", finalError);
              case 14:
                _this5.lineEmitter(_types3.LINE_EVENTS.UNREGISTERED);
                _context17.next = 18;
                break;
              case 17:
                _this5.lineEmitter(_types3.LINE_EVENTS.UNREGISTERED);
              case 18:
                return _context17.abrupt("return", false);
              case 19:
              case "end":
                return _context17.stop();
            }
          }, _callee17);
        }));
        return function (_x11, _x12) {
          return _ref8.apply(this, arguments);
        };
      }();
    }

    /**
     * Triggers the registration with the given list of Mobius servers
     * Registration is attempted with primary and backup until it succeeds or the list is exhausted
     */
  }, {
    key: "triggerRegistration",
    value: (function () {
      var _triggerRegistration = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18() {
        var abort;
        return _regenerator.default.wrap(function _callee18$(_context18) {
          while (1) switch (_context18.prev = _context18.next) {
            case 0:
              if (!(this.primaryMobiusUris.length > 0)) {
                _context18.next = 7;
                break;
              }
              _context18.next = 3;
              return this.attemptRegistrationWithServers(this.triggerRegistration.name, this.primaryMobiusUris);
            case 3:
              abort = _context18.sent;
              if (!(!this.isDeviceRegistered() && !abort)) {
                _context18.next = 7;
                break;
              }
              _context18.next = 7;
              return this.startFailoverTimer();
            case 7:
            case "end":
              return _context18.stop();
          }
        }, _callee18, this);
      }));
      function triggerRegistration() {
        return _triggerRegistration.apply(this, arguments);
      }
      return triggerRegistration;
    }()
    /**
     * Attempts registration with the server list received in
     * argument one by one until registration either succeeds with
     * one or all of them are tried.
     *
     *          attempt has hit a final error and a retry should not be scheduled
     *          else false.
     */
    )
  }, {
    key: "attemptRegistrationWithServers",
    value: (function () {
      var _attemptRegistrationWithServers = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee19(caller) {
        var _this6 = this;
        var servers,
          abort,
          _iterator,
          _step,
          url,
          _this$deviceInfo$devi,
          _this$deviceInfo$devi2,
          resp,
          body,
          _args19 = arguments;
        return _regenerator.default.wrap(function _callee19$(_context19) {
          while (1) switch (_context19.prev = _context19.next) {
            case 0:
              servers = _args19.length > 1 && _args19[1] !== undefined ? _args19[1] : this.primaryMobiusUris;
              abort = false;
              this.retryAfter = undefined;
              if (!this.failoverImmediately) {
                _context19.next = 5;
                break;
              }
              return _context19.abrupt("return", abort);
            case 5:
              if (!this.isDeviceRegistered()) {
                _context19.next = 8;
                break;
              }
              _Logger.default.info("[".concat(caller, "] : Device already registered with : ").concat(this.activeMobiusUrl), {
                file: _constants2.REGISTRATION_FILE,
                method: _constants2.REGISTER_UTIL
              });
              return _context19.abrupt("return", abort);
            case 8:
              _iterator = _createForOfIteratorHelper(servers);
              _context19.prev = 9;
              _iterator.s();
            case 11:
              if ((_step = _iterator.n()).done) {
                _context19.next = 48;
                break;
              }
              url = _step.value;
              _context19.prev = 13;
              abort = false;
              this.registrationStatus = _types2.RegistrationStatus.INACTIVE;
              this.lineEmitter(_types3.LINE_EVENTS.CONNECTING);
              _Logger.default.info("[".concat(caller, "] : Mobius url to contact: ").concat(url), {
                file: _constants2.REGISTRATION_FILE,
                method: _constants2.REGISTER_UTIL
              });
              // eslint-disable-next-line no-await-in-loop
              _context19.next = 20;
              return this.postRegistration(url);
            case 20:
              resp = _context19.sent;
              this.deviceInfo = resp.body;
              this.registrationStatus = _types2.RegistrationStatus.ACTIVE;
              this.lineEmitter(_types3.LINE_EVENTS.REGISTERED, resp.body);
              _Logger.default.log("Registration successful for deviceId: ".concat((_this$deviceInfo$devi = this.deviceInfo.device) === null || _this$deviceInfo$devi === void 0 ? void 0 : _this$deviceInfo$devi.deviceId, " userId: ").concat(this.userId), {
                file: _constants2.REGISTRATION_FILE,
                method: _constants2.METHODS.REGISTER
              });
              this.setActiveMobiusUrl(url);
              this.setIntervalValues(this.deviceInfo);
              this.metricManager.setDeviceInfo(this.deviceInfo);
              this.metricManager.submitRegistrationMetric(_types.METRIC_EVENT.REGISTRATION, _types.REG_ACTION.REGISTER, _types.METRIC_TYPE.BEHAVIORAL, undefined);
              this.startKeepaliveTimer((_this$deviceInfo$devi2 = this.deviceInfo.device) === null || _this$deviceInfo$devi2 === void 0 ? void 0 : _this$deviceInfo$devi2.uri, this.deviceInfo.keepaliveInterval);
              this.initiateFailback();
              return _context19.abrupt("break", 48);
            case 34:
              _context19.prev = 34;
              _context19.t0 = _context19["catch"](13);
              body = _context19.t0; // eslint-disable-next-line no-await-in-loop, @typescript-eslint/no-unused-vars
              _context19.next = 39;
              return (0, _common.handleRegistrationErrors)(body, function (clientError, finalError) {
                if (finalError) {
                  _this6.lineEmitter(_types3.LINE_EVENTS.ERROR, undefined, clientError);
                } else {
                  _this6.lineEmitter(_types3.LINE_EVENTS.UNREGISTERED);
                }
                _this6.metricManager.submitRegistrationMetric(_types.METRIC_EVENT.REGISTRATION_ERROR, _types.REG_ACTION.REGISTER, _types.METRIC_TYPE.BEHAVIORAL, clientError);
              }, {
                method: caller,
                file: _constants2.REGISTRATION_FILE
              }, function (retryAfter, retryCaller) {
                return _this6.handle429Retry(retryAfter, retryCaller);
              }, this.restoreRegistrationCallBack());
            case 39:
              abort = _context19.sent;
              if (!(this.registrationStatus === _types2.RegistrationStatus.ACTIVE)) {
                _context19.next = 43;
                break;
              }
              _Logger.default.info("[".concat(caller, "] : Device is already restored, active mobius url: ").concat(this.activeMobiusUrl), {
                file: _constants2.REGISTRATION_FILE,
                method: this.attemptRegistrationWithServers.name
              });
              return _context19.abrupt("break", 48);
            case 43:
              if (!abort) {
                _context19.next = 46;
                break;
              }
              this.setStatus(_types2.RegistrationStatus.INACTIVE);
              return _context19.abrupt("break", 48);
            case 46:
              _context19.next = 11;
              break;
            case 48:
              _context19.next = 53;
              break;
            case 50:
              _context19.prev = 50;
              _context19.t1 = _context19["catch"](9);
              _iterator.e(_context19.t1);
            case 53:
              _context19.prev = 53;
              _iterator.f();
              return _context19.finish(53);
            case 56:
              return _context19.abrupt("return", abort);
            case 57:
            case "end":
              return _context19.stop();
          }
        }, _callee19, this, [[9, 50, 53, 56], [13, 34]]);
      }));
      function attemptRegistrationWithServers(_x13) {
        return _attemptRegistrationWithServers.apply(this, arguments);
      }
      return attemptRegistrationWithServers;
    }()
    /**
     * This method sets up a timer to periodically send keep-alive requests to maintain a connection.
     * It handles retries, error handling, and re-registration attempts based on the response, ensuring continuous connectivity with the server.
     */
    )
  }, {
    key: "startKeepaliveTimer",
    value: function startKeepaliveTimer(url, interval) {
      var _this7 = this;
      var keepAliveRetryCount = 0;
      this.clearKeepaliveTimer();
      var RETRY_COUNT_THRESHOLD = this.isCCFlow ? 4 : 5;
      this.keepaliveTimer = setInterval( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee21() {
        var logContext;
        return _regenerator.default.wrap(function _callee21$(_context21) {
          while (1) switch (_context21.prev = _context21.next) {
            case 0:
              logContext = {
                file: _constants2.REGISTRATION_FILE,
                method: _this7.startKeepaliveTimer.name
              };
              _context21.next = 3;
              return _this7.mutex.runExclusive( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee20() {
                var res, error, abort;
                return _regenerator.default.wrap(function _callee20$(_context20) {
                  while (1) switch (_context20.prev = _context20.next) {
                    case 0:
                      if (!(_this7.isDeviceRegistered() && keepAliveRetryCount < RETRY_COUNT_THRESHOLD)) {
                        _context20.next = 30;
                        break;
                      }
                      _context20.prev = 1;
                      _context20.next = 4;
                      return _this7.postKeepAlive(url);
                    case 4:
                      res = _context20.sent;
                      _Logger.default.log("Sent Keepalive, status: ".concat(res.statusCode), logContext);
                      if (keepAliveRetryCount > 0) {
                        _this7.lineEmitter(_types3.LINE_EVENTS.RECONNECTED);
                      }
                      keepAliveRetryCount = 0;
                      _context20.next = 30;
                      break;
                    case 10:
                      _context20.prev = 10;
                      _context20.t0 = _context20["catch"](1);
                      keepAliveRetryCount += 1;
                      error = _context20.t0;
                      _Logger.default.warn("Keep-alive missed ".concat(keepAliveRetryCount, " times. Status -> ").concat(error.statusCode, " "), logContext);
                      _context20.next = 17;
                      return (0, _common.handleRegistrationErrors)(error, function (clientError, finalError) {
                        if (finalError) {
                          _this7.lineEmitter(_types3.LINE_EVENTS.ERROR, undefined, clientError);
                        }
                        _this7.metricManager.submitRegistrationMetric(_types.METRIC_EVENT.REGISTRATION, _types.REG_ACTION.KEEPALIVE_FAILURE, _types.METRIC_TYPE.BEHAVIORAL, clientError);
                      }, {
                        method: _this7.startKeepaliveTimer.name,
                        file: _constants2.REGISTRATION_FILE
                      });
                    case 17:
                      abort = _context20.sent;
                      if (!(abort || keepAliveRetryCount >= RETRY_COUNT_THRESHOLD)) {
                        _context20.next = 29;
                        break;
                      }
                      _this7.failoverImmediately = _this7.isCCFlow;
                      _this7.setStatus(_types2.RegistrationStatus.INACTIVE);
                      _this7.clearKeepaliveTimer();
                      _this7.clearFailbackTimer();
                      _this7.lineEmitter(_types3.LINE_EVENTS.UNREGISTERED);
                      if (abort) {
                        _context20.next = 27;
                        break;
                      }
                      _context20.next = 27;
                      return _this7.reconnectOnFailure(_this7.startKeepaliveTimer.name);
                    case 27:
                      _context20.next = 30;
                      break;
                    case 29:
                      _this7.lineEmitter(_types3.LINE_EVENTS.RECONNECTING);
                    case 30:
                    case "end":
                      return _context20.stop();
                  }
                }, _callee20, null, [[1, 10]]);
              })));
            case 3:
            case "end":
              return _context21.stop();
          }
        }, _callee21);
      })), interval * 1000);
    }

    /**
     * Clears the keepalive timer if running.
     */
  }, {
    key: "clearKeepaliveTimer",
    value: function clearKeepaliveTimer() {
      if (this.keepaliveTimer) {
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = undefined;
      }
    }
  }, {
    key: "isReconnectPending",
    value: function isReconnectPending() {
      return this.reconnectPending;
    }
  }, {
    key: "deregister",
    value: function () {
      var _deregister = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee22() {
        var _this$deviceInfo$devi3, _this$deviceInfo$devi4;
        return _regenerator.default.wrap(function _callee22$(_context22) {
          while (1) switch (_context22.prev = _context22.next) {
            case 0:
              _context22.prev = 0;
              _context22.next = 3;
              return this.deleteRegistration(this.activeMobiusUrl, (_this$deviceInfo$devi3 = this.deviceInfo.device) === null || _this$deviceInfo$devi3 === void 0 ? void 0 : _this$deviceInfo$devi3.deviceId, (_this$deviceInfo$devi4 = this.deviceInfo.device) === null || _this$deviceInfo$devi4 === void 0 ? void 0 : _this$deviceInfo$devi4.clientDeviceUri);
            case 3:
              _Logger.default.log('Registration successfully deregistered', {
                file: _constants2.REGISTRATION_FILE,
                method: _constants2.METHODS.DEREGISTER
              });
              _context22.next = 9;
              break;
            case 6:
              _context22.prev = 6;
              _context22.t0 = _context22["catch"](0);
              _Logger.default.warn("Delete failed with Mobius: ".concat(_context22.t0), {
                file: _constants2.REGISTRATION_FILE,
                method: _constants2.METHODS.DEREGISTER
              });
            case 9:
              this.clearKeepaliveTimer();
              this.setStatus(_types2.RegistrationStatus.INACTIVE);
            case 11:
            case "end":
              return _context22.stop();
          }
        }, _callee22, this, [[0, 6]]);
      }));
      function deregister() {
        return _deregister.apply(this, arguments);
      }
      return deregister;
    }()
    /**
     *          Indicates whether the calling client is in a mode
     *          to retry registration.
     */
  }, {
    key: "isRegRetry",
    value: function isRegRetry() {
      return this.registerRetry;
    }

    /**
     * Sets the received value in instance variable
     * registerRetry for registration retry cases.
     *
     */
  }, {
    key: "setRegRetry",
    value: function setRegRetry(value) {
      this.registerRetry = value;
    }

    /**
     * Restores the deviceInfo object in callingClient when receiving a 403 with error code 101.
     *
     */
  }, {
    key: "getExistingDevice",
    value: function getExistingDevice(restoreData) {
      if (restoreData.devices && restoreData.devices.length > 0) {
        this.deviceInfo = {
          userId: restoreData.userId,
          device: restoreData.devices[0],
          keepaliveInterval: _constants2.DEFAULT_KEEPALIVE_INTERVAL,
          rehomingIntervalMax: _constants2.DEFAULT_REHOMING_INTERVAL_MAX,
          rehomingIntervalMin: _constants2.DEFAULT_REHOMING_INTERVAL_MIN
        };
        var stringToReplace = "".concat(_constants2.DEVICES_ENDPOINT_RESOURCE, "/").concat(restoreData.devices[0].deviceId);
        var uri = restoreData.devices[0].uri.replace(stringToReplace, '');
        this.setActiveMobiusUrl(uri);
        this.registrationStatus = _types2.RegistrationStatus.ACTIVE;
        return true;
      }
      return false;
    }

    /**
     * Invoked to re-register in cases when the registration
     * is lost due to some failure.
     * If there are active calls, it will only mark reconnectPending
     * as true and then retry will happen when this method gets
     * invoked again on receiving all calls cleared event from
     * callManager.
     *
     */
  }, {
    key: "reconnectOnFailure",
    value: (function () {
      var _reconnectOnFailure = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee23(caller) {
        var abort;
        return _regenerator.default.wrap(function _callee23$(_context23) {
          while (1) switch (_context23.prev = _context23.next) {
            case 0:
              _Logger.default.info(_constants.METHOD_START_MESSAGE, {
                method: _constants2.METHODS.RECONNECT_ON_FAILURE,
                file: _constants2.REGISTRATION_FILE
              });
              this.reconnectPending = false;
              if (this.isDeviceRegistered()) {
                _context23.next = 14;
                break;
              }
              if (!((0, _keys.default)(this.callManager.getActiveCalls()).length === 0)) {
                _context23.next = 12;
                break;
              }
              _context23.next = 6;
              return this.restorePreviousRegistration(caller);
            case 6:
              abort = _context23.sent;
              if (!(!abort && !this.isDeviceRegistered())) {
                _context23.next = 10;
                break;
              }
              _context23.next = 10;
              return this.restartRegistration(caller);
            case 10:
              _context23.next = 14;
              break;
            case 12:
              this.reconnectPending = true;
              _Logger.default.info('Active call(s) present, deferred reconnect till call cleanup.', {
                file: _constants2.REGISTRATION_FILE,
                method: _constants2.METHODS.RECONNECT_ON_FAILURE
              });
            case 14:
            case "end":
              return _context23.stop();
          }
        }, _callee23, this);
      }));
      function reconnectOnFailure(_x14) {
        return _reconnectOnFailure.apply(this, arguments);
      }
      return reconnectOnFailure;
    }())
  }]);
  return Registration;
}();
/*
 */
var createRegistration = exports.createRegistration = function createRegistration(webex, serviceData, mutex, lineEmitter, logLevel, jwe) {
  return new Registration(webex, serviceData, mutex, lineEmitter, logLevel, jwe);
};
//# sourceMappingURL=register.js.map
