"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));
var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));
var _asyncMutex = require("async-mutex");
var _register = require("./register");
var _testUtil = require("../../common/testUtil");
var _types = require("../../common/types");
var utils = _interopRequireWildcard(require("../../common/Utils"));
var _Logger = _interopRequireDefault(require("../../Logger"));
var _types2 = require("../../Logger/types");
var _registerFixtures = require("./registerFixtures");
var _common = require("../../common");
var _types3 = require("../../Errors/types");
var _constants = require("../constants");
var _types4 = require("../line/types");
var _LineError = require("../../Errors/catalog/LineError");
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = _Object$keys2(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; } /* eslint-disable @typescript-eslint/no-shadow */
var webex = (0, _testUtil.getTestUtilsWebex)();
var MockServiceData = {
  indicator: _types.ServiceIndicator.CALLING,
  domain: ''
};
var logSpy = jest.spyOn(_Logger.default, 'log');
var infoSpy = jest.spyOn(_Logger.default, 'info');
var warnSpy = jest.spyOn(_Logger.default, 'warn');
var handleErrorSpy = jest.spyOn(utils, 'handleRegistrationErrors');
jest.spyOn(utils, 'uploadLogs').mockResolvedValue();
describe('Registration Tests', function () {
  var originalProcessNextTick = process.nextTick;
  function flushPromises() {
    return new _promise.default(function (resolve) {
      originalProcessNextTick(resolve);
    });
  }
  var lineEmitter = jest.fn();
  var mobiusUris = (0, _common.filterMobiusUris)((0, _testUtil.getMobiusDiscoveryResponse)(), _registerFixtures.URL);
  var mockResponse = _objectSpread(_objectSpread({}, (0, _testUtil.getMockRequestTemplate)()), {}, {
    uri: "".concat(mobiusUris.primary[0], "device"),
    body: {
      userId: webex.internal.device.userId,
      clientDeviceUri: webex.internal.device.url,
      serviceData: {
        domain: '',
        indicator: 'calling'
      }
    }
  });
  var ccMockResponse = _objectSpread(_objectSpread({}, mockResponse), {}, {
    body: _objectSpread(_objectSpread({}, mockResponse.body), {}, {
      serviceData: {
        domain: '',
        indicator: 'contactcenter'
      }
    })
  });
  var failurePayload = {
    statusCode: 500,
    body: _registerFixtures.mockPostResponse
  };
  var failurePayload429One = {
    statusCode: 429,
    body: _registerFixtures.mockPostResponse,
    headers: {
      'retry-after': 42
    }
  };
  var failurePayload429Two = {
    statusCode: 429,
    body: _registerFixtures.mockPostResponse,
    headers: {
      'retry-after': 33
    }
  };
  var failurePayload429Three = {
    statusCode: 429,
    body: _registerFixtures.mockPostResponse,
    headers: {
      'retry-after': 136
    }
  };
  var failurePayload429Four = {
    statusCode: 429,
    body: _registerFixtures.mockPostResponse,
    headers: {
      'retry-after': 81
    }
  };
  var successPayload = {
    statusCode: 200,
    body: _registerFixtures.mockPostResponse
  };
  var reg;
  var restartSpy;
  var restoreSpy;
  var postRegistrationSpy;
  var failoverSpy;
  var retry429Spy;
  var setupRegistration = function setupRegistration(mockServiceData) {
    var mutex = new _asyncMutex.Mutex();
    reg = (0, _register.createRegistration)(webex, mockServiceData, mutex, lineEmitter, _types2.LOGGER.INFO);
    reg.setMobiusServers(mobiusUris.primary, mobiusUris.backup);
    jest.clearAllMocks();
    restartSpy = jest.spyOn(reg, 'restartRegistration');
    restoreSpy = jest.spyOn(reg, 'restorePreviousRegistration');
    postRegistrationSpy = jest.spyOn(reg, 'postRegistration');
    failoverSpy = jest.spyOn(reg, 'startFailoverTimer');
    retry429Spy = jest.spyOn(reg, 'handle429Retry');
  };
  beforeEach(function () {
    setupRegistration(MockServiceData);
  });
  afterEach(function () {
    webex.request = jest.fn();
    jest.clearAllTimers();
    jest.clearAllMocks();
    jest.useRealTimers();
  });
  it('verify successful registration', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          webex.request.mockReturnValueOnce({
            body: _registerFixtures.mockPostResponse
          });
          _context.next = 3;
          return reg.triggerRegistration();
        case 3:
          expect(webex.request).toBeCalledOnceWith(_objectSpread(_objectSpread({}, mockResponse), {}, {
            method: 'POST'
          }));
          expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
          expect(lineEmitter).toBeCalledTimes(2);
          expect(lineEmitter).toBeCalledWith(_types4.LINE_EVENTS.CONNECTING);
          expect(lineEmitter).toBeCalledWith(_types4.LINE_EVENTS.REGISTERED, _registerFixtures.mockPostResponse);

          // Check that log.log was called for successful registration
          expect(logSpy).toBeCalledWith("Registration successful for deviceId: ".concat(_registerFixtures.mockPostResponse.device.deviceId, " userId: ").concat(_registerFixtures.mockPostResponse.userId), expect.objectContaining({
            file: _constants.REGISTRATION_FILE,
            method: expect.any(String)
          }));
        case 9:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })));
  it('verify failure registration', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
    var error;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          webex.request.mockRejectedValue({
            body: _registerFixtures.mockPostResponse,
            statusCode: 401
          });
          _context2.next = 3;
          return reg.triggerRegistration();
        case 3:
          expect(webex.request).toBeCalledOnceWith(_objectSpread(_objectSpread({}, mockResponse), {}, {
            method: 'POST'
          }));
          error = (0, _LineError.createLineError)('User is unauthorized due to an expired token. Sign out, then sign back in.', {}, _types3.ERROR_TYPE.TOKEN_ERROR, _types.RegistrationStatus.INACTIVE);
          expect(reg.getStatus()).toEqual(_types.RegistrationStatus.INACTIVE);
          expect(lineEmitter).toBeCalledTimes(2);
          expect(lineEmitter).nthCalledWith(1, _types4.LINE_EVENTS.CONNECTING);
          expect(lineEmitter).nthCalledWith(2, _types4.LINE_EVENTS.ERROR, undefined, error);
        case 9:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  })));
  it('verify failure registration 403-101', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          webex.request.mockRejectedValueOnce({
            body: {
              userId: _registerFixtures.mockPostResponse.userId,
              errorCode: 101,
              devices: [_registerFixtures.mockPostResponse.device]
            },
            statusCode: 403
          }).mockResolvedValueOnce({
            statusCode: 200,
            body: _registerFixtures.mockPostResponse
          });
          global.fetch = jest.fn(function () {
            return _promise.default.resolve({
              json: function json() {
                return _registerFixtures.mockDeleteResponse;
              }
            });
          });
          expect(reg.getStatus()).toEqual(_types.RegistrationStatus.IDLE);
          _context3.next = 5;
          return reg.triggerRegistration();
        case 5:
          expect(webex.request).toBeCalledTimes(2);
          expect(webex.request).toBeCalledWith(_objectSpread(_objectSpread({}, mockResponse), {}, {
            method: 'POST'
          }));
          expect(global.fetch).toBeCalledOnceWith(_registerFixtures.mockPostResponse.device.uri, {
            method: 'DELETE',
            headers: expect.anything()
          });
          expect(warnSpy).toBeCalledWith('User device limit exceeded', expect.anything());
          expect(infoSpy).toBeCalledWith('Registration restoration in progress.', expect.anything());
          expect(infoSpy).toBeCalledWith('Registration restored successfully.', expect.anything());
          expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
          expect(lineEmitter).toBeCalledTimes(4);
          expect(lineEmitter).nthCalledWith(1, _types4.LINE_EVENTS.CONNECTING);
          expect(lineEmitter).nthCalledWith(2, _types4.LINE_EVENTS.UNREGISTERED);
          expect(lineEmitter).nthCalledWith(3, _types4.LINE_EVENTS.CONNECTING);
          expect(lineEmitter).nthCalledWith(4, _types4.LINE_EVENTS.REGISTERED, _registerFixtures.mockPostResponse);
        case 17:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  })));
  describe('429 handling tests', function () {
    var loggerContext = {
      file: _constants.REGISTRATION_FILE,
      method: _constants.FAILOVER_UTIL
    };
    var logSpy = jest.spyOn(_Logger.default, 'log');
    beforeEach(function () {
      mobiusUris.backup.pop();
    });
    afterEach(function () {
      mobiusUris.backup.push(_registerFixtures.URL);
      jest.clearAllMocks();
    });
    it('handle 429 received during initial registration failure and first attempt with primary', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
      return _regenerator.default.wrap(function _callee4$(_context4) {
        while (1) switch (_context4.prev = _context4.next) {
          case 0:
            jest.useFakeTimers();
            logSpy.mockClear();
            webex.request.mockRejectedValueOnce(failurePayload429One).mockRejectedValueOnce(failurePayload429Two).mockRejectedValueOnce(failurePayload);
            _context4.next = 5;
            return reg.triggerRegistration();
          case 5:
            /* Initial registration failed with 429 with higher retyrAfter, interval should be updtaed with retryAfter.
             * The first attempt to register with primary should be made after retryAfter seconds.
             */

            expect(webex.request).toHaveBeenNthCalledWith(1, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.INACTIVE);
            expect(retry429Spy).toBeCalledOnceWith(failurePayload429One.headers['retry-after'], 'triggerRegistration');
            expect(reg.retryAfter).toEqual(failurePayload429One.headers['retry-after']);
            expect(failoverSpy).toBeCalledOnceWith();
            expect(logSpy).toBeCalledWith("Scheduled retry with primary in ".concat(failurePayload429One.headers['retry-after'], " seconds, number of attempts : 1"), loggerContext);
            retry429Spy.mockClear();
            failoverSpy.mockClear();
            jest.advanceTimersByTime(Number(failurePayload429One.headers['retry-after']) * _constants.SEC_TO_MSEC_MFACTOR);
            _context4.next = 16;
            return flushPromises();
          case 16:
            /* The first attempt to register with primary failed with 429 with lower retryAfter, interval should remain the same.
             * The second attempt to register with primary will be scheduled as per the interval calculated.
             */

            expect(webex.request).toHaveBeenNthCalledWith(2, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(retry429Spy).toBeCalledOnceWith(failurePayload429Two.headers['retry-after'], 'startFailoverTimer');
            expect(reg.retryAfter).toEqual(failurePayload429Two.headers['retry-after']);
            expect(failoverSpy).toBeCalledOnceWith(2, failurePayload429One.headers['retry-after']);
            retry429Spy.mockClear();
            failoverSpy.mockClear();
            jest.advanceTimersByTime(43 * _constants.SEC_TO_MSEC_MFACTOR);
            _context4.next = 25;
            return flushPromises();
          case 25:
            /* The second attempt to register with primary failed with 500, the retryAfter should be undefined.
             * The third attempt to register with primary will be scheduled as per the interval calculated.
             */
            expect(webex.request).toHaveBeenNthCalledWith(3, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(retry429Spy).not.toBeCalled();
            expect(reg.retryAfter).toEqual(undefined);
            expect(failoverSpy).toBeCalledOnceWith(3, 85);
          case 29:
          case "end":
            return _context4.stop();
        }
      }, _callee4);
    })));
    it('handle 429 received with higher retryAfter than the interval when interval with elapsedTime is already reaching threshold timer so we failover immediately', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
      return _regenerator.default.wrap(function _callee5$(_context5) {
        while (1) switch (_context5.prev = _context5.next) {
          case 0:
            reg.isCCFlow = true;
            jest.spyOn(reg, 'getRegRetryInterval').mockReturnValueOnce(33).mockReturnValueOnce(40).mockReturnValueOnce(47).mockReturnValueOnce(52);
            jest.useFakeTimers();
            webex.request.mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload429One).mockResolvedValueOnce(successPayload);
            _context5.next = 6;
            return reg.triggerRegistration();
          case 6:
            expect(webex.request).toHaveBeenNthCalledWith(1, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.INACTIVE);
            expect(retry429Spy).not.toBeCalled();
            expect(failoverSpy).toBeCalledOnceWith();
            expect(logSpy).toBeCalledWith("Scheduled retry with primary in 33 seconds, number of attempts : 1", loggerContext);
            failoverSpy.mockClear();
            jest.advanceTimersByTime(33 * _constants.SEC_TO_MSEC_MFACTOR);
            _context5.next = 15;
            return flushPromises();
          case 15:
            expect(webex.request).toHaveBeenNthCalledWith(2, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(retry429Spy).not.toBeCalled();
            expect(failoverSpy).toBeCalledOnceWith(2, 33);
            expect(logSpy).toBeCalledWith("Scheduled retry with primary in 40 seconds, number of attempts : 2", loggerContext);
            logSpy.mockClear();
            failoverSpy.mockClear();
            jest.advanceTimersByTime(40 * _constants.SEC_TO_MSEC_MFACTOR);
            _context5.next = 24;
            return flushPromises();
          case 24:
            expect(webex.request).toHaveBeenNthCalledWith(3, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(retry429Spy).toBeCalledOnceWith(failurePayload429One.headers['retry-after'], 'startFailoverTimer');
            expect(failoverSpy).toBeCalledOnceWith(3, 73);
            expect(logSpy).not.toBeCalledWith("Scheduled retry with primary in ".concat(failurePayload429One.headers['retry-after'], " seconds, number of attempts : 3"), loggerContext);
            expect(infoSpy).toBeCalledWith("Failing over to backup servers.", loggerContext);
            expect(webex.request).toHaveBeenNthCalledWith(4, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.backup[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
          case 31:
          case "end":
            return _context5.stop();
        }
      }, _callee5);
    })));
    it('handle 429 received while the last attempt for primary', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
      return _regenerator.default.wrap(function _callee6$(_context6) {
        while (1) switch (_context6.prev = _context6.next) {
          case 0:
            reg.isCCFlow = true;
            jest.spyOn(reg, 'getRegRetryInterval').mockReturnValueOnce(33).mockReturnValueOnce(40).mockReturnValueOnce(47).mockReturnValueOnce(52);
            jest.useFakeTimers();
            webex.request.mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload429One).mockResolvedValueOnce(successPayload);
            _context6.next = 6;
            return reg.triggerRegistration();
          case 6:
            /* Initial registration and first 2 attempts with primary failed with non-final 5xx error responses.
             * Last attempt with primary failed with 429, the retryAfter should be used to schedule the next attempt but
             * the failover is triggered before the scheduling logic kicks in.
             */
            expect(webex.request).toHaveBeenNthCalledWith(1, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.INACTIVE);
            expect(retry429Spy).not.toBeCalled();
            expect(failoverSpy).toBeCalledOnceWith();
            expect(logSpy).toBeCalledWith("Scheduled retry with primary in 33 seconds, number of attempts : 1", loggerContext);
            failoverSpy.mockClear();
            jest.advanceTimersByTime(33 * _constants.SEC_TO_MSEC_MFACTOR);
            _context6.next = 15;
            return flushPromises();
          case 15:
            expect(webex.request).toHaveBeenNthCalledWith(2, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(retry429Spy).not.toBeCalled();
            expect(failoverSpy).toBeCalledOnceWith(2, 33);
            expect(logSpy).toBeCalledWith("Scheduled retry with primary in 40 seconds, number of attempts : 2", loggerContext);
            logSpy.mockClear();
            failoverSpy.mockClear();
            jest.advanceTimersByTime(40 * _constants.SEC_TO_MSEC_MFACTOR);
            _context6.next = 24;
            return flushPromises();
          case 24:
            expect(webex.request).toHaveBeenNthCalledWith(3, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(retry429Spy).not.toBeCalled();
            expect(failoverSpy).toBeCalledOnceWith(3, 73);
            expect(logSpy).toBeCalledWith("Scheduled retry with primary in 41 seconds, number of attempts : 3", loggerContext);
            failoverSpy.mockClear();
            jest.advanceTimersByTime(41 * _constants.SEC_TO_MSEC_MFACTOR);
            _context6.next = 32;
            return flushPromises();
          case 32:
            expect(webex.request).toHaveBeenNthCalledWith(4, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(retry429Spy).toBeCalledOnceWith(failurePayload429One.headers['retry-after'], 'startFailoverTimer');
            expect(failoverSpy).toBeCalledOnceWith(4, 114);
            expect(infoSpy).toBeCalledWith("Failing over to backup servers.", loggerContext);
            expect(webex.request).toHaveBeenNthCalledWith(5, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.backup[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
          case 38:
          case "end":
            return _context6.stop();
        }
      }, _callee6);
    })));
    it('handle 429 received while failing over to backup server for CC flow', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
      return _regenerator.default.wrap(function _callee7$(_context7) {
        while (1) switch (_context7.prev = _context7.next) {
          case 0:
            reg.isCCFlow = true;
            jest.useFakeTimers();
            webex.request.mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload429One).mockResolvedValueOnce(successPayload);
            _context7.next = 5;
            return reg.triggerRegistration();
          case 5:
            jest.advanceTimersByTime(_constants.REG_TRY_BACKUP_TIMER_VAL_FOR_CC_IN_SEC * _constants.SEC_TO_MSEC_MFACTOR);
            _context7.next = 8;
            return flushPromises();
          case 8:
            expect(webex.request).toBeCalledTimes(3);
            expect(webex.request).toHaveBeenNthCalledWith(1, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(webex.request).toHaveBeenNthCalledWith(2, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));

            /* Failover to backup server failed with 429, the retryAfter is used to schedule the next attempt with backup server.
             * Interval will be updated with retryAfter as interval calculated is less than the retryAfter.
             */
            expect(webex.request).toHaveBeenNthCalledWith(3, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.backup[0], "device")
            }));
            expect(retry429Spy).toBeCalledOnceWith(failurePayload429One.headers['retry-after'], 'startFailoverTimer');
            expect(logSpy).toBeCalledWith("Scheduled retry with backup servers in ".concat(failurePayload429One.headers['retry-after'], " seconds."), loggerContext);
            webex.request.mockClear();
            jest.advanceTimersByTime(Number(failurePayload429One.headers['retry-after']) * _constants.SEC_TO_MSEC_MFACTOR);
            _context7.next = 18;
            return flushPromises();
          case 18:
            expect(webex.request).toBeCalledOnceWith(_objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.backup[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
          case 20:
          case "end":
            return _context7.stop();
        }
      }, _callee7);
    })));
    it('checking the retryAfter exceeding the threshold timers in first attempt itself', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
      return _regenerator.default.wrap(function _callee8$(_context8) {
        while (1) switch (_context8.prev = _context8.next) {
          case 0:
            reg.isCCFlow = true;
            jest.useFakeTimers();
            jest.spyOn(reg, 'getRegRetryInterval').mockReturnValueOnce(40);
            webex.request.mockRejectedValueOnce(failurePayload429Three);
            _context8.next = 6;
            return reg.triggerRegistration();
          case 6:
            expect(webex.request).toHaveBeenNthCalledWith(1, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.INACTIVE);
            expect(failoverSpy).toBeCalledOnceWith();
            expect(infoSpy).toBeCalledWith("Failing over to backup servers.", loggerContext);
            expect(logSpy).not.toBeCalledWith("Scheduled retry with primary in 40 seconds, number of attempts : 1", loggerContext);
            expect(logSpy).not.toBeCalledWith("Scheduled retry with primary in ".concat(failurePayload429Three.headers['retry-after'], " seconds, number of attempts : 1"), loggerContext);
            expect(webex.request).toHaveBeenNthCalledWith(2, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.backup[0], "device")
            }));
          case 13:
          case "end":
            return _context8.stop();
        }
      }, _callee8);
    })));
    it('checking the retryAfter exceeding the threshold timers in later attempts', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
      return _regenerator.default.wrap(function _callee9$(_context9) {
        while (1) switch (_context9.prev = _context9.next) {
          case 0:
            reg.isCCFlow = true;
            jest.useFakeTimers();
            jest.spyOn(reg, 'getRegRetryInterval').mockReturnValueOnce(39).mockReturnValueOnce(43);
            webex.request.mockRejectedValueOnce(failurePayload429One).mockRejectedValueOnce(failurePayload429Four).mockResolvedValueOnce(successPayload);
            _context9.next = 6;
            return reg.triggerRegistration();
          case 6:
            expect(webex.request).toHaveBeenNthCalledWith(1, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.INACTIVE);
            expect(failoverSpy).toBeCalledOnceWith();
            expect(logSpy).toBeCalledWith("Scheduled retry with primary in ".concat(failurePayload429One.headers['retry-after'], " seconds, number of attempts : 1"), loggerContext);
            failoverSpy.mockClear();
            jest.advanceTimersByTime(Number(failurePayload429One.headers['retry-after']) * _constants.SEC_TO_MSEC_MFACTOR);
            _context9.next = 14;
            return flushPromises();
          case 14:
            expect(webex.request).toHaveBeenNthCalledWith(2, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(failoverSpy).toBeCalledOnceWith(2, failurePayload429One.headers['retry-after']);
            expect(logSpy).not.toBeCalledWith("Scheduled retry with primary in 43 seconds, number of attempts : 2", loggerContext);
            expect(infoSpy).toBeCalledWith("Failing over to backup servers.", loggerContext);
            expect(logSpy).not.toBeCalledWith("Scheduled retry with primary in ".concat(failurePayload429Four.headers['retry-after'], " seconds, number of attempts : 2"), loggerContext);
            expect(infoSpy).toBeCalledWith("Failing over to backup servers.", loggerContext);
            expect(webex.request).toHaveBeenNthCalledWith(3, _objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.backup[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
          case 22:
          case "end":
            return _context9.stop();
        }
      }, _callee9);
    })));
  });
  describe('Registration failover tests', function () {
    it('verify unreachable primary with reachable backup servers', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
      return _regenerator.default.wrap(function _callee10$(_context10) {
        while (1) switch (_context10.prev = _context10.next) {
          case 0:
            jest.useFakeTimers();
            // try the primary twice and register successfully with backup servers
            webex.request.mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockResolvedValueOnce(successPayload);
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.IDLE);
            _context10.next = 5;
            return reg.triggerRegistration();
          case 5:
            jest.advanceTimersByTime(_constants.REG_TRY_BACKUP_TIMER_VAL_IN_SEC * _constants.SEC_TO_MSEC_MFACTOR);
            _context10.next = 8;
            return flushPromises();
          case 8:
            expect(webex.request).toBeCalledTimes(3);
            expect(webex.request).toBeCalledWith(_objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(webex.request).toBeCalledWith(_objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.backup[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
            /* Active Url must match with the backup url as per the test */
            expect(reg.getActiveMobiusUrl()).toEqual(mobiusUris.backup[0]);
          case 13:
          case "end":
            return _context10.stop();
        }
      }, _callee10);
    })));
    it('cc: verify unreachable primary with reachable backup server', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
      return _regenerator.default.wrap(function _callee11$(_context11) {
        while (1) switch (_context11.prev = _context11.next) {
          case 0:
            setupRegistration(_objectSpread(_objectSpread({}, MockServiceData), {}, {
              indicator: _types.ServiceIndicator.CONTACT_CENTER
            }));
            jest.useFakeTimers();
            webex.request.mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockResolvedValueOnce(successPayload);
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.IDLE);
            _context11.next = 6;
            return reg.triggerRegistration();
          case 6:
            jest.advanceTimersByTime(_constants.REG_TRY_BACKUP_TIMER_VAL_FOR_CC_IN_SEC * _constants.SEC_TO_MSEC_MFACTOR);
            _context11.next = 9;
            return flushPromises();
          case 9:
            expect(webex.request).toBeCalledTimes(3);
            expect(webex.request).toBeCalledWith(_objectSpread(_objectSpread({}, ccMockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(webex.request).toBeCalledWith(_objectSpread(_objectSpread({}, ccMockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.backup[0], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
            /* Active Url must match with the backup url as per the test */
            expect(reg.getActiveMobiusUrl()).toEqual(mobiusUris.backup[0]);
          case 14:
          case "end":
            return _context11.stop();
        }
      }, _callee11);
    })));
    it('verify unreachable primary and backup servers', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
      return _regenerator.default.wrap(function _callee12$(_context12) {
        while (1) switch (_context12.prev = _context12.next) {
          case 0:
            jest.useFakeTimers();
            // try the primary twice and register successfully with backup servers
            webex.request.mockRejectedValue(failurePayload);
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.IDLE);
            _context12.next = 5;
            return reg.triggerRegistration();
          case 5:
            jest.advanceTimersByTime(_constants.REG_TRY_BACKUP_TIMER_VAL_IN_SEC * _constants.SEC_TO_MSEC_MFACTOR);
            _context12.next = 8;
            return flushPromises();
          case 8:
            jest.advanceTimersByTime(_constants.REG_TRY_BACKUP_TIMER_VAL_IN_SEC * _constants.SEC_TO_MSEC_MFACTOR);
            _context12.next = 11;
            return flushPromises();
          case 11:
            /*
             * 2 calls for primary -> initial and after timer expiry.
             * 2 calls for each backup entry -> 2 * 2 = 4.
             * So a total of 6 calls to webex.request and handleErrors
             */
            expect(webex.request).toBeCalledTimes(6);
            expect(handleErrorSpy).toBeCalledTimes(6);
            expect(webex.request).toBeCalledWith(_objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.primary[0], "device")
            }));
            expect(webex.request).toBeCalledWith(_objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.backup[0], "device")
            }));
            expect(webex.request).toBeCalledWith(_objectSpread(_objectSpread({}, mockResponse), {}, {
              method: 'POST',
              uri: "".concat(mobiusUris.backup[1], "device")
            }));
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.INACTIVE);
          case 17:
          case "end":
            return _context12.stop();
        }
      }, _callee12);
    })));
  });
  describe('Registration failback tests', function () {
    beforeEach( /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
      return _regenerator.default.wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            /* keep keepalive as active so that it wont interfere with the failback tests */
            jest.spyOn(reg, 'postKeepAlive').mockResolvedValue(successPayload);
            jest.useFakeTimers();
            postRegistrationSpy.mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockResolvedValueOnce(successPayload);
            _context13.next = 5;
            return reg.triggerRegistration();
          case 5:
            jest.advanceTimersByTime(_constants.REG_TRY_BACKUP_TIMER_VAL_IN_SEC * _constants.SEC_TO_MSEC_MFACTOR);
            _context13.next = 8;
            return flushPromises();
          case 8:
            reg.rehomingIntervalMin = _constants.DEFAULT_REHOMING_INTERVAL_MIN;
            reg.rehomingIntervalMax = _constants.DEFAULT_REHOMING_INTERVAL_MAX;

            /* These 2 calls to handleErrorSpy are for primary after which it fails over to backup */
            expect(handleErrorSpy).toBeCalledTimes(2);

            /* Active Url must match with the backup url as per the test */
            expect(reg.getActiveMobiusUrl()).toStrictEqual(mobiusUris.backup[0]);
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
          case 13:
          case "end":
            return _context13.stop();
        }
      }, _callee13);
    })));
    afterEach(function () {
      jest.clearAllTimers();
      jest.clearAllMocks();
    });
    it('verify 429 error with failback to primary after initial registration with backup: Restore failure', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14() {
      return _regenerator.default.wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            // delete should be successful
            global.fetch = jest.fn(function () {
              return _promise.default.resolve({
                json: function json() {
                  return _registerFixtures.mockDeleteResponse;
                }
              });
            });
            postRegistrationSpy.mockRejectedValue(failurePayload429Two);

            /* Wait for failback to be triggered. */
            jest.advanceTimersByTime(reg.rehomingIntervalMax * _constants.MINUTES_TO_SEC_MFACTOR * _constants.SEC_TO_MSEC_MFACTOR);
            _context14.next = 5;
            return flushPromises();
          case 5:
            expect(infoSpy).toBeCalledWith("Attempting failback to primary.", {
              method: 'executeFailback',
              file: _constants.REGISTRATION_FILE
            });
            jest.advanceTimersByTime(10000);
            _context14.next = 9;
            return flushPromises();
          case 9:
            expect(retry429Spy).toBeCalledWith(failurePayload429Two.headers['retry-after'], 'executeFailback');
            expect(reg.failback429RetryAttempts).toBe(0);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.INACTIVE);
            expect(restoreSpy).toBeCalledOnceWith(_constants.REG_429_RETRY_UTIL);
            expect(restartSpy).toBeCalledOnceWith(_constants.REG_429_RETRY_UTIL);
            expect(reg.failbackTimer).toBe(undefined);
            expect(reg.rehomingIntervalMin).toBe(_constants.DEFAULT_REHOMING_INTERVAL_MIN);
            expect(reg.rehomingIntervalMax).toBe(_constants.DEFAULT_REHOMING_INTERVAL_MAX);
          case 17:
          case "end":
            return _context14.stop();
        }
      }, _callee14);
    })));
    it('verify unsuccessful failback to primary after initial registration with backup: Restore failure', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15() {
      return _regenerator.default.wrap(function _callee15$(_context15) {
        while (1) switch (_context15.prev = _context15.next) {
          case 0:
            postRegistrationSpy.mockRejectedValue(failurePayload);

            /* Wait for failback to be triggered. */
            jest.advanceTimersByTime(reg.rehomingIntervalMax * _constants.MINUTES_TO_SEC_MFACTOR * _constants.SEC_TO_MSEC_MFACTOR);
            _context15.next = 4;
            return flushPromises();
          case 4:
            expect(infoSpy).toBeCalledWith("Attempting failback to primary.", {
              method: 'executeFailback',
              file: _constants.REGISTRATION_FILE
            });
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.INACTIVE);
            expect(restoreSpy).toBeCalledOnceWith(_constants.FAILBACK_UTIL);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.INACTIVE);
            expect(restartSpy).toBeCalledOnceWith(_constants.FAILBACK_UTIL);
            expect(reg.rehomingIntervalMin).toBe(_constants.DEFAULT_REHOMING_INTERVAL_MIN);
            expect(reg.rehomingIntervalMax).toBe(_constants.DEFAULT_REHOMING_INTERVAL_MAX);
          case 11:
          case "end":
            return _context15.stop();
        }
      }, _callee15);
    })));
    it('verify unsuccessful failback to primary after initial registration with backup: Restore failure with final error', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16() {
      var finalErrorPayload;
      return _regenerator.default.wrap(function _callee16$(_context16) {
        while (1) switch (_context16.prev = _context16.next) {
          case 0:
            finalErrorPayload = {
              statusCode: 401,
              body: _registerFixtures.mockPostResponse
            };
            postRegistrationSpy.mockClear();
            postRegistrationSpy.mockRejectedValue(finalErrorPayload).mockRejectedValueOnce(failurePayload);
            /* Wait for failback to be triggered. */
            jest.advanceTimersByTime(reg.rehomingIntervalMax * _constants.MINUTES_TO_SEC_MFACTOR * _constants.SEC_TO_MSEC_MFACTOR);
            _context16.next = 6;
            return flushPromises();
          case 6:
            expect(infoSpy).toBeCalledWith("Attempting failback to primary.", {
              method: 'executeFailback',
              file: _constants.REGISTRATION_FILE
            });
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.INACTIVE);
            expect(restoreSpy).toBeCalledOnceWith(_constants.FAILBACK_UTIL);
            expect(restartSpy).not.toBeCalled();
            expect(reg.failbackTimer).toBe(undefined);
            expect(reg.rehomingIntervalMin).toBe(_constants.DEFAULT_REHOMING_INTERVAL_MIN);
            expect(reg.rehomingIntervalMax).toBe(_constants.DEFAULT_REHOMING_INTERVAL_MAX);
          case 13:
          case "end":
            return _context16.stop();
        }
      }, _callee16);
    })));
    it('verify unsuccessful failback to primary after initial registration with backup: Restore success', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17() {
      return _regenerator.default.wrap(function _callee17$(_context17) {
        while (1) switch (_context17.prev = _context17.next) {
          case 0:
            postRegistrationSpy.mockRejectedValueOnce(failurePayload).mockResolvedValue(successPayload);

            /* Wait for failback to be triggered. */
            jest.advanceTimersByTime(reg.rehomingIntervalMax * _constants.MINUTES_TO_SEC_MFACTOR * _constants.SEC_TO_MSEC_MFACTOR);
            _context17.next = 4;
            return flushPromises();
          case 4:
            expect(infoSpy).toBeCalledWith("Attempting failback to primary.", {
              method: 'executeFailback',
              file: _constants.REGISTRATION_FILE
            });
            /* Active Url should still match backup url */
            expect(reg.getActiveMobiusUrl()).toStrictEqual(mobiusUris.backup[0]);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);
            expect(restoreSpy).toBeCalledOnceWith(_constants.FAILBACK_UTIL);
            expect(restartSpy).not.toBeCalled();
            expect(reg.rehomingIntervalMin).toBe(_constants.DEFAULT_REHOMING_INTERVAL_MIN);
            expect(reg.rehomingIntervalMax).toBe(_constants.DEFAULT_REHOMING_INTERVAL_MAX);
          case 11:
          case "end":
            return _context17.stop();
        }
      }, _callee17);
    })));
    it('verify successful failback to primary after initial registration with backup', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18() {
      return _regenerator.default.wrap(function _callee18$(_context18) {
        while (1) switch (_context18.prev = _context18.next) {
          case 0:
            postRegistrationSpy.mockResolvedValue(successPayload);

            /* Wait for failback to be triggered. */
            jest.advanceTimersByTime(reg.rehomingIntervalMax * _constants.MINUTES_TO_SEC_MFACTOR * _constants.SEC_TO_MSEC_MFACTOR);
            _context18.next = 4;
            return flushPromises();
          case 4:
            expect(infoSpy).toBeCalledWith("Attempting failback to primary.", {
              method: 'executeFailback',
              file: _constants.REGISTRATION_FILE
            });

            /* Active Url must now match with the primary url */
            expect(reg.getActiveMobiusUrl()).toStrictEqual(mobiusUris.primary[0]);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);
            expect(reg.failbackTimer).toBe(undefined);
            expect(restoreSpy).not.toBeCalled();
            expect(reg.rehomingIntervalMin).toBe(_registerFixtures.mockPostResponse.rehomingIntervalMin);
            expect(reg.rehomingIntervalMax).toBe(_registerFixtures.mockPostResponse.rehomingIntervalMax);
          case 11:
          case "end":
            return _context18.stop();
        }
      }, _callee18);
    })));
    it('verify unsuccessful failback attempt due to active call', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee19() {
      return _regenerator.default.wrap(function _callee19$(_context19) {
        while (1) switch (_context19.prev = _context19.next) {
          case 0:
            /** create a new call */
            reg.callManager.createCall();
            expect((0, _keys.default)(reg.callManager.getActiveCalls()).length).toBe(1);
            postRegistrationSpy.mockRejectedValueOnce(failurePayload).mockResolvedValue(successPayload);

            /* Wait for failback to be triggered. */
            jest.advanceTimersByTime(reg.rehomingIntervalMax * _constants.MINUTES_TO_SEC_MFACTOR * _constants.SEC_TO_MSEC_MFACTOR);
            _context19.next = 6;
            return flushPromises();
          case 6:
            expect(infoSpy).toBeCalledWith("Active calls present, deferring failback to next cycle.", {
              method: 'executeFailback',
              file: _constants.REGISTRATION_FILE
            });

            /* Active Url should still match backup url */
            expect(reg.getActiveMobiusUrl()).toStrictEqual(mobiusUris.backup[0]);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);
            expect(restoreSpy).not.toBeCalled();
            expect(restartSpy).not.toBeCalled();
            expect(infoSpy).toBeCalledWith('Active calls present, deferring failback to next cycle.', {
              file: _constants.REGISTRATION_FILE,
              method: _constants.FAILBACK_UTIL
            });
            expect(reg.rehomingIntervalMin).toBe(_constants.DEFAULT_REHOMING_INTERVAL_MIN);
            expect(reg.rehomingIntervalMax).toBe(_constants.DEFAULT_REHOMING_INTERVAL_MAX);
          case 14:
          case "end":
            return _context19.stop();
        }
      }, _callee19);
    })));
  });

  // Keep-alive related test cases
  describe('Keep-alive Tests', function () {
    var logObj = {
      file: _constants.REGISTRATION_FILE,
      method: 'startKeepaliveTimer'
    };
    var mockKeepAliveBody = {
      device: _registerFixtures.mockPostResponse.device
    };
    var beforeEachSetupForKeepalive = /*#__PURE__*/function () {
      var _ref20 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee20() {
        return _regenerator.default.wrap(function _callee20$(_context20) {
          while (1) switch (_context20.prev = _context20.next) {
            case 0:
              postRegistrationSpy.mockResolvedValueOnce(successPayload);
              jest.useFakeTimers();
              _context20.next = 4;
              return reg.triggerRegistration();
            case 4:
              expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);
            case 5:
            case "end":
              return _context20.stop();
          }
        }, _callee20);
      }));
      return function beforeEachSetupForKeepalive() {
        return _ref20.apply(this, arguments);
      };
    }();
    afterEach(function () {
      jest.clearAllTimers();
      jest.clearAllMocks();
      if (reg.keepaliveTimer) {
        clearInterval(reg.keepaliveTimer);
        reg.keepaliveTimer = undefined;
      }
      reg.reconnectPending = false;
      var calls = (0, _values.default)(reg.callManager.getActiveCalls());
      calls.forEach(function (call) {
        call.end();
      });
    });
    it('verify successful keep-alive cases', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee21() {
      var keepAlivePayload, funcSpy;
      return _regenerator.default.wrap(function _callee21$(_context21) {
        while (1) switch (_context21.prev = _context21.next) {
          case 0:
            _context21.next = 2;
            return beforeEachSetupForKeepalive();
          case 2:
            keepAlivePayload = {
              statusCode: 200,
              body: mockKeepAliveBody
            };
            webex.request.mockReturnValue(keepAlivePayload);
            funcSpy = jest.spyOn(reg, 'postKeepAlive');
            jest.advanceTimersByTime(2 * _registerFixtures.mockPostResponse.keepaliveInterval * _constants.SEC_TO_MSEC_MFACTOR);
            _context21.next = 8;
            return flushPromises();
          case 8:
            expect(funcSpy).toBeCalledTimes(2); // should be called 2 times: first try and after the interval.

            expect(logSpy).toBeCalledWith('Sent Keepalive, status: 200', logObj);
            expect(infoSpy).not.toBeCalledWith('Sent Keepalive, status: 200', logObj);
          case 11:
          case "end":
            return _context21.stop();
        }
      }, _callee21);
    })));
    it('verify failure keep-alive cases: Retry Success', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee22() {
      var failurePayload, successPayload, timer;
      return _regenerator.default.wrap(function _callee22$(_context22) {
        while (1) switch (_context22.prev = _context22.next) {
          case 0:
            _context22.next = 2;
            return beforeEachSetupForKeepalive();
          case 2:
            failurePayload = {
              statusCode: 503,
              body: mockKeepAliveBody
            };
            successPayload = {
              statusCode: 200,
              body: mockKeepAliveBody
            };
            timer = reg.keepaliveTimer;
            lineEmitter.mockClear();
            webex.request.mockRejectedValueOnce(failurePayload).mockResolvedValue(successPayload);
            jest.advanceTimersByTime(2 * _registerFixtures.mockPostResponse.keepaliveInterval * _constants.SEC_TO_MSEC_MFACTOR);
            _context22.next = 10;
            return flushPromises();
          case 10:
            expect(handleErrorSpy).toBeCalledOnceWith(failurePayload, expect.anything(), {
              method: 'startKeepaliveTimer',
              file: _constants.REGISTRATION_FILE
            });
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);
            expect(reg.keepaliveTimer).toBe(timer);
            expect(lineEmitter).nthCalledWith(1, _types4.LINE_EVENTS.RECONNECTING);
            expect(lineEmitter).nthCalledWith(2, _types4.LINE_EVENTS.RECONNECTED);
            expect(lineEmitter).toBeCalledTimes(2);
          case 16:
          case "end":
            return _context22.stop();
        }
      }, _callee22);
    })));
    it('verify failure keep-alive cases: Restore failure', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee23() {
      var restoreSpy, restartRegSpy, reconnectSpy, failurePayload, clearIntervalSpy, timer;
      return _regenerator.default.wrap(function _callee23$(_context23) {
        while (1) switch (_context23.prev = _context23.next) {
          case 0:
            _context23.next = 2;
            return beforeEachSetupForKeepalive();
          case 2:
            restoreSpy = jest.spyOn(reg, 'restorePreviousRegistration');
            restartRegSpy = jest.spyOn(reg, 'restartRegistration');
            reconnectSpy = jest.spyOn(reg, 'reconnectOnFailure');
            failurePayload = {
              statusCode: 503,
              body: mockKeepAliveBody
            };
            clearIntervalSpy = jest.spyOn(global, 'clearInterval');
            lineEmitter.mockClear();
            webex.request.mockRejectedValue(failurePayload);
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
            timer = reg.keepaliveTimer;
            jest.advanceTimersByTime(5 * _registerFixtures.mockPostResponse.keepaliveInterval * _constants.SEC_TO_MSEC_MFACTOR);
            _context23.next = 14;
            return flushPromises();
          case 14:
            expect(clearIntervalSpy).toBeCalledOnceWith(timer);

            // sendKeepAlive tries to retry 5 times before accepting failure
            // later 2 attempts to register with primary server
            expect(handleErrorSpy).toBeCalledTimes(7);
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.INACTIVE);
            expect(reg.reconnectPending).toStrictEqual(false);
            expect(reconnectSpy).toBeCalledOnceWith(_constants.KEEPALIVE_UTIL);
            expect(restoreSpy).toBeCalledOnceWith(_constants.KEEPALIVE_UTIL);
            expect(restartRegSpy).toBeCalledOnceWith(_constants.KEEPALIVE_UTIL);
            expect(warnSpy).toHaveBeenCalledWith('Keep-alive missed 1 times. Status -> 503 ', expect.objectContaining({
              file: _constants.REGISTRATION_FILE,
              method: 'startKeepaliveTimer'
            }));
            expect(webex.request).toBeCalledTimes(7);
            expect(reg.keepaliveTimer).toBe(undefined);
            expect(warnSpy).toHaveBeenCalledWith('Keep-alive missed 1 times. Status -> 503 ', expect.objectContaining({
              file: _constants.REGISTRATION_FILE,
              method: 'startKeepaliveTimer'
            }));
            expect(lineEmitter).nthCalledWith(1, _types4.LINE_EVENTS.RECONNECTING);
            expect(lineEmitter).nthCalledWith(4, _types4.LINE_EVENTS.RECONNECTING);
            expect(lineEmitter).nthCalledWith(5, _types4.LINE_EVENTS.UNREGISTERED);

            /** there will be 2 registration attempts */
            expect(lineEmitter).nthCalledWith(6, _types4.LINE_EVENTS.CONNECTING);
            expect(lineEmitter).nthCalledWith(7, _types4.LINE_EVENTS.UNREGISTERED);
            expect(lineEmitter).nthCalledWith(8, _types4.LINE_EVENTS.CONNECTING);
            expect(lineEmitter).nthCalledWith(9, _types4.LINE_EVENTS.UNREGISTERED);
            expect(lineEmitter).toBeCalledTimes(9);
          case 33:
          case "end":
            return _context23.stop();
        }
      }, _callee23);
    })));
    it('verify failure keep-alive cases: Restore Success', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee24() {
      var restoreSpy, restartRegSpy, reconnectSpy, failurePayload, successPayload, clearIntervalSpy, url, timer;
      return _regenerator.default.wrap(function _callee24$(_context24) {
        while (1) switch (_context24.prev = _context24.next) {
          case 0:
            _context24.next = 2;
            return beforeEachSetupForKeepalive();
          case 2:
            restoreSpy = jest.spyOn(reg, 'restorePreviousRegistration');
            restartRegSpy = jest.spyOn(reg, 'restartRegistration');
            reconnectSpy = jest.spyOn(reg, 'reconnectOnFailure');
            failurePayload = {
              statusCode: 503,
              body: mockKeepAliveBody
            };
            successPayload = {
              statusCode: 200,
              body: mockKeepAliveBody
            };
            clearIntervalSpy = jest.spyOn(global, 'clearInterval');
            webex.request.mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockResolvedValue(successPayload);

            /* successful registration */
            // webex.request.mockResolvedValue(successPayload);

            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
            url = 'https://mobius.asydm-m-1.prod.infra.webex.com/api/v1';
            /* set active Url and expect the registration to restore to this url */
            reg.setActiveMobiusUrl(url);
            timer = reg.keepaliveTimer;
            jest.advanceTimersByTime(5 * _registerFixtures.mockPostResponse.keepaliveInterval * _constants.SEC_TO_MSEC_MFACTOR);
            _context24.next = 16;
            return flushPromises();
          case 16:
            expect(clearIntervalSpy).toBeCalledOnceWith(timer);
            expect(handleErrorSpy).toBeCalledTimes(5);
            expect(reg.getStatus()).toEqual(_types.RegistrationStatus.ACTIVE);
            expect(reconnectSpy).toBeCalledOnceWith(_constants.KEEPALIVE_UTIL);
            expect(restoreSpy).toBeCalledOnceWith(_constants.KEEPALIVE_UTIL);
            expect(restartRegSpy).not.toBeCalled();
            expect(reg.getActiveMobiusUrl()).toStrictEqual(url);
            expect(reg.reconnectPending).toStrictEqual(false);
            expect(reg.keepaliveTimer).toBeTruthy();
            expect(reg.keepaliveTimer).not.toBe(timer);
          case 26:
          case "end":
            return _context24.stop();
        }
      }, _callee24);
    })));
    it('verify failure followed by recovery of keepalive', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee25() {
      var failurePayload, successPayload, clearIntervalSpy, timer;
      return _regenerator.default.wrap(function _callee25$(_context25) {
        while (1) switch (_context25.prev = _context25.next) {
          case 0:
            _context25.next = 2;
            return beforeEachSetupForKeepalive();
          case 2:
            failurePayload = {
              statusCode: 503,
              body: mockKeepAliveBody
            };
            successPayload = {
              statusCode: 200,
              body: mockKeepAliveBody
            };
            clearIntervalSpy = jest.spyOn(global, 'clearInterval');
            webex.request.mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockResolvedValue(successPayload);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);
            timer = reg.keepaliveTimer; // sendKeepAlive tries to retry 3 times and receiving success on third time
            jest.advanceTimersByTime(3 * _registerFixtures.mockPostResponse.keepaliveInterval * _constants.SEC_TO_MSEC_MFACTOR);
            _context25.next = 11;
            return flushPromises();
          case 11:
            expect(webex.request).toBeCalledTimes(3);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);
            expect(handleErrorSpy).toBeCalledTimes(2);
            expect(clearIntervalSpy).not.toBeCalled();
            expect(reg.keepaliveTimer).toBe(timer);
          case 16:
          case "end":
            return _context25.stop();
        }
      }, _callee25);
    })));
    it('cc: verify failover to backup server after 4 keep alive failure with primary server', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee26() {
      var failurePayload, successPayload, clearIntervalSpy, timer;
      return _regenerator.default.wrap(function _callee26$(_context26) {
        while (1) switch (_context26.prev = _context26.next) {
          case 0:
            // Register with contact center service
            setupRegistration(_objectSpread(_objectSpread({}, MockServiceData), {}, {
              indicator: _types.ServiceIndicator.CONTACT_CENTER
            }));
            _context26.next = 3;
            return beforeEachSetupForKeepalive();
          case 3:
            failurePayload = {
              statusCode: 503,
              body: mockKeepAliveBody
            };
            successPayload = {
              statusCode: 200,
              body: mockKeepAliveBody
            };
            clearIntervalSpy = jest.spyOn(global, 'clearInterval');
            jest.spyOn(reg, 'postKeepAlive').mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockResolvedValue(successPayload);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);
            timer = reg.keepaliveTimer;
            jest.advanceTimersByTime(5 * _registerFixtures.mockPostResponse.keepaliveInterval * _constants.SEC_TO_MSEC_MFACTOR);
            _context26.next = 12;
            return flushPromises();
          case 12:
            expect(clearIntervalSpy).toBeCalledOnceWith(timer);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.INACTIVE);
            expect(reg.keepaliveTimer).not.toBe(timer);
            webex.request.mockResolvedValue(successPayload);
            jest.advanceTimersByTime(_constants.REG_TRY_BACKUP_TIMER_VAL_FOR_CC_IN_SEC * _constants.SEC_TO_MSEC_MFACTOR);
            _context26.next = 19;
            return flushPromises();
          case 19:
            /* Active Url must match with the backup url as per the test */
            expect(reg.getActiveMobiusUrl()).toEqual(mobiusUris.backup[0]);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);
          case 21:
          case "end":
            return _context26.stop();
        }
      }, _callee26);
    })));
    it('verify final error for keep-alive', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee27() {
      var restoreSpy, restartRegSpy, reconnectSpy, failurePayload, clearIntervalSpy;
      return _regenerator.default.wrap(function _callee27$(_context27) {
        while (1) switch (_context27.prev = _context27.next) {
          case 0:
            _context27.next = 2;
            return beforeEachSetupForKeepalive();
          case 2:
            restoreSpy = jest.spyOn(reg, 'restorePreviousRegistration');
            restartRegSpy = jest.spyOn(reg, 'restartRegistration');
            reconnectSpy = jest.spyOn(reg, 'reconnectOnFailure');
            failurePayload = {
              statusCode: 404,
              body: mockKeepAliveBody
            };
            clearIntervalSpy = jest.spyOn(global, 'clearInterval');
            webex.request.mockRejectedValue(failurePayload);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);

            /* send one keepalive */
            jest.advanceTimersByTime(_registerFixtures.mockPostResponse.keepaliveInterval * _constants.SEC_TO_MSEC_MFACTOR);
            _context27.next = 12;
            return flushPromises();
          case 12:
            expect(clearIntervalSpy).toBeCalledTimes(1);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.INACTIVE);
            expect(reconnectSpy).not.toBeCalled();
            expect(restoreSpy).not.toBeCalled();
            expect(restartRegSpy).not.toBeCalled();
            expect(reg.reconnectPending).toStrictEqual(false);
            expect(webex.request).toBeCalledOnceWith({
              headers: mockResponse.headers,
              uri: "".concat(mockKeepAliveBody.device.uri, "/status"),
              method: 'POST',
              service: mockResponse.service
            });
            expect(reg.keepaliveTimer).toBe(undefined);
            expect(handleErrorSpy).toBeCalledOnceWith(failurePayload, expect.anything(), {
              file: _constants.REGISTRATION_FILE,
              method: _constants.KEEPALIVE_UTIL
            });
            expect(warnSpy).toBeCalledWith('Keep-alive missed 1 times. Status -> 404 ', expect.objectContaining({
              file: _constants.REGISTRATION_FILE,
              method: 'startKeepaliveTimer'
            }));
          case 22:
          case "end":
            return _context27.stop();
        }
      }, _callee27);
    })));
    it('verify failure keep-alive case with active call present: Restore Success after call ends', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee28() {
      var restoreSpy, restartRegSpy, reconnectSpy, failurePayload, successPayload, clearIntervalSpy, url, timer, call;
      return _regenerator.default.wrap(function _callee28$(_context28) {
        while (1) switch (_context28.prev = _context28.next) {
          case 0:
            _context28.next = 2;
            return beforeEachSetupForKeepalive();
          case 2:
            restoreSpy = jest.spyOn(reg, 'restorePreviousRegistration');
            restartRegSpy = jest.spyOn(reg, 'restartRegistration');
            reconnectSpy = jest.spyOn(reg, 'reconnectOnFailure');
            failurePayload = {
              statusCode: 503,
              body: mockKeepAliveBody
            };
            successPayload = {
              statusCode: 200,
              body: mockKeepAliveBody
            };
            clearIntervalSpy = jest.spyOn(global, 'clearInterval');
            webex.request.mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockRejectedValueOnce(failurePayload).mockResolvedValue(successPayload);

            // jest.spyOn(callingClient['registration'], 'createDevice').mockResolvedValue(successPayload);
            url = 'https://mobius.asydm-m-1.prod.infra.webex.com/api/v1';
            reg.setActiveMobiusUrl(url);
            expect(reg.reconnectPending).toStrictEqual(false);
            timer = reg.keepaliveTimer;
            /* add a call to the callManager */
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            call = reg.callManager.createCall();
            expect((0, _keys.default)(reg.callManager.getActiveCalls()).length).toBe(1);

            /* send one keepalive */
            jest.advanceTimersByTime(5 * _registerFixtures.mockPostResponse.keepaliveInterval * _constants.SEC_TO_MSEC_MFACTOR);
            _context28.next = 18;
            return flushPromises();
          case 18:
            expect(clearIntervalSpy).toBeCalledOnceWith(timer);
            expect(handleErrorSpy).toBeCalledTimes(5);
            expect(reg.keepaliveTimer).toStrictEqual(undefined);
            expect(reg.failbackTimer).toStrictEqual(undefined);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.INACTIVE);
            expect(lineEmitter).lastCalledWith(_types4.LINE_EVENTS.UNREGISTERED);
            expect(reconnectSpy).toBeCalledOnceWith(_constants.KEEPALIVE_UTIL);
            expect(restoreSpy).not.toBeCalled();
            expect(restartRegSpy).not.toBeCalled();
            expect(reg.reconnectPending).toStrictEqual(true);
            expect(infoSpy).toBeCalledWith('Active call(s) present, deferred reconnect till call cleanup.', {
              file: _constants.REGISTRATION_FILE,
              method: expect.any(String)
            });
            reconnectSpy.mockClear();

            /* simulate call disconnect and Calling client will trigger reconnect upon receiving disconnect event from CallManager */
            reg.callManager.callCollection = {};
            _context28.next = 33;
            return reg.reconnectOnFailure(_constants.CALLS_CLEARED_HANDLER_UTIL);
          case 33:
            expect((0, _keys.default)(reg.callManager.getActiveCalls()).length).toBe(0);
            expect(reg.getStatus()).toBe(_types.RegistrationStatus.ACTIVE);
            expect(reconnectSpy).toBeCalledOnceWith(_constants.CALLS_CLEARED_HANDLER_UTIL);
            expect(restoreSpy).toBeCalledOnceWith(_constants.CALLS_CLEARED_HANDLER_UTIL);
            expect(restartRegSpy).not.toBeCalled();
            expect(reg.reconnectPending).toStrictEqual(false);
            expect(reg.getActiveMobiusUrl()).toStrictEqual(url);
            expect(reg.keepaliveTimer).toBeTruthy();
            expect(reg.keepaliveTimer).not.toBe(timer);
          case 42:
          case "end":
            return _context28.stop();
        }
      }, _callee28);
    })));
  });
});
//# sourceMappingURL=register.test.js.map
