"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var InternalMediaCoreModule = _interopRequireWildcard(require("@webex/internal-media-core"));
var _webMediaEffects = require("@webex/web-media-effects");
var _types = require("../../Errors/types");
var _Utils = _interopRequireWildcard(require("../../common/Utils"));
var Utils = _Utils;
var _types2 = require("../../Events/types");
var _constants = require("../constants");
var _types3 = require("../../common/types");
var _types4 = require("../../Metrics/types");
var _call = require("./call");
var _types5 = require("./types");
var _testUtil = require("../../common/testUtil");
var _callManager = require("./callManager");
var _Logger = _interopRequireDefault(require("../../Logger"));
var _Errors = require("../../Errors");
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/* eslint-disable @typescript-eslint/no-explicit-any */
/* eslint-disable dot-notation */
/* eslint-disable @typescript-eslint/no-shadow */

jest.mock('@webex/internal-media-core');
var webex = (0, _testUtil.getTestUtilsWebex)();
var mockInternalMediaCoreModule = InternalMediaCoreModule;
var defaultServiceIndicator = _types3.ServiceIndicator.CALLING;
var activeUrl = 'FakeActiveUrl';
var mockLineId = 'e4e8ee2a-a154-4e52-8f11-ef4cde2dce72';
describe('Call Tests', function () {
  var deviceId = '55dfb53f-bed2-36da-8e85-cee7f02aa68e';
  var dest = {
    type: _types3.CallType.URI,
    address: 'tel:5003'
  };
  var dummyMidCallEvent = {
    eventType: 'callInfo',
    eventData: {
      callerId: {
        from: '"Bob Marley" <sip:5010@207.182.171.130;user=phone>;tag=888068389-1654853820619-'
      }
    }
  };
  var callManager;
  var deleteCallFromCollection = jest.fn();
  var disconnectStats = {
    'rtp-rxstat': {
      Dur: 53.77999999999787,
      LostPkt: 11,
      LatePkt: 0,
      Oct: 41156,
      Pkt: 2379,
      AvgJit: 0.041720656289440466,
      VQMetrics: {
        maxJitter: 0,
        VoPktSizeMs: 20,
        VoOneWayDelayMs: 0.26116666666666666,
        hwType: 'OS X 10.15.7 64-bit/Chrome-105.0.0.0',
        networkType: 'wifi',
        VoRxCodec: 'opus'
      }
    },
    'rtp-txstat': {
      Dur: 53.77999999999787,
      Pkt: 2410,
      Oct: 41156,
      VQMetrics: {
        VoTxCodec: 'opus',
        rtpBitRate: 32000
      }
    }
  };
  var parseMediaQualityStatisticsMock = jest.spyOn(Utils, 'parseMediaQualityStatistics').mockReturnValue(disconnectStats);
  var mockTrack = {
    enabled: false
  };
  var mockEffect = {
    isEnabled: true,
    effectTrack: mockTrack,
    on: jest.fn(),
    off: jest.fn()
  };
  var roapMediaConnectionConfig = {
    skipInactiveTransceivers: true,
    iceServers: [],
    iceCandidatesTimeout: _constants.ICE_CANDIDATES_TIMEOUT,
    sdpMunging: {
      convertPort9to0: true,
      addContentSlides: false,
      copyClineToSessionLevel: true
    }
  };
  var roapMediaConnectionOptions = {
    localTracks: {
      audio: mockTrack
    },
    direction: {
      audio: 'sendrecv',
      video: 'inactive',
      screenShareVideo: 'inactive'
    }
  };
  afterEach(function () {
    webex.request = jest.fn();
  });
  beforeEach(function () {
    callManager = (0, _callManager.getCallManager)(webex, defaultServiceIndicator);
  });
  it('create call object', function () {
    webex.request.mockReturnValueOnce({
      statusCode: 200,
      body: {
        device: {
          deviceId: '8a67806f-fc4d-446b-a131-31e71ea5b010',
          correlationId: '8a67806f-fc4d-446b-a131-31e71ea5b011'
        },
        callId: '8a67806f-fc4d-446b-a131-31e71ea5b020',
        callData: {
          callState: _types5.MobiusCallState.PROCEEDING
        }
      }
    });
    var call = (0, _call.createCall)(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, deleteCallFromCollection, defaultServiceIndicator, dest);
    expect(call).toBeTruthy();
  });
  it('should log a warning when sending a digit fails', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
    var tone, errorMessage, mockMediaConnection, callManager, call, realMediaConnection, logWarnSpy;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          tone = '1';
          errorMessage = 'Failed to send digit'; // Mock the mediaConnection object
          mockMediaConnection = {
            insertDTMF: jest.fn(function () {
              throw new Error(errorMessage);
            })
          };
          callManager = (0, _callManager.getCallManager)(webex, defaultServiceIndicator);
          call = callManager.createCall(_types3.CallDirection.OUTBOUND, deviceId, mockLineId, dest);
          realMediaConnection = call.mediaConnection; // Set the mock mediaConnection object
          call.mediaConnection = mockMediaConnection;

          // Spy on the log.warn method
          logWarnSpy = jest.spyOn(_Logger.default, 'warn'); // Call the sendDigit method
          call.sendDigit(tone);

          // Expect the log.warn method to be called with the error message
          expect(logWarnSpy).toHaveBeenLastCalledWith("Unable to send digit on call: ".concat(errorMessage), {
            file: 'call',
            method: 'sendDigit'
          });

          // Restore the real mediaConnection object
          call.mediaConnection = realMediaConnection;
          call.end();
          _context.next = 14;
          return (0, _Utils.waitForMsecs)(50);
        case 14:
          // Need to add a small delay for Promise and callback to finish.

          /* After call ends, call manager should have 0 record */
          expect((0, _keys.default)(callManager.getActiveCalls()).length).toBe(0);
        case 15:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })));
  it('delete call object when ending the call', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
    var callManager, mockStream, localAudioStream, call;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          webex.request.mockReturnValue({
            statusCode: 200,
            body: {
              device: {
                deviceId: '8a67806f-fc4d-446b-a131-31e71ea5b010',
                correlationId: '8a67806f-fc4d-446b-a131-31e71ea5b011'
              },
              callId: '8a67806f-fc4d-446b-a131-31e71ea5b020'
            }
          });
          callManager = (0, _callManager.getCallManager)(webex, defaultServiceIndicator);
          mockStream = {
            on: jest.fn(),
            setUserMuted: jest.fn()
          };
          localAudioStream = mockStream;
          call = callManager.createCall(_types3.CallDirection.OUTBOUND, deviceId, mockLineId, dest);
          expect(call).toBeTruthy();
          /* After creation , call manager should have 1 record */
          expect((0, _keys.default)(callManager.getActiveCalls()).length).toBe(1);
          call.mute(localAudioStream);
          expect(call.isMuted()).toEqual(true);
          expect(mockStream.setUserMuted).toBeCalledOnceWith(true);
          call.mute(localAudioStream);
          expect(mockStream.setUserMuted).toBeCalledWith(false);
          expect(call.isMuted()).toEqual(false);
          call.end();
          _context2.next = 16;
          return (0, _Utils.waitForMsecs)(50);
        case 16:
          // Need to add a small delay for Promise and callback to finish.
          expect(parseMediaQualityStatisticsMock).toHaveBeenCalledTimes(1);
          expect(webex.request.mock.calls[0][0].body.metrics).toStrictEqual(disconnectStats);
          expect(call.getDisconnectReason().code).toBe(_types5.DisconnectCode.NORMAL);
          expect(call.getDisconnectReason().cause).toBe(_types5.DisconnectCause.NORMAL);

          /* After call ends, call manager should have 0 record */
          expect((0, _keys.default)(callManager.getActiveCalls()).length).toBe(0);
        case 21:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  })));
  it('Check whether media requests succeed or not', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
    var mediaResponse, call, response;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          webex.request.mockReturnValue({
            statusCode: 200,
            body: {
              device: {
                deviceId: '8a67806f-fc4d-446b-a131-31e71ea5b010',
                correlationId: '8a67806f-fc4d-446b-a131-31e71ea5b011'
              },
              callId: '8a67806f-fc4d-446b-a131-31e71ea5b020'
            }
          });
          mediaResponse = {
            statusCode: 200,
            body: {
              device: {
                deviceId: '8a67806f-fc4d-446b-a131-31e71ea5b010',
                correlationId: '8a67806f-fc4d-446b-a131-31e71ea5b011'
              },
              callId: '8a67806f-fc4d-446b-a131-31e71ea5b020'
            }
          };
          call = callManager.createCall(_types3.CallDirection.INBOUND, deviceId, mockLineId, dest);
          _context3.next = 5;
          return call['postMedia']({});
        case 5:
          response = _context3.sent;
          expect(response.body).toStrictEqual(mediaResponse.body);
        case 7:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  })));
  it('check whether callerId midcall event is serviced or not', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
    var call;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          call = callManager.createCall(_types3.CallDirection.OUTBOUND, deviceId, mockLineId, dest);
          call.handleMidCallEvent(dummyMidCallEvent);
          _context4.next = 4;
          return (0, _Utils.waitForMsecs)(50);
        case 4:
          expect(call.getCallerInfo().name).toStrictEqual('Bob Marley');
          expect(call.getCallerInfo().num).toStrictEqual('5010');
          expect(call.getCallerInfo().avatarSrc).toBeFalsy();
        case 7:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  })));
  it('check whether call midcall event is serviced or not', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
    var call, logSpy, corelationId;
    return _regenerator.default.wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          call = callManager.createCall(_types3.CallDirection.OUTBOUND, deviceId, mockLineId, dest);
          dummyMidCallEvent.eventType = 'callState';
          logSpy = jest.spyOn(_Logger.default, 'log');
          call.handleMidCallEvent(dummyMidCallEvent);
          _context5.next = 6;
          return (0, _Utils.waitForMsecs)(50);
        case 6:
          corelationId = call.getCorrelationId();
          expect(logSpy).toHaveBeenLastCalledWith("Received Midcall call event for correlationId : ".concat(corelationId), {
            file: 'call',
            method: 'handleMidCallEvent'
          });
        case 8:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  })));
  it('check call stats for active call', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
    var call, callRtpStats;
    return _regenerator.default.wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          call = callManager.createCall(_types3.CallDirection.OUTBOUND, deviceId, mockLineId, dest);
          _context6.prev = 1;
          _context6.next = 4;
          return call.getCallRtpStats();
        case 4:
          callRtpStats = _context6.sent;
          _context6.next = 10;
          break;
        case 7:
          _context6.prev = 7;
          _context6.t0 = _context6["catch"](1);
          console.error(_context6.t0);
        case 10:
          expect(callRtpStats).toStrictEqual(disconnectStats);
        case 11:
        case "end":
          return _context6.stop();
      }
    }, _callee6, null, [[1, 7]]);
  })));
  it('dial functionality tests for coverage', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
    var mockStream, localAudioStream, warnSpy, call, bnrMetricSpy;
    return _regenerator.default.wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          mockStream = {
            outputStream: {
              getAudioTracks: jest.fn().mockReturnValue([mockTrack])
            },
            on: jest.fn(),
            getEffectByKind: jest.fn().mockImplementation(function () {
              return mockEffect;
            })
          };
          localAudioStream = mockStream;
          warnSpy = jest.spyOn(_Logger.default, 'warn');
          call = (0, _call.createCall)(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, deleteCallFromCollection, defaultServiceIndicator, dest);
          bnrMetricSpy = jest.spyOn(call['metricManager'], 'submitBNRMetric');
          call.dial(localAudioStream);
          expect(mockTrack.enabled).toEqual(true);
          expect(mockInternalMediaCoreModule.RoapMediaConnection).toBeCalledOnceWith(roapMediaConnectionConfig, roapMediaConnectionOptions, expect.any(String), expect.any(Function), expect.any(Function), expect.any(Function));
          expect(call['mediaStateMachine'].state.value).toBe('S_SEND_ROAP_OFFER');
          expect(bnrMetricSpy).toBeCalledOnceWith(_types4.METRIC_EVENT.BNR_ENABLED, _types4.METRIC_TYPE.BEHAVIORAL, call.getCallId(), call.getCorrelationId());

          /* Now change the state and recall to check for error */
          call['mediaStateMachine'].state.value = 'S_SEND_ROAP_OFFER';
          call.dial(localAudioStream);
          expect(call['mediaStateMachine'].state.value).toBe('S_SEND_ROAP_OFFER');
          expect(warnSpy).toBeCalledOnceWith("Call cannot be dialed because the state is already : S_SEND_ROAP_OFFER", {
            file: 'call',
            method: 'dial'
          });
        case 14:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  })));
  it('answer functionality tests for coverage', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
    var mockStream, localAudioStream, warnSpy, call, bnrMetricSpy;
    return _regenerator.default.wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          mockStream = {
            outputStream: {
              getAudioTracks: jest.fn().mockReturnValue([mockTrack])
            },
            on: jest.fn(),
            getEffectByKind: jest.fn().mockImplementation(function () {
              return mockEffect;
            })
          };
          localAudioStream = mockStream;
          warnSpy = jest.spyOn(_Logger.default, 'warn');
          call = (0, _call.createCall)(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, deleteCallFromCollection, defaultServiceIndicator, dest);
          /** Cannot answer in idle state */
          bnrMetricSpy = jest.spyOn(call['metricManager'], 'submitBNRMetric');
          call.answer(localAudioStream);
          expect(mockTrack.enabled).toEqual(true);
          expect(mockInternalMediaCoreModule.RoapMediaConnection).toBeCalledOnceWith(roapMediaConnectionConfig, roapMediaConnectionOptions, expect.any(String), expect.any(Function), expect.any(Function), expect.any(Function));
          expect(call['callStateMachine'].state.value).toBe('S_IDLE');
          expect(warnSpy).toBeCalledOnceWith("Call cannot be answered because the state is : S_IDLE", {
            file: 'call',
            method: 'answer'
          });

          /* Now change the state and recall to check for correct flow */
          call['callStateMachine'].state.value = 'S_SEND_CALL_PROGRESS';
          call.answer(localAudioStream);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_CONNECT');
          expect(bnrMetricSpy).toBeCalledOnceWith(_types4.METRIC_EVENT.BNR_ENABLED, _types4.METRIC_TYPE.BEHAVIORAL, call.getCallId(), call.getCorrelationId());
        case 14:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  })));
  it('testing enabling/disabling the BNR on an active call', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
    var mockStream, localAudioStream, onStreamSpy, onEffectSpy, offStreamSpy, offEffectSpy, call, updateLocalTracksSpy, bnrMetricSpy;
    return _regenerator.default.wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          mockStream = {
            outputStream: {
              getAudioTracks: jest.fn().mockReturnValue([mockTrack])
            },
            on: jest.fn(),
            off: jest.fn(),
            getEffectByKind: jest.fn()
          };
          localAudioStream = mockStream;
          onStreamSpy = jest.spyOn(localAudioStream, 'on');
          onEffectSpy = jest.spyOn(mockEffect, 'on');
          offStreamSpy = jest.spyOn(localAudioStream, 'off');
          offEffectSpy = jest.spyOn(mockEffect, 'off');
          call = (0, _call.createCall)(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, deleteCallFromCollection, defaultServiceIndicator, dest);
          call.dial(localAudioStream);
          expect(mockTrack.enabled).toEqual(true);
          expect(mockInternalMediaCoreModule.RoapMediaConnection).toBeCalledOnceWith(roapMediaConnectionConfig, roapMediaConnectionOptions, expect.any(String), expect.any(Function), expect.any(Function), expect.any(Function));
          expect(call['mediaStateMachine'].state.value).toBe('S_SEND_ROAP_OFFER');
          updateLocalTracksSpy = jest.spyOn(call['mediaConnection'], 'updateLocalTracks');
          bnrMetricSpy = jest.spyOn(call['metricManager'], 'submitBNRMetric');
          /* Update the stream with the effect */
          jest.spyOn(localAudioStream, 'getEffectByKind').mockReturnValue(mockEffect);

          /* Checking if listeners on the localAudioStream have been registered */
          expect(onStreamSpy).toBeCalledTimes(2);
          expect(onStreamSpy).toBeCalledWith(InternalMediaCoreModule.LocalStreamEventNames.OutputTrackChange, expect.any(Function));
          expect(onStreamSpy).toBeCalledWith(InternalMediaCoreModule.LocalStreamEventNames.EffectAdded, expect.any(Function));
          bnrMetricSpy.mockClear();
          /* Invoking the callback function to trigger EffectAdded event to simulate adding effect to the stream */
          onStreamSpy.mock.calls[1][1](mockEffect);
          expect(onEffectSpy).toBeCalledWith(_webMediaEffects.EffectEvent.Enabled, expect.any(Function));
          expect(onEffectSpy).toBeCalledWith(_webMediaEffects.EffectEvent.Disabled, expect.any(Function));

          /* Send Enabled event on the effect, update track and send metrics for BNR disabled */
          onStreamSpy.mock.calls[0][1](mockTrack);
          onEffectSpy.mock.calls[0][1]();
          expect(updateLocalTracksSpy).toBeCalledOnceWith({
            audio: mockTrack
          });
          expect(bnrMetricSpy).toBeCalledOnceWith(_types4.METRIC_EVENT.BNR_ENABLED, _types4.METRIC_TYPE.BEHAVIORAL, call.getCallId(), call.getCorrelationId());

          /* Clear the mocks */
          updateLocalTracksSpy.mockClear();
          bnrMetricSpy.mockClear();

          /* Send Disabled event on the effect, update track and send metrics for BNR disabled */
          mockEffect.isEnabled = false;
          onStreamSpy.mock.calls[0][1](mockTrack);
          onEffectSpy.mock.calls[1][1]();
          expect(updateLocalTracksSpy).toBeCalledOnceWith({
            audio: mockTrack
          });
          expect(bnrMetricSpy).toBeCalledOnceWith(_types4.METRIC_EVENT.BNR_DISABLED, _types4.METRIC_TYPE.BEHAVIORAL, call.getCallId(), call.getCorrelationId());
          call.end();
          _context9.next = 35;
          return (0, _Utils.waitForMsecs)(50);
        case 35:
          /* Checks for switching off the listeners on call disconnect */
          expect(offStreamSpy).toBeCalledTimes(2);
          expect(offStreamSpy).toBeCalledWith(InternalMediaCoreModule.LocalStreamEventNames.OutputTrackChange, expect.any(Function));
          expect(offStreamSpy).toBeCalledWith(InternalMediaCoreModule.LocalStreamEventNames.EffectAdded, expect.any(Function));
          expect(offEffectSpy).toBeCalledWith(_webMediaEffects.EffectEvent.Enabled, expect.any(Function));
          expect(offEffectSpy).toBeCalledWith(_webMediaEffects.EffectEvent.Disabled, expect.any(Function));
        case 40:
        case "end":
          return _context9.stop();
      }
    }, _callee9);
  })));
  it('answer fails if localAudioTrack is empty', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
    var mockStream, localAudioStream, warnSpy, call;
    return _regenerator.default.wrap(function _callee10$(_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          mockStream = {
            outputStream: {
              getAudioTracks: jest.fn().mockReturnValue([])
            },
            on: jest.fn(),
            off: jest.fn(),
            getEffectByKind: jest.fn()
          };
          localAudioStream = mockStream;
          webex.request.mockReturnValue({
            statusCode: 200,
            body: {
              device: {
                deviceId: '8a67806f-fc4d-446b-a131-31e71ea5b010',
                correlationId: '8a67806f-fc4d-446b-a131-31e71ea5b011'
              },
              callId: '8a67806f-fc4d-446b-a131-31e71ea5b020'
            }
          });
          warnSpy = jest.spyOn(_Logger.default, 'warn');
          call = (0, _call.createCall)(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, deleteCallFromCollection, defaultServiceIndicator, dest);
          call.answer(localAudioStream);
          _context10.next = 8;
          return (0, _Utils.waitForMsecs)(50);
        case 8:
          expect(warnSpy).toBeCalledTimes(2);
          expect(warnSpy).toBeCalledWith("Did not find a local track while answering the call ".concat(call.getCorrelationId()), {
            file: 'call',
            method: 'answer'
          });
          expect(call['callStateMachine'].state.value).toBe('S_CALL_CLEARED');
          expect(call['mediaStateMachine'].state.value).toBe('S_ROAP_IDLE');
          expect(call.getDisconnectReason().code).toBe(_types5.DisconnectCode.MEDIA_INACTIVITY);
          expect(call.getDisconnectReason().cause).toBe(_types5.DisconnectCause.MEDIA_INACTIVITY);
          expect(webex.request.mock.calls[0][0].body.metrics).toStrictEqual(disconnectStats);
        case 15:
        case "end":
          return _context10.stop();
      }
    }, _callee10);
  })));
  it('dial fails if localAudioTrack is empty', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
    var mockStream, localAudioStream, warnSpy, call;
    return _regenerator.default.wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          mockStream = {
            outputStream: {
              getAudioTracks: jest.fn().mockReturnValue([])
            },
            on: jest.fn()
          };
          localAudioStream = mockStream;
          warnSpy = jest.spyOn(_Logger.default, 'warn');
          call = (0, _call.createCall)(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, deleteCallFromCollection, defaultServiceIndicator, dest);
          call.dial(localAudioStream);
          _context11.next = 7;
          return (0, _Utils.waitForMsecs)(50);
        case 7:
          expect(warnSpy).toBeCalledTimes(1);
          expect(warnSpy).toBeCalledWith("Did not find a local track while dialing the call ".concat(call.getCorrelationId()), {
            file: 'call',
            method: 'dial'
          });
          expect(call['callStateMachine'].state.value).toBe('S_IDLE');
          expect(call['mediaStateMachine'].state.value).toBe('S_ROAP_IDLE');
          expect(webex.request).not.toBeCalledOnceWith();
        case 12:
        case "end":
          return _context11.stop();
      }
    }, _callee11);
  })));
  it('update media after call creation with valid stream', function () {
    var callManager = (0, _callManager.getCallManager)(webex, defaultServiceIndicator);
    var mockStream = {
      outputStream: {
        getAudioTracks: jest.fn().mockReturnValue([mockTrack])
      },
      on: jest.fn(),
      off: jest.fn(),
      getEffectByKind: jest.fn()
    };
    var localAudioStream = mockStream;
    var onStream1Spy = jest.spyOn(localAudioStream, 'on');
    var offStream1Spy = jest.spyOn(localAudioStream, 'off');
    var call = callManager.createCall(_types3.CallDirection.OUTBOUND, deviceId, mockLineId, dest);
    call.dial(localAudioStream);
    expect(mockTrack.enabled).toEqual(true);
    expect(onStream1Spy).toBeCalledTimes(2);
    expect(onStream1Spy).toBeCalledWith(InternalMediaCoreModule.LocalStreamEventNames.OutputTrackChange, expect.any(Function));
    expect(onStream1Spy).toBeCalledWith(InternalMediaCoreModule.LocalStreamEventNames.EffectAdded, expect.any(Function));
    var mockTrack2 = {
      enabled: true
    };
    var mockStream2 = {
      outputStream: {
        getAudioTracks: jest.fn().mockReturnValue([mockTrack2])
      },
      on: jest.fn(),
      getEffectByKind: jest.fn()
    };
    var localAudioStream2 = mockStream2;
    var onStream2Spy = jest.spyOn(localAudioStream2, 'on');
    call.updateMedia(localAudioStream2);
    expect(call['mediaConnection'].updateLocalTracks).toBeCalledOnceWith({
      audio: mockTrack2
    });
    expect(call['localAudioStream']).toEqual(localAudioStream2);
    expect(offStream1Spy).toBeCalledWith(InternalMediaCoreModule.LocalStreamEventNames.EffectAdded, expect.any(Function));
    expect(onStream2Spy).toBeCalledWith(InternalMediaCoreModule.LocalStreamEventNames.OutputTrackChange, expect.any(Function));
    expect(onStream2Spy).toBeCalledWith(InternalMediaCoreModule.LocalStreamEventNames.EffectAdded, expect.any(Function));
  });
  it('update media with invalid stream', function () {
    var callManager = (0, _callManager.getCallManager)(webex, defaultServiceIndicator);
    var warnSpy = jest.spyOn(_Logger.default, 'warn');
    var mockStream = {
      outputStream: {
        getAudioTracks: jest.fn().mockReturnValue([mockTrack])
      },
      on: jest.fn(),
      getEffectByKind: jest.fn()
    };
    var localAudioStream = mockStream;
    var call = callManager.createCall(_types3.CallDirection.OUTBOUND, deviceId, mockLineId, dest);
    call.dial(localAudioStream);
    expect(mockTrack.enabled).toEqual(true);
    var errorStream = {
      outputStream: {
        getAudioTracks: jest.fn().mockReturnValue([])
      }
    };
    var localAudioStream2 = errorStream;
    call.updateMedia(localAudioStream2);
    expect(call['mediaConnection'].updateLocalTracks).not.toBeCalled();
    expect(warnSpy).toBeCalledOnceWith("Did not find a local track while updating media for call ".concat(call.getCorrelationId(), ". Will not update media"), {
      file: 'call',
      method: 'updateMedia'
    });
  });
  it('test system mute and user mute different scnearios', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
    var logSpy, callManager, mockStream, localAudioStream, call;
    return _regenerator.default.wrap(function _callee12$(_context12) {
      while (1) switch (_context12.prev = _context12.next) {
        case 0:
          logSpy = jest.spyOn(_Logger.default, 'info');
          webex.request.mockReturnValue({
            statusCode: 200,
            body: {
              device: {
                deviceId: '8a67806f-fc4d-446b-a131-31e71ea5b010',
                correlationId: '8a67806f-fc4d-446b-a131-31e71ea5b011'
              },
              callId: '8a67806f-fc4d-446b-a131-31e71ea5b020'
            }
          });
          callManager = (0, _callManager.getCallManager)(webex, defaultServiceIndicator);
          mockStream = {
            on: jest.fn(),
            setUserMuted: jest.fn(),
            systemMuted: false,
            userMuted: false
          };
          localAudioStream = mockStream;
          call = callManager.createCall(dest, _types3.CallDirection.OUTBOUND, deviceId, mockLineId);
          expect(call).toBeTruthy();
          /* System mute is being triggered, mute state within call object should update to true */
          mockStream.systemMuted = true;
          call.mute(localAudioStream, _types5.MUTE_TYPE.SYSTEM);
          expect(call.isMuted()).toEqual(true);

          /* User mute is triggered, but no change will happen to the call object mute state since it is system muted */
          logSpy.mockClear();
          call.mute(localAudioStream, _types5.MUTE_TYPE.USER);
          expect(call.isMuted()).toEqual(true);
          expect(mockStream.setUserMuted).not.toBeCalledOnceWith(true);
          expect(logSpy).toBeCalledOnceWith("Call is muted on the system - ".concat(call.getCorrelationId(), "."), {
            file: 'call',
            method: 'mute'
          });

          /* System mute is being triggered, mute state within call object should update to false */
          mockStream.systemMuted = false;
          call.mute(localAudioStream, _types5.MUTE_TYPE.SYSTEM);
          expect(call.isMuted()).toEqual(false);

          /* User mute can be triggered now updating call object mute state as well */
          call.mute(localAudioStream, _types5.MUTE_TYPE.USER);
          expect(call.isMuted()).toEqual(true);
          expect(mockStream.setUserMuted).toBeCalledOnceWith(true);
          mockStream.userMuted = true;

          /* System mute being triggered now won't update the mute state within call object but will block the user unmute */
          logSpy.mockClear();
          mockStream.systemMuted = true;
          call.mute(localAudioStream, _types5.MUTE_TYPE.SYSTEM);
          expect(call.isMuted()).toEqual(true);
          expect(logSpy).toBeCalledOnceWith("Call is muted by the user already - ".concat(call.getCorrelationId(), "."), {
            file: 'call',
            method: 'mute'
          });

          /* User mute now won't be able to update mute state back to false as system mute is also set */
          call.mute(localAudioStream, _types5.MUTE_TYPE.USER);
          expect(call.isMuted()).toEqual(true);
          expect(mockStream.setUserMuted).not.toBeCalledOnceWith(false);

          /* Revert the system mute but call mute state remains same */
          mockStream.systemMuted = false;
          call.mute(localAudioStream, _types5.MUTE_TYPE.SYSTEM);
          expect(call.isMuted()).toEqual(true);

          /* User mute will be able update the mute state now */
          mockStream.setUserMuted.mockClear();
          call.mute(localAudioStream, _types5.MUTE_TYPE.USER);
          expect(call.isMuted()).toEqual(false);
          expect(mockStream.setUserMuted).toBeCalledOnceWith(false);
        case 37:
        case "end":
          return _context12.stop();
      }
    }, _callee12);
  })));
  describe('Guest Calling Flow Tests', function () {
    var dummyEvent = {
      type: 'E_SEND_CALL_SETUP',
      data: undefined
    };
    var call;
    it('outgoing call without guest calling must have callee', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
      var requestSpy, requestArgs;
      return _regenerator.default.wrap(function _callee13$(_context13) {
        while (1) switch (_context13.prev = _context13.next) {
          case 0:
            call = new _call.Call(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, function () {
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              var dummy = 10;
            }, defaultServiceIndicator, dest);
            call['callStateMachine'].state.value = 'S_IDLE';
            requestSpy = jest.spyOn(webex, 'request');
            call.sendCallStateMachineEvt(dummyEvent);
            requestArgs = requestSpy.mock.calls[0][0];
            expect('callee' in requestArgs.body).toBe(true);
          case 6:
          case "end":
            return _context13.stop();
        }
      }, _callee13);
    })));
    it('outgoing call for guest calling must not have callee', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14() {
      var requestSpy, requestArgs;
      return _regenerator.default.wrap(function _callee14$(_context14) {
        while (1) switch (_context14.prev = _context14.next) {
          case 0:
            call = new _call.Call(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, function () {
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              var dummy = 10;
            }, defaultServiceIndicator);
            call['callStateMachine'].state.value = 'S_IDLE';
            requestSpy = jest.spyOn(webex, 'request');
            call.sendCallStateMachineEvt(dummyEvent);
            requestArgs = requestSpy.mock.calls[0][0];
            expect('callee' in requestArgs.body).toBe(false);
          case 6:
          case "end":
            return _context14.stop();
        }
      }, _callee14);
    })));
  });
});
describe('State Machine handler tests', function () {
  var deviceId = '55dfb53f-bed2-36da-8e85-cee7f02aa68e';
  var dest = {
    type: _types3.CallType.URI,
    address: 'tel:5003'
  };
  var mockStatusBody = {
    device: {
      deviceId: '123e4567-e89b-12d3-a456-426614174000',
      correlationId: 'b5476d4c-f48b-475e-b4e2-994e24d14ca2'
    },
    callId: 'fcf86aa5-5539-4c9f-8b72-667786ae9b6c'
  };
  var call;
  var dtmfMock;
  beforeEach(function () {
    call = new _call.Call(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, function () {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      var dummy = 10;
    }, defaultServiceIndicator, dest);
    jest.clearAllTimers();
    jest.useFakeTimers();
    call['callStateMachine'].state.value = 'S_IDLE';
    call.mediaConnection = _testUtil.mediaConnection;
    dtmfMock = jest.spyOn(call['mediaConnection'], 'insertDTMF');
  });

  // afterEach(() => call.removeAllListeners());

  it('successful session refresh', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee15() {
    var statusPayload, dummyEvent, funcSpy, logSpy;
    return _regenerator.default.wrap(function _callee15$(_context15) {
      while (1) switch (_context15.prev = _context15.next) {
        case 0:
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_CALL_ESTABLISHED'
          };
          call['callStateMachine'].state.value = 'S_SEND_CALL_CONNECT';
          webex.request.mockReturnValue(statusPayload);
          jest.spyOn(global, 'setInterval');
          funcSpy = jest.spyOn(call, 'postStatus').mockResolvedValue(statusPayload);
          logSpy = jest.spyOn(_Logger.default, 'info');
          call.sendCallStateMachineEvt(dummyEvent);
          jest.advanceTimersByTime(_constants.DEFAULT_SESSION_TIMER);

          /* This is to flush all the promises from the Promise queue so that
           * Jest.fakeTimers can advance time and also clear the promise Queue
           */
          _context15.next = 11;
          return (0, _testUtil.flushPromises)(3);
        case 11:
          expect(setInterval).toHaveBeenCalledTimes(1);
          expect(funcSpy).toBeCalledTimes(1);
          expect(logSpy).toBeCalledWith('Session refresh successful', {
            file: 'call',
            method: 'handleCallEstablished'
          });
        case 14:
        case "end":
          return _context15.stop();
      }
    }, _callee15);
  })));
  it('session refresh failure', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee16() {
    var statusPayload, funcSpy;
    return _regenerator.default.wrap(function _callee16$(_context16) {
      while (1) switch (_context16.prev = _context16.next) {
        case 0:
          expect.assertions(4);
          statusPayload = {
            statusCode: 403
          };
          webex.request.mockReturnValue(statusPayload);
          jest.spyOn(global, 'clearInterval');
          call.on(_types2.CALL_EVENT_KEYS.CALL_ERROR, function (errObj) {
            expect(errObj.type).toStrictEqual(_types.ERROR_TYPE.FORBIDDEN_ERROR);
            expect(errObj.message).toStrictEqual('An unauthorized action has been received. This action has been blocked. Please contact the administrator if this persists.');
          });
          funcSpy = jest.spyOn(call, 'postStatus').mockRejectedValue(statusPayload);
          if (call['sessionTimer'] === undefined) {
            /* In cases where this test is run independently/alone, there is no sessionTimer initiated
            Thus we will check and initialize the timer when not present by calling handleCallEstablish() */
            call['handleCallEstablished']({});
          }
          call['handleCallEstablished']({});
          jest.advanceTimersByTime(_constants.DEFAULT_SESSION_TIMER);

          /* This is to flush all the promises from the Promise queue so that
           * Jest.fakeTimers can advance time and also clear the promise Queue
           */
          _context16.next = 11;
          return _promise.default.resolve();
        case 11:
          _context16.next = 13;
          return _promise.default.resolve();
        case 13:
          expect(clearInterval).toHaveBeenCalledTimes(1);
          expect(funcSpy).toBeCalledTimes(1);
        case 15:
        case "end":
          return _context16.stop();
      }
    }, _callee16);
  })));
  it('state changes during successful incoming call', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee17() {
    var statusPayload, dummyEvent, postMediaSpy, deleteSpy, dummyOkEvent;
    return _regenerator.default.wrap(function _callee17$(_context17) {
      while (1) switch (_context17.prev = _context17.next) {
        case 0:
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_RECV_CALL_SETUP',
            data: {
              seq: 1,
              messageType: 'OFFER'
            }
          };
          postMediaSpy = jest.spyOn(call, 'postMedia');
          deleteSpy = jest.spyOn(call, 'delete');
          webex.request.mockReturnValue(statusPayload);
          call['direction'] = _types3.CallDirection.INBOUND;
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_PROGRESS');
          dummyEvent.type = 'E_SEND_CALL_CONNECT';
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_CONNECT');

          /* we should expect to forward the roap offer message to mediaSdk for further processing */
          dummyEvent.type = 'E_RECV_ROAP_OFFER';
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);

          /* expect sending roap answer to mobius */
          dummyEvent.type = 'E_SEND_ROAP_ANSWER';
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(postMediaSpy).toBeCalledOnceWith(dummyEvent.data);
          dummyOkEvent = {
            type: 'E_ROAP_OK',
            data: {
              received: true,
              message: {
                seq: 1,
                messageType: 'OFFER'
              }
            }
          };
          /* we receive roap Ok from mobius and expect mediaSdk to process it */
          call.sendMediaStateMachineEvt(dummyOkEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyOkEvent.data.message);
          expect(call['callStateMachine'].state.value).toBe('S_CALL_ESTABLISHED');
          expect(call.isConnected()).toBe(true);
          call.sendDigit('1');
          expect(dtmfMock).toBeCalledOnceWith('1');
          call.sendCallStateMachineEvt({
            type: 'E_RECV_CALL_DISCONNECT'
          });
          expect(deleteSpy).toBeCalledOnceWith();
          expect(call['callStateMachine'].state.value).toBe('S_RECV_CALL_DISCONNECT');
        case 27:
        case "end":
          return _context17.stop();
      }
    }, _callee17);
  })));
  it('state changes during unsuccessful incoming call due to no offer', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee18() {
    var statusPayload, dummyEvent;
    return _regenerator.default.wrap(function _callee18$(_context18) {
      while (1) switch (_context18.prev = _context18.next) {
        case 0:
          call['direction'] = _types3.CallDirection.INBOUND;
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_RECV_CALL_SETUP',
            data: {
              seq: 1,
              message: {},
              type: 'OFFER'
            }
          };
          webex.request.mockReturnValue(statusPayload);
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_PROGRESS');
          _context18.next = 8;
          return call['handleOutgoingCallConnect']({
            type: 'E_SEND_CALL_CONNECT'
          });
        case 8:
          /* state should not change since there is no offer received. */
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_PROGRESS');
          expect(call.isConnected()).toBeFalsy();
          call.sendCallStateMachineEvt({
            type: 'E_RECV_CALL_DISCONNECT'
          });
          expect(call['callStateMachine'].state.value).toBe('S_RECV_CALL_DISCONNECT');
        case 12:
        case "end":
          return _context18.stop();
      }
    }, _callee18);
  })));
  it('state changes during unsuccessful incoming call due error in call connect', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee19() {
    var warnSpy, stateMachineSpy, statusPayload, roapMessage;
    return _regenerator.default.wrap(function _callee19$(_context19) {
      while (1) switch (_context19.prev = _context19.next) {
        case 0:
          warnSpy = jest.spyOn(_Logger.default, 'warn');
          stateMachineSpy = jest.spyOn(call, 'sendCallStateMachineEvt');
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          roapMessage = {
            seq: 1,
            message: {},
            type: 'OFFER'
          };
          call['direction'] = _types3.CallDirection.INBOUND;
          webex.request.mockReturnValue(statusPayload);
          call.sendCallStateMachineEvt({
            type: 'E_RECV_CALL_SETUP'
          });
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_PROGRESS');
          call.sendMediaStateMachineEvt({
            type: 'E_RECV_ROAP_OFFER',
            data: roapMessage
          });
          webex.request.mockRejectedValueOnce({
            statusCode: 403
          }).mockResolvedValue(statusPayload);
          _context19.next = 12;
          return call['handleOutgoingCallConnect']({
            type: 'E_SEND_CALL_CONNECT'
          });
        case 12:
          expect(call['callStateMachine'].state.value).toBe('S_UNKNOWN');
          expect(stateMachineSpy).toBeCalledTimes(3);
          expect(warnSpy).toBeCalledTimes(4);
        case 15:
        case "end":
          return _context19.stop();
      }
    }, _callee19);
  })));
  it('state changes during successful outgoing call', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee20() {
    var statusPayload, dummyEvent, postMediaSpy, dummyOkEvent;
    return _regenerator.default.wrap(function _callee20$(_context20) {
      while (1) switch (_context20.prev = _context20.next) {
        case 0:
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_SEND_CALL_SETUP',
            data: undefined
          };
          postMediaSpy = jest.spyOn(call, 'postMedia');
          webex.request.mockReturnValue(statusPayload);
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_SETUP');
          dummyEvent.type = 'E_RECV_CALL_PROGRESS';
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_RECV_CALL_PROGRESS');
          dummyEvent.type = 'E_SEND_ROAP_OFFER';
          call.sendMediaStateMachineEvt(dummyEvent);

          /**
           * Since the event doesn't have any data above, we should request media sdk for an offer here.
           * The below event is expected to be called again my mediaSdk.
           */
          dummyEvent.data = {
            seq: 1,
            messageType: 'OFFER',
            sdp: 'sdp'
          };
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(_testUtil.mediaConnection.initiateOffer).toHaveBeenCalledTimes(1);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyEvent.type = 'E_RECV_ROAP_ANSWER';
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyOkEvent = {
            type: 'E_ROAP_OK',
            data: {
              received: false,
              message: {
                seq: 1,
                messageType: 'OK'
              }
            }
          };
          call.sendMediaStateMachineEvt(dummyOkEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyOkEvent.data.message);
          dummyEvent.type = 'E_RECV_ROAP_OFFER_REQUEST';
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyEvent.type = 'E_SEND_ROAP_OFFER';
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyEvent.type = 'E_RECV_ROAP_ANSWER';
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          call.sendMediaStateMachineEvt(dummyOkEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyOkEvent.data.message);

          /* With the two roap offer/answer transactions that we simulated earlier
            we get a total 4 outgoing and 3 incoming roap messages.
          */
          expect(postMediaSpy).toBeCalledTimes(4);
          expect(_testUtil.mediaConnection.roapMessageReceived).toBeCalledTimes(3);
          dummyEvent.type = 'E_RECV_CALL_CONNECT';
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_CALL_ESTABLISHED');
          expect(call.isConnected()).toBe(true);
          call.sendCallStateMachineEvt({
            type: 'E_SEND_CALL_DISCONNECT'
          });
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_DISCONNECT');
        case 40:
        case "end":
          return _context20.stop();
      }
    }, _callee20);
  })));
  it('outgoing call where we receive connect directly after setup. Media established before connect. test call and media state changes', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee21() {
    var statusPayload, dummySetupEvent, dummyConnectEvent, dummyOfferEvent, dummyAnswerEvent, dummyOkEvent, postMediaSpy;
    return _regenerator.default.wrap(function _callee21$(_context21) {
      while (1) switch (_context21.prev = _context21.next) {
        case 0:
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          dummySetupEvent = {
            type: 'E_SEND_CALL_SETUP',
            data: undefined
          };
          dummyConnectEvent = {
            type: 'E_RECV_CALL_CONNECT',
            data: undefined
          };
          dummyOfferEvent = {
            type: 'E_SEND_ROAP_OFFER',
            data: undefined
          };
          dummyAnswerEvent = {
            type: 'E_RECV_ROAP_ANSWER',
            data: {
              seq: 1,
              messageType: 'ANSWER',
              sdp: 'sdp'
            }
          };
          dummyOkEvent = {
            type: 'E_ROAP_OK',
            data: {
              received: false,
              message: {
                seq: 1,
                messageType: 'OK'
              }
            }
          };
          postMediaSpy = jest.spyOn(call, 'postMedia');
          webex.request.mockReturnValue(statusPayload);
          call.sendCallStateMachineEvt(dummySetupEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_SETUP');
          call.sendMediaStateMachineEvt(dummyOfferEvent);

          /**
           * Since the event doesn't have any data above, we should request media sdk for an offer here.
           * The below event is expected to be called again my mediaSdk.
           */
          dummyOfferEvent.data = {
            seq: 1,
            messageType: 'OFFER',
            sdp: 'sdp'
          };
          call.sendMediaStateMachineEvt(dummyOfferEvent);
          expect(_testUtil.mediaConnection.initiateOffer).toHaveBeenCalledTimes(1);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyOfferEvent.data);
          call.sendMediaStateMachineEvt(dummyAnswerEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyAnswerEvent.data);
          call.sendMediaStateMachineEvt(dummyOkEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyOkEvent.data.message);
          expect(call['mediaStateMachine'].state.value).toBe('S_ROAP_OK');
          call.sendCallStateMachineEvt(dummyConnectEvent);
          expect(call['callStateMachine'].state.value).toBe('S_CALL_ESTABLISHED');
          expect(call.isConnected()).toBe(true);
          call.sendCallStateMachineEvt({
            type: 'E_SEND_CALL_DISCONNECT'
          });
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_DISCONNECT');
        case 25:
        case "end":
          return _context21.stop();
      }
    }, _callee21);
  })));
  it('state changes during successful outgoing call with early media', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee22() {
    var statusPayload, dummyEvent;
    return _regenerator.default.wrap(function _callee22$(_context22) {
      while (1) switch (_context22.prev = _context22.next) {
        case 0:
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_SEND_CALL_SETUP',
            data: {
              seq: 1,
              message: {},
              type: 'OFFER'
            }
          };
          webex.request.mockReturnValue(statusPayload);
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_SETUP');
          dummyEvent.type = 'E_RECV_CALL_PROGRESS';
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_RECV_CALL_PROGRESS');

          /* Send a second callProgress event with inband media and it should handle */
          dummyEvent.data['callProgressData'] = {
            inbandMedia: true
          };
          dummyEvent.data['callerId'] = {
            from: '"Bob Marley" <sip:5010@207.182.171.130;user=phone>;tag=888068389-1654853820619-'
          };
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_RECV_CALL_PROGRESS');
          dummyEvent.type = 'E_RECV_CALL_CONNECT';
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_CALL_ESTABLISHED');
          call.sendCallStateMachineEvt({
            type: 'E_RECV_CALL_DISCONNECT'
          });
          expect(call['callStateMachine'].state.value).toBe('S_RECV_CALL_DISCONNECT');
        case 17:
        case "end":
          return _context22.stop();
      }
    }, _callee22);
  })));
  it('state changes during unsuccessful outgoing call due to error in call setup', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee23() {
    var statusPayload, dummyEvent;
    return _regenerator.default.wrap(function _callee23$(_context23) {
      while (1) switch (_context23.prev = _context23.next) {
        case 0:
          statusPayload = {
            statusCode: 403,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_SEND_CALL_SETUP',
            data: {
              seq: 1,
              message: {},
              type: 'OFFER'
            }
          };
          webex.request.mockRejectedValueOnce(statusPayload);
          call.sendCallStateMachineEvt(dummyEvent);
          _context23.next = 6;
          return (0, _testUtil.flushPromises)(3);
        case 6:
          expect(call['callStateMachine'].state.value).toBe('S_UNKNOWN');
        case 7:
        case "end":
          return _context23.stop();
      }
    }, _callee23);
  })));
  it('state changes during unsuccessful outgoing call due to error in media ok', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee24() {
    var statusPayload, dummyEvent;
    return _regenerator.default.wrap(function _callee24$(_context24) {
      while (1) switch (_context24.prev = _context24.next) {
        case 0:
          statusPayload = {
            statusCode: 403,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_ROAP_OK',
            data: {
              received: false,
              message: {}
            }
          };
          call['callStateMachine'].state.value = 'S_RECV_CALL_PROGRESS';
          call['earlyMedia'] = true;
          call['mediaStateMachine'].state.value = 'S_RECV_ROAP_ANSWER';
          webex.request.mockRejectedValue(statusPayload);
          _context24.next = 8;
          return call['handleRoapEstablished']({}, dummyEvent);
        case 8:
          _context24.next = 10;
          return (0, _testUtil.flushPromises)(2);
        case 10:
          expect(call.isConnected()).toBe(false);
          expect(call['mediaStateMachine'].state.value).toBe('S_ROAP_ERROR');
          expect(call['callStateMachine'].state.value).toBe('S_UNKNOWN');
        case 13:
        case "end":
          return _context24.stop();
      }
    }, _callee24);
  })));
  it('state changes during unsuccessful outgoing call since no sdp in offer', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee25() {
    var statusPayload, dummyEvent;
    return _regenerator.default.wrap(function _callee25$(_context25) {
      while (1) switch (_context25.prev = _context25.next) {
        case 0:
          statusPayload = {
            statusCode: 403,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_SEND_ROAP_OFFER',
            data: {
              seq: 1,
              type: 'OFFER'
            }
          };
          webex.request.mockReturnValue(statusPayload);
          call['callStateMachine'].state.value = 'S_RECV_CALL_PROGRESS';
          call['mediaStateMachine'].state.value = 'S_ROAP_IDLE';
          call.sendMediaStateMachineEvt(dummyEvent);
          /* since there is no sdp, mediaMachine should remain in same state
          and an initiateOffer request to be sent to SDK only once */
          expect(call['mediaStateMachine'].state.value).toBe('S_SEND_ROAP_OFFER');
          expect(_testUtil.mediaConnection.initiateOffer).toBeCalledOnceWith();
        case 8:
        case "end":
          return _context25.stop();
      }
    }, _callee25);
  })));
  it('Outgoing Roap offer retry-after error case during midcall', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee26() {
    var statusPayload, funcSpy, stateMachineSpy, dummyEvent;
    return _regenerator.default.wrap(function _callee26$(_context26) {
      while (1) switch (_context26.prev = _context26.next) {
        case 0:
          statusPayload = {
            statusCode: 503,
            headers: {
              'retry-after': 1
            },
            body: mockStatusBody
          };
          jest.spyOn(global, 'setTimeout');
          funcSpy = jest.spyOn(call, 'postMedia').mockRejectedValueOnce(statusPayload);
          stateMachineSpy = jest.spyOn(call, 'sendMediaStateMachineEvt');
          dummyEvent = {
            type: 'E_SEND_ROAP_OFFER',
            data: {
              seq: 1,
              message: {},
              type: 'OFFER',
              sdp: 'sdp'
            }
          };
          call['connected'] = true;
          _context26.next = 8;
          return call['handleOutgoingRoapOffer']({}, dummyEvent);
        case 8:
          jest.advanceTimersByTime(1005);
          expect(setTimeout).toHaveBeenCalledTimes(1);
          expect(funcSpy).toHaveBeenCalledWith(dummyEvent.data);

          /* first failure , and second because of retry-after */
          expect(funcSpy).toHaveBeenCalledTimes(2);
          expect(stateMachineSpy).toBeCalledOnceWith(dummyEvent);
        case 13:
        case "end":
          return _context26.stop();
      }
    }, _callee26);
  })));
  it('Outgoing Roap offer retry-after error case during call establishment', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee27() {
    var statusPayload, funcSpy, stateMachineSpy, dummyEvent;
    return _regenerator.default.wrap(function _callee27$(_context27) {
      while (1) switch (_context27.prev = _context27.next) {
        case 0:
          statusPayload = {
            statusCode: 503,
            headers: {
              'retry-after': 1
            },
            body: mockStatusBody
          };
          jest.spyOn(global, 'setTimeout');
          funcSpy = jest.spyOn(call, 'postMedia').mockRejectedValueOnce(statusPayload);
          stateMachineSpy = jest.spyOn(call, 'sendMediaStateMachineEvt');
          dummyEvent = {
            type: 'E_SEND_ROAP_OFFER',
            data: {
              seq: 1,
              message: {},
              type: 'OFFER',
              sdp: 'sdp'
            }
          };
          call['connected'] = false;
          _context27.next = 8;
          return call['handleOutgoingRoapOffer']({}, dummyEvent);
        case 8:
          jest.advanceTimersByTime(1005);
          expect(funcSpy).toBeCalledOnceWith(dummyEvent.data);

          /* These shouldn't be called as call is not connected yet */
          expect(setTimeout).not.toHaveBeenCalled();
          expect(stateMachineSpy).not.toBeCalled();
        case 12:
        case "end":
          return _context27.stop();
      }
    }, _callee27);
  })));
  it('Outgoing Roap Answer retry-after error case during midcall', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee28() {
    var statusPayload, funcSpy, stateMachineSpy, dummyEvent;
    return _regenerator.default.wrap(function _callee28$(_context28) {
      while (1) switch (_context28.prev = _context28.next) {
        case 0:
          statusPayload = {
            statusCode: 503,
            headers: {
              'retry-after': 1
            },
            body: mockStatusBody
          };
          jest.spyOn(global, 'setTimeout');
          funcSpy = jest.spyOn(call, 'postMedia').mockRejectedValueOnce(statusPayload);
          stateMachineSpy = jest.spyOn(call, 'sendMediaStateMachineEvt');
          dummyEvent = {
            type: 'E_SEND_ROAP_ANSWER',
            data: {
              seq: 1,
              message: {},
              type: 'OFFER'
            }
          };
          call['connected'] = true;
          call['mediaStateMachine'].state.value = 'S_RECV_ROAP_OFFER';
          _context28.next = 9;
          return call['handleOutgoingRoapAnswer']({}, dummyEvent);
        case 9:
          jest.advanceTimersByTime(1005);
          expect(setTimeout).toHaveBeenCalledTimes(1);
          expect(funcSpy).toHaveBeenCalledWith(dummyEvent.data);

          /* first failure , and second because of retry-after */
          expect(funcSpy).toHaveBeenCalledTimes(2);
          expect(stateMachineSpy).toBeCalledOnceWith(dummyEvent);
        case 14:
        case "end":
          return _context28.stop();
      }
    }, _callee28);
  })));
  it('Outgoing Roap answer retry-after error case during call establishment', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee29() {
    var statusPayload, funcSpy, stateMachineSpy, dummyEvent;
    return _regenerator.default.wrap(function _callee29$(_context29) {
      while (1) switch (_context29.prev = _context29.next) {
        case 0:
          statusPayload = {
            statusCode: 503,
            headers: {
              'retry-after': 1
            },
            body: mockStatusBody
          };
          jest.spyOn(global, 'setTimeout');
          funcSpy = jest.spyOn(call, 'postMedia').mockRejectedValueOnce(statusPayload);
          stateMachineSpy = jest.spyOn(call, 'sendMediaStateMachineEvt');
          dummyEvent = {
            type: 'E_SEND_ROAP_ANSWER',
            data: {
              seq: 1,
              message: {},
              type: 'OFFER'
            }
          };
          call['connected'] = false;
          _context29.next = 8;
          return call['handleOutgoingRoapAnswer']({}, dummyEvent);
        case 8:
          jest.advanceTimersByTime(1005);
          expect(funcSpy).toBeCalledOnceWith(dummyEvent.data);
          expect(funcSpy).toHaveBeenCalledTimes(1);

          /* These shouldn't be called as call is not connected yet */
          expect(setTimeout).not.toHaveBeenCalled();
          expect(stateMachineSpy).not.toBeCalled();
        case 13:
        case "end":
          return _context29.stop();
      }
    }, _callee29);
  })));
  it('ROAP error during mid call', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee30() {
    var statusPayload, warnSpy, stateMachineSpy, funcSpy, errorEvent;
    return _regenerator.default.wrap(function _callee30$(_context30) {
      while (1) switch (_context30.prev = _context30.next) {
        case 0:
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          warnSpy = jest.spyOn(_Logger.default, 'warn');
          stateMachineSpy = jest.spyOn(call, 'sendCallStateMachineEvt');
          funcSpy = jest.spyOn(call, 'postMedia').mockResolvedValue(statusPayload);
          errorEvent = {
            type: 'E_ROAP_ERROR',
            data: {
              seq: 2,
              messageType: 'ERROR',
              errorType: 'OUT_OF_ORDER'
            }
          };
          call['mediaStateMachine'].state.value = 'S_SEND_ROAP_ANSWER';
          call['connected'] = true;
          call.sendMediaStateMachineEvt(errorEvent);
          expect(funcSpy).toBeCalledOnceWith(errorEvent.data);
          expect(warnSpy).not.toHaveBeenCalled();
          expect(stateMachineSpy).not.toHaveBeenCalled();
        case 11:
        case "end":
          return _context30.stop();
      }
    }, _callee30);
  })));
  it('ROAP ok retry-after during mid call', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee31() {
    var statusPayload, funcSpy, stateMachineSpy, dummyEvent;
    return _regenerator.default.wrap(function _callee31$(_context31) {
      while (1) switch (_context31.prev = _context31.next) {
        case 0:
          statusPayload = {
            statusCode: 503,
            headers: {
              'retry-after': 1
            },
            body: mockStatusBody
          };
          jest.spyOn(global, 'setTimeout');
          funcSpy = jest.spyOn(call, 'postMedia').mockRejectedValueOnce(statusPayload);
          stateMachineSpy = jest.spyOn(call, 'sendMediaStateMachineEvt');
          dummyEvent = {
            type: 'E_ROAP_OK',
            data: {
              seq: 1,
              message: {},
              type: 'OK'
            }
          };
          call['connected'] = true;
          call['mediaStateMachine'].state.value = 'S_RECV_ROAP_ANSWER';
          _context31.next = 9;
          return call['handleRoapEstablished']({}, dummyEvent);
        case 9:
          jest.advanceTimersByTime(1005);
          expect(setTimeout).toHaveBeenCalledTimes(1);
          expect(funcSpy).toHaveBeenCalled();

          /* first failure , and second because of retry-after */
          expect(funcSpy).toHaveBeenCalledTimes(2);
          expect(stateMachineSpy).toBeCalledOnceWith(dummyEvent);
        case 14:
        case "end":
          return _context31.stop();
      }
    }, _callee31);
  })));
  it('Unable to communicate roap error with mobius', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee32() {
    var statusPayload, stateMachineSpy, funcSpy, errorEvent;
    return _regenerator.default.wrap(function _callee32$(_context32) {
      while (1) switch (_context32.prev = _context32.next) {
        case 0:
          statusPayload = {
            statusCode: 403,
            body: mockStatusBody
          };
          stateMachineSpy = jest.spyOn(call, 'sendCallStateMachineEvt');
          funcSpy = jest.spyOn(call, 'postMedia').mockRejectedValue(statusPayload);
          errorEvent = {
            type: 'E_ROAP_ERROR',
            data: {
              seq: 2,
              messageType: 'ERROR',
              errorType: 'OUT_OF_ORDER'
            }
          };
          call['mediaStateMachine'].state.value = 'S_SEND_ROAP_ANSWER';
          call['connected'] = true;
          call.sendMediaStateMachineEvt(errorEvent);
          expect(funcSpy).toBeCalledOnceWith(errorEvent.data);
          expect(stateMachineSpy).not.toHaveBeenCalled();
        case 9:
        case "end":
          return _context32.stop();
      }
    }, _callee32);
  })));
  it('ROAP error during call establishment', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee33() {
    var statusPayload, warnSpy, stateMachineSpy, funcSpy, errorEvent;
    return _regenerator.default.wrap(function _callee33$(_context33) {
      while (1) switch (_context33.prev = _context33.next) {
        case 0:
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          warnSpy = jest.spyOn(_Logger.default, 'warn');
          stateMachineSpy = jest.spyOn(call, 'sendCallStateMachineEvt');
          funcSpy = jest.spyOn(call, 'postMedia').mockResolvedValue(statusPayload);
          errorEvent = {
            type: 'E_ROAP_ERROR',
            data: {
              seq: 2,
              messageType: 'ERROR',
              errorType: 'OUT_OF_ORDER'
            }
          };
          call['connected'] = false;
          _context33.next = 8;
          return call['handleRoapError']({}, errorEvent);
        case 8:
          expect(funcSpy).toBeCalledOnceWith(errorEvent.data);
          expect(warnSpy).toBeCalledOnceWith('Call failed due to media issue', {
            file: 'call',
            method: 'handleRoapError'
          });
          expect(stateMachineSpy).toBeCalledOnceWith({
            data: {
              media: true
            },
            type: 'E_UNKNOWN'
          });
        case 11:
        case "end":
          return _context33.stop();
      }
    }, _callee33);
  })));
  it('state changes during successful incoming call with out of order events', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee34() {
    var statusPayload, dummyEvent, postMediaSpy, dummyOkEvent, dummyOfferEvent;
    return _regenerator.default.wrap(function _callee34$(_context34) {
      while (1) switch (_context34.prev = _context34.next) {
        case 0:
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_RECV_CALL_SETUP',
            data: {
              seq: 1,
              messageType: 'OFFER'
            }
          };
          postMediaSpy = jest.spyOn(call, 'postMedia');
          webex.request.mockReturnValue(statusPayload);
          call['direction'] = _types3.CallDirection.INBOUND;
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_PROGRESS');
          dummyEvent.type = 'E_SEND_CALL_CONNECT';
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_CONNECT');

          /* we should expect to forward the roap offer message to mediaSdk for further processing */
          dummyEvent.type = 'E_RECV_ROAP_OFFER';
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);

          /* expect sending roap answer to mobius */
          dummyEvent.type = 'E_SEND_ROAP_ANSWER';
          dummyEvent.data = {
            seq: 1,
            messageType: 'ANSWER'
          };
          _context34.next = 17;
          return call.sendMediaStateMachineEvt(dummyEvent);
        case 17:
          expect(postMediaSpy).toBeCalledOnceWith(dummyEvent.data);

          /* we receive roap Offer Request followed by roap Ok from mobius and handle
            out of order events by buffering and processing them in sequence */
          dummyOkEvent = {
            type: 'E_ROAP_OK',
            data: {
              received: true,
              message: {
                seq: 1,
                messageType: 'OK'
              }
            }
          };
          dummyEvent.type = 'E_RECV_ROAP_OFFER_REQUEST';
          dummyEvent.data = {
            seq: 2,
            messageType: 'OFFER_REQUEST'
          };
          _context34.next = 23;
          return call.sendMediaStateMachineEvt(dummyEvent);
        case 23:
          expect(call['receivedRoapOKSeq']).toBe(0);
          expect(_testUtil.mediaConnection.roapMessageReceived).not.toHaveBeenLastCalledWith(dummyEvent.data);
          call.sendMediaStateMachineEvt(dummyOkEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenNthCalledWith(2, dummyOkEvent.data.message);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyOfferEvent = {
            type: 'E_SEND_ROAP_OFFER',
            data: {
              seq: 2,
              messageType: 'OFFER',
              sdp: 'sdp'
            }
          };
          expect(call['mediaStateMachine'].state.value).toBe('S_RECV_ROAP_OFFER_REQUEST');
          call.sendMediaStateMachineEvt(dummyOfferEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyOfferEvent.data);
          dummyEvent.type = 'E_RECV_ROAP_ANSWER';
          dummyEvent.data = {
            seq: 2,
            messageType: 'ANSWER'
          };
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyOkEvent.data = {
            received: false,
            message: {
              seq: 2,
              messageType: 'OK'
            }
          };
          call.sendMediaStateMachineEvt(dummyOkEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyOkEvent.data.message);

          /* With the two roap offer/answer transactions that we simulated earlier
            we get a total 4 outgoing and 3 incoming roap messages.
          */
          expect(postMediaSpy).toBeCalledTimes(3);
          expect(_testUtil.mediaConnection.roapMessageReceived).toBeCalledTimes(4);
          expect(call['callStateMachine'].state.value).toBe('S_CALL_ESTABLISHED');
          expect(call.isConnected()).toBe(true);
          dummyEvent.type = 'E_CALL_HOLD';
          dummyEvent.data = {
            seq: 3,
            messageType: 'OFFER'
          };
          call.sendCallStateMachineEvt(dummyEvent);
          dummyEvent.type = 'E_RECV_ROAP_OFFER';
          _context34.next = 49;
          return call.sendMediaStateMachineEvt(dummyEvent);
        case 49:
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyEvent.type = 'E_SEND_ROAP_ANSWER';
          dummyEvent.data = {
            seq: 3,
            messageType: 'ANSWER'
          };
          _context34.next = 54;
          return call.sendMediaStateMachineEvt(dummyEvent);
        case 54:
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyEvent.type = 'E_RECV_ROAP_OFFER';
          dummyEvent.data = {
            seq: 4,
            messageType: 'OFFER'
          };
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(call['receivedRoapOKSeq']).toBe(2);
          expect(_testUtil.mediaConnection.roapMessageReceived).not.toHaveBeenLastCalledWith(dummyEvent.data);
          dummyOkEvent.data = {
            received: true,
            message: {
              seq: 3,
              messageType: 'OK'
            }
          };
          _context34.next = 63;
          return call.sendMediaStateMachineEvt(dummyOkEvent);
        case 63:
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenNthCalledWith(6, dummyOkEvent.data.message);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyEvent.type = 'E_SEND_ROAP_ANSWER';
          dummyEvent.data = {
            seq: 4,
            messageType: 'ANSWER'
          };
          expect(call['mediaStateMachine'].state.value).toBe('S_RECV_ROAP_OFFER');
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyEvent.data);
        case 70:
        case "end":
          return _context34.stop();
      }
    }, _callee34);
  })));
  it('successfully handles out of order events when ROAP OK is received while executing outgoingRoapAnswer', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee35() {
    var mockStatusBody, statusPayload, dummyEvent, postMediaSpy, dummyOkEvent, dummyOfferEvent;
    return _regenerator.default.wrap(function _callee35$(_context35) {
      while (1) switch (_context35.prev = _context35.next) {
        case 0:
          mockStatusBody = {
            device: {
              deviceId: '123e4567-e89b-12d3-a456-426614174000',
              correlationId: 'b5476d4c-f48b-475e-b4e2-994e24d14ca2'
            },
            callId: 'fcf86aa5-5539-4c9f-8b72-667786ae9b6c'
          };
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_RECV_CALL_SETUP',
            data: {
              seq: 1,
              messageType: 'OFFER'
            }
          };
          postMediaSpy = jest.spyOn(call, 'postMedia');
          webex.request.mockReturnValue(statusPayload);
          call['direction'] = _types3.CallDirection.INBOUND;
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_PROGRESS');
          dummyEvent.type = 'E_SEND_CALL_CONNECT';
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_CONNECT');

          /* we should expect to forward the roap offer message to mediaSdk for further processing */
          dummyEvent.type = 'E_RECV_ROAP_OFFER';
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);

          /* expect sending roap answer to mobius */
          dummyEvent.type = 'E_SEND_ROAP_ANSWER';
          dummyEvent.data = {
            seq: 1,
            messageType: 'ANSWER'
          };
          _context35.next = 18;
          return call.sendMediaStateMachineEvt(dummyEvent);
        case 18:
          expect(postMediaSpy).toBeCalledOnceWith(dummyEvent.data);

          /* we receive roap Offer Request followed by roap Ok from mobius and handle
            out of order events by buffering and processing them in sequence */
          dummyOkEvent = {
            type: 'E_ROAP_OK',
            data: {
              received: true,
              message: {
                seq: 1,
                messageType: 'OK'
              }
            }
          };
          dummyEvent.type = 'E_RECV_ROAP_OFFER_REQUEST';
          dummyEvent.data = {
            seq: 2,
            messageType: 'OFFER_REQUEST'
          };
          _context35.next = 24;
          return call.sendMediaStateMachineEvt(dummyEvent);
        case 24:
          expect(call['receivedRoapOKSeq']).toBe(0);
          expect(_testUtil.mediaConnection.roapMessageReceived).not.toHaveBeenLastCalledWith(dummyEvent.data);
          call.sendMediaStateMachineEvt(dummyOkEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenNthCalledWith(2, dummyOkEvent.data.message);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyOfferEvent = {
            type: 'E_SEND_ROAP_OFFER',
            data: {
              seq: 2,
              messageType: 'OFFER',
              sdp: 'sdp'
            }
          };
          expect(call['mediaStateMachine'].state.value).toBe('S_RECV_ROAP_OFFER_REQUEST');
          call.sendMediaStateMachineEvt(dummyOfferEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyOfferEvent.data);
          dummyEvent.type = 'E_RECV_ROAP_ANSWER';
          dummyEvent.data = {
            seq: 2,
            messageType: 'ANSWER'
          };
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyOkEvent.data = {
            received: false,
            message: {
              seq: 2,
              messageType: 'OK'
            }
          };
          call.sendMediaStateMachineEvt(dummyOkEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyOkEvent.data.message);

          /* With the two roap offer/answer transactions that we simulated earlier
            we get a total 4 outgoing and 3 incoming roap messages.
          */
          expect(postMediaSpy).toBeCalledTimes(3);
          expect(_testUtil.mediaConnection.roapMessageReceived).toBeCalledTimes(4);
          expect(call['callStateMachine'].state.value).toBe('S_CALL_ESTABLISHED');
          expect(call.isConnected()).toBe(true);
          dummyEvent.type = 'E_CALL_HOLD';
          dummyEvent.data = {
            seq: 3,
            messageType: 'OFFER'
          };
          call.sendCallStateMachineEvt(dummyEvent);
          dummyEvent.type = 'E_RECV_ROAP_OFFER';
          _context35.next = 50;
          return call.sendMediaStateMachineEvt(dummyEvent);
        case 50:
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyEvent.type = 'E_SEND_ROAP_ANSWER';
          dummyEvent.data = {
            seq: 3,
            messageType: 'ANSWER'
          };
          _context35.next = 55;
          return call.sendMediaStateMachineEvt(dummyEvent);
        case 55:
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyEvent.type = 'E_RECV_ROAP_OFFER';
          dummyEvent.data = {
            seq: 4,
            messageType: 'OFFER'
          };
          dummyOkEvent.data = {
            received: true,
            message: {
              seq: 3,
              messageType: 'OK'
            }
          };
          call.sendMediaStateMachineEvt(dummyEvent);
          _context35.next = 62;
          return call.sendMediaStateMachineEvt(dummyOkEvent);
        case 62:
          expect(call['receivedRoapOKSeq']).toBe(3);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenNthCalledWith(6, dummyOkEvent.data.message);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyEvent.type = 'E_SEND_ROAP_ANSWER';
          dummyEvent.data = {
            seq: 4,
            messageType: 'ANSWER'
          };
          expect(call['mediaStateMachine'].state.value).toBe('S_RECV_ROAP_OFFER');
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyEvent.data);
        case 70:
        case "end":
          return _context35.stop();
      }
    }, _callee35);
  })));
  it('handle hold event successfully when media received after progress but before connect', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee36() {
    var statusPayload, dummyEvent, postMediaSpy, infoSpy, dummyOkEvent;
    return _regenerator.default.wrap(function _callee36$(_context36) {
      while (1) switch (_context36.prev = _context36.next) {
        case 0:
          statusPayload = {
            statusCode: 200,
            body: mockStatusBody
          };
          dummyEvent = {
            type: 'E_SEND_CALL_SETUP',
            data: {
              seq: 1,
              messageType: 'OFFER',
              sdp: 'sdp'
            }
          };
          postMediaSpy = jest.spyOn(call, 'postMedia');
          infoSpy = jest.spyOn(_Logger.default, 'info');
          webex.request.mockReturnValue(statusPayload);
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_SETUP');
          dummyEvent.type = 'E_SEND_ROAP_OFFER';
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyEvent.data);
          dummyEvent.type = 'E_RECV_CALL_PROGRESS';
          dummyEvent.data = undefined;
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_RECV_CALL_PROGRESS');
          dummyEvent.type = 'E_RECV_ROAP_ANSWER';
          dummyEvent.data = {
            seq: 1,
            messageType: 'ANSWER',
            sdp: 'sdp'
          };
          call.sendMediaStateMachineEvt(dummyEvent);
          expect(_testUtil.mediaConnection.roapMessageReceived).toHaveBeenLastCalledWith(dummyEvent.data);
          expect(call['mediaNegotiationCompleted']).toBe(false);
          dummyOkEvent = {
            type: 'E_ROAP_OK',
            data: {
              received: false,
              message: {
                seq: 1,
                messageType: 'OK'
              }
            }
          };
          call.sendMediaStateMachineEvt(dummyOkEvent);
          expect(call['mediaNegotiationCompleted']).toBe(true);
          expect(postMediaSpy).toHaveBeenLastCalledWith(dummyOkEvent.data.message);
          dummyEvent.type = 'E_RECV_CALL_CONNECT';
          dummyEvent.data = undefined;
          call.sendCallStateMachineEvt(dummyEvent);

          /* Call will move to connect state then immediately move to established state as
             media negotiation is already completed before connect was received
          */
          expect(call['callStateMachine'].state.value).toBe('S_CALL_ESTABLISHED');
          expect(call.isConnected()).toBe(true);
          dummyEvent.type = 'E_CALL_HOLD';
          dummyEvent.data = undefined;
          call.sendCallStateMachineEvt(dummyEvent);
          expect(call['callStateMachine'].state.value).toBe('S_CALL_HOLD');
          expect(infoSpy).toHaveBeenLastCalledWith("handleCallHold: ".concat(call.getCorrelationId(), "  "), {
            file: 'call',
            method: 'handleCallHold'
          });
        case 33:
        case "end":
          return _context36.stop();
      }
    }, _callee36);
  })));
  describe('Call event timers tests', function () {
    var callManager;
    beforeEach(function () {
      jest.useFakeTimers();
      callManager = (0, _callManager.getCallManager)(webex, defaultServiceIndicator);
    });
    afterEach(function () {
      jest.clearAllTimers();
    });
    it('times out if the next event is not received - 60 seconds timeout', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee37() {
      var statusPayload, dummyEvent, logSpy, emitSpy, deleteSpy, dummyOkEvent;
      return _regenerator.default.wrap(function _callee37$(_context37) {
        while (1) switch (_context37.prev = _context37.next) {
          case 0:
            statusPayload = {
              statusCode: 200,
              body: mockStatusBody
            };
            dummyEvent = {
              type: 'E_SEND_CALL_SETUP',
              data: undefined
            };
            logSpy = jest.spyOn(_Logger.default, 'warn');
            emitSpy = jest.spyOn(call, 'emit');
            deleteSpy = jest.spyOn(call, 'delete');
            callManager.callCollection = {};
            webex.request.mockReturnValue(statusPayload);

            // handleOutgoingCallSetup is asynchronous
            _context37.next = 9;
            return call.sendCallStateMachineEvt(dummyEvent);
          case 9:
            expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_SETUP');
            dummyEvent.type = 'E_RECV_CALL_PROGRESS';
            call.sendCallStateMachineEvt(dummyEvent);
            expect(call['callStateMachine'].state.value).toBe('S_RECV_CALL_PROGRESS');

            // Media setup for the call
            dummyEvent.type = 'E_SEND_ROAP_OFFER';
            call.sendMediaStateMachineEvt(dummyEvent);
            dummyEvent.data = {
              seq: 1,
              messageType: 'OFFER',
              sdp: 'sdp'
            };
            call.sendMediaStateMachineEvt(dummyEvent);
            dummyEvent.type = 'E_RECV_ROAP_ANSWER';
            call.sendMediaStateMachineEvt(dummyEvent);
            dummyOkEvent = {
              type: 'E_ROAP_OK',
              data: {
                received: false,
                message: {
                  seq: 1,
                  messageType: 'OK'
                }
              }
            };
            call.sendMediaStateMachineEvt(dummyOkEvent);
            dummyEvent.type = 'E_RECV_ROAP_OFFER_REQUEST';
            call.sendMediaStateMachineEvt(dummyEvent);
            dummyEvent.type = 'E_SEND_ROAP_OFFER';
            call.sendMediaStateMachineEvt(dummyEvent);
            dummyEvent.type = 'E_RECV_ROAP_ANSWER';
            logSpy.mockClear();
            jest.advanceTimersByTime(60000);
            expect(logSpy.mock.calls[0][0]).toBe('Call timed out');
            expect(emitSpy).toHaveBeenCalledWith(_types2.CALL_EVENT_KEYS.DISCONNECT, call.getCorrelationId());
            expect(deleteSpy).toHaveBeenCalledTimes(1);
            expect(callManager.callCollection).toStrictEqual({});
          case 32:
          case "end":
            return _context37.stop();
        }
      }, _callee37);
    })));
    it('times out if the next event is not received - 10 seconds timeout', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee38() {
      var statusPayload, dummyEvent, call, emitSpy, deleteSpy, logSpy;
      return _regenerator.default.wrap(function _callee38$(_context38) {
        while (1) switch (_context38.prev = _context38.next) {
          case 0:
            statusPayload = {
              statusCode: 200,
              body: mockStatusBody
            };
            dummyEvent = {
              type: 'E_SEND_CALL_SETUP',
              data: undefined
            };
            callManager.callCollection = {};
            call = callManager.createCall(dest, _types3.CallDirection.OUTBOUND, deviceId, mockLineId);
            emitSpy = jest.spyOn(call, 'emit');
            deleteSpy = jest.spyOn(call, 'delete');
            logSpy = jest.spyOn(_Logger.default, 'warn');
            webex.request.mockReturnValue(statusPayload);
            expect((0, _keys.default)(callManager.callCollection)[0]).toBe(call.getCorrelationId());

            // handleOutgoingCallSetup is asynchronous
            _context38.next = 11;
            return call.sendCallStateMachineEvt(dummyEvent);
          case 11:
            expect(call['callStateMachine'].state.value).toBe('S_SEND_CALL_SETUP');
            logSpy.mockClear();
            jest.advanceTimersByTime(10000);
            expect(logSpy.mock.calls[0][0]).toBe('Call timed out');
            expect(emitSpy).toHaveBeenCalledWith(_types2.CALL_EVENT_KEYS.DISCONNECT, call.getCorrelationId());
            expect(deleteSpy).toHaveBeenCalledTimes(1);
            expect(callManager.callCollection).toStrictEqual({});
          case 18:
          case "end":
            return _context38.stop();
        }
      }, _callee38);
    })));
  });
});
describe('Supplementary Services tests', function () {
  var deviceId = '55dfb53f-bed2-36da-8e85-cee7f02aa68e';
  var dest = {
    type: _types3.CallType.URI,
    address: 'tel:5003'
  };
  var mockResponseBody = {
    device: {
      deviceId: '123e4567-e89b-12d3-a456-426614174000',
      correlationId: 'b5476d4c-f48b-475e-b4e2-994e24d14ca2'
    },
    callId: 'fcf86aa5-5539-4c9f-8b72-667786ae9b6c'
  };
  var call;
  beforeEach(function () {
    /* Since we are not actually testing from the start of a call , so it's good to set the below
     * parameters manually
     */

    call = new _call.Call(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, function () {
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      var dummy = 10;
    }, defaultServiceIndicator, dest);
    call['connected'] = true;
    call['earlyMedia'] = false;

    /* Also supplementary services will start always from Call_Established state */
    call['callStateMachine'].state.value = 'S_CALL_ESTABLISHED';
    call.removeAllListeners(_types2.CALL_EVENT_KEYS.CALL_ERROR);
    jest.clearAllTimers();
    jest.useFakeTimers();
  });
  describe('Call hold-resume tests', function () {
    var mockHeldEvent = {
      eventType: 'callState',
      eventData: {
        callState: 'HELD'
      }
    };
    var mockResumeEvent = {
      eventType: 'callState',
      eventData: {
        callState: 'CONNECTED'
      }
    };
    var dummyEvent = {
      type: 'E_SEND_ROAP_OFFER',
      data: {
        seq: 1,
        message: {},
        type: 'OFFER'
      }
    };
    beforeEach(function () {
      call.removeAllListeners();
    });
    it('Handle successful Call hold case without delayed http response', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee40() {
      var responsePayload, warnSpy, roapEvent;
      return _regenerator.default.wrap(function _callee40$(_context40) {
        while (1) switch (_context40.prev = _context40.next) {
          case 0:
            expect.assertions(7);
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockResolvedValue(responsePayload);
            jest.spyOn(global, 'setTimeout');
            jest.spyOn(global, 'clearTimeout');
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            call['held'] = false;
            call.on(_types2.CALL_EVENT_KEYS.HELD, /*#__PURE__*/function () {
              var _ref40 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee39(correlationId) {
                return _regenerator.default.wrap(function _callee39$(_context39) {
                  while (1) switch (_context39.prev = _context39.next) {
                    case 0:
                      expect(correlationId).toStrictEqual(call.getCorrelationId());
                    case 1:
                    case "end":
                      return _context39.stop();
                  }
                }, _callee39);
              }));
              return function (_x) {
                return _ref40.apply(this, arguments);
              };
            }());
            _context40.next = 10;
            return call.doHoldResume();
          case 10:
            _context40.next = 12;
            return (0, _testUtil.flushPromises)(2);
          case 12:
            expect(setTimeout).toHaveBeenCalledTimes(1);
            call.handleMidCallEvent(mockHeldEvent);

            /* At this point, the Call State should be S_CALL_HOLD
             */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_HOLD');

            /* We simulate the media Connection events manually here as we are not really testing with actual
             * media.
             */
            call['handleIncomingRoapOffer']({}, dummyEvent);
            roapEvent = JSON.parse((0, _stringify.default)(dummyEvent));
            roapEvent.data.type = 'ANSWER';
            _context40.next = 20;
            return call['handleOutgoingRoapAnswer']({}, dummyEvent);
          case 20:
            roapEvent.data.type = 'OK';
            _context40.next = 23;
            return call['handleRoapEstablished']({}, dummyEvent);
          case 23:
            expect(clearTimeout).toHaveBeenCalledTimes(1);
            /* isHeld flag should be set and an Hold event should be emitted */
            expect(call.isHeld()).toStrictEqual(true);
            /* We should return back to call established state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            jest.advanceTimersByTime(12000);
            expect(warnSpy).not.toHaveBeenCalledWith('Hold response timed out', {
              file: 'call',
              method: 'handleCallHold'
            });
          case 28:
          case "end":
            return _context40.stop();
        }
      }, _callee40);
    })));
    it('Handle successful Call hold case with delayed http response', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee42() {
      var responsePayload, warnSpy, roapEvent;
      return _regenerator.default.wrap(function _callee42$(_context42) {
        while (1) switch (_context42.prev = _context42.next) {
          case 0:
            expect.assertions(8);
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockResolvedValue(responsePayload);
            jest.spyOn(global, 'setTimeout');
            jest.spyOn(global, 'clearTimeout');
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            call['held'] = false;
            call.on(_types2.CALL_EVENT_KEYS.HELD, /*#__PURE__*/function () {
              var _ref42 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee41(correlationId) {
                return _regenerator.default.wrap(function _callee41$(_context41) {
                  while (1) switch (_context41.prev = _context41.next) {
                    case 0:
                      expect(correlationId).toStrictEqual(call.getCorrelationId());
                    case 1:
                    case "end":
                      return _context41.stop();
                  }
                }, _callee41);
              }));
              return function (_x2) {
                return _ref42.apply(this, arguments);
              };
            }());
            call.doHoldResume();
            _context42.next = 11;
            return _promise.default.resolve();
          case 11:
            _context42.next = 13;
            return _promise.default.resolve();
          case 13:
            expect(setTimeout).not.toHaveBeenCalled();
            call.handleMidCallEvent(mockHeldEvent);

            /* At this point, the Call State should be S_CALL_HOLD
             */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_HOLD');
            expect(call.isHeld()).toBe(true);
            /* We simulate the media Connection events manually here as we are not really testing with actual
             * media.
             */
            call['handleIncomingRoapOffer']({}, dummyEvent);
            roapEvent = JSON.parse((0, _stringify.default)(dummyEvent));
            roapEvent.data.type = 'ANSWER';
            _context42.next = 22;
            return call['handleOutgoingRoapAnswer']({}, dummyEvent);
          case 22:
            roapEvent.data.type = 'OK';
            _context42.next = 25;
            return call['handleRoapEstablished']({}, dummyEvent);
          case 25:
            expect(clearTimeout).not.toHaveBeenCalled();
            /* isHeld flag should be set and an Hold event should be emitted */
            expect(call.isHeld()).toStrictEqual(true);
            /* We should return back to call established state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            jest.advanceTimersByTime(12000);
            expect(warnSpy).not.toHaveBeenCalledWith('Hold response timed out', {
              file: 'call',
              method: 'handleCallHold'
            });
          case 30:
          case "end":
            return _context42.stop();
        }
      }, _callee42);
    })));
    it('Handle failure Call Hold case during signalling', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee44() {
      var responsePayload;
      return _regenerator.default.wrap(function _callee44$(_context44) {
        while (1) switch (_context44.prev = _context44.next) {
          case 0:
            expect.assertions(4);
            responsePayload = {
              statusCode: 503,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockRejectedValue(responsePayload);
            call['held'] = false;
            call.on(_types2.CALL_EVENT_KEYS.HOLD_ERROR, /*#__PURE__*/function () {
              var _ref44 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee43(errObj) {
                return _regenerator.default.wrap(function _callee43$(_context43) {
                  while (1) switch (_context43.prev = _context43.next) {
                    case 0:
                      expect(errObj.type).toStrictEqual(_types.ERROR_TYPE.SERVICE_UNAVAILABLE);
                      expect(errObj.message).toStrictEqual('An unknown error occurred. Wait a moment and try again.');
                    case 2:
                    case "end":
                      return _context43.stop();
                  }
                }, _callee43);
              }));
              return function (_x3) {
                return _ref44.apply(this, arguments);
              };
            }());
            _context44.next = 7;
            return call.doHoldResume();
          case 7:
            _context44.next = 9;
            return (0, _testUtil.flushPromises)(2);
          case 9:
            expect(call.isHeld()).toStrictEqual(false);

            /* At this point , the Call State should transition to S_CALL_ESTABLISHED
             */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
          case 11:
          case "end":
            return _context44.stop();
        }
      }, _callee44);
    })));
    it('Handle failure Call Hold case during offer/answer exchange', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee46() {
      var responsePayload, rejectPayload, roapEvent;
      return _regenerator.default.wrap(function _callee46$(_context46) {
        while (1) switch (_context46.prev = _context46.next) {
          case 0:
            expect.assertions(5);
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            rejectPayload = {
              statusCode: 503,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockResolvedValueOnce(responsePayload).mockRejectedValueOnce(rejectPayload);
            call['held'] = false;
            call.on(_types2.CALL_EVENT_KEYS.HOLD_ERROR, /*#__PURE__*/function () {
              var _ref46 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee45(errObj) {
                return _regenerator.default.wrap(function _callee45$(_context45) {
                  while (1) switch (_context45.prev = _context45.next) {
                    case 0:
                      expect(errObj.type).toStrictEqual(_types.ERROR_TYPE.SERVICE_UNAVAILABLE);
                      expect(errObj.message).toStrictEqual('An unknown error occurred. Wait a moment and try again.');
                    case 2:
                    case "end":
                      return _context45.stop();
                  }
                }, _callee45);
              }));
              return function (_x4) {
                return _ref46.apply(this, arguments);
              };
            }());
            call.doHoldResume();
            _context46.next = 9;
            return (0, _testUtil.flushPromises)(2);
          case 9:
            /* the Call State should transition to S_CALL_ESTABLISHED
             */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_HOLD');
            call['handleIncomingRoapOffer']({}, dummyEvent);
            roapEvent = JSON.parse((0, _stringify.default)(dummyEvent));
            /* We are intentionally failing the ROAP ANSWER */
            roapEvent.data.type = 'ANSWER';
            _context46.next = 15;
            return call['handleOutgoingRoapAnswer']({}, dummyEvent);
          case 15:
            expect(call.isHeld()).toStrictEqual(false);
            /* We should return back to call established state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
          case 17:
          case "end":
            return _context46.stop();
        }
      }, _callee46);
    })));
    it('Handle failure Call Hold case during roap ok out', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee47() {
      var responsePayload, warnSpy, roapEvent;
      return _regenerator.default.wrap(function _callee47$(_context47) {
        while (1) switch (_context47.prev = _context47.next) {
          case 0:
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockResolvedValue(responsePayload);
            jest.spyOn(global, 'setTimeout');
            jest.spyOn(global, 'clearTimeout');
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            call['held'] = false;
            _context47.next = 8;
            return call.doHoldResume();
          case 8:
            _context47.next = 10;
            return (0, _testUtil.flushPromises)(2);
          case 10:
            expect(setTimeout).toHaveBeenCalledTimes(1);

            /* At this point, the Call State should be S_CALL_HOLD
             */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_HOLD');

            /* We simulate the media Connection events manually here as we are not really testing with actual
             * media.
             */
            call['handleIncomingRoapOffer']({}, dummyEvent);
            roapEvent = JSON.parse((0, _stringify.default)(dummyEvent));
            roapEvent.data.type = 'ANSWER';
            _context47.next = 17;
            return call['handleOutgoingRoapAnswer']({}, dummyEvent);
          case 17:
            jest.spyOn(webex, 'request').mockRejectedValue({
              statusCode: 403
            });
            roapEvent.data.type = 'OK';
            _context47.next = 21;
            return call['handleRoapEstablished']({}, dummyEvent);
          case 21:
            /* this is for coverage */
            call['callStateMachine'].state.value = 'S_CALL_HOLD';
            _context47.next = 24;
            return call['handleRoapEstablished']({}, dummyEvent);
          case 24:
            expect(call.isHeld()).toStrictEqual(false);
            /* We should return back to call established state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            expect(warnSpy).toHaveBeenCalledWith('Failed to process MediaOk request', {
              file: 'call',
              method: 'handleRoapEstablished'
            });
          case 27:
          case "end":
            return _context47.stop();
        }
      }, _callee47);
    })));
    it('Handle failure Call resume case during roap ok out', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee48() {
      var responsePayload, warnSpy, roapEvent;
      return _regenerator.default.wrap(function _callee48$(_context48) {
        while (1) switch (_context48.prev = _context48.next) {
          case 0:
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockResolvedValue(responsePayload);
            jest.spyOn(global, 'setTimeout');
            jest.spyOn(global, 'clearTimeout');
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            call['held'] = true;
            _context48.next = 8;
            return call.doHoldResume();
          case 8:
            _context48.next = 10;
            return (0, _testUtil.flushPromises)(2);
          case 10:
            expect(setTimeout).toHaveBeenCalledTimes(1);

            /* At this point, the Call State should be S_CALL_RESUME
             */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_RESUME');

            /* We simulate the media Connection events manually here as we are not really testing with actual
             * media.
             */
            call['handleIncomingRoapOffer']({}, dummyEvent);
            roapEvent = JSON.parse((0, _stringify.default)(dummyEvent));
            roapEvent.data.type = 'ANSWER';
            _context48.next = 17;
            return call['handleOutgoingRoapAnswer']({}, dummyEvent);
          case 17:
            jest.spyOn(webex, 'request').mockRejectedValue({
              statusCode: 403
            });
            roapEvent.data.type = 'OK';
            _context48.next = 21;
            return call['handleRoapEstablished']({}, dummyEvent);
          case 21:
            expect(call.isHeld()).toStrictEqual(true);
            /* We should return back to call established state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            expect(warnSpy).toHaveBeenCalledWith('Failed to process MediaOk request', {
              file: 'call',
              method: 'handleRoapEstablished'
            });
          case 24:
          case "end":
            return _context48.stop();
        }
      }, _callee48);
    })));
    it('Handle Call hold case where successful Held response does not come', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee50() {
      var responsePayload, roapEvent;
      return _regenerator.default.wrap(function _callee50$(_context50) {
        while (1) switch (_context50.prev = _context50.next) {
          case 0:
            expect.assertions(5);
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockResolvedValue(responsePayload);
            call['held'] = false;
            call.on(_types2.CALL_EVENT_KEYS.HOLD_ERROR, /*#__PURE__*/function () {
              var _ref50 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee49(errObj) {
                return _regenerator.default.wrap(function _callee49$(_context49) {
                  while (1) switch (_context49.prev = _context49.next) {
                    case 0:
                      expect(errObj.type).toStrictEqual(_types.ERROR_TYPE.TIMEOUT);
                      expect(errObj.message).toStrictEqual('An error occurred while placing the call on hold. Wait a moment and try again.');
                    case 2:
                    case "end":
                      return _context49.stop();
                  }
                }, _callee49);
              }));
              return function (_x5) {
                return _ref50.apply(this, arguments);
              };
            }());
            jest.runAllTimers();
            call.doHoldResume();
            _context50.next = 9;
            return (0, _testUtil.flushPromises)(2);
          case 9:
            /* At this point, the Call State should be S_CALL_HOLD
             */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_HOLD');

            /* We simulate the media Connection events manually here as we are not really testing with actual
             * media.
             */
            call['handleIncomingRoapOffer']({}, dummyEvent);
            roapEvent = JSON.parse((0, _stringify.default)(dummyEvent));
            roapEvent.data.type = 'ANSWER';
            _context50.next = 15;
            return call['handleOutgoingRoapAnswer']({}, dummyEvent);
          case 15:
            roapEvent.data.type = 'OK';
            _context50.next = 18;
            return call['handleRoapEstablished']({}, dummyEvent);
          case 18:
            /* Advancing timer by 12 seconds so that it gets timed out */
            jest.advanceTimersByTime(12000);

            /* isHeld flag should be unset */
            expect(call.isHeld()).toStrictEqual(false);
            /* We should return back to call established state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
          case 21:
          case "end":
            return _context50.stop();
        }
      }, _callee50);
    })));
    it('Handle successful Call Resume case without delayed http response', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee52() {
      var responsePayload, warnSpy, roapEvent;
      return _regenerator.default.wrap(function _callee52$(_context52) {
        while (1) switch (_context52.prev = _context52.next) {
          case 0:
            expect.assertions(7);
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockResolvedValue(responsePayload);
            jest.spyOn(global, 'setTimeout');
            jest.spyOn(global, 'clearTimeout');
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            call['held'] = true;
            call.on(_types2.CALL_EVENT_KEYS.RESUMED, /*#__PURE__*/function () {
              var _ref52 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee51(correlationId) {
                return _regenerator.default.wrap(function _callee51$(_context51) {
                  while (1) switch (_context51.prev = _context51.next) {
                    case 0:
                      expect(correlationId).toStrictEqual(call.getCorrelationId());
                    case 1:
                    case "end":
                      return _context51.stop();
                  }
                }, _callee51);
              }));
              return function (_x6) {
                return _ref52.apply(this, arguments);
              };
            }());
            _context52.next = 10;
            return call.doHoldResume();
          case 10:
            _context52.next = 12;
            return (0, _testUtil.flushPromises)(2);
          case 12:
            expect(setTimeout).toHaveBeenCalledTimes(1);
            call.handleMidCallEvent(mockResumeEvent);

            /* At this point ,the Call State should be S_CALL_RESUME
             */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_RESUME');

            /* We simulate the media Connection events manually here as we are not really testing with actual
             * media.
             */
            call['handleIncomingRoapOffer']({}, dummyEvent);
            roapEvent = JSON.parse((0, _stringify.default)(dummyEvent));
            roapEvent.data.type = 'ANSWER';
            _context52.next = 20;
            return call['handleOutgoingRoapAnswer']({}, dummyEvent);
          case 20:
            roapEvent.data.type = 'OK';
            _context52.next = 23;
            return call['handleRoapEstablished']({}, dummyEvent);
          case 23:
            expect(clearTimeout).toHaveBeenCalledTimes(1);
            /* isHeld flag should not be set and an Resume event should be emitted */
            expect(call.isHeld()).toStrictEqual(false);
            /* We should return back to call established state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            jest.advanceTimersByTime(12000);
            expect(warnSpy).not.toHaveBeenCalledWith('Resume response timed out', {
              file: 'call',
              method: 'handleCallResume'
            });
          case 28:
          case "end":
            return _context52.stop();
        }
      }, _callee52);
    })));
    it('Handle successful Call Resume case with delayed http response', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee54() {
      var responsePayload, warnSpy, roapEvent;
      return _regenerator.default.wrap(function _callee54$(_context54) {
        while (1) switch (_context54.prev = _context54.next) {
          case 0:
            expect.assertions(7);
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockResolvedValue(responsePayload);
            jest.spyOn(global, 'setTimeout');
            jest.spyOn(global, 'clearTimeout');
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            call['held'] = true;
            call.on(_types2.CALL_EVENT_KEYS.RESUMED, /*#__PURE__*/function () {
              var _ref54 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee53(correlationId) {
                return _regenerator.default.wrap(function _callee53$(_context53) {
                  while (1) switch (_context53.prev = _context53.next) {
                    case 0:
                      expect(correlationId).toStrictEqual(call.getCorrelationId());
                    case 1:
                    case "end":
                      return _context53.stop();
                  }
                }, _callee53);
              }));
              return function (_x7) {
                return _ref54.apply(this, arguments);
              };
            }());
            call.doHoldResume();
            _context54.next = 11;
            return _promise.default.resolve();
          case 11:
            _context54.next = 13;
            return _promise.default.resolve();
          case 13:
            expect(setTimeout).not.toHaveBeenCalled();
            call.handleMidCallEvent(mockResumeEvent);

            /* At this point ,the Call State should be S_CALL_RESUME
             */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_RESUME');

            /* We simulate the media Connection events manually here as we are not really testing with actual
             * media.
             */
            call['handleIncomingRoapOffer']({}, dummyEvent);
            roapEvent = JSON.parse((0, _stringify.default)(dummyEvent));
            roapEvent.data.type = 'ANSWER';
            _context54.next = 21;
            return call['handleOutgoingRoapAnswer']({}, dummyEvent);
          case 21:
            roapEvent.data.type = 'OK';
            _context54.next = 24;
            return call['handleRoapEstablished']({}, dummyEvent);
          case 24:
            expect(clearTimeout).not.toHaveBeenCalled();
            /* isHeld flag should not be set and an Resume event should be emitted */
            expect(call.isHeld()).toStrictEqual(false);
            /* We should return back to call established state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            jest.advanceTimersByTime(12000);
            expect(warnSpy).not.toHaveBeenCalledWith('Resume response timed out', {
              file: 'call',
              method: 'handleCallResume'
            });
          case 29:
          case "end":
            return _context54.stop();
        }
      }, _callee54);
    })));
    it('Handle failure Call Resume case during signalling', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee56() {
      var responsePayload;
      return _regenerator.default.wrap(function _callee56$(_context56) {
        while (1) switch (_context56.prev = _context56.next) {
          case 0:
            expect.assertions(4);
            responsePayload = {
              statusCode: 503,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockRejectedValue(responsePayload);
            call['held'] = true;
            call.on(_types2.CALL_EVENT_KEYS.RESUME_ERROR, /*#__PURE__*/function () {
              var _ref56 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee55(errObj) {
                return _regenerator.default.wrap(function _callee55$(_context55) {
                  while (1) switch (_context55.prev = _context55.next) {
                    case 0:
                      expect(errObj.type).toStrictEqual(_types.ERROR_TYPE.SERVICE_UNAVAILABLE);
                      expect(errObj.message).toStrictEqual('An unknown error occurred. Wait a moment and try again.');
                    case 2:
                    case "end":
                      return _context55.stop();
                  }
                }, _callee55);
              }));
              return function (_x8) {
                return _ref56.apply(this, arguments);
              };
            }());
            _context56.next = 7;
            return call.doHoldResume();
          case 7:
            _context56.next = 9;
            return (0, _testUtil.flushPromises)(2);
          case 9:
            expect(call.isHeld()).toStrictEqual(true);

            /* At this point , the Call State should transition to S_CALL_ESTABLISHED
             */

            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
          case 11:
          case "end":
            return _context56.stop();
        }
      }, _callee56);
    })));
    it('Handle failure Call Resume case during offer/answer exchange', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee58() {
      var responsePayload, rejectPayload, roapEvent;
      return _regenerator.default.wrap(function _callee58$(_context58) {
        while (1) switch (_context58.prev = _context58.next) {
          case 0:
            expect.assertions(5);
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            rejectPayload = {
              statusCode: 503,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockResolvedValueOnce(responsePayload).mockRejectedValueOnce(rejectPayload);
            call['held'] = true;
            call.on(_types2.CALL_EVENT_KEYS.RESUME_ERROR, /*#__PURE__*/function () {
              var _ref58 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee57(errObj) {
                return _regenerator.default.wrap(function _callee57$(_context57) {
                  while (1) switch (_context57.prev = _context57.next) {
                    case 0:
                      expect(errObj.type).toStrictEqual(_types.ERROR_TYPE.SERVICE_UNAVAILABLE);
                      expect(errObj.message).toStrictEqual('An unknown error occurred. Wait a moment and try again.');
                    case 2:
                    case "end":
                      return _context57.stop();
                  }
                }, _callee57);
              }));
              return function (_x9) {
                return _ref58.apply(this, arguments);
              };
            }());
            call.doHoldResume();
            _context58.next = 9;
            return (0, _testUtil.flushPromises)(2);
          case 9:
            /* At this point , the Call State should transition to S_CALL_ESTABLISHED
             */

            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_RESUME');
            call['handleIncomingRoapOffer']({}, dummyEvent);
            roapEvent = JSON.parse((0, _stringify.default)(dummyEvent));
            /* We are intentionally failing the ROAP ANSWER */
            roapEvent.data.type = 'ANSWER';
            _context58.next = 15;
            return call['handleOutgoingRoapAnswer']({}, dummyEvent);
          case 15:
            expect(call.isHeld()).toStrictEqual(true);
            /* We should return back to call established state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
          case 17:
          case "end":
            return _context58.stop();
        }
      }, _callee58);
    })));
    it('Handle Call resume case where successful response does not come', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee60() {
      var responsePayload, roapEvent;
      return _regenerator.default.wrap(function _callee60$(_context60) {
        while (1) switch (_context60.prev = _context60.next) {
          case 0:
            expect.assertions(5);
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            jest.spyOn(webex, 'request').mockResolvedValue(responsePayload);
            call['held'] = true;
            call.on(_types2.CALL_EVENT_KEYS.RESUME_ERROR, /*#__PURE__*/function () {
              var _ref60 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee59(errObj) {
                return _regenerator.default.wrap(function _callee59$(_context59) {
                  while (1) switch (_context59.prev = _context59.next) {
                    case 0:
                      expect(errObj.type).toStrictEqual(_types.ERROR_TYPE.TIMEOUT);
                      expect(errObj.message).toStrictEqual('An error occurred while resuming the call. Wait a moment and try again.');
                    case 2:
                    case "end":
                      return _context59.stop();
                  }
                }, _callee59);
              }));
              return function (_x10) {
                return _ref60.apply(this, arguments);
              };
            }());
            call.doHoldResume();
            _context60.next = 8;
            return (0, _testUtil.flushPromises)(2);
          case 8:
            /* At this point ,the Call State should be S_CALL_RESUME
             */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_RESUME');

            /* We simulate the media Connection events manually here as we are not really testing with actual
             * media.
             */
            call['handleIncomingRoapOffer']({}, dummyEvent);
            roapEvent = JSON.parse((0, _stringify.default)(dummyEvent));
            roapEvent.data.type = 'ANSWER';
            _context60.next = 14;
            return call['handleOutgoingRoapAnswer']({}, dummyEvent);
          case 14:
            roapEvent.data.type = 'OK';
            _context60.next = 17;
            return call['handleRoapEstablished']({}, dummyEvent);
          case 17:
            /* Advancing timer by 12 seconds so that it gets timed out */
            jest.advanceTimersByTime(12000);
            expect(call.isHeld()).toStrictEqual(true);
            /* We should return back to call established state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
          case 20:
          case "end":
            return _context60.stop();
        }
      }, _callee60);
    })));
  });
  describe('Call transfer tests', function () {
    var transfereeNumber = '5004';
    var transfereeDest = {
      type: _types3.CallType.URI,
      address: "tel:".concat(transfereeNumber)
    };
    var secondCall;

    /* A spy on handleCallErrors to check whether it is being invoked or not depending on tests */
    var handleErrorSpy = jest.spyOn(Utils, 'handleCallErrors');
    var uploadLogsSpy = jest.spyOn(Utils, 'uploadLogs');
    var transferLoggingContext = {
      file: 'call',
      method: 'completeTransfer'
    };
    beforeEach(function () {
      /* We will put the first call on hold to perform the transfer */
      call['held'] = true;

      /* We will create a second call just like the first call, but call is active, i.e, not held */
      secondCall = new _call.Call(activeUrl, webex, _types3.CallDirection.OUTBOUND, deviceId, mockLineId, function () {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var dummy = 10;
      }, defaultServiceIndicator, transfereeDest);
      secondCall['connected'] = true;
      secondCall['earlyMedia'] = false;
      secondCall['callStateMachine'].state.value = 'S_CALL_ESTABLISHED';
      secondCall.removeAllListeners(_types2.CALL_EVENT_KEYS.CALL_ERROR);
      secondCall['held'] = false;
    });
    it('Handle successful consult transfer case ', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee63() {
      var responsePayload, requestSpy, warnSpy, infoSpy, metricSpy;
      return _regenerator.default.wrap(function _callee63$(_context63) {
        while (1) switch (_context63.prev = _context63.next) {
          case 0:
            expect.assertions(10);
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            requestSpy = jest.spyOn(webex, 'request').mockResolvedValue(responsePayload);
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            infoSpy = jest.spyOn(_Logger.default, 'info');
            metricSpy = jest.spyOn(call['metricManager'], 'submitCallMetric');
            call.on(_types2.CALL_EVENT_KEYS.DISCONNECT, /*#__PURE__*/function () {
              var _ref62 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee61(correlationId) {
                return _regenerator.default.wrap(function _callee61$(_context61) {
                  while (1) switch (_context61.prev = _context61.next) {
                    case 0:
                      expect(correlationId).toStrictEqual(call.getCorrelationId());
                    case 1:
                    case "end":
                      return _context61.stop();
                  }
                }, _callee61);
              }));
              return function (_x11) {
                return _ref62.apply(this, arguments);
              };
            }());
            secondCall.on(_types2.CALL_EVENT_KEYS.DISCONNECT, /*#__PURE__*/function () {
              var _ref63 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee62(correlationId) {
                return _regenerator.default.wrap(function _callee62$(_context62) {
                  while (1) switch (_context62.prev = _context62.next) {
                    case 0:
                      expect(correlationId).toStrictEqual(secondCall.getCorrelationId());
                    case 1:
                    case "end":
                      return _context62.stop();
                  }
                }, _callee62);
              }));
              return function (_x12) {
                return _ref63.apply(this, arguments);
              };
            }());
            _context63.next = 10;
            return call.completeTransfer(_types5.TransferType.CONSULT, secondCall.getCallId(), undefined);
          case 10:
            _context63.next = 12;
            return (0, _testUtil.flushPromises)(2);
          case 12:
            expect(requestSpy).toBeCalled();
            expect(metricSpy).toHaveBeenCalledWith(_types4.METRIC_EVENT.CALL, _types4.TRANSFER_ACTION.CONSULT, _types4.METRIC_TYPE.BEHAVIORAL, call.getCallId(), call.getCorrelationId(), undefined);
            call.sendCallStateMachineEvt({
              type: 'E_RECV_CALL_DISCONNECT'
            });
            secondCall.sendCallStateMachineEvt({
              type: 'E_RECV_CALL_DISCONNECT'
            });

            /* We should return back to S_RECV_CALL_DISCONNECT state for both the calls */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_RECV_CALL_DISCONNECT');
            expect(secondCall['callStateMachine'].state.value).toStrictEqual('S_RECV_CALL_DISCONNECT');
            expect(handleErrorSpy).not.toBeCalled();
            expect(uploadLogsSpy).not.toBeCalled();
            expect(infoSpy).toHaveBeenCalledWith("Initiating Consult transfer between : ".concat(call.getCallId(), " and ").concat(secondCall.getCallId()), transferLoggingContext);
            expect(warnSpy).not.toHaveBeenCalledWith("Consult Transfer failed for correlationId ".concat(call.getCorrelationId()), transferLoggingContext);
          case 22:
          case "end":
            return _context63.stop();
        }
      }, _callee63);
    })));
    it('Handle successful blind transfer case ', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee65() {
      var responsePayload, requestSpy, warnSpy, infoSpy, metricSpy;
      return _regenerator.default.wrap(function _callee65$(_context65) {
        while (1) switch (_context65.prev = _context65.next) {
          case 0:
            expect.assertions(8);
            responsePayload = {
              statusCode: 200,
              body: mockResponseBody
            };
            requestSpy = jest.spyOn(webex, 'request').mockResolvedValue(responsePayload);
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            infoSpy = jest.spyOn(_Logger.default, 'info');
            metricSpy = jest.spyOn(call['metricManager'], 'submitCallMetric');
            call.on(_types2.CALL_EVENT_KEYS.DISCONNECT, /*#__PURE__*/function () {
              var _ref65 = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee64(correlationId) {
                return _regenerator.default.wrap(function _callee64$(_context64) {
                  while (1) switch (_context64.prev = _context64.next) {
                    case 0:
                      expect(correlationId).toStrictEqual(call.getCorrelationId());
                    case 1:
                    case "end":
                      return _context64.stop();
                  }
                }, _callee64);
              }));
              return function (_x13) {
                return _ref65.apply(this, arguments);
              };
            }());
            _context65.next = 9;
            return call.completeTransfer(_types5.TransferType.BLIND, undefined, transfereeNumber);
          case 9:
            _context65.next = 11;
            return (0, _testUtil.flushPromises)(2);
          case 11:
            expect(requestSpy).toBeCalled();
            expect(metricSpy).toHaveBeenCalledWith(_types4.METRIC_EVENT.CALL, _types4.TRANSFER_ACTION.BLIND, _types4.METRIC_TYPE.BEHAVIORAL, call.getCallId(), call.getCorrelationId(), undefined);
            call.sendCallStateMachineEvt({
              type: 'E_RECV_CALL_DISCONNECT'
            });

            /* We should return back to S_RECV_CALL_DISCONNECT state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_RECV_CALL_DISCONNECT');
            expect(handleErrorSpy).not.toBeCalled();
            expect(uploadLogsSpy).not.toBeCalled();
            expect(infoSpy).toHaveBeenCalledWith("Initiating Blind transfer with : ".concat(transfereeNumber), transferLoggingContext);
            expect(warnSpy).not.toHaveBeenCalledWith("Blind Transfer failed for correlationId ".concat(call.getCorrelationId()), transferLoggingContext);
          case 19:
          case "end":
            return _context65.stop();
        }
      }, _callee65);
    })));
    it('Handle unsuccessful blind transfer case', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee66() {
      var responsePayload, emitSpy, requestSpy, warnSpy, metricSpy;
      return _regenerator.default.wrap(function _callee66$(_context66) {
        while (1) switch (_context66.prev = _context66.next) {
          case 0:
            responsePayload = {
              statusCode: 403,
              body: mockResponseBody
            };
            emitSpy = jest.spyOn(call, 'emit');
            requestSpy = jest.spyOn(webex, 'request').mockRejectedValue(responsePayload);
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            metricSpy = jest.spyOn(call['metricManager'], 'submitCallMetric');
            _context66.next = 7;
            return call.completeTransfer(_types5.TransferType.BLIND, undefined, transfereeNumber);
          case 7:
            _context66.next = 9;
            return (0, _testUtil.flushPromises)(1);
          case 9:
            expect(requestSpy).toBeCalled();
            /* We should be in CALL_ESTABLISHED state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            expect(call['held']).toBe(true);
            expect(handleErrorSpy).toHaveBeenCalledWith(expect.anything(), _types.ERROR_LAYER.CALL_CONTROL,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            expect.anything(), call.getCorrelationId(), responsePayload, 'completeTransfer', 'call');
            expect(uploadLogsSpy).toHaveBeenCalledWith({
              correlationId: call.getCorrelationId(),
              callId: call.getCallId()
            });
            /* check whether error event is being emitted by sdk */
            expect(emitSpy).toBeCalledOnceWith(_types2.CALL_EVENT_KEYS.TRANSFER_ERROR, expect.any(_Errors.CallError));
            expect(warnSpy).toHaveBeenCalledWith("Blind Transfer failed for correlationId ".concat(call.getCorrelationId()), transferLoggingContext);
            expect(metricSpy).toHaveBeenCalledWith(_types4.METRIC_EVENT.CALL_ERROR, _types4.TRANSFER_ACTION.BLIND, _types4.METRIC_TYPE.BEHAVIORAL, call.getCallId(), call.getCorrelationId(), expect.any(_Errors.CallError));
          case 17:
          case "end":
            return _context66.stop();
        }
      }, _callee66);
    })));
    it('Handle unsuccessful consult transfer case', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee67() {
      var responsePayload, emitSpy, requestSpy, warnSpy, metricSpy;
      return _regenerator.default.wrap(function _callee67$(_context67) {
        while (1) switch (_context67.prev = _context67.next) {
          case 0:
            responsePayload = {
              statusCode: 403,
              body: mockResponseBody
            };
            emitSpy = jest.spyOn(call, 'emit');
            requestSpy = jest.spyOn(webex, 'request').mockRejectedValue(responsePayload);
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            metricSpy = jest.spyOn(call['metricManager'], 'submitCallMetric');
            _context67.next = 7;
            return call.completeTransfer(_types5.TransferType.CONSULT, secondCall.getCallId(), undefined);
          case 7:
            _context67.next = 9;
            return (0, _testUtil.flushPromises)(2);
          case 9:
            expect(requestSpy).toBeCalled();
            /* We should be in CALL_ESTABLISHED state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            expect(call['held']).toBe(true);
            expect(secondCall['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            expect(handleErrorSpy).toHaveBeenCalledWith(expect.anything(), _types.ERROR_LAYER.CALL_CONTROL,
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            expect.anything(), call.getCorrelationId(), responsePayload, 'completeTransfer', 'call');
            expect(uploadLogsSpy).toHaveBeenCalledWith({
              correlationId: call.getCorrelationId(),
              callId: call.getCallId()
            });
            /* check whether error event is being emitted by sdk */
            expect(emitSpy).toHaveBeenCalledWith(_types2.CALL_EVENT_KEYS.TRANSFER_ERROR, expect.any(_Errors.CallError));
            expect(warnSpy).toHaveBeenCalledWith("Consult Transfer failed for correlationId ".concat(call.getCorrelationId()), transferLoggingContext);
            expect(metricSpy).toHaveBeenCalledWith(_types4.METRIC_EVENT.CALL_ERROR, _types4.TRANSFER_ACTION.CONSULT, _types4.METRIC_TYPE.BEHAVIORAL, call.getCallId(), call.getCorrelationId(), expect.any(_Errors.CallError));
          case 18:
          case "end":
            return _context67.stop();
        }
      }, _callee67);
    })));
    it('Handle blind transfer with undefined transferTarget', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee68() {
      var requestSpy, warnSpy;
      return _regenerator.default.wrap(function _callee68$(_context68) {
        while (1) switch (_context68.prev = _context68.next) {
          case 0:
            requestSpy = jest.spyOn(webex, 'request');
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            _context68.next = 4;
            return call.completeTransfer(_types5.TransferType.BLIND, undefined, undefined);
          case 4:
            /* We should be in CALL_ESTABLISHED state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            expect(secondCall['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            expect(handleErrorSpy).not.toBeCalled();
            expect(uploadLogsSpy).not.toBeCalled();
            expect(requestSpy).not.toBeCalled();
            expect(warnSpy).toBeCalledOnceWith("Invalid information received, transfer failed for correlationId: ".concat(call.getCorrelationId()), transferLoggingContext);
          case 10:
          case "end":
            return _context68.stop();
        }
      }, _callee68);
    })));
    it('Handle consult transfer with undefined transferCallId', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee69() {
      var requestSpy, warnSpy;
      return _regenerator.default.wrap(function _callee69$(_context69) {
        while (1) switch (_context69.prev = _context69.next) {
          case 0:
            requestSpy = jest.spyOn(webex, 'request');
            warnSpy = jest.spyOn(_Logger.default, 'warn');
            _context69.next = 4;
            return call.completeTransfer(_types5.TransferType.CONSULT, undefined, undefined);
          case 4:
            /* We should be in CALL_ESTABLISHED state */
            expect(call['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            expect(secondCall['callStateMachine'].state.value).toStrictEqual('S_CALL_ESTABLISHED');
            expect(handleErrorSpy).not.toBeCalled();
            expect(uploadLogsSpy).not.toBeCalled();
            expect(requestSpy).not.toBeCalled();
            expect(warnSpy).toBeCalledOnceWith("Invalid information received, transfer failed for correlationId: ".concat(call.getCorrelationId()), transferLoggingContext);
          case 10:
          case "end":
            return _context69.stop();
        }
      }, _callee69);
    })));
  });
});
//# sourceMappingURL=call.test.js.map
