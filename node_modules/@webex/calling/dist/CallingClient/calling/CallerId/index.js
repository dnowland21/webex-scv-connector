"use strict";

var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.createCallerId = exports.CallerId = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _index = _interopRequireDefault(require("../../../Logger/index"));
var _constants = require("../../constants");
var _SDKConnector = _interopRequireDefault(require("../../../SDKConnector"));
var _common = require("../../../common");
/* eslint-disable no-underscore-dangle */
/* eslint-disable valid-jsdoc */
/**
 *
 */
var CallerId = exports.CallerId = /*#__PURE__*/function () {
  /**
   * Start the callerId instance.
   *
   * @param webex -.
   * @param callObj -.
   * @param emitter -.
   */
  function CallerId(webex, emitter) {
    (0, _classCallCheck2.default)(this, CallerId);
    (0, _defineProperty2.default)(this, "webex", void 0);
    (0, _defineProperty2.default)(this, "callerInfo", void 0);
    (0, _defineProperty2.default)(this, "sdkConnector", void 0);
    (0, _defineProperty2.default)(this, "emitter", void 0);
    this.sdkConnector = _SDKConnector.default;
    this.callerInfo = {};
    if (!this.sdkConnector.getWebex()) {
      _SDKConnector.default.setWebex(webex);
    }
    this.webex = this.sdkConnector.getWebex();
    this.emitter = emitter;
  }

  /**
   * The handler which processes the data received from the SCIM query
   * performed through externalId.
   *
   * @param filter - A filter to be used for query.
   */
  (0, _createClass2.default)(CallerId, [{
    key: "resolveCallerId",
    value: (function () {
      var _resolveCallerId = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(filter) {
        var displayResult, isChanged;
        return _regenerator.default.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return (0, _common.resolveCallerIdDisplay)(filter);
            case 2:
              displayResult = _context.sent;
              isChanged = false;
              /* It makes sense to emit only if the resolution gives different results than what we already have.
               * Note that results gathered from the SCIM Query is always given preference.
               */
              if (displayResult.name && this.callerInfo.name !== displayResult.name) {
                _index.default.info('Updating Name after resolution', {
                  file: _constants.CALLER_ID_FILE,
                  method: 'resolveCallerId'
                });
                this.callerInfo.name = displayResult.name;
                isChanged = true;
              }
              if (displayResult.num && this.callerInfo.num !== displayResult.num) {
                _index.default.info('Updating Number after resolution', {
                  file: _constants.CALLER_ID_FILE,
                  method: 'resolveCallerId'
                });
                this.callerInfo.num = displayResult.num;
                isChanged = true;
              }
              if (!this.callerInfo.avatarSrc || this.callerInfo.avatarSrc !== displayResult.avatarSrc) {
                _index.default.info('Updating Avatar Id after resolution', {
                  file: _constants.CALLER_ID_FILE,
                  method: 'resolveCallerId'
                });
                this.callerInfo.avatarSrc = displayResult.avatarSrc;
                isChanged = true;
              }
              if (!this.callerInfo.id || this.callerInfo.id !== displayResult.id) {
                _index.default.info('Updating User Id after resolution', {
                  file: _constants.CALLER_ID_FILE,
                  method: 'resolveCallerId'
                });
                this.callerInfo.id = displayResult.id;
                isChanged = true;
              }
              if (isChanged) {
                this.emitter(this.callerInfo);
              }
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee, this);
      }));
      function resolveCallerId(_x) {
        return _resolveCallerId.apply(this, arguments);
      }
      return resolveCallerId;
    }()
    /**
     *  Remote party Id parser.
     *
     * @param data - Entire URI string.
     */
    )
  }, {
    key: "parseRemotePartyInfo",
    value: (function () {
      var _parseRemotePartyInfo = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(data) {
        var lastToken, externalId;
        return _regenerator.default.wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              /* External Id will be the last token if at all it exists */
              lastToken = data.split(';').slice(-1)[0];
              if (lastToken.includes('externalId')) {
                externalId = lastToken.split('=')[1];
                _index.default.info("externalId retrieved: ".concat(externalId), {
                  file: _constants.CALLER_ID_FILE,
                  method: 'parseRemotePartyInfo'
                });
                this.resolveCallerId("id eq \"".concat(externalId, "\""));
              } else {
                _index.default.warn("externalId not found!", {
                  file: _constants.CALLER_ID_FILE,
                  method: 'parseRemotePartyInfo'
                });
              }
            case 2:
            case "end":
              return _context2.stop();
          }
        }, _callee2, this);
      }));
      function parseRemotePartyInfo(_x2) {
        return _parseRemotePartyInfo.apply(this, arguments);
      }
      return parseRemotePartyInfo;
    }()
    /**
     *  Parser for SIP Uris.
     *
     * @param paid - Entire sip uri. Can be PA-Id or From header.
     * @returns -  a collection of name and number.
     * @example
     * const paid1 = '"John O' Connor - (Guest)" <sip:1234567890@domain>';
     * const result1 = parseSipUri(paid1);
     * result1.name = "John O' Connor - (Guest)"
     * result1.num = "1234567890"
     */
    )
  }, {
    key: "parseSipUri",
    value: function parseSipUri(paid) {
      var result = {};

      // Extract name
      var nameMatch = paid.split('<')[0].replace(/"/g, '');
      if (nameMatch) {
        result.name = nameMatch.trim();
      } else {
        _index.default.warn("Name field not found!", {
          file: _constants.CALLER_ID_FILE,
          method: 'parseSipUri'
        });
      }

      // Extract number
      var data = paid.split('@')[0].replace(/"/g, '');
      var num = data.substring(data.indexOf(':') + 1, data.length);
      var phoneMatch = num.match(_constants.VALID_PHONE_REGEX);
      if (phoneMatch && phoneMatch[0].length === num.length) {
        result.num = num;
      } else {
        _index.default.warn("Number field not found!", {
          file: _constants.CALLER_ID_FILE,
          method: 'parseSipUri'
        });
      }
      return result;
    }

    /**
     * The main entrypoint of the Caller-Id instance.
     * It returns intermediate name and number and starts the
     * caller Id resolution in background.
     *
     * @param callerId - CallerId data passed to us by Call Instance.
     * @returns - A collection of name and number.
     */
  }, {
    key: "fetchCallerDetails",
    value: function fetchCallerDetails(callerId) {
      /* resetting previously set fields */
      this.callerInfo.id = undefined;
      this.callerInfo.avatarSrc = undefined;
      this.callerInfo.name = undefined;
      this.callerInfo.num = undefined;
      if ('p-asserted-identity' in callerId) {
        _index.default.info('Parsing p-asserted-identity within remote party information', {
          file: _constants.CALLER_ID_FILE,
          method: 'fetchCallerDetails'
        });
        var result = this.parseSipUri(callerId['p-asserted-identity']);

        /* For P-Asserted-Identity, we update the callerInfo blindly, as it is of highest preference */
        this.callerInfo.name = result.name;
        this.callerInfo.num = result.num;
      }
      if (callerId.from) {
        _index.default.info('Parsing from header within the remote party information', {
          file: _constants.CALLER_ID_FILE,
          method: 'fetchCallerDetails'
        });
        var _result = this.parseSipUri(callerId.from);

        /* For From header , we should only update if not filled already by P-Asserted-Identity */
        if (!this.callerInfo.name && _result.name) {
          _index.default.info('Updating name field from From header', {
            file: _constants.CALLER_ID_FILE,
            method: 'fetchCallerDetails'
          });
          this.callerInfo.name = _result.name;
        }
        if (!this.callerInfo.num && _result.num) {
          _index.default.info('Updating number field from From header', {
            file: _constants.CALLER_ID_FILE,
            method: 'fetchCallerDetails'
          });
          this.callerInfo.num = _result.num;
        }
      }

      /* Emit the intermediate CallerId */

      if (this.callerInfo.name || this.callerInfo.num) {
        this.emitter(this.callerInfo);
      }

      /* We need to parse x-broadworks-remote-party-info if present asynchronously */
      if ('x-broadworks-remote-party-info' in callerId) {
        _index.default.info('Parsing x-broadworks-remote-party-info within remote party information', {
          file: _constants.CALLER_ID_FILE,
          method: 'fetchCallerDetails'
        });
        this.parseRemotePartyInfo(callerId['x-broadworks-remote-party-info']);
      }
      return this.callerInfo;
    }
  }]);
  return CallerId;
}();
/**
 * To create CallerId instance.
 *
 * @param webex -.
 * @param emitterCb -.
 */
var createCallerId = exports.createCallerId = function createCallerId(webex, emitterCb) {
  return new CallerId(webex, emitterCb);
};
//# sourceMappingURL=index.js.map
