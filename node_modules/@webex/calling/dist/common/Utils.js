"use strict";

var _typeof = require("@babel/runtime-corejs2/helpers/typeof");
var _Array$from = require("@babel/runtime-corejs2/core-js/array/from");
var _Symbol = require("@babel/runtime-corejs2/core-js/symbol");
var _Symbol$iterator = require("@babel/runtime-corejs2/core-js/symbol/iterator");
var _Array$isArray = require("@babel/runtime-corejs2/core-js/array/is-array");
var _Object$keys2 = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _WeakMap = require("@babel/runtime-corejs2/core-js/weak-map");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.emitFinalFailure = emitFinalFailure;
exports.fetchVoicemailList = fetchVoicemailList;
exports.filterMobiusUris = filterMobiusUris;
exports.getCallingBackEnd = getCallingBackEnd;
exports.getSortedVoicemailList = getSortedVoicemailList;
exports.getVgActionEndpoint = getVgActionEndpoint;
exports.getXsiActionEndpoint = getXsiActionEndpoint;
exports.handleCallErrors = handleCallErrors;
exports.handleCallingClientErrors = handleCallingClientErrors;
exports.handleRegistrationErrors = handleRegistrationErrors;
exports.inferIdFromUuid = inferIdFromUuid;
exports.modifySdpForIPv4 = modifySdpForIPv4;
exports.parseMediaQualityStatistics = parseMediaQualityStatistics;
exports.resolveCallerIdByName = resolveCallerIdByName;
exports.resolveCallerIdDisplay = resolveCallerIdDisplay;
exports.resolveContact = resolveContact;
exports.scimQuery = scimQuery;
exports.serviceErrorCodeHandler = serviceErrorCodeHandler;
exports.storeVoicemailList = storeVoicemailList;
exports.uploadLogs = uploadLogs;
exports.validateServiceData = validateServiceData;
exports.waitForMsecs = void 0;
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _keys = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/keys"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
var _promise = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/promise"));
var _values = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/values"));
var _parseInt2 = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/parse-int"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var platform = _interopRequireWildcard(require("platform"));
var _types = require("../Metrics/types");
var _Metrics = require("../Metrics");
var _CallError = require("../Errors/catalog/CallError");
var _types2 = require("../Errors/types");
var _types3 = require("./types");
var _Logger = _interopRequireDefault(require("../Logger"));
var _CallingDeviceError = require("../Errors/catalog/CallingDeviceError");
var _constants = require("../CallingClient/constants");
var _constants2 = require("./constants");
var _SDKConnector = _interopRequireDefault(require("../SDKConnector"));
var _LineError = require("../Errors/catalog/LineError");
function _getRequireWildcardCache(e) { if ("function" != typeof _WeakMap) return null; var r = new _WeakMap(), t = new _WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != _typeof(e) && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = _Object$defineProperty && _Object$getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) { var i = a ? _Object$getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? _Object$defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
function ownKeys(e, r) { var t = _Object$keys2(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof _Symbol !== "undefined" && o[_Symbol$iterator] || o["@@iterator"]; if (!it) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return _Array$from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; } /* eslint-disable no-fallthrough */ /* eslint-disable no-underscore-dangle */ /* eslint-disable @typescript-eslint/no-shadow */
function filterMobiusUris(mobiusServers, defaultMobiusUrl) {
  var _mobiusServers$primar, _mobiusServers$backup;
  var logContext = {
    file: _constants.UTILS_FILE,
    method: filterMobiusUris.name
  };
  var urisArrayPrimary = [];
  var urisArrayBackup = [];
  if (mobiusServers !== null && mobiusServers !== void 0 && (_mobiusServers$primar = mobiusServers.primary) !== null && _mobiusServers$primar !== void 0 && _mobiusServers$primar.uris) {
    _Logger.default.info('Adding Primary uris', logContext);
    var _iterator = _createForOfIteratorHelper(mobiusServers.primary.uris),
      _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var uri = _step.value;
        urisArrayPrimary.push("".concat(uri).concat(_constants.URL_ENDPOINT));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  if (mobiusServers !== null && mobiusServers !== void 0 && (_mobiusServers$backup = mobiusServers.backup) !== null && _mobiusServers$backup !== void 0 && _mobiusServers$backup.uris) {
    _Logger.default.info('Adding Backup uris', logContext);
    var _iterator2 = _createForOfIteratorHelper(mobiusServers.backup.uris),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _uri = _step2.value;
        urisArrayBackup.push("".concat(_uri).concat(_constants.URL_ENDPOINT));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  /*
   * If there are no entries in both primary and backup arrays then add the default
   * uri in primary array, otherwise in backup.
   */
  _Logger.default.info('Adding Default uri', logContext);
  if (!urisArrayPrimary.length && !urisArrayBackup.length) {
    urisArrayPrimary.push("".concat(defaultMobiusUrl).concat(_constants.URL_ENDPOINT));
  } else {
    urisArrayBackup.push("".concat(defaultMobiusUrl).concat(_constants.URL_ENDPOINT));
  }
  var primaryUris = [];
  var backupUris = [];

  /* Remove duplicates from primary by keeping the order intact */
  for (var i = 0; i < urisArrayPrimary.length; i += 1) {
    if (primaryUris.indexOf(urisArrayPrimary[i]) === -1) {
      primaryUris.push(urisArrayPrimary[i]);
    }
  }

  /* Remove duplicates from backup by keeping the order intact */
  for (var _i = 0; _i < urisArrayBackup.length; _i += 1) {
    if (backupUris.indexOf(urisArrayBackup[_i]) === -1) {
      backupUris.push(urisArrayBackup[_i]);
    }
  }
  return {
    primary: primaryUris,
    backup: backupUris
  };
}

/**
 * Updates the error context for a particular calling client instance.
 *
 * @param errContext - Error Context as generated by the caller.
 * @param type - Error type based on status code.
 * @param message - Custom message for user.
 * @param correlationId - Unique identifier for a call.
 * @param callError - Call error instance.
 */
function updateCallErrorContext(errContext, type, message, correlationId, callError) {
  var errObj = {};
  errObj.context = errContext;
  errObj.type = type;
  errObj.message = message;
  errObj.correlationId = correlationId;
  callError.setCallError(errObj);
}

/**
 * Updates the error context for a particular line instance.
 *
 * @param errContext - Error Context.
 * @param type - Error type based on status code.
 * @param message - Custom message for user.
 * @param status - Status of line.
 * @param lineError - Line error instance.
 */
function updateLineErrorContext(errContext, type, message, status, lineError) {
  var errObj = {};
  errObj.context = errContext;
  errObj.type = type;
  errObj.message = message;
  errObj.status = status;
  lineError.setError(errObj);
}

/**
 * Updates the error context for a particular calling client instance.
 *
 * @param errContext - Error Context as generated by the caller.
 * @param type - Error type based on status code.
 * @param message - Custom message for user.
 * @param clientError - Client Error.
 */
function updateErrorContext(errContext, type, message, clientError) {
  var errObj = {};
  errObj.context = errContext;
  errObj.type = type;
  errObj.message = message;
  clientError.setError(errObj);
}

/**
 * Emits final failure to the client after it gives up
 * retrying registration and records error metric.
 *
 * @param line - Instance of line.
 * @param caller - Method which called this handler.
 * @param file - File name from where error got reported.
 */
function emitFinalFailure(emitterCb, loggerContext) {
  var clientError = (0, _LineError.createLineError)('', {}, _types2.ERROR_TYPE.DEFAULT, _types3.RegistrationStatus.INACTIVE);
  updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.SERVICE_UNAVAILABLE, 'An unknown error occurred. Wait a moment and try again. Please contact the administrator if the problem persists.', _types3.RegistrationStatus.INACTIVE, clientError);
  emitterCb(clientError);
}

/**
 * Handle various Registration related Error flows here. Decide whether to emit event or retry.
 * @param err - Error body.
 * @param emitterCb - LineErrorEmitterCallback
 * @param loggerContext - Logging context that has method and file name
 * @param restoreRegCb - Callback which will try restoring resgistration in case of 403
 *
 * In emitterCb,
 * For non final error scenarios in registration flow,
 * send Unregistered event only without any error message
 * in order to have the web client update only the UI
 * state to disconnected and not show any error dialog
 * to the end user as in those scenarios a retry will
 * be scheduled to attempt registration again.
 *
 */
function handleRegistrationErrors(_x, _x2, _x3, _x4, _x5) {
  return _handleRegistrationErrors.apply(this, arguments);
}
/**
 * Handle various Error flows related to calling client here. Decide whether to emit event or retry.
 * @param err - Error body.
 * @param emitterCb - CallingClientErrorEmitter
 * @param loggerContext - Logging context that has method and file name
 * @param restoreRegCb - Callback which will try restoring resgistration in case of 403
 */
function _handleRegistrationErrors() {
  _handleRegistrationErrors = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee(err, emitterCb, loggerContext, retry429Cb, restoreRegCb) {
    var lineError, errorCode, finalError, caller, retryAfter, errorBody, code, errorMessage, _caller, _errorMessage, _errorMessage2, _errorMessage3;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          lineError = (0, _LineError.createLineError)('', {}, _types2.ERROR_TYPE.DEFAULT, _types3.RegistrationStatus.INACTIVE);
          errorCode = Number(err.statusCode);
          finalError = false;
          _Logger.default.warn("Status code: -> ".concat(errorCode), loggerContext);
          _context.t0 = errorCode;
          _context.next = _context.t0 === _types2.ERROR_CODE.BAD_REQUEST ? 7 : _context.t0 === _types2.ERROR_CODE.UNAUTHORIZED ? 12 : _context.t0 === _types2.ERROR_CODE.DEVICE_NOT_FOUND ? 17 : _context.t0 === _types2.ERROR_CODE.TOO_MANY_REQUESTS ? 22 : _context.t0 === _types2.ERROR_CODE.INTERNAL_SERVER_ERROR ? 26 : _context.t0 === _types2.ERROR_CODE.SERVICE_UNAVAILABLE ? 30 : _context.t0 === _types2.ERROR_CODE.FORBIDDEN ? 34 : 69;
          break;
        case 7:
          finalError = true;
          _Logger.default.warn("400 Bad Request", loggerContext);
          updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.SERVER_ERROR, 'Invalid input. Please verify the required parameters, sign out and then sign back in with the valid data', _types3.RegistrationStatus.INACTIVE, lineError);
          emitterCb(lineError, finalError);
          return _context.abrupt("break", 72);
        case 12:
          // Return it to the Caller
          finalError = true;
          _Logger.default.warn("401 Unauthorized", loggerContext);
          updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.TOKEN_ERROR, 'User is unauthorized due to an expired token. Sign out, then sign back in.', _types3.RegistrationStatus.INACTIVE, lineError);
          emitterCb(lineError, finalError);
          return _context.abrupt("break", 72);
        case 17:
          finalError = true;
          _Logger.default.warn("404 Device Not Found", loggerContext);
          updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.NOT_FOUND, 'Webex Calling is unable to find your device. Sign out, then sign back in', _types3.RegistrationStatus.INACTIVE, lineError);
          emitterCb(lineError, finalError);
          return _context.abrupt("break", 72);
        case 22:
          _Logger.default.warn("429 Too Many Requests", loggerContext);
          caller = loggerContext.method || 'handleErrors';
          if (retry429Cb && err.headers) {
            retryAfter = Number(err.headers['retry-after']);
            retry429Cb(retryAfter, caller);
          }
          return _context.abrupt("break", 72);
        case 26:
          _Logger.default.warn("500 Internal Server Error", loggerContext);
          updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.SERVER_ERROR, 'An unknown error occurred while placing the request. Wait a moment and try again.', _types3.RegistrationStatus.INACTIVE, lineError);
          emitterCb(lineError, finalError);
          return _context.abrupt("break", 72);
        case 30:
          _Logger.default.warn("503 Service Unavailable", loggerContext);
          updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.SERVICE_UNAVAILABLE, 'An error occurred on the server while processing the request. Wait a moment and try again.', _types3.RegistrationStatus.INACTIVE, lineError);
          emitterCb(lineError, finalError);
          return _context.abrupt("break", 72);
        case 34:
          _Logger.default.warn("403 Forbidden", loggerContext);
          errorBody = err.body;
          if (errorBody) {
            _context.next = 41;
            break;
          }
          _Logger.default.warn('Error response has no body, throwing default error', loggerContext);
          updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.FORBIDDEN_ERROR, 'An unauthorized action has been received. This action has been blocked. Please contact the administrator if this persists.', _types3.RegistrationStatus.INACTIVE, lineError);
          emitterCb(lineError, finalError);
          return _context.abrupt("return", finalError);
        case 41:
          code = Number(errorBody.errorCode);
          _Logger.default.warn("Error code found : ".concat(code), loggerContext);
          _context.t1 = code;
          _context.next = _context.t1 === _types2.DEVICE_ERROR_CODE.DEVICE_LIMIT_EXCEEDED ? 46 : _context.t1 === _types2.DEVICE_ERROR_CODE.DEVICE_CREATION_DISABLED ? 53 : _context.t1 === _types2.DEVICE_ERROR_CODE.DEVICE_CREATION_FAILED ? 59 : 64;
          break;
        case 46:
          errorMessage = 'User device limit exceeded';
          _Logger.default.warn(errorMessage, loggerContext);
          if (!restoreRegCb) {
            _context.next = 52;
            break;
          }
          _caller = loggerContext.method || 'handleErrors';
          _context.next = 52;
          return restoreRegCb(errorBody, _caller);
        case 52:
          return _context.abrupt("break", 68);
        case 53:
          _errorMessage = 'User is not configured for WebRTC calling. Please contact the administrator to resolve this issue.';
          finalError = true;
          updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.FORBIDDEN_ERROR, _errorMessage, _types3.RegistrationStatus.INACTIVE, lineError);
          _Logger.default.warn(_errorMessage, loggerContext);
          emitterCb(lineError, true);
          return _context.abrupt("break", 68);
        case 59:
          _errorMessage2 = 'An unknown error occurred while provisioning the device. Wait a moment and try again.';
          updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.FORBIDDEN_ERROR, _errorMessage2, _types3.RegistrationStatus.INACTIVE, lineError);
          _Logger.default.warn(_errorMessage2, loggerContext);
          emitterCb(lineError, finalError);
          return _context.abrupt("break", 68);
        case 64:
          _errorMessage3 = 'An unknown error occurred. Wait a moment and try again. Please contact the administrator if the problem persists.';
          updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.FORBIDDEN_ERROR, _errorMessage3, _types3.RegistrationStatus.INACTIVE, lineError);
          _Logger.default.warn(_errorMessage3, loggerContext);
          emitterCb(lineError, finalError);
        case 68:
          return _context.abrupt("break", 72);
        case 69:
          updateLineErrorContext(loggerContext, _types2.ERROR_TYPE.DEFAULT, 'Unknown error', _types3.RegistrationStatus.INACTIVE, lineError);
          _Logger.default.warn("Unknown Error", loggerContext);
          emitterCb(lineError, finalError);
        case 72:
          return _context.abrupt("return", finalError);
        case 73:
        case "end":
          return _context.stop();
      }
    }, _callee);
  }));
  return _handleRegistrationErrors.apply(this, arguments);
}
function handleCallingClientErrors(_x6, _x7, _x8) {
  return _handleCallingClientErrors.apply(this, arguments);
}
/**
 * Handler for call related errors.
 *
 * @param emitterCb - Event emitter function.
 * @param errorType - Type of error experienced.
 * @param errorLayer - Call control or media layer.
 * @param retryCb - Failure retry function.
 * @param correlationId - CorrelationId of the call.
 * @param err - Error Response.
 * @param caller - Caller function.
 * @param file - File name.
 */
function _handleCallingClientErrors() {
  _handleCallingClientErrors = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2(err, emitterCb, loggerContext) {
    var clientError, errorCode, finalError;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          clientError = (0, _CallingDeviceError.createClientError)('', {}, _types2.ERROR_TYPE.DEFAULT, _types3.RegistrationStatus.INACTIVE);
          errorCode = Number(err.statusCode);
          finalError = false;
          _Logger.default.warn("Status code: -> ".concat(errorCode), loggerContext);
          _context2.t0 = errorCode;
          _context2.next = _context2.t0 === _types2.ERROR_CODE.INTERNAL_SERVER_ERROR ? 7 : 11;
          break;
        case 7:
          _Logger.default.warn("500 Internal Server Error", loggerContext);
          updateErrorContext(loggerContext, _types2.ERROR_TYPE.SERVER_ERROR, 'An unknown error occurred while placing the request. Wait a moment and try again.', clientError);
          emitterCb(clientError, finalError);
          return _context2.abrupt("break", 14);
        case 11:
          updateErrorContext(loggerContext, _types2.ERROR_TYPE.DEFAULT, 'Unknown error', clientError);
          _Logger.default.warn("Unknown Error", loggerContext);
          emitterCb(clientError, finalError);
        case 14:
          _context2.next = 16;
          return uploadLogs();
        case 16:
          return _context2.abrupt("return", finalError);
        case 17:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  }));
  return _handleCallingClientErrors.apply(this, arguments);
}
function handleCallErrors(_x9, _x10, _x11, _x12, _x13, _x14, _x15) {
  return _handleCallErrors.apply(this, arguments);
}
/**
 *Function to return error details.
 *
 * @param errorCode - WebexRequestPayload // Error status code for failed cases.
 * @param err -.
 * @param loggerContext -.
 * @returns Error response (status code and error message).
 */
function _handleCallErrors() {
  _handleCallErrors = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3(emitterCb, errorLayer, retryCb, correlationId, err, caller, file) {
    var loggerContext, callError, errorCode, errorBody, retryInterval, code, message;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          loggerContext = {
            file: file,
            method: caller
          };
          callError = (0, _CallError.createCallError)('', loggerContext, _types2.ERROR_TYPE.DEFAULT, '', errorLayer);
          errorCode = Number(err.statusCode);
          _Logger.default.warn("Status code: ->".concat(errorCode), loggerContext);
          _context3.t0 = errorCode;
          _context3.next = _context3.t0 === _types2.ERROR_CODE.UNAUTHORIZED ? 7 : _context3.t0 === _types2.ERROR_CODE.FORBIDDEN ? 11 : _context3.t0 === _types2.ERROR_CODE.SERVICE_UNAVAILABLE ? 11 : _context3.t0 === _types2.ERROR_CODE.DEVICE_NOT_FOUND ? 48 : _context3.t0 === _types2.ERROR_CODE.INTERNAL_SERVER_ERROR ? 52 : 56;
          break;
        case 7:
          _Logger.default.warn("401 Unauthorized", loggerContext);
          updateCallErrorContext(loggerContext, _types2.ERROR_TYPE.TOKEN_ERROR, 'User is unauthorized due to an expired token. Sign out, then sign back in.', correlationId, callError);
          emitterCb(callError);
          return _context3.abrupt("break", 57);
        case 11:
          errorBody = err.body;
          if (errorBody) {
            _context3.next = 17;
            break;
          }
          _Logger.default.warn('Error response has no body, throwing default error', loggerContext);
          updateCallErrorContext(loggerContext, err.statusCode === 403 ? _types2.ERROR_TYPE.FORBIDDEN_ERROR : _types2.ERROR_TYPE.SERVICE_UNAVAILABLE, err.statusCode === 403 ? 'An unauthorized action has been received. This action has been blocked. Please contact the administrator if this persists.' : 'An error occurred on the server while processing the request. Wait a moment and try again.', correlationId, callError);
          emitterCb(callError);
          return _context3.abrupt("return");
        case 17:
          if (!(err.headers && 'retry-after' in err.headers && retryCb)) {
            _context3.next = 22;
            break;
          }
          retryInterval = Number(err.headers['retry-after']);
          _Logger.default.warn("Retry Interval received: ".concat(retryInterval), loggerContext);
          retryCb(retryInterval);
          return _context3.abrupt("return");
        case 22:
          /* Handling various Error codes */
          code = Number(errorBody.errorCode);
          _context3.t1 = code;
          _context3.next = _context3.t1 === _types2.CALL_ERROR_CODE.INVALID_STATUS_UPDATE ? 26 : _context3.t1 === _types2.CALL_ERROR_CODE.DEVICE_NOT_REGISTERED ? 28 : _context3.t1 === _types2.CALL_ERROR_CODE.CALL_NOT_FOUND ? 30 : _context3.t1 === _types2.CALL_ERROR_CODE.ERROR_PROCESSING ? 32 : _context3.t1 === _types2.CALL_ERROR_CODE.USER_BUSY ? 34 : _context3.t1 === _types2.CALL_ERROR_CODE.PARSING_ERROR ? 36 : _context3.t1 === _types2.CALL_ERROR_CODE.NOT_ACCEPTABLE ? 38 : _context3.t1 === _types2.CALL_ERROR_CODE.CALL_REJECTED ? 40 : _context3.t1 === _types2.CALL_ERROR_CODE.NOT_AVAILABLE ? 42 : 44;
          break;
        case 26:
          message = 'An invalid status update has been received for the call. Wait a moment and try again.';
          return _context3.abrupt("break", 45);
        case 28:
          message = 'The client has unregistered. Please wait for the client to register before attempting the call. If error persists, sign out, sign back in and attempt the call.';
          return _context3.abrupt("break", 45);
        case 30:
          message = 'Call is not found on the server. Wait a moment and try again.';
          return _context3.abrupt("break", 45);
        case 32:
          message = 'An error occurred while processing the call on the server. Wait a moment and try again.';
          return _context3.abrupt("break", 45);
        case 34:
          message = 'Called user is busy.';
          return _context3.abrupt("break", 45);
        case 36:
          message = 'An error occurred while parsing the provided information. Wait a moment and try again.';
          return _context3.abrupt("break", 45);
        case 38:
          message = 'An error occurred on the server while accepting the call. Wait a moment and try again. Please contact the administrator if this persists.';
          return _context3.abrupt("break", 45);
        case 40:
          message = 'Call rejected by the server. Wait a moment and try again. Please contact the administrator if this persists.';
          return _context3.abrupt("break", 45);
        case 42:
          message = 'Calling services not available. Wait a moment and try again. Please contact the administrator if this persists.';
          return _context3.abrupt("break", 45);
        case 44:
          message = 'An unknown error occurred. Wait a moment and try again.';
        case 45:
          /* We just emit the errors to the app */

          updateCallErrorContext(loggerContext, err.statusCode === 403 ? _types2.ERROR_TYPE.FORBIDDEN_ERROR : _types2.ERROR_TYPE.SERVICE_UNAVAILABLE, message, correlationId, callError);
          emitterCb(callError);
          return _context3.abrupt("break", 57);
        case 48:
          _Logger.default.warn("404 Call Not Found", loggerContext);
          updateCallErrorContext(loggerContext, _types2.ERROR_TYPE.NOT_FOUND, 'Call is no longer active. Wait a moment and try again.', correlationId, callError);
          emitterCb(callError);
          return _context3.abrupt("break", 57);
        case 52:
          _Logger.default.warn("500 Internal Server Error", loggerContext);
          updateCallErrorContext(loggerContext, _types2.ERROR_TYPE.SERVER_ERROR, 'An unknown error occurred in the call. Wait a moment and try again.', correlationId, callError);
          emitterCb(callError);
          return _context3.abrupt("break", 57);
        case 56:
          _Logger.default.warn("Unknown Error", loggerContext);
        case 57:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  }));
  return _handleCallErrors.apply(this, arguments);
}
function serviceErrorCodeHandler(_x16, _x17) {
  return _serviceErrorCodeHandler.apply(this, arguments);
}
/**
 * @param stats - RTC peer connection stats.
 * @returns CallRtpStats.
 */
function _serviceErrorCodeHandler() {
  _serviceErrorCodeHandler = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4(err, loggerContext) {
    var errorCode, failureMessage, errorDetails, _errorDetails, _errorDetails2, _errorDetails3, _errorDetails4, _errorDetails5, _errorDetails6, _errorDetails7, _errorDetails8;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          errorCode = Number(err.statusCode);
          failureMessage = 'FAILURE';
          _context4.t0 = errorCode;
          _context4.next = _context4.t0 === _types2.ERROR_CODE.BAD_REQUEST ? 5 : _context4.t0 === _types2.ERROR_CODE.UNAUTHORIZED ? 8 : _context4.t0 === _types2.ERROR_CODE.FORBIDDEN ? 11 : _context4.t0 === _types2.ERROR_CODE.DEVICE_NOT_FOUND ? 14 : _context4.t0 === _types2.ERROR_CODE.REQUEST_TIMEOUT ? 17 : _context4.t0 === _types2.ERROR_CODE.NOT_IMPLEMENTED ? 20 : _context4.t0 === _types2.ERROR_CODE.INTERNAL_SERVER_ERROR ? 23 : _context4.t0 === _types2.ERROR_CODE.SERVICE_UNAVAILABLE ? 26 : 29;
          break;
        case 5:
          _Logger.default.warn("400 Bad request", loggerContext);
          errorDetails = {
            statusCode: 400,
            data: {
              error: '400 Bad request'
            },
            message: failureMessage
          };
          return _context4.abrupt("return", errorDetails);
        case 8:
          _Logger.default.warn("401 User is unauthorised, possible token expiry", loggerContext);
          _errorDetails = {
            statusCode: 401,
            data: {
              error: 'User is unauthorised, possible token expiry'
            },
            message: failureMessage
          };
          return _context4.abrupt("return", _errorDetails);
        case 11:
          _Logger.default.warn("403 User request is forbidden", loggerContext);
          _errorDetails2 = {
            statusCode: 403,
            data: {
              error: 'User request is forbidden'
            },
            message: failureMessage
          };
          return _context4.abrupt("return", _errorDetails2);
        case 14:
          _Logger.default.warn("404 User info not found", loggerContext);
          _errorDetails3 = {
            statusCode: 404,
            data: {
              error: 'User info not found'
            },
            message: failureMessage
          };
          return _context4.abrupt("return", _errorDetails3);
        case 17:
          _Logger.default.warn("408 Request to the server timedout", loggerContext);
          _errorDetails4 = {
            statusCode: 408,
            data: {
              error: 'Request to the server timedout'
            },
            message: failureMessage
          };
          return _context4.abrupt("return", _errorDetails4);
        case 20:
          _Logger.default.warn("501 Not Implemented error occurred", loggerContext);
          _errorDetails5 = {
            statusCode: 501,
            data: {
              error: 'Method is not implemented at the backend'
            },
            message: failureMessage
          };
          return _context4.abrupt("return", _errorDetails5);
        case 23:
          _Logger.default.warn("500 Internal server error occurred", loggerContext);
          _errorDetails6 = {
            statusCode: 500,
            data: {
              error: 'Internal server error occurred'
            },
            message: failureMessage
          };
          return _context4.abrupt("return", _errorDetails6);
        case 26:
          _Logger.default.warn("503 Unable to establish a connection with the server", loggerContext);
          _errorDetails7 = {
            statusCode: 503,
            data: {
              error: 'Unable to establish a connection with the server'
            },
            message: failureMessage
          };
          return _context4.abrupt("return", _errorDetails7);
        case 29:
          _Logger.default.warn("".concat(errorCode || 422, " Exception has occurred"), loggerContext);
          _errorDetails8 = {
            statusCode: errorCode || 422,
            data: {
              error: "".concat(errorCode || 422, " Exception has occurred")
            },
            message: failureMessage
          };
          return _context4.abrupt("return", _errorDetails8);
        case 32:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  }));
  return _serviceErrorCodeHandler.apply(this, arguments);
}
function parseMediaQualityStatistics(stats) {
  if (!stats || navigator.userAgent.indexOf('Firefox') !== -1) {
    _Logger.default.info('RTCStatsReport is null, adding dummy stats', {
      file: _constants.UTILS_FILE,
      method: parseMediaQualityStatistics.name
    });
    return _constants.DUMMY_METRICS;
  }
  try {
    var type;
    var id;
    var inboundCodec;
    var outboundCodec;
    var localCandidates = {};
    var candidatePairs = {};
    var codecList = {};
    var rxStat = {};
    var txStat = {};
    var vqPayload = {};
    var jitterBufferDelay = 0;
    var jitterBufferEmittedCount = 0;
    var totalRoundTripTime = 0;
    var roundTripTimeMeasurements = 0;
    var selectedPair = '';
    var bitRate = 0;

    /* Set defaults */
    vqPayload.maxJitter = 0;
    vqPayload.VoPktSizeMs = 20;

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    stats.forEach(function (report) {
      (0, _keys.default)(report).forEach(function (statName) {
        if (statName !== _constants.TIMESTAMP) {
          if (!type || statName === _constants.TYPE) {
            type = report[statName];
          } else if (!id || statName === _constants.MEDIA_ID) {
            id = report[statName];
          } else if (id && id.indexOf(_constants.RTC_ICE_CANDIDATE_PAIR) !== -1) {
            if (statName === _constants.LOCAL_CANDIDATE_ID) {
              candidatePairs[id] = report[statName];
            }
          } else if (id && id.indexOf(_constants.RTC_ICE_CANDIDATE) !== -1) {
            if (statName === _constants.NETWORK_TYPE) {
              localCandidates[id] = report[statName];
            }
          } else if (id && (id.indexOf(_constants.INBOUND_CODEC_MATCH) !== -1 || id.indexOf(_constants.OUTBOUND_CODEC_MATCH) !== -1 || id.indexOf(_constants.RTC_CODEC) !== -1)) {
            if (statName === _constants.MIME_TYPE) {
              codecList[id] = report[statName];
            }
          } else if (type && type === _constants.REMOTE_INBOUND_RTP) {
            switch (statName) {
              case _constants.TOTAL_ROUND_TRIP_TIME:
                {
                  totalRoundTripTime = report[statName];
                  break;
                }
              case _constants.ROUND_TRIP_TIME_MEASUREMENTS:
                {
                  roundTripTimeMeasurements = report[statName];
                  break;
                }
              default:
                {
                  // We don't care about the other stats
                }
            }
          } else if (type && type === _constants.INBOUND_RTP) {
            switch (statName) {
              case _constants.CODEC_ID:
                {
                  inboundCodec = report[statName];
                  break;
                }
              case _constants.PACKETS_RECEIVED:
                {
                  rxStat.Pkt = report[statName];
                  break;
                }
              case _constants.BYTES_RECEIVED:
                {
                  rxStat.Oct = report[statName];
                  break;
                }
              case _constants.PACKETS_DISCARDED:
                {
                  rxStat.LatePkt = report[statName];
                  break;
                }
              case _constants.PACKETS_LOST:
                {
                  rxStat.LostPkt = report[statName];
                  break;
                }
              case _constants.JITTER_BUFFER_DELAY:
                {
                  jitterBufferDelay = report[statName];
                  break;
                }
              case _constants.JITTER_BUFFER_EMITTED_COUNT:
                {
                  jitterBufferEmittedCount = report[statName];
                  break;
                }
              default:
                {
                  // We don't care about the other stats
                }
            }
          } else if (type && type === _constants.TRANSPORT) {
            switch (statName) {
              case _constants.SELECTED_CANDIDATE_PAIR_ID:
                {
                  selectedPair = report[statName];
                  break;
                }
              default:
                {
                  // We don't care about the other stats
                }
            }
          } else if (type && type === _constants.OUTBOUND_RTP) {
            switch (statName) {
              case _constants.CODEC_ID:
                {
                  outboundCodec = report[statName];
                  break;
                }
              case _constants.PACKETS_SENT:
                {
                  txStat.Pkt = report[statName];
                  break;
                }
              case _constants.BYTES_SENT:
                {
                  txStat.Oct = report[statName];
                  break;
                }
              case _constants.TARGET_BIT_RATE:
                {
                  bitRate = report[statName];
                  break;
                }
              default:
                {
                  // We don't care about the other stats
                }
            }
          } else if (type && type === _constants.MEDIA_SOURCE) {
            switch (statName) {
              case _constants.TOTAL_SAMPLES_DURATION:
                {
                  rxStat.Dur = report[statName];
                  txStat.Dur = report[statName];
                  break;
                }
              default:
                {
                  // We don't care about the other stats
                }
            }
          }
        }
      });
    });

    /* One way Delay */
    if (roundTripTimeMeasurements !== 0) {
      vqPayload.VoOneWayDelayMs = totalRoundTripTime / (2 * roundTripTimeMeasurements);
    } else {
      vqPayload.VoOneWayDelayMs = 0;
    }
    /* Application type */
    vqPayload.hwType = "".concat(platform.os, "/").concat(platform.name, "-").concat(platform.version);

    /* Network type */
    vqPayload.networkType = localCandidates[candidatePairs[selectedPair]];

    /* Average Jitter */
    rxStat.AvgJit = jitterBufferDelay / jitterBufferEmittedCount;

    /* Update codec */
    // eslint-disable-next-line prefer-destructuring
    vqPayload.VoRxCodec = codecList[inboundCodec].split('/')[1];
    var txVqPayload = {};

    // eslint-disable-next-line prefer-destructuring
    txVqPayload.VoTxCodec = codecList[outboundCodec].split('/')[1];
    txVqPayload.rtpBitRate = bitRate;
    var byeStats = {};
    rxStat.VQMetrics = vqPayload;
    txStat.VQMetrics = txVqPayload;
    byeStats[_constants.RTP_RX_STAT] = rxStat;
    byeStats[_constants.RTP_TX_STAT] = txStat;
    _Logger.default.log((0, _stringify.default)(byeStats), {
      file: _constants.UTILS_FILE,
      method: parseMediaQualityStatistics.name
    });
    return byeStats;
  } catch (err) {
    _Logger.default.warn("Caught error while parsing RTP stats, ".concat(err), {
      file: _constants.UTILS_FILE,
      method: parseMediaQualityStatistics.name
    });
    return _constants.DUMMY_METRICS;
  }
}

/**
 * To simulate delays.
 *
 * @param msec - Amount of delay.
 * @returns - Promise.
 */
var waitForMsecs = exports.waitForMsecs = function waitForMsecs(msec) {
  return new _promise.default(function (resolve) {
    setTimeout(resolve, msec);
  });
};

/**
 * Register calling backend.
 *
 * @param webex -.
 * @returns CallingBackEnd.
 */
function getCallingBackEnd(webex) {
  var entModels = webex.internal.device.features.entitlement.models;
  var callingBackend;
  if (webex.internal.device.callingBehavior === _constants2.NATIVE_WEBEX_TEAMS_CALLING) {
    for (var i = 0; i < entModels.length; i += 1) {
      if (entModels[i][_constants2.VALUES][_constants2.KEY] === _constants2.ENTITLEMENT_BASIC || entModels[i][_constants2.VALUES][_constants2.KEY] === _constants2.ENTITLEMENT_STANDARD) {
        callingBackend = _types3.CALLING_BACKEND.WXC;
        break;
      } else if (entModels[i][_constants2.VALUES][_constants2.KEY] === _constants2.ENTITLEMENT_BROADWORKS_CONN) {
        callingBackend = _types3.CALLING_BACKEND.BWRKS;
        break;
      }
    }
  } else if (webex.internal.device.callingBehavior === _constants2.NATIVE_SIP_CALL_TO_UCM) {
    callingBackend = _types3.CALLING_BACKEND.UCM;
  } else {
    callingBackend = _types3.CALLING_BACKEND.INVALID;
  }
  return callingBackend;
}

/**
 * Register XSI endpoint based on calling backend.
 *
 * @param webex -.
 * @param loggerContext -.
 * @param callingBackend -.
 * @returns Promise.
 */
function getXsiActionEndpoint(_x18, _x19, _x20) {
  return _getXsiActionEndpoint.apply(this, arguments);
}
/**
 * Get sorted VoicemailList based on sort order passed.
 *
 * @param webex - Webex object to get service urls.
 * @param callingBackend - CallingBackend will have info like UCM.
 * @returns VGEndpointUrl.
 */
function _getXsiActionEndpoint() {
  _getXsiActionEndpoint = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5(webex, loggerContext, callingBackend) {
    var userIdResponse, response, xsiEndpoint, bwTokenResponse, _response, _xsiEndpoint, xsiUrl, errorInfo;
    return _regenerator.default.wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          _context5.prev = 0;
          _context5.t0 = callingBackend;
          _context5.next = _context5.t0 === _types3.CALLING_BACKEND.WXC ? 4 : _context5.t0 === _types3.CALLING_BACKEND.BWRKS ? 10 : 18;
          break;
        case 4:
          _context5.next = 6;
          return webex.request({
            uri: "".concat(webex.internal.services._serviceUrls.hydra, "/").concat(_constants2.XSI_ACTION_ENDPOINT_ORG_URL_PARAM),
            method: _types3.HTTP_METHODS.GET
          });
        case 6:
          userIdResponse = _context5.sent;
          response = userIdResponse.body;
          xsiEndpoint = response[_constants2.ITEMS][0][_constants2.XSI_ACTION_ENDPOINT];
          return _context5.abrupt("return", xsiEndpoint);
        case 10:
          _context5.next = 12;
          return webex.request({
            uri: "".concat(webex.internal.services._serviceUrls.wdm, "/").concat(_constants2.DEVICES),
            method: _types3.HTTP_METHODS.GET
          });
        case 12:
          bwTokenResponse = _context5.sent;
          _response = bwTokenResponse.body;
          _xsiEndpoint = _response[_constants2.DEVICES][0][_constants2.SETTINGS][_constants2.BW_XSI_URL];
          xsiUrl = _response[_constants2.DEVICES][0][_constants2.SETTINGS][_constants2.BW_XSI_URL]; // Check if it ends with specific version and slice accordingly
          if (xsiUrl.endsWith(_constants2.BW_XSI_ENDPOINT_VERSION)) {
            _xsiEndpoint = xsiUrl.slice(0, -5); // Remove 'v2.0'
          } else if (xsiUrl.endsWith(_constants2.BW_XSI_ENDPOINT_VERSION_WITH_SLASH)) {
            _xsiEndpoint = xsiUrl.slice(0, -6); // Remove 'v2.0/'
          }
          return _context5.abrupt("return", _xsiEndpoint);
        case 18:
          throw new Error('Calling backend is not identified, exiting....');
        case 19:
          _context5.next = 26;
          break;
        case 21:
          _context5.prev = 21;
          _context5.t1 = _context5["catch"](0);
          errorInfo = _context5.t1;
          serviceErrorCodeHandler(errorInfo, loggerContext);
          return _context5.abrupt("return", errorInfo);
        case 26:
        case "end":
          return _context5.stop();
      }
    }, _callee5, null, [[0, 21]]);
  }));
  return _getXsiActionEndpoint.apply(this, arguments);
}
function getVgActionEndpoint(webex, callingBackend) {
  try {
    if (callingBackend && callingBackend === _types3.CALLING_BACKEND.UCM) {
      return webex.internal.services._serviceUrls['ucmgmt-gateway'];
    }
    throw new Error('Calling backend is not identified, exiting....');
  } catch (err) {
    var errorInfo = err;
    return errorInfo;
  }
}

/**
 * Get sorted VoiceMailList based on sort order passed.
 *
 * @param voiceMessageList - List of voicemessage.
 * @param sortOrder - Type of sort either ascending or descending.
 * @returns Sorted voicemessageList .
 */
function getSortedVoicemailList(voiceMessageList, sortOrder) {
  /* istanbul ignore else */
  if (sortOrder === _types3.SORT.DESC) {
    voiceMessageList.sort(function (voiceMail, nextVoiceMail) {
      return nextVoiceMail[_constants2.TIME][_constants2.PLACEHOLDER_KEY] - voiceMail[_constants2.TIME][_constants2.PLACEHOLDER_KEY];
    });
  } else if (sortOrder === _types3.SORT.ASC) {
    voiceMessageList.sort(function (voiceMail, nextVoiceMail) {
      return voiceMail[_constants2.TIME][_constants2.PLACEHOLDER_KEY] - nextVoiceMail[_constants2.TIME][_constants2.PLACEHOLDER_KEY];
    });
  }
  return voiceMessageList;
}

/**
 *  Handler to perform a SCIM Query.
 *
 * @param filter - A filter for the query.
 * @returns - Promise.
 */
function scimQuery(_x21) {
  return _scimQuery.apply(this, arguments);
}
/**
 * Resolve Caller Id display information using SCIM query.
 *
 * @param filter - CI userId.
 */
function _scimQuery() {
  _scimQuery = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6(filter) {
    var sdkConnector, webex, isProd, webexHost, scimUrl, query;
    return _regenerator.default.wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          _Logger.default.info("Starting resolution for filter:- ".concat(filter), {
            file: _constants.UTILS_FILE,
            method: 'scimQuery'
          });
          sdkConnector = _SDKConnector.default;
          webex = sdkConnector.getWebex();
          isProd = !webex.internal.device.url.includes('-int');
          webexHost = isProd ? _constants2.WEBEX_API_PROD : _constants2.WEBEX_API_BTS;
          scimUrl = "".concat(webexHost, "/").concat(_constants2.IDENTITY_ENDPOINT_RESOURCE, "/").concat(_constants2.SCIM_ENDPOINT_RESOURCE, "/").concat(webex.internal.device.orgId, "/").concat(_constants2.SCIM_USER_FILTER);
          query = scimUrl + encodeURIComponent(filter);
          return _context6.abrupt("return", webex.request({
            uri: query,
            method: _types3.HTTP_METHODS.GET,
            headers: (0, _defineProperty2.default)((0, _defineProperty2.default)({}, _constants.CISCO_DEVICE_URL, webex.internal.device.url), _constants.SPARK_USER_AGENT, _constants.CALLING_USER_AGENT)
          }));
        case 8:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  }));
  return _scimQuery.apply(this, arguments);
}
function resolveCallerIdDisplay(_x22) {
  return _resolveCallerIdDisplay.apply(this, arguments);
}
/**
 * Resolve contact info from display name, using people search API.
 *
 * @param name - Display name.
 */
function _resolveCallerIdDisplay() {
  _resolveCallerIdDisplay = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7(filter) {
    var _resolution;
    var resolution, displayResult, response, res, _scimResource$phoneNu, _scimResource$phoneNu2, _scimResource$photos, scimResource, numberObj, photo;
    return _regenerator.default.wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          displayResult = {};
          _context7.prev = 1;
          _context7.next = 4;
          return scimQuery(filter);
        case 4:
          response = _context7.sent;
          resolution = response.body;
          _Logger.default.info("Number of records found for this user :- ".concat(resolution.totalResults), {
            file: _constants.UTILS_FILE,
            method: 'resolveCallerIdDisplay'
          });
          _context7.next = 13;
          break;
        case 9:
          _context7.prev = 9;
          _context7.t0 = _context7["catch"](1);
          res = _context7.t0;
          _Logger.default.warn("Error response: - ".concat(res.statusCode), {
            file: _constants.UTILS_FILE,
            method: 'resolveCallerIdDisplay'
          });
        case 13:
          if ((_resolution = resolution) !== null && _resolution !== void 0 && _resolution.totalResults && resolution.totalResults > 0) {
            /* Every user has single resource from what we have discussed. May need to revisit this later
             * for shared-line use-cases.
             */
            scimResource = resolution.Resources[0];
            displayResult.name = scimResource.displayName;

            /* Pick only the primary number  OR  2nd preference Work */
            numberObj = ((_scimResource$phoneNu = scimResource.phoneNumbers) === null || _scimResource$phoneNu === void 0 ? void 0 : _scimResource$phoneNu.find(function (num) {
              return num.primary;
            })) || ((_scimResource$phoneNu2 = scimResource.phoneNumbers) === null || _scimResource$phoneNu2 === void 0 ? void 0 : _scimResource$phoneNu2.find(function (num) {
              return num.type.toLowerCase() === 'work';
            }));
            if (numberObj) {
              displayResult.num = numberObj.value;
            } else if (scimResource.phoneNumbers && scimResource.phoneNumbers.length > 0) {
              /* When no primary number exists OR PA-ID/From failed to populate, we take the first number */
              _Logger.default.info('Failure to resolve caller information. Setting number as caller ID', {
                file: _constants.UTILS_FILE,
                method: 'resolveCallerIdDisplay'
              });
              displayResult.num = scimResource.phoneNumbers[0].value;
            }

            /* For Webapp, we are only picking thumbnail photo */
            photo = (_scimResource$photos = scimResource.photos) === null || _scimResource$photos === void 0 ? void 0 : _scimResource$photos.find(function (photo) {
              return photo.type === 'thumbnail';
            });
            displayResult.avatarSrc = photo ? photo.value : 'unknown';
            displayResult.id = scimResource.id;
          }
          return _context7.abrupt("return", displayResult);
        case 15:
        case "end":
          return _context7.stop();
      }
    }, _callee7, null, [[1, 9]]);
  }));
  return _resolveCallerIdDisplay.apply(this, arguments);
}
function resolveCallerIdByName(_x23) {
  return _resolveCallerIdByName.apply(this, arguments);
}
/**
 * Resolve the contact information.
 *
 * @param callingPartyInfo - Calling Party Info.
 */
function _resolveCallerIdByName() {
  _resolveCallerIdByName = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8(name) {
    var displayResult, sdkConnector, webex, searchDirectory;
    return _regenerator.default.wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          displayResult = {};
          sdkConnector = _SDKConnector.default;
          webex = sdkConnector.getWebex();
          /**
           * @param query - Display name.
           */
          searchDirectory = function searchDirectory(query) {
            return webex.people.list({
              displayName: query
            });
          };
          _context8.next = 6;
          return searchDirectory(name).then(function (results) {
            _Logger.default.info("DS Result: ".concat(results), {
              file: _constants.UTILS_FILE,
              method: 'resolveCallerIdByName'
            });
            if (results && results.items && results.items.length > 0) {
              var resolution = results.items[0];
              displayResult.name = resolution.displayName;

              /* id is like cisco spark://us/PEOPLE/b853bbd1-1136-4d25-938d-0c37541b1234
               *  We need to extract UUID portion. */
              var id = Buffer.from(resolution.id, 'base64').toString('binary');
              displayResult.id = id.split('/').pop();
              var numObj = resolution.phoneNumbers.find(function (num) {
                return num.type === 'work';
              });
              if (numObj) {
                displayResult.num = numObj.value;
              } else if (resolution.phoneNumbers.length > 0) {
                displayResult.num = resolution.phoneNumbers[0].value;
              }
              displayResult.avatarSrc = resolution.avatar;
              _Logger.default.info("Extracted details:- name: ".concat(displayResult.name, " , number: ").concat(displayResult.num, ", photo: ").concat(displayResult.avatarSrc, ", id: ").concat(displayResult.id), {
                file: _constants.UTILS_FILE,
                method: 'resolveCallerIdByName'
              });
            }
          });
        case 6:
          return _context8.abrupt("return", displayResult);
        case 7:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  }));
  return _resolveCallerIdByName.apply(this, arguments);
}
function resolveContact(_x24) {
  return _resolveContact.apply(this, arguments);
}
/**
 * Store encrypted voicemailList in SessionStorage.
 *
 * @param context - Context for storage.
 * @param voiceMessageList - List of voicemessage.
 */
function _resolveContact() {
  _resolveContact = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9(callingPartyInfo) {
    return _regenerator.default.wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          if (!(callingPartyInfo.userExternalId && callingPartyInfo.userExternalId.$)) {
            _context9.next = 2;
            break;
          }
          return _context9.abrupt("return", resolveCallerIdDisplay("id eq \"".concat(callingPartyInfo.userExternalId.$, "\"")));
        case 2:
          if (!(callingPartyInfo.name && callingPartyInfo.name.$)) {
            _context9.next = 4;
            break;
          }
          return _context9.abrupt("return", resolveCallerIdByName(callingPartyInfo.name.$));
        case 4:
          return _context9.abrupt("return", null);
        case 5:
        case "end":
          return _context9.stop();
      }
    }, _callee9);
  }));
  return _resolveContact.apply(this, arguments);
}
function storeVoicemailList(context, voiceMessageList) {
  var vmEncodedList = Buffer.from((0, _stringify.default)(voiceMessageList), 'utf8').toString('base64');
  sessionStorage.setItem(context, vmEncodedList.toString());
}

/**
 * Fetch decrypted voicemailList from SessionStorage.
 *
 * @param context - Context for the storage.
 * @param offset - Number of voicemail records to skip.
 * @param offsetLimit - Number of voicemail list to fetch from the offset.
 * @param loggerContext - File, method name object.
 * @returns - Array containing voicemails and flag to indicate availability of more voicemails.
 */
function fetchVoicemailList(context, offset, offsetLimit, loggerContext) {
  var moreVoicemails = false;
  var requiredVoicemailList = [];
  try {
    var voicemailList = JSON.parse(Buffer.from(sessionStorage.getItem(context), 'base64').toString('utf8'));
    _Logger.default.info("Length of voicemail list:  ".concat(voicemailList.length), loggerContext);
    if (voicemailList.length > offset + offsetLimit) {
      moreVoicemails = true;
    }
    requiredVoicemailList = voicemailList.slice(offset, offset + offsetLimit);
  } catch (err) {
    _Logger.default.warn("Caught exception while fetching voicemail from storage. ".concat(err), loggerContext);
    var errorInfo = err;
    serviceErrorCodeHandler(errorInfo, {});
  }
  return {
    messages: requiredVoicemailList,
    moreVMAvailable: moreVoicemails
  };
}

/**
 * Converts a uuid to a hydra id without a network dip.
 *
 * @param id - ID to be encoded to base64.
 * @param decodeType - DecodeType.
 * @returns - Encoded string value.
 */
function inferIdFromUuid(id, decodeType) {
  return Buffer.from("".concat(_constants2.INFER_ID_CONSTANT, "/").concat(decodeType, "/").concat(id), 'binary').toString('base64');
}

/**
 * Validates service indicator.
 *
 * @param indicator - Must match with one of the values in ServiceIndicator enum.
 * @returns True if validation is successful else false.
 */
function isValidServiceIndicator(indicator) {
  return (0, _values.default)(_types3.ServiceIndicator).some(function (v) {
    return v === indicator;
  });
}

/**
 * Validates domain field in input service data object.
 * Domain value must be in valid domain format for service
 * type contactcenter.
 * But for service type calling it's allowed to be empty or
 * undefined however if it's not empty/undefined for service
 * type calling then even that will be validated to see if it
 * is in valid domain format.
 *
 * @param serviceData - .
 * @returns True if validation is successful else false.
 */
function isValidServiceDomain(serviceData) {
  var regexp = /^[a-z0-9]+([-.]{1}[a-z0-9]+)*\.[a-z]{2,6}$/i;
  var domain = serviceData.domain;
  if (!domain) {
    return serviceData.indicator === _types3.ServiceIndicator.CALLING || serviceData.indicator === _types3.ServiceIndicator.GUEST_CALLING;
  }
  return regexp.test(domain);
}

/**
 * Validates service data object(indicator & domain) and throws
 * exception with a message indicating the reason for validation
 * failure.
 *
 * @param serviceData - Input service data to be validated.
 */
function validateServiceData(serviceData) {
  var allowedValues = (0, _values.default)(_types3.ServiceIndicator);
  var formattedValues = allowedValues.join(', ').replace(/,([^,]*)$/, ' and$1');
  if (!isValidServiceIndicator(serviceData.indicator)) {
    throw new Error("Invalid service indicator, Allowed values are: ".concat(formattedValues));
  }
  if (!isValidServiceDomain(serviceData)) {
    throw new Error('Invalid service domain.');
  }
}

/**
 * Modifies SDP to replace IPv6 "c=" lines with IPv4.And adds an IPv4 candidate if none exists.
 *
 * @param sdp - Session Description Protocol string.
 * @returns Modified SDP string.
 */
function modifySdpForIPv4(sdp) {
  try {
    // Normalize line endings to avoid issues
    sdp = sdp.replace(/\r\n|\r/g, '\n');

    // Ensure consistent spacing without removing intentional indentation
    sdp = sdp.replace(/^[ \t]+/gm, '');

    // Check if at least one IPv6 "c=" line is present
    var ipv6CLineMatches = sdp.match(/c=IN IP6 [\da-f:.]+/gi) || [];
    var hasIPv6CLine = ipv6CLineMatches.length > 0;
    if (hasIPv6CLine) {
      _Logger.default.info('Modifying SDP for IPv4 compatibility', {
        file: _constants.UTILS_FILE,
        method: modifySdpForIPv4.name
      });

      // Extract an existing IPv4 candidate's IP, if available
      var ipv4CandidateMatch = sdp.match(/a=candidate:\d+ \d+ \w+ \d+ ([\d.]+) \d+ typ \w+/);
      var ipv4Address = (ipv4CandidateMatch === null || ipv4CandidateMatch === void 0 ? void 0 : ipv4CandidateMatch[1]) || '192.1.1.1'; // Default fallback

      // Replace all IPv6 "c=" lines with IPv4 using the extracted IP (or default)
      sdp = sdp.replace(/c=IN IP6 [\da-f:.]+/gi, "c=IN IP4 ".concat(ipv4Address));

      // Ensure newline separation between candidate lines
      if (!ipv4CandidateMatch) {
        var ipv4CandidateAdded = false;
        sdp = sdp.replace(/(a=candidate:(\d+) (\d+) (\w+) (\d+) ([\da-f:.]+) (\d+) typ (\w+)[^\n]*)/g, function (match, full, foundation, componentId, transport, priority, connectionAddress, port, candidateType) {
          if (!ipv4CandidateAdded && connectionAddress.includes(':')) {
            // Ensure it's IPv6 and only add once
            ipv4CandidateAdded = true;
            var newFoundation = ((0, _parseInt2.default)(foundation, 10) + 1).toString();
            return "".concat(full, "\n") + "a=candidate:".concat(newFoundation, " ").concat(componentId, " ").concat(transport, " ").concat(priority, " ").concat(ipv4Address, " ").concat(port, " typ ").concat(candidateType, " generation 0 network-id 1 network-cost 10");
          }
          return match;
        });
      }
    }
    return sdp;
  } catch (error) {
    _Logger.default.warn("Error modifying SDP for IPv4 compatibility: ".concat(error), {
      file: _constants.UTILS_FILE,
      method: modifySdpForIPv4.name
    });
    return sdp; // Return original SDP in case of an error
  }
}

/**
 * Uploads logs to backend.
 *
 * @param metaData - Metadata to be uploaded.
 * @param throwError - Whether to throw exception on failure (default: false).
 * @returns Promise containing upload response if successful.
 */
function uploadLogs() {
  return _uploadLogs.apply(this, arguments);
}
function _uploadLogs() {
  _uploadLogs = (0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
    var metaData,
      throwError,
      webex,
      feedbackId,
      response,
      errorLog,
      _args10 = arguments;
    return _regenerator.default.wrap(function _callee10$(_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          metaData = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : {};
          throwError = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : false;
          webex = _SDKConnector.default.getWebex();
          feedbackId = crypto.randomUUID();
          _context10.prev = 4;
          _context10.next = 7;
          return webex.internal.support.submitLogs(_objectSpread(_objectSpread({}, metaData), {}, {
            feedbackId: feedbackId
          }), undefined,
          // we dont send logs but take from webex logger
          {
            type: 'diff'
          } // this is to take the diff logs from previous upload
          );
        case 7:
          response = _context10.sent;
          _Logger.default.info("Logs uploaded successfully with feedbackId: ".concat(feedbackId), {
            file: _constants.UTILS_FILE,
            method: 'uploadLogs'
          });
          (0, _Metrics.getMetricManager)().submitUploadLogsMetric(_types.METRIC_EVENT.UPLOAD_LOGS_SUCCESS, _types.UPLOAD_LOGS_ACTION, _types.METRIC_TYPE.BEHAVIORAL, response === null || response === void 0 ? void 0 : response.trackingid, feedbackId, metaData === null || metaData === void 0 ? void 0 : metaData.correlationId);
          return _context10.abrupt("return", _objectSpread(_objectSpread(_objectSpread(_objectSpread({
            trackingid: response.trackingid
          }, response.url ? {
            url: response.url
          } : {}), response.userId ? {
            userId: response.userId
          } : {}), response.correlationId ? {
            correlationId: response.correlationId
          } : {}), {}, {
            feedbackId: feedbackId
          }));
        case 13:
          _context10.prev = 13;
          _context10.t0 = _context10["catch"](4);
          errorLog = new Error("Failed to upload Logs ".concat(_context10.t0));
          _Logger.default.error(errorLog, {
            file: _constants.UTILS_FILE,
            method: 'uploadLogs'
          });
          (0, _Metrics.getMetricManager)().submitUploadLogsMetric(_types.METRIC_EVENT.UPLOAD_LOGS_FAILED, _types.UPLOAD_LOGS_ACTION, _types.METRIC_TYPE.BEHAVIORAL, feedbackId, metaData === null || metaData === void 0 ? void 0 : metaData.correlationId, errorLog.message);
          if (!throwError) {
            _context10.next = 20;
            break;
          }
          throw _context10.t0;
        case 20:
          return _context10.abrupt("return", undefined);
        case 21:
        case "end":
          return _context10.stop();
      }
    }, _callee10, null, [[4, 13]]);
  }));
  return _uploadLogs.apply(this, arguments);
}
//# sourceMappingURL=Utils.js.map
