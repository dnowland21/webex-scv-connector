"use strict";

var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
var _regenerator = _interopRequireDefault(require("@babel/runtime-corejs2/regenerator"));
var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/asyncToGenerator"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _assign = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/object/assign"));
var _stringify = _interopRequireDefault(require("@babel/runtime-corejs2/core-js/json/stringify"));
var _calling = require("../CallingClient/calling");
var _Errors = require("../Errors");
var _testUtil = require("./testUtil");
var _types = require("./types");
var _Logger = _interopRequireDefault(require("../Logger"));
var _constants = require("../CallingClient/constants");
var _types2 = require("../Errors/types");
var _Utils = require("./Utils");
var _voicemailFixture = require("../Voicemail/voicemailFixture");
var _constants2 = require("./constants");
var _types3 = require("../Events/types");
var _SDKConnector = _interopRequireDefault(require("../SDKConnector"));
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; } /* eslint-disable no-underscore-dangle */
var mockSubmitRegistrationMetric = jest.fn();
var mockEmitterCb = jest.fn();
var mockRestoreCb = jest.fn();
var webex = (0, _testUtil.getTestUtilsWebex)();
_SDKConnector.default.setWebex(webex);
webex.internal.metrics.submitClientMetrics = mockSubmitRegistrationMetric;
describe('Mobius service discovery tests', function () {
  it('test filter mobius uris', function () {
    var defaultMobiusUrl = 'https://mobius.webex.com/api/v1/calling/web';
    var callingContext = '/calling/web/';
    var discoveryResponse = (0, _testUtil.getMobiusDiscoveryResponse)();

    // add a duplicate which will be filtered out
    discoveryResponse.backup.uris.push(discoveryResponse.backup.uris[0]);
    var filteredUris = (0, _Utils.filterMobiusUris)(discoveryResponse, defaultMobiusUrl);
    expect(filteredUris.primary.length).toBe(1);
    expect(filteredUris.backup.length).toBe(2);
    expect(filteredUris.primary[0]).toBe(discoveryResponse.primary.uris[0] + callingContext);
    expect(filteredUris.backup[0]).toBe(discoveryResponse.backup.uris[0] + callingContext);
    expect(filteredUris.backup[1]).toBe(defaultMobiusUrl + callingContext);

    /** Remove Uris and test if the defaultUrls is returned */
    discoveryResponse.backup.uris = [];
    discoveryResponse.primary.uris = [];
    filteredUris = (0, _Utils.filterMobiusUris)(discoveryResponse, defaultMobiusUrl);
    expect(filteredUris.primary.length).toBe(1);
    expect(filteredUris.primary[0]).toBe(defaultMobiusUrl + callingContext);
    expect(filteredUris.backup.length).toBe(0);
  });
});
describe('Registration Tests', function () {
  /**
   * TestCase inputs
   * name: TestCase name
   * code: Response code of type ERROR_CODE
   * bodyPresent: Indicates if response has a body
   * subErrorCode: sub error code of type CALL_ERROR_CODE
   * retryAfter: Indicates if retry-after header is present
   * message: Custom message for the error context
   * type: Error type based on the response code
   * errorLayer: Call control or media layer
   * cbExpected: Indicates if event emitter callback is expected
   * logMsg: log message.
   */
  var errorCodes = [{
    name: 'verify 404 error response',
    statusCode: _types2.ERROR_CODE.DEVICE_NOT_FOUND,
    deviceErrorCode: 0,
    retryAfter: 0,
    message: 'The client has unregistered. Please wait for the client to register before attempting the call. If error persists, sign out, sign back in and attempt the call.',
    errorType: _types2.ERROR_TYPE.NOT_FOUND,
    emitterCbExpected: true,
    finalError: true,
    restoreCbExpected: false,
    logMsg: '404 Device Not Found'
  }, {
    name: 'verify 500 error response',
    statusCode: _types2.ERROR_CODE.INTERNAL_SERVER_ERROR,
    deviceErrorCode: 0,
    retryAfter: 0,
    message: 'An unknown error occurred while placing the request. Wait a moment and try again.',
    errorType: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    emitterCbExpected: true,
    finalError: false,
    restoreCbExpected: false,
    logMsg: '500 Internal Server Error'
  }, {
    name: 'verify 503 error response',
    statusCode: _types2.ERROR_CODE.SERVICE_UNAVAILABLE,
    deviceErrorCode: 0,
    retryAfter: 0,
    message: 'An error occurred on the server while processing the request. Wait a moment and try again.',
    errorType: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    emitterCbExpected: true,
    finalError: false,
    restoreCbExpected: false,
    logMsg: '503 Service Unavailable'
  }, {
    name: 'verify 403 response with no response body',
    statusCode: _types2.ERROR_CODE.FORBIDDEN,
    deviceErrorCode: 0,
    retryAfter: 0,
    message: 'An unauthorized action has been received. This action has been blocked. Please contact the administrator if this persists.',
    errorType: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    emitterCbExpected: true,
    finalError: false,
    restoreCbExpected: false,
    logMsg: 'Error response has no body, throwing default error',
    customBodyPresent: true,
    body: undefined
  }, {
    name: 'verify 403 response with unknown device.errorCode',
    statusCode: _types2.ERROR_CODE.FORBIDDEN,
    deviceErrorCode: 0,
    retryAfter: 0,
    message: 'An unknown error occurred. Wait a moment and try again. Please contact the administrator if the problem persists.',
    errorType: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    emitterCbExpected: true,
    finalError: false,
    restoreCbExpected: false,
    logMsg: 'Error code found : 0'
  }, {
    name: 'verify 403 response with code 101',
    statusCode: _types2.ERROR_CODE.FORBIDDEN,
    deviceErrorCode: _types2.DEVICE_ERROR_CODE.DEVICE_LIMIT_EXCEEDED,
    retryAfter: 0,
    message: 'User device limit exceeded',
    errorType: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    emitterCbExpected: false,
    finalError: false,
    restoreCbExpected: true,
    logMsg: 'User device limit exceeded'
  }, {
    name: 'verify 403 response with code 102',
    statusCode: _types2.ERROR_CODE.FORBIDDEN,
    deviceErrorCode: _types2.DEVICE_ERROR_CODE.DEVICE_CREATION_DISABLED,
    retryAfter: 0,
    message: 'User is not configured for WebRTC calling. Please contact the administrator to resolve this issue.',
    errorType: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    emitterCbExpected: true,
    finalError: true,
    restoreCbExpected: false,
    logMsg: 'User is not configured for WebRTC calling. Please contact the administrator to resolve this issue.'
  }, {
    name: 'verify 403 response with code 103',
    statusCode: _types2.ERROR_CODE.FORBIDDEN,
    deviceErrorCode: _types2.DEVICE_ERROR_CODE.DEVICE_CREATION_FAILED,
    retryAfter: 0,
    message: 'An unknown error occurred while provisioning the device. Wait a moment and try again.',
    errorType: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    emitterCbExpected: true,
    finalError: false,
    restoreCbExpected: false,
    logMsg: 'An unknown error occurred while provisioning the device. Wait a moment and try again.'
  }, {
    name: 'verify 401 error response',
    statusCode: _types2.ERROR_CODE.UNAUTHORIZED,
    deviceErrorCode: 0,
    retryAfter: 0,
    message: 'User is unauthorized due to an expired token. Sign out, then sign back in.',
    errorType: _types2.ERROR_TYPE.TOKEN_ERROR,
    emitterCbExpected: true,
    finalError: true,
    restoreCbExpected: false,
    logMsg: '401 Unauthorized'
  }, {
    name: 'verify unknown error response',
    statusCode: 206,
    deviceErrorCode: 0,
    retryAfter: 0,
    message: 'Unknown error',
    errorType: _types2.ERROR_TYPE.DEFAULT,
    emitterCbExpected: true,
    finalError: false,
    restoreCbExpected: false,
    logMsg: 'Unknown Error'
  }].map(function (stat) {
    return (0, _assign.default)(stat, {
      toString: function toString() {
        return this.name;
      }
    });
  });
  var logSpy = jest.spyOn(_Logger.default, 'warn');
  var logObj = {
    file: 'CallingClient',
    method: _constants.REGISTER_UTIL
  };

  /* eslint-disable @typescript-eslint/no-explicit-any */
  it.each(errorCodes)('%s', function (codeObj) {
    var webexPayload = {
      statusCode: codeObj.statusCode,
      headers: {
        trackingid: 'webex-js-sdk_b5812e58-7246-4a9b-bf64-831bdf13b0cd_31'
      },
      body: {
        device: {
          deviceId: '8a67806f-fc4d-446b-a131-31e71ea5b010'
        },
        userId: '8a67806f-fc4d-446b-a131-31e71ea5b0e9',
        errorCode: codeObj.deviceErrorCode,
        devices: [{
          deviceId: '8a67806f-fc4d-446b-a131-31e71ea5b010',
          uri: 'https://mobius.webex.com/api/v1/calling/web/',
          status: 'active',
          lastSeen: '2022-04-07T18:00:40Z',
          addresses: ['sip:sipAddress@webex.com']
        }]
      }
    };
    if (codeObj.customBodyPresent) {
      webexPayload.body = codeObj.body;
    }
    var mockErrorEvent = {
      type: codeObj.errorType,
      message: codeObj.message,
      context: logObj
    };
    var callClientError = new _Errors.CallingClientError(mockErrorEvent.message, mockErrorEvent.context, mockErrorEvent.type, _types.RegistrationStatus.ACTIVE);
    (0, _Utils.handleRegistrationErrors)(webexPayload, mockEmitterCb, logObj, mockRestoreCb);
    if (codeObj.emitterCbExpected) {
      expect(mockEmitterCb).toBeCalledOnceWith(callClientError, codeObj.finalError);
    }
    if (codeObj.restoreCbExpected) {
      expect(mockRestoreCb).toBeCalledOnceWith(webexPayload.body, logObj.method);
    } else {
      expect(mockRestoreCb).not.toHaveBeenCalled();
    }
    expect(logSpy).toHaveBeenCalledWith("Status code: -> ".concat(codeObj.statusCode), logObj);
    expect(logSpy).toHaveBeenCalledWith(codeObj.logMsg, logObj);
  });
});
describe('Call Tests', function () {
  /* Error flows tests starts */
  var logSpy = jest.spyOn(_Logger.default, 'warn');
  var logObj = {
    file: _constants.CALL_FILE,
    method: 'handleCallErrors'
  };
  var deviceId = '55dfb53f-bed2-36da-8e85-cee7f02aa68e';
  var dest = {
    type: _types.CallType.URI,
    address: 'tel:5003'
  };
  var deleteCallFromCollection = jest.fn();
  var retryCallback = jest.fn();
  var activeUrl = 'FakeActiveUrl';
  var defaultServiceIndicator = _types.ServiceIndicator.CALLING;
  var call = new _calling.Call(activeUrl, webex, dest, _types.CallDirection.OUTBOUND, deviceId, deleteCallFromCollection, defaultServiceIndicator);
  var dummyCorrelationId = '8a67806f-fc4d-446b-a131-31e71ea5b010';
  beforeEach(function () {
    jest.clearAllTimers();
    jest.useFakeTimers();
    call.removeAllListeners(_types3.CALL_EVENT_KEYS.CALL_ERROR);
  });

  /**
   * TestCase inputs
   * name: TestCase name
   * code: Response code of type ERROR_CODE
   * bodyPresent: Indicates if response has a body
   * subErrorCode: sub error code of type CALL_ERROR_CODE
   * retryAfter: Indicates if retry-after header is present
   * message: Custom message for the error context
   * type: Error type based on the response code
   * errorLayer: Call control or media layer
   * cbExpected: Indicates if event emitter callback is expected
   * logMsg: log message.
   */
  var errorCodes = [/* 401 Unauthorized. */
  {
    name: 'verify 401 error response',
    code: 401,
    bodyPresent: true,
    subErrorCode: 0,
    retryAfter: 0,
    message: 'User is unauthorized due to an expired token. Sign out, then sign back in.',
    type: _types2.ERROR_TYPE.TOKEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: '401 Unauthorized'
  }, /* 403 error code from here. */
  // Without body
  {
    name: 'verify 403 error response without body',
    code: 403,
    bodyPresent: false,
    subErrorCode: 0,
    retryAfter: 0,
    message: 'An unauthorized action has been received. This action has been blocked. Please contact the administrator if this persists.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Error response has no body, throwing default error'
  },
  // error body with sub error code 111
  {
    name: 'verify 403 error response with code 111',
    code: 403,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.INVALID_STATUS_UPDATE,
    retryAfter: 0,
    message: 'An invalid status update has been received for the call. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->403'
  },
  // error body with sub error code 112
  {
    name: 'verify 403 error response with code 112',
    code: 403,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.DEVICE_NOT_REGISTERED,
    retryAfter: 0,
    message: 'The client has unregistered. Please wait for the client to register before attempting the call. If error persists, sign out, sign back in and attempt the call.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->403'
  },
  // error body with sub error code 113
  {
    name: 'verify 403 error response with code 113',
    code: 403,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.CALL_NOT_FOUND,
    retryAfter: 0,
    message: 'Call is not found on the server. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->403'
  },
  // error body with sub error code 114
  {
    name: 'verify 403 error response with code 114',
    code: 403,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.ERROR_PROCESSING,
    retryAfter: 0,
    message: 'An error occurred while processing the call on the server. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->403'
  },
  // error body with sub error code 115
  {
    name: 'verify 403 error response with code 115',
    code: 403,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.USER_BUSY,
    retryAfter: 0,
    message: 'Called user is busy.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->403'
  },
  // error body with sub error code 116
  {
    name: 'verify 403 error response with code 116',
    code: 403,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.PARSING_ERROR,
    retryAfter: 0,
    message: 'An error occurred while parsing the provided information. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.MEDIA,
    cbExpected: true,
    logMsg: 'Status code: ->403'
  },
  // error body with sub error code 118
  {
    name: 'verify 403 error response with code 118',
    code: 403,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.NOT_ACCEPTABLE,
    retryAfter: 0,
    message: 'An error occurred on the server while accepting the call. Wait a moment and try again. Please contact the administrator if this persists.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.MEDIA,
    cbExpected: true,
    logMsg: 'Status code: ->403'
  },
  // error body with sub error code 119
  {
    name: 'verify 403 error response with code 119',
    code: 403,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.CALL_REJECTED,
    retryAfter: 0,
    message: 'Call rejected by the server. Wait a moment and try again. Please contact the administrator if this persists.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->403'
  },
  // error body with sub error code 120
  {
    name: 'verify 403 error response with code 120',
    code: 403,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.NOT_AVAILABLE,
    retryAfter: 0,
    message: 'Calling services not available. Wait a moment and try again. Please contact the administrator if this persists.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->403'
  },
  // error body with unknown/unhandled sub error code
  {
    name: 'verify 403 error response with unknown error code',
    code: 403,
    bodyPresent: true,
    subErrorCode: 999,
    retryAfter: 0,
    message: 'An unknown error occurred. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.FORBIDDEN_ERROR,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->403'
  }, /* 403 error code till here. */
  /* 503 error code from here. */
  // Without body
  {
    name: 'verify 503 error response without body',
    code: 503,
    bodyPresent: false,
    subErrorCode: 0,
    retryAfter: 0,
    message: 'An error occurred on the server while processing the request. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Error response has no body, throwing default error'
  },
  // error body with sub error code 111
  {
    name: 'verify 503 error response with code 111',
    code: 503,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.INVALID_STATUS_UPDATE,
    retryAfter: 0,
    message: 'An invalid status update has been received for the call. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->503'
  },
  // error body with sub error code 112
  {
    name: 'verify 503 error response with code 112',
    code: 503,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.DEVICE_NOT_REGISTERED,
    retryAfter: 0,
    message: 'The client has unregistered. Please wait for the client to register before attempting the call. If error persists, sign out, sign back in and attempt the call.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->503'
  },
  // error body with sub error code 113
  {
    name: 'verify 503 error response with code 113',
    code: 503,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.CALL_NOT_FOUND,
    retryAfter: 0,
    message: 'Call is not found on the server. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->503'
  },
  // error body with sub error code 114
  {
    name: 'verify 503 error response with code 114',
    code: 503,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.ERROR_PROCESSING,
    retryAfter: 0,
    message: 'An error occurred while processing the call on the server. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->503'
  },
  // error body with sub error code 115
  {
    name: 'verify 503 error response with code 115',
    code: 503,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.USER_BUSY,
    retryAfter: 0,
    message: 'Called user is busy.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->503'
  },
  // error body with sub error code 116
  {
    name: 'verify 503 error response with code 116',
    code: 503,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.PARSING_ERROR,
    retryAfter: 0,
    message: 'An error occurred while parsing the provided information. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.MEDIA,
    cbExpected: true,
    logMsg: 'Status code: ->503'
  },
  // error body with sub error code 118
  {
    name: 'verify 503 error response with code 118',
    code: 503,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.NOT_ACCEPTABLE,
    retryAfter: 0,
    message: 'An error occurred on the server while accepting the call. Wait a moment and try again. Please contact the administrator if this persists.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.MEDIA,
    cbExpected: true,
    logMsg: 'Status code: ->503'
  },
  // error body with sub error code 119
  {
    name: 'verify 503 error response with code 119',
    code: 503,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.CALL_REJECTED,
    retryAfter: 0,
    message: 'Call rejected by the server. Wait a moment and try again. Please contact the administrator if this persists.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->503'
  },
  // error body with sub error code 120
  {
    name: 'verify 503 error response with code 120',
    code: 503,
    bodyPresent: true,
    subErrorCode: _types2.CALL_ERROR_CODE.NOT_AVAILABLE,
    retryAfter: 0,
    message: 'Calling services not available. Wait a moment and try again. Please contact the administrator if this persists.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->503'
  },
  // error body with unknown/unhandled sub error code
  {
    name: 'verify 503 error response with unknown error code',
    code: 503,
    bodyPresent: true,
    subErrorCode: 999,
    retryAfter: 0,
    message: 'An unknown error occurred. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: 'Status code: ->503'
  },
  // with retry-after
  {
    name: 'verify 503 error response with retry-after',
    code: 503,
    bodyPresent: true,
    subErrorCode: 0,
    retryAfter: 60,
    message: 'An unknown error occurred. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.SERVICE_UNAVAILABLE,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: false,
    logMsg: 'Retry Interval received: 60'
  }, /* 503 error code till here. */
  /* 404 Not Found. */
  {
    name: 'verify 404 error response',
    code: 404,
    bodyPresent: true,
    subErrorCode: 0,
    retryAfter: 0,
    message: 'Call is no longer active. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.NOT_FOUND,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: true,
    logMsg: '404 Call Not Found'
  }, /* 500 Internal Server Error. */
  {
    name: 'verify 500 error response',
    code: 500,
    bodyPresent: true,
    subErrorCode: 0,
    retryAfter: 0,
    message: 'An unknown error occurred in the call. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.SERVER_ERROR,
    errorLayer: _types2.ERROR_LAYER.MEDIA,
    cbExpected: true,
    logMsg: '500 Internal Server Error'
  }, /* Unknown error code. */
  {
    name: 'verify unknown error response',
    code: 0,
    bodyPresent: true,
    subErrorCode: 0,
    retryAfter: 0,
    message: 'An unknown error occurred in the call. Wait a moment and try again.',
    type: _types2.ERROR_TYPE.DEFAULT,
    errorLayer: _types2.ERROR_LAYER.CALL_CONTROL,
    cbExpected: false,
    logMsg: 'Unknown Error'
  }].map(function (stat) {
    return (0, _assign.default)(stat, {
      toString: function toString() {
        return this.name;
      }
    });
  });

  /* eslint-disable @typescript-eslint/no-explicit-any */
  it.each(errorCodes)('%s', function (codeObj, done) {
    var cbTriggered = false;
    var mockPayload = _objectSpread({
      statusCode: codeObj.code,
      headers: _objectSpread({
        trackingid: 'webex-js-sdk_b5812e58-7246-4a9b-bf64-831bdf13b0cd_31'
      }, codeObj.retryAfter && {
        'retry-after': codeObj.retryAfter
      })
    }, codeObj.bodyPresent && {
      body: _objectSpread({
        device: {
          deviceId: '8a67806f-fc4d-446b-a131-31e71ea5b010'
        }
      }, codeObj.subErrorCode ? {
        errorCode: codeObj.subErrorCode
      } : {})
    });
    var mockErrorEvent = {
      type: codeObj.type,
      message: codeObj.message,
      context: logObj,
      correlationId: dummyCorrelationId,
      errorLayer: codeObj.errorLayer
    };
    if (codeObj.cbExpected) {
      call.on(_types3.CALL_EVENT_KEYS.CALL_ERROR, function (errObj) {
        expect(errObj).toMatchObject(mockErrorEvent);
        done();
      });
    } else {
      done();
    }
    (0, _Utils.handleCallErrors)(function (error) {
      call.emit(_types3.CALL_EVENT_KEYS.CALL_ERROR, error);
      cbTriggered = true;
    }, codeObj.errorLayer, retryCallback, dummyCorrelationId, mockPayload, logObj.method, logObj.file);
    expect(cbTriggered).toBe(codeObj.cbExpected);
    expect(logSpy).toBeCalledWith(codeObj.logMsg, logObj);
    if (codeObj.retryAfter) {
      expect(retryCallback).toBeCalledOnceWith(codeObj.retryAfter);
    } else {
      expect(retryCallback).not.toBeCalled();
    }
  });
});
describe('parseMediaQualityStatistics tests', function () {
  var logSpyObj = jest.spyOn(_Logger.default, 'log');
  var infoSpyObj = jest.spyOn(_Logger.default, 'info');
  var warnSpyObj = jest.spyOn(_Logger.default, 'warn');
  var logObj = {
    file: _constants.UTILS_FILE,
    method: _Utils.parseMediaQualityStatistics.name
  };
  var stats = (0, _testUtil.getSampleRawAndParsedMediaStats)();
  var statsWithVoOneWayDelayAndNw = stats.statsWithVoOneWayDelayAndNw;
  var statsWithoutVoOneWayDelayAndNw = stats.statsWithoutVoOneWayDelayAndNw;

  /**
   * TestCase inputs
   * name: TestCase name
   * original: Original RTCStatsReport
   * parsed: Parsed stats in form of CallRtpStats
   * logSpy: SpyInstance on the log object
   * logMsg: Expected log message.
   */
  var mqStats = [{
    name: 'Valid stats with non-zero VoOneWayDelayMs and networkType vpn',
    original: statsWithVoOneWayDelayAndNw.raw,
    parsed: statsWithVoOneWayDelayAndNw.parsed,
    logSpy: logSpyObj,
    logMsg: (0, _stringify.default)(statsWithVoOneWayDelayAndNw.parsed)
  }, {
    name: 'Valid stats with zero VoOneWayDelayMs and undefined networkType',
    original: statsWithoutVoOneWayDelayAndNw.raw,
    parsed: statsWithoutVoOneWayDelayAndNw.parsed,
    logSpy: logSpyObj,
    logMsg: (0, _stringify.default)(statsWithoutVoOneWayDelayAndNw.parsed)
  }, {
    name: 'undefined stats passed to parse function',
    original: undefined,
    parsed: _constants.DUMMY_METRICS,
    logSpy: infoSpyObj,
    logMsg: 'RTCStatsReport is null, adding dummy stats'
  }, {
    name: 'invalid metrics passed when outbound call is disconnected before a connect',
    original: {
      size: 26
    },
    parsed: _constants.DUMMY_METRICS,
    logSpy: warnSpyObj,
    logMsg: 'Caught error while parsing RTP stats, TypeError: stats.forEach is not a function'
  }].map(function (stat) {
    return (0, _assign.default)(stat, {
      toString: function toString() {
        return this.name;
      }
    });
  });
  it.each(mqStats)('%s', function (stat) {
    var result = (0, _Utils.parseMediaQualityStatistics)(stat.original);
    expect(result).toStrictEqual(stat.parsed);
    expect(stat.logSpy).toBeCalledOnceWith(stat.logMsg, logObj);
  });
});
describe('Voicemail Sorting Tests', function () {
  /* Tests Voicemail sorting in ascending and descending orders */

  it('verify VoiceMails sorting in Ascending order', function () {
    var voiceMailList = _voicemailFixture.getVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo;
    var sortedVoicemail = (0, _Utils.getSortedVoicemailList)(voiceMailList, _types.SORT.ASC);
    var voiceMailListAscOrder = _voicemailFixture.getAscVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo;
    expect(sortedVoicemail).toStrictEqual(voiceMailListAscOrder);
  });
  it('verify VoiceMails sorting in Descending Order', function () {
    var voiceMailList = _voicemailFixture.getVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo;
    var sortedVoicemail = (0, _Utils.getSortedVoicemailList)(voiceMailList, _types.SORT.DESC);
    var voiceMailListDescOrder = _voicemailFixture.getDescVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo;
    expect(sortedVoicemail).toStrictEqual(voiceMailListDescOrder);
  });
});
describe('resolveContact tests', function () {
  var scimUrl = "".concat(_constants2.WEBEX_API_BTS, "/").concat(_constants2.IDENTITY_ENDPOINT_RESOURCE, "/").concat(_constants2.SCIM_ENDPOINT_RESOURCE, "/").concat(webex.internal.device.orgId, "/").concat(_constants2.SCIM_USER_FILTER);
  it('Invalid CallingPartyInfo', function () {
    var callingPartyInfo = {};
    (0, _Utils.resolveContact)(callingPartyInfo).then(function (result) {
      expect(result).toBeNull();
    });
  });
  it('Resolve by userExternalId', function () {
    var callingPartyInfo = {};
    var webexSpy = jest.spyOn(webex, 'request').mockResolvedValue({
      statusCode: 200,
      body: (0, _testUtil.getSampleScimResponse)()
    });
    callingPartyInfo.userExternalId = {
      $: 'userExternalId'
    };
    (0, _Utils.resolveContact)(callingPartyInfo).then(function (displayInfo) {
      var _callingPartyInfo$use;
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.name).toStrictEqual('Cathy');
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.num).toStrictEqual('5008');
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.avatarSrc).toStrictEqual((0, _testUtil.getSampleScimResponse)().Resources[0].photos[0].value);
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.id).toStrictEqual((0, _testUtil.getSampleScimResponse)().Resources[0].id);
      var query = scimUrl + encodeURIComponent("id eq \"".concat((_callingPartyInfo$use = callingPartyInfo.userExternalId) === null || _callingPartyInfo$use === void 0 ? void 0 : _callingPartyInfo$use.$, "\""));
      expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
        uri: query
      }));
    });
  });
  it('Resolve by userExternalId - SCIM exception', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee() {
    var _callingPartyInfo$use2;
    var callingPartyInfo, warnSpy, webexSpy, displayInfo, query;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) switch (_context.prev = _context.next) {
        case 0:
          callingPartyInfo = {};
          warnSpy = jest.spyOn(_Logger.default, 'warn');
          webexSpy = jest.spyOn(webex, 'request').mockRejectedValueOnce({
            statusCode: 500
          });
          callingPartyInfo.userExternalId = {
            $: 'userExternalId'
          };
          _context.next = 6;
          return (0, _Utils.resolveContact)(callingPartyInfo);
        case 6:
          displayInfo = _context.sent;
          expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.name).toBeUndefined();
          expect(warnSpy).toHaveBeenCalledWith('Error response: - 500', {
            file: 'utils',
            method: 'resolveCallerIdDisplay'
          });
          query = scimUrl + encodeURIComponent("id eq \"".concat((_callingPartyInfo$use2 = callingPartyInfo.userExternalId) === null || _callingPartyInfo$use2 === void 0 ? void 0 : _callingPartyInfo$use2.$, "\""));
          expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
            uri: query
          }));
        case 11:
        case "end":
          return _context.stop();
      }
    }, _callee);
  })));
  it('Resolve by userExternalId - totalResults zero', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee2() {
    var _callingPartyInfo$use3;
    var callingPartyInfo, scimResponse, webexSpy, displayInfo, query;
    return _regenerator.default.wrap(function _callee2$(_context2) {
      while (1) switch (_context2.prev = _context2.next) {
        case 0:
          callingPartyInfo = {};
          scimResponse = (0, _testUtil.getSampleScimResponse)();
          scimResponse.totalResults = '0';
          webexSpy = jest.spyOn(webex, 'request').mockResolvedValueOnce({
            statusCode: 200,
            body: scimResponse
          });
          callingPartyInfo.userExternalId = {
            $: 'userExternalId'
          };
          _context2.next = 7;
          return (0, _Utils.resolveContact)(callingPartyInfo);
        case 7:
          displayInfo = _context2.sent;
          query = scimUrl + encodeURIComponent("id eq \"".concat((_callingPartyInfo$use3 = callingPartyInfo.userExternalId) === null || _callingPartyInfo$use3 === void 0 ? void 0 : _callingPartyInfo$use3.$, "\""));
          expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.name).toBeUndefined();
          expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
            uri: query
          }));
          scimResponse.totalResults = '1';
        case 12:
        case "end":
          return _context2.stop();
      }
    }, _callee2);
  })));
  it('Resolve by userExternalId - no primary number and no phone numbers', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee3() {
    var _callingPartyInfo$use4, _displayInfo, _displayInfo2;
    var callingPartyInfo, scimResponse, webexSpy, displayInfo, query, phoneNumbers;
    return _regenerator.default.wrap(function _callee3$(_context3) {
      while (1) switch (_context3.prev = _context3.next) {
        case 0:
          callingPartyInfo = {};
          scimResponse = (0, _testUtil.getSampleScimResponse)();
          scimResponse.Resources[0].phoneNumbers[1].primary = false;
          webexSpy = jest.spyOn(webex, 'request').mockResolvedValueOnce({
            statusCode: 200,
            body: scimResponse
          });
          callingPartyInfo.userExternalId = {
            $: 'userExternalId'
          };
          _context3.next = 7;
          return (0, _Utils.resolveContact)(callingPartyInfo);
        case 7:
          displayInfo = _context3.sent;
          query = scimUrl + encodeURIComponent("id eq \"".concat((_callingPartyInfo$use4 = callingPartyInfo.userExternalId) === null || _callingPartyInfo$use4 === void 0 ? void 0 : _callingPartyInfo$use4.$, "\""));
          expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
            uri: query
          }));
          expect((_displayInfo = displayInfo) === null || _displayInfo === void 0 ? void 0 : _displayInfo.num).toStrictEqual('5008');
          webexSpy.mockReset();
          scimResponse.Resources[0].phoneNumbers[1].primary = true;

          /* No phone numbers */
          phoneNumbers = scimResponse.Resources[0].phoneNumbers;
          scimResponse.Resources[0].phoneNumbers = [];
          webex.request.mockResolvedValueOnce({
            statusCode: 200,
            body: scimResponse
          });
          _context3.next = 18;
          return (0, _Utils.resolveContact)(callingPartyInfo);
        case 18:
          displayInfo = _context3.sent;
          expect((_displayInfo2 = displayInfo) === null || _displayInfo2 === void 0 ? void 0 : _displayInfo2.num).toBeUndefined();
          expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
            uri: query
          }));
          scimResponse.Resources[0].phoneNumbers = phoneNumbers;
        case 22:
        case "end":
          return _context3.stop();
      }
    }, _callee3);
  })));
  it('Resolve by userExternalId - no photo', function () {
    var callingPartyInfo = {};
    var scimResponse = (0, _testUtil.getSampleScimResponse)();
    scimResponse.Resources[0].photos = [];
    var webexSpy = jest.spyOn(webex, 'request').mockResolvedValue({
      statusCode: 200,
      body: scimResponse
    });
    callingPartyInfo.userExternalId = {
      $: 'userExternalId'
    };
    (0, _Utils.resolveContact)(callingPartyInfo).then(function (displayInfo) {
      var _callingPartyInfo$use5;
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.name).toStrictEqual('Cathy');
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.num).toStrictEqual('5008');
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.avatarSrc).toStrictEqual('unknown');
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.id).toStrictEqual((0, _testUtil.getSampleScimResponse)().Resources[0].id);
      var query = scimUrl + encodeURIComponent("id eq \"".concat((_callingPartyInfo$use5 = callingPartyInfo.userExternalId) === null || _callingPartyInfo$use5 === void 0 ? void 0 : _callingPartyInfo$use5.$, "\""));
      expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
        uri: query
      }));
    });
  });
  it('Resolve with minimal response from SCIM', function () {
    var callingPartyInfo = {};
    var scimResponse = (0, _testUtil.getSampleMinimumScimResponse)();

    // scimResponse.Resources[0].photos = [];
    var webexSpy = jest.spyOn(webex, 'request').mockResolvedValue({
      statusCode: 200,
      body: scimResponse
    });
    callingPartyInfo.userExternalId = {
      $: 'userExternalId'
    };
    (0, _Utils.resolveContact)(callingPartyInfo).then(function (displayInfo) {
      var _callingPartyInfo$use6;
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.name).toBeUndefined();
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.num).toBeUndefined();
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.avatarSrc).toStrictEqual('unknown');
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.id).toStrictEqual((0, _testUtil.getSampleMinimumScimResponse)().Resources[0].id);
      var query = scimUrl + encodeURIComponent("id eq \"".concat((_callingPartyInfo$use6 = callingPartyInfo.userExternalId) === null || _callingPartyInfo$use6 === void 0 ? void 0 : _callingPartyInfo$use6.$, "\""));
      expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
        uri: query
      }));
    });
  });
  it('Resolve by name', function () {
    var callingPartyInfo = {};
    var webexSpy = jest.spyOn(webex.people, 'list').mockResolvedValue((0, _testUtil.getSamplePeopleListResponse)());
    callingPartyInfo.name = {
      $: 'Name'
    };
    (0, _Utils.resolveContact)(callingPartyInfo).then(function (displayInfo) {
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.name).toStrictEqual((0, _testUtil.getSamplePeopleListResponse)().items[0].displayName);
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.num).toStrictEqual((0, _testUtil.getSamplePeopleListResponse)().items[0].phoneNumbers[0].value);
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.avatarSrc).toStrictEqual((0, _testUtil.getSamplePeopleListResponse)().items[0].avatar);
      expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.id).toStrictEqual(Buffer.from((0, _testUtil.getSamplePeopleListResponse)().items[0].id, 'base64').toString('binary').split('/').pop());
      expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
        displayName: 'Name'
      }));
    });
  });
  it('Resolve by name - Empty Info', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee4() {
    var callingPartyInfo, peopleListResponse, items, webexSpy, displayInfo;
    return _regenerator.default.wrap(function _callee4$(_context4) {
      while (1) switch (_context4.prev = _context4.next) {
        case 0:
          callingPartyInfo = {};
          peopleListResponse = (0, _testUtil.getSamplePeopleListResponse)();
          items = peopleListResponse.items;
          peopleListResponse.items = [];
          webexSpy = jest.spyOn(webex.people, 'list').mockResolvedValueOnce(peopleListResponse);
          callingPartyInfo.name = {
            $: 'Name'
          };
          _context4.next = 8;
          return (0, _Utils.resolveContact)(callingPartyInfo);
        case 8:
          displayInfo = _context4.sent;
          expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.name).toBeUndefined();
          expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
            displayName: 'Name'
          }));
          peopleListResponse.items = items;
        case 12:
        case "end":
          return _context4.stop();
      }
    }, _callee4);
  })));
  it('Resolve by name - ID as plain UUID instead of part of URI', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee5() {
    var _displayInfo3, _displayInfo4, _displayInfo5, _displayInfo6, _displayInfo7, _displayInfo8;
    var callingPartyInfo, peopleListResponse, id, webexSpy, displayInfo;
    return _regenerator.default.wrap(function _callee5$(_context5) {
      while (1) switch (_context5.prev = _context5.next) {
        case 0:
          callingPartyInfo = {};
          peopleListResponse = (0, _testUtil.getSamplePeopleListResponse)();
          id = peopleListResponse.items[0].id;
          /* Yjg1M2JiZDEtMTEzNi00ZDI1LTkzOGQtMGMzNzUzMWIxMjMz -> b853bbd1-1136-4d25-938d-0c37531b1233 */
          peopleListResponse.items[0].id = 'Yjg1M2JiZDEtMTEzNi00ZDI1LTkzOGQtMGMzNzUzMWIxMjMz';
          webexSpy = jest.spyOn(webex.people, 'list').mockResolvedValueOnce(peopleListResponse);
          callingPartyInfo.name = {
            $: 'Name'
          };
          _context5.next = 8;
          return (0, _Utils.resolveContact)(callingPartyInfo);
        case 8:
          displayInfo = _context5.sent;
          expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
            displayName: 'Name'
          }));
          expect((_displayInfo3 = displayInfo) === null || _displayInfo3 === void 0 ? void 0 : _displayInfo3.name).toStrictEqual(peopleListResponse.items[0].displayName);
          expect((_displayInfo4 = displayInfo) === null || _displayInfo4 === void 0 ? void 0 : _displayInfo4.num).toStrictEqual(peopleListResponse.items[0].phoneNumbers[0].value);
          expect((_displayInfo5 = displayInfo) === null || _displayInfo5 === void 0 ? void 0 : _displayInfo5.avatarSrc).toStrictEqual(peopleListResponse.items[0].avatar);
          expect((_displayInfo6 = displayInfo) === null || _displayInfo6 === void 0 ? void 0 : _displayInfo6.id).toStrictEqual(Buffer.from(peopleListResponse.items[0].id, 'base64').toString('binary').split('/').pop());
          webexSpy.mockReset();

          /* Also test empty id */
          peopleListResponse.items[0].id = '';
          webex.people.list.mockResolvedValueOnce(peopleListResponse);
          _context5.next = 19;
          return (0, _Utils.resolveContact)(callingPartyInfo);
        case 19:
          displayInfo = _context5.sent;
          expect((_displayInfo7 = displayInfo) === null || _displayInfo7 === void 0 ? void 0 : _displayInfo7.id).toStrictEqual('');
          expect((_displayInfo8 = displayInfo) === null || _displayInfo8 === void 0 ? void 0 : _displayInfo8.name).toStrictEqual(peopleListResponse.items[0].displayName);
          expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
            displayName: 'Name'
          }));
          peopleListResponse.items[0].id = id;
        case 24:
        case "end":
          return _context5.stop();
      }
    }, _callee5);
  })));
  it('Resolve by name - Phone numbers no match for type - work', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee6() {
    var callingPartyInfo, peopleListResponse, phoneNumbers, webexSpy, displayInfo;
    return _regenerator.default.wrap(function _callee6$(_context6) {
      while (1) switch (_context6.prev = _context6.next) {
        case 0:
          callingPartyInfo = {};
          peopleListResponse = (0, _testUtil.getSamplePeopleListResponse)();
          phoneNumbers = peopleListResponse.items[0].phoneNumbers;
          peopleListResponse.items[0].phoneNumbers[0].type = 'mobile';
          peopleListResponse.items[0].phoneNumbers[1].type = 'mobile';
          webexSpy = jest.spyOn(webex.people, 'list').mockResolvedValueOnce(peopleListResponse);
          callingPartyInfo.name = {
            $: 'Name'
          };
          _context6.next = 9;
          return (0, _Utils.resolveContact)(callingPartyInfo);
        case 9:
          displayInfo = _context6.sent;
          expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.name).toStrictEqual(peopleListResponse.items[0].displayName);
          expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.num).toStrictEqual(peopleListResponse.items[0].phoneNumbers[0].value);
          expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.avatarSrc).toStrictEqual(peopleListResponse.items[0].avatar);
          expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
            displayName: 'Name'
          }));
          peopleListResponse.items[0].phoneNumbers = phoneNumbers;
        case 15:
        case "end":
          return _context6.stop();
      }
    }, _callee6);
  })));
  it('Resolve by name - Phone numbers empty', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee7() {
    var callingPartyInfo, peopleListResponse, phoneNumbers, webexSpy, displayInfo;
    return _regenerator.default.wrap(function _callee7$(_context7) {
      while (1) switch (_context7.prev = _context7.next) {
        case 0:
          callingPartyInfo = {};
          peopleListResponse = (0, _testUtil.getSamplePeopleListResponse)();
          phoneNumbers = peopleListResponse.items[0].phoneNumbers;
          peopleListResponse.items[0].phoneNumbers = [];
          webexSpy = jest.spyOn(webex.people, 'list').mockResolvedValueOnce(peopleListResponse);
          callingPartyInfo.name = {
            $: 'Name'
          };
          _context7.next = 8;
          return (0, _Utils.resolveContact)(callingPartyInfo);
        case 8:
          displayInfo = _context7.sent;
          expect(webexSpy).toBeCalledOnceWith(expect.objectContaining({
            displayName: 'Name'
          }));
          expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.name).toStrictEqual(peopleListResponse.items[0].displayName);
          expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.num).toBeUndefined();
          expect(displayInfo === null || displayInfo === void 0 ? void 0 : displayInfo.avatarSrc).toStrictEqual(peopleListResponse.items[0].avatar);
          peopleListResponse.items[0].phoneNumbers = phoneNumbers;
        case 14:
        case "end":
          return _context7.stop();
      }
    }, _callee7);
  })));
});
describe('Store and Fetch voicemail tests', function () {
  /* Tests Voicemail pagination - storing voicemail list to and fetching from session storage */
  var dummyContext = 'dummy';
  var logContext = {
    file: 'voicemail',
    method: 'fetchVoicemail'
  };
  var getEncryptedVoicemail = function getEncryptedVoicemail(vmList) {
    return Buffer.from((0, _stringify.default)(vmList), 'utf8').toString('base64');
  };
  var getDecryptedVoicemail = function getDecryptedVoicemail() {
    var decryptedList = JSON.parse(Buffer.from(sessionStorage.getItem(dummyContext), 'base64').toString('utf8'));
    return decryptedList;
  };
  beforeAll(function () {
    // Mock storage
    var vmListStorage = {};
    global.Storage.prototype.setItem = jest.fn(function (key, value) {
      vmListStorage[key] = value;
    });
    global.Storage.prototype.getItem = jest.fn(function (key) {
      return vmListStorage[key];
    });
  });
  it('verify saving Voicemails in session storage', function () {
    var voicemailList = _voicemailFixture.getVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo;
    (0, _Utils.storeVoicemailList)(dummyContext, voicemailList);
    var voicemailFromSessionStorage = getDecryptedVoicemail();
    expect(global.sessionStorage.setItem).toHaveBeenCalledTimes(1);
    expect(voicemailFromSessionStorage).toEqual(voicemailList);
  });
  it('verify fetching all 5 voicemails from session storage', function () {
    var voicemailList = _voicemailFixture.getVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo;
    var encryptedVm = getEncryptedVoicemail(voicemailList);
    global.sessionStorage.setItem(dummyContext, encryptedVm.toString());
    var voicemailFromSessionStorage = (0, _Utils.fetchVoicemailList)(dummyContext, 0, 5, logContext);
    expect(global.Storage.prototype.getItem).toHaveBeenCalledTimes(1);
    expect(voicemailFromSessionStorage).toEqual({
      messages: voicemailList,
      moreVMAvailable: false
    });
  });
  it('verify fetching first 3 VoiceMails from session storage', function () {
    var voicemailList = _voicemailFixture.getVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo;
    var encryptedVm = getEncryptedVoicemail(voicemailList);
    global.sessionStorage.setItem(dummyContext, encryptedVm.toString());
    var voicemailFromSessionStorage = (0, _Utils.fetchVoicemailList)(dummyContext, 0, 3, logContext);
    expect(global.Storage.prototype.getItem).toHaveBeenCalledTimes(1);
    expect(voicemailFromSessionStorage).toEqual({
      messages: voicemailList.slice(0, 3),
      moreVMAvailable: true
    });
  });
  it('verify fetching 2nd and 3rd Voicemails from session storage', function () {
    var voicemailList = _voicemailFixture.getVoicemailListJsonWXC.body.VoiceMessagingMessages.messageInfoList.messageInfo;
    var encryptedVm = getEncryptedVoicemail(voicemailList);
    global.sessionStorage.setItem(dummyContext, encryptedVm.toString());
    var voicemailFromSessionStorage = (0, _Utils.fetchVoicemailList)(dummyContext, 1, 2, logContext);
    expect(global.Storage.prototype.getItem).toHaveBeenCalledTimes(1);
    expect(voicemailFromSessionStorage).toEqual({
      messages: voicemailList.slice(1, 3),
      moreVMAvailable: true
    });
  });
  it('verify fetch Voicemails with offset limit more than the available ones from session storage', function () {
    var voicemailList = [];
    var encryptedVm = getEncryptedVoicemail(voicemailList);
    global.sessionStorage.setItem(dummyContext, encryptedVm.toString());
    var voicemailFromSessionStorage = (0, _Utils.fetchVoicemailList)(dummyContext, 1, 5, logContext);
    expect(global.Storage.prototype.getItem).toHaveBeenCalledTimes(1);
    expect(voicemailFromSessionStorage).toEqual({
      messages: voicemailList.slice(1, 5),
      moreVMAvailable: false
    });
  });
  it('verify fetching Voicemails when it is []', function () {
    var voicemailFromSessionStorage = (0, _Utils.fetchVoicemailList)(dummyContext, 1, 5, logContext);
    expect(global.Storage.prototype.getItem).toHaveBeenCalledTimes(1);
    expect(voicemailFromSessionStorage).toEqual({
      messages: [],
      moreVMAvailable: false
    });
  });
  it('verify fetching Voicemails when there is exception', function () {
    var voiceMailList = '$%%';
    var logSpy = jest.spyOn(_Logger.default, 'warn');
    global.sessionStorage.setItem(dummyContext, voiceMailList);
    var voicemailFromSessionStorage = (0, _Utils.fetchVoicemailList)(dummyContext, 1, 5, logContext);
    expect(global.Storage.prototype.getItem).toBeCalledOnceWith('dummy');
    expect(logSpy).toHaveBeenCalledTimes(2);
    expect(logSpy).toHaveBeenCalledWith('Caught exception while fetching voicemail from storage. SyntaxError: Unexpected end of JSON input', logContext);
    expect(logSpy).toHaveBeenCalledWith('422 Exception has occurred', {});
    expect(voicemailFromSessionStorage).toEqual({
      messages: [],
      moreVMAvailable: false
    });
  });
});
describe('Infer id from  UUID Tests', function () {
  /* Tests conversion of UUID to hydra Id */

  it('verify encoding of userId to personId', function () {
    var uuid = '14533573-f6aa-429d-b4fe-58aa04a2b631';
    var hydraId = (0, _Utils.inferIdFromUuid)(uuid, _types.DecodeType.PEOPLE);
    var uuidAgain = Buffer.from(hydraId, 'base64').toString('binary');
    expect("".concat(_constants2.INFER_ID_CONSTANT, "/").concat(_types.DecodeType.PEOPLE, "/").concat(uuid)).toStrictEqual(uuidAgain);
  });
  it('verify encoding of orgId', function () {
    var orgId = '24533573-f6aa-429d-b4fe-58aa04a2b630';
    var encodedOrgId = (0, _Utils.inferIdFromUuid)(orgId, _types.DecodeType.ORGANIZATION);
    var orgIdAgain = Buffer.from(encodedOrgId, 'base64').toString('binary');
    expect("".concat(_constants2.INFER_ID_CONSTANT, "/").concat(_types.DecodeType.ORGANIZATION, "/").concat(orgId)).toStrictEqual(orgIdAgain);
  });
});
describe('Get endpoint by CALLING_BACKEND tests', function () {
  it('verify invalid calling backend ucm for xsi endpoint', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee8() {
    return _regenerator.default.wrap(function _callee8$(_context8) {
      while (1) switch (_context8.prev = _context8.next) {
        case 0:
          _context8.t0 = expect;
          _context8.next = 3;
          return (0, _Utils.getXsiActionEndpoint)(webex, {
            file: 'testFile',
            method: 'testMethod'
          }, _types.CALLING_BACKEND.UCM);
        case 3:
          _context8.t1 = _context8.sent;
          (0, _context8.t0)(_context8.t1).toBeInstanceOf(Error);
        case 5:
        case "end":
          return _context8.stop();
      }
    }, _callee8);
  })));
  it('verify invalid calling backend wxc for vg endpoint', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee9() {
    return _regenerator.default.wrap(function _callee9$(_context9) {
      while (1) switch (_context9.prev = _context9.next) {
        case 0:
          _context9.t0 = expect;
          _context9.next = 3;
          return (0, _Utils.getVgActionEndpoint)(webex, _types.CALLING_BACKEND.WXC);
        case 3:
          _context9.t1 = _context9.sent;
          (0, _context9.t0)(_context9.t1).toBeInstanceOf(Error);
        case 5:
        case "end":
          return _context9.stop();
      }
    }, _callee9);
  })));
});
describe('Get XSI Action Endpoint tests', function () {
  var mockWebex = {
    request: jest.fn(),
    internal: {
      services: {
        _serviceUrls: {
          wdm: 'https://fake-webex-url.com'
        }
      }
    }
  };
  var loggerContext = {
    file: 'testFile',
    method: 'testMethod'
  };
  it('should return xsiEndpoint for BWRKS backend when URL ends with /v2.0', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee10() {
    var mockResponse, xsiEndpoint;
    return _regenerator.default.wrap(function _callee10$(_context10) {
      while (1) switch (_context10.prev = _context10.next) {
        case 0:
          mockResponse = {
            body: {
              devices: [{
                settings: {
                  broadworksXsiActionsUrl: 'https://fake-broadworks-url.com/v2.0'
                }
              }]
            }
          };
          mockWebex.request.mockResolvedValue(mockResponse);
          _context10.next = 4;
          return (0, _Utils.getXsiActionEndpoint)(mockWebex, loggerContext, _types.CALLING_BACKEND.BWRKS);
        case 4:
          xsiEndpoint = _context10.sent;
          expect(mockWebex.request).toHaveBeenCalledTimes(1);
          expect(xsiEndpoint).toBe('https://fake-broadworks-url.com');
        case 7:
        case "end":
          return _context10.stop();
      }
    }, _callee10);
  })));
  it('should return xsiEndpoint for BWRKS backend when URL ends with /v2.0/', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee11() {
    var mockResponse, xsiEndpoint;
    return _regenerator.default.wrap(function _callee11$(_context11) {
      while (1) switch (_context11.prev = _context11.next) {
        case 0:
          mockResponse = {
            body: {
              devices: [{
                settings: {
                  broadworksXsiActionsUrl: 'https://fake-broadworks-url.com/v2.0/'
                }
              }]
            }
          };
          mockWebex.request.mockResolvedValue(mockResponse);
          _context11.next = 4;
          return (0, _Utils.getXsiActionEndpoint)(mockWebex, loggerContext, _types.CALLING_BACKEND.BWRKS);
        case 4:
          xsiEndpoint = _context11.sent;
          expect(mockWebex.request).toHaveBeenCalledTimes(1);
          expect(xsiEndpoint).toBe('https://fake-broadworks-url.com');
        case 7:
        case "end":
          return _context11.stop();
      }
    }, _callee11);
  })));
  it('should return xsiEndpoint for BWRKS backend when URL does not end with any version', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee12() {
    var mockResponse, xsiEndpoint;
    return _regenerator.default.wrap(function _callee12$(_context12) {
      while (1) switch (_context12.prev = _context12.next) {
        case 0:
          mockResponse = {
            body: {
              devices: [{
                settings: {
                  broadworksXsiActionsUrl: 'https://fake-broadworks-url.com'
                }
              }]
            }
          };
          mockWebex.request.mockResolvedValue(mockResponse);
          _context12.next = 4;
          return (0, _Utils.getXsiActionEndpoint)(mockWebex, loggerContext, _types.CALLING_BACKEND.BWRKS);
        case 4:
          xsiEndpoint = _context12.sent;
          expect(mockWebex.request).toHaveBeenCalledTimes(1);
          expect(xsiEndpoint).toBe('https://fake-broadworks-url.com');
        case 7:
        case "end":
          return _context12.stop();
      }
    }, _callee12);
  })));
});
describe('modifySdpForIPv4', function () {
  it('should return original SDP if input is empty', function () {
    expect((0, _Utils.modifySdpForIPv4)('')).toBe('');
  });
  it('should return original SDP if there is no IPv6 c= line', function () {
    var sdp = "v=0\no=- 12345 67890 IN IP4 192.168.1.1\n\ns=Test Session";
    expect((0, _Utils.modifySdpForIPv4)(sdp)).toEqual(sdp);
  });
  it('should replace IPv6 c= line with default IPv4 if no IPv4 candidate exists', function () {
    var sdp = "v=0\n    o=- 12345 67890 IN IP6 2001:db8::1\n    s=Test Session\n    c=IN IP6 2001:db8::1\n    a=candidate:1 1 UDP 2122260223 2001:db8::1 3478 typ host";
    var expectedSdp = "v=0\no=- 12345 67890 IN IP6 2001:db8::1\ns=Test Session\nc=IN IP4 192.1.1.1\na=candidate:1 1 UDP 2122260223 2001:db8::1 3478 typ host\na=candidate:2 1 UDP 2122260223 192.1.1.1 3478 typ host generation 0 network-id 1 network-cost 10";
    var result = (0, _Utils.modifySdpForIPv4)(sdp);
    expect(result).toEqual(expectedSdp);
  });
  it('should replace IPv6 c= line with an existing IPv4 candidate address', function () {
    var sdp = "v=0\n    o=- 12345 67890 IN IP6 2001:db8::1\n    s=Test Session\n    c=IN IP6 2001:db8::1\n    a=candidate:1 1 UDP 2122260223 192.168.1.2 3478 typ host";
    var expectedSdp = "v=0\no=- 12345 67890 IN IP6 2001:db8::1\ns=Test Session\nc=IN IP4 192.168.1.2\na=candidate:1 1 UDP 2122260223 192.168.1.2 3478 typ host";
    expect((0, _Utils.modifySdpForIPv4)(sdp).trim()).toEqual(expectedSdp.trim());
  });
  it('should correctly handle both UDP and TCP candidates by adding only one IPv4 candidate UDP first', function () {
    var sdp = "v=0\n    o=- 12345 67890 IN IP6 2001:db8::1\n    s=Test Session\n    c=IN IP6 2001:db8::1\n    a=candidate:1 1 UDP 2122260223 2001:db8::1 3478 typ host\n    a=candidate:2 1 TCP 2122260223 2001:db8::2 3479 typ host";
    var expectedSdp = "v=0\no=- 12345 67890 IN IP6 2001:db8::1\ns=Test Session\nc=IN IP4 192.1.1.1\na=candidate:1 1 UDP 2122260223 2001:db8::1 3478 typ host\na=candidate:2 1 UDP 2122260223 192.1.1.1 3478 typ host generation 0 network-id 1 network-cost 10\na=candidate:2 1 TCP 2122260223 2001:db8::2 3479 typ host\n";
    expect((0, _Utils.modifySdpForIPv4)(sdp).trim()).toEqual(expectedSdp.trim());
  });
  it('should correctly handle both UDP and TCP candidates by adding only one IPv4 candidate TCP first', function () {
    var sdp = "v=0\n    o=- 12345 67890 IN IP6 2001:db8::1\n    s=Test Session\n    c=IN IP6 2001:db8::1\n    a=candidate:1 1 TCP 2122260223 2001:db8::2 3479 typ host\n    a=candidate:1 1 UDP 2122260223 2001:db8::1 3478 typ host";
    var expectedSdp = "v=0\no=- 12345 67890 IN IP6 2001:db8::1\ns=Test Session\nc=IN IP4 192.1.1.1\na=candidate:1 1 TCP 2122260223 2001:db8::2 3479 typ host\na=candidate:2 1 TCP 2122260223 192.1.1.1 3479 typ host generation 0 network-id 1 network-cost 10\na=candidate:1 1 UDP 2122260223 2001:db8::1 3478 typ host";
    expect((0, _Utils.modifySdpForIPv4)(sdp).trim()).toEqual(expectedSdp.trim());
  });
  it('should replace all IPv6 c= line if multiple exist', function () {
    var sdp = "v=0\n    o=- 12345 67890 IN IP6 2001:db8::1\n    s=Test Session\n    c=IN IP6 2001:db8::1\n    c=IN IP6 2001:db8::2\n    a=candidate:1 1 UDP 2122260223 2001:db8::1 3478 typ host";
    var expectedSdp = "v=0\no=- 12345 67890 IN IP6 2001:db8::1\ns=Test Session\nc=IN IP4 192.1.1.1\nc=IN IP4 192.1.1.1\na=candidate:1 1 UDP 2122260223 2001:db8::1 3478 typ host\na=candidate:2 1 UDP 2122260223 192.1.1.1 3478 typ host generation 0 network-id 1 network-cost 10";
    expect((0, _Utils.modifySdpForIPv4)(sdp).trim()).toEqual(expectedSdp.trim());
  });
  it('should not modify SDP if IPv6 c= line is absent and IPv4 candidate already exists', function () {
    var sdp = "v=0\no=- 12345 67890 IN IP4 192.168.1.1\ns=Test Session\nc=IN IP4 192.168.1.1\na=candidate:1 1 UDP 2122260223 192.168.1.1 3478 typ host";
    expect((0, _Utils.modifySdpForIPv4)(sdp).trim()).toEqual(sdp.trim());
  });
  it('should handle malformed SDP gracefully and return unmodified input', function () {
    var malformedSdp = "random text without proper format";
    expect((0, _Utils.modifySdpForIPv4)(malformedSdp).trim()).toEqual(malformedSdp.trim());
  });
  it('should handle an SDP with both IP6 and IP4 c= lines correctly', function () {
    var sdp = "v=0\n    o=- 12345 67890 IN IP6 2001:db8::1\n    s=Test Session\n    c=IN IP6 2001:db8::1\n    c=IN IP4 192.168.1.3\n    a=candidate:1 1 UDP 2122260223 192.168.1.3 3478 typ host";
    var expectedSdp = "v=0\no=- 12345 67890 IN IP6 2001:db8::1\ns=Test Session\nc=IN IP4 192.168.1.3\nc=IN IP4 192.168.1.3\na=candidate:1 1 UDP 2122260223 192.168.1.3 3478 typ host";
    expect((0, _Utils.modifySdpForIPv4)(sdp).trim()).toEqual(expectedSdp.trim());
  });
});
describe('uploadLogs tests', function () {
  it('should call submitLogs with the provided data', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee13() {
    var mockData;
    return _regenerator.default.wrap(function _callee13$(_context13) {
      while (1) switch (_context13.prev = _context13.next) {
        case 0:
          mockData = {
            someKey: 'someValue'
          };
          _context13.next = 3;
          return (0, _Utils.uploadLogs)(mockData);
        case 3:
          expect(_SDKConnector.default.getWebex().internal.support.submitLogs).toHaveBeenCalledTimes(1);
          expect(_SDKConnector.default.getWebex().internal.support.submitLogs).toHaveBeenCalledWith(mockData);
        case 5:
        case "end":
          return _context13.stop();
      }
    }, _callee13);
  })));
  it('should handle errors when submitLogs fails', /*#__PURE__*/(0, _asyncToGenerator2.default)( /*#__PURE__*/_regenerator.default.mark(function _callee14() {
    var mockError, logSpy;
    return _regenerator.default.wrap(function _callee14$(_context14) {
      while (1) switch (_context14.prev = _context14.next) {
        case 0:
          mockError = new Error('Test error');
          _SDKConnector.default.getWebex().internal.support.submitLogs.mockRejectedValue(mockError);
          logSpy = jest.spyOn(_Logger.default, 'error');
          _context14.next = 5;
          return (0, _Utils.uploadLogs)({});
        case 5:
          expect(logSpy).toHaveBeenCalledWith(mockError, {
            file: _constants.UTILS_FILE,
            method: 'uploadLogs'
          });
        case 6:
        case "end":
          return _context14.stop();
      }
    }, _callee14);
  })));
});
//# sourceMappingURL=Utils.test.js.map
