import { EventEmitter } from 'events';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var logger = {exports: {}};

/*!
 * js-logger - http://github.com/jonnyreeves/js-logger
 * Jonny Reeves, http://jonnyreeves.co.uk/
 * js-logger may be freely distributed under the MIT license.
 */

(function (module) {
(function (global) {

	// Top level module for the global, static logger instance.
	var Logger = { };

	// For those that are at home that are keeping score.
	Logger.VERSION = "1.6.1";

	// Function which handles all incoming log messages.
	var logHandler;

	// Map of ContextualLogger instances by name; used by Logger.get() to return the same named instance.
	var contextualLoggersByNameMap = {};

	// Polyfill for ES5's Function.bind.
	var bind = function(scope, func) {
		return function() {
			return func.apply(scope, arguments);
		};
	};

	// Super exciting object merger-matron 9000 adding another 100 bytes to your download.
	var merge = function () {
		var args = arguments, target = args[0], key, i;
		for (i = 1; i < args.length; i++) {
			for (key in args[i]) {
				if (!(key in target) && args[i].hasOwnProperty(key)) {
					target[key] = args[i][key];
				}
			}
		}
		return target;
	};

	// Helper to define a logging level object; helps with optimisation.
	var defineLogLevel = function(value, name) {
		return { value: value, name: name };
	};

	// Predefined logging levels.
	Logger.TRACE = defineLogLevel(1, 'TRACE');
	Logger.DEBUG = defineLogLevel(2, 'DEBUG');
	Logger.INFO = defineLogLevel(3, 'INFO');
	Logger.TIME = defineLogLevel(4, 'TIME');
	Logger.WARN = defineLogLevel(5, 'WARN');
	Logger.ERROR = defineLogLevel(8, 'ERROR');
	Logger.OFF = defineLogLevel(99, 'OFF');

	// Inner class which performs the bulk of the work; ContextualLogger instances can be configured independently
	// of each other.
	var ContextualLogger = function(defaultContext) {
		this.context = defaultContext;
		this.setLevel(defaultContext.filterLevel);
		this.log = this.info;  // Convenience alias.
	};

	ContextualLogger.prototype = {
		// Changes the current logging level for the logging instance.
		setLevel: function (newLevel) {
			// Ensure the supplied Level object looks valid.
			if (newLevel && "value" in newLevel) {
				this.context.filterLevel = newLevel;
			}
		},
		
		// Gets the current logging level for the logging instance
		getLevel: function () {
			return this.context.filterLevel;
		},

		// Is the logger configured to output messages at the supplied level?
		enabledFor: function (lvl) {
			var filterLevel = this.context.filterLevel;
			return lvl.value >= filterLevel.value;
		},

		trace: function () {
			this.invoke(Logger.TRACE, arguments);
		},

		debug: function () {
			this.invoke(Logger.DEBUG, arguments);
		},

		info: function () {
			this.invoke(Logger.INFO, arguments);
		},

		warn: function () {
			this.invoke(Logger.WARN, arguments);
		},

		error: function () {
			this.invoke(Logger.ERROR, arguments);
		},

		time: function (label) {
			if (typeof label === 'string' && label.length > 0) {
				this.invoke(Logger.TIME, [ label, 'start' ]);
			}
		},

		timeEnd: function (label) {
			if (typeof label === 'string' && label.length > 0) {
				this.invoke(Logger.TIME, [ label, 'end' ]);
			}
		},

		// Invokes the logger callback if it's not being filtered.
		invoke: function (level, msgArgs) {
			if (logHandler && this.enabledFor(level)) {
				logHandler(msgArgs, merge({ level: level }, this.context));
			}
		}
	};

	// Protected instance which all calls to the to level `Logger` module will be routed through.
	var globalLogger = new ContextualLogger({ filterLevel: Logger.OFF });

	// Configure the global Logger instance.
	(function() {
		// Shortcut for optimisers.
		var L = Logger;

		L.enabledFor = bind(globalLogger, globalLogger.enabledFor);
		L.trace = bind(globalLogger, globalLogger.trace);
		L.debug = bind(globalLogger, globalLogger.debug);
		L.time = bind(globalLogger, globalLogger.time);
		L.timeEnd = bind(globalLogger, globalLogger.timeEnd);
		L.info = bind(globalLogger, globalLogger.info);
		L.warn = bind(globalLogger, globalLogger.warn);
		L.error = bind(globalLogger, globalLogger.error);

		// Don't forget the convenience alias!
		L.log = L.info;
	}());

	// Set the global logging handler.  The supplied function should expect two arguments, the first being an arguments
	// object with the supplied log messages and the second being a context object which contains a hash of stateful
	// parameters which the logging function can consume.
	Logger.setHandler = function (func) {
		logHandler = func;
	};

	// Sets the global logging filter level which applies to *all* previously registered, and future Logger instances.
	// (note that named loggers (retrieved via `Logger.get`) can be configured independently if required).
	Logger.setLevel = function(level) {
		// Set the globalLogger's level.
		globalLogger.setLevel(level);

		// Apply this level to all registered contextual loggers.
		for (var key in contextualLoggersByNameMap) {
			if (contextualLoggersByNameMap.hasOwnProperty(key)) {
				contextualLoggersByNameMap[key].setLevel(level);
			}
		}
	};

	// Gets the global logging filter level
	Logger.getLevel = function() {
		return globalLogger.getLevel();
	};

	// Retrieve a ContextualLogger instance.  Note that named loggers automatically inherit the global logger's level,
	// default context and log handler.
	Logger.get = function (name) {
		// All logger instances are cached so they can be configured ahead of use.
		return contextualLoggersByNameMap[name] ||
			(contextualLoggersByNameMap[name] = new ContextualLogger(merge({ name: name }, globalLogger.context)));
	};

	// CreateDefaultHandler returns a handler function which can be passed to `Logger.setHandler()` which will
	// write to the window's console object (if present); the optional options object can be used to customise the
	// formatter used to format each log message.
	Logger.createDefaultHandler = function (options) {
		options = options || {};

		options.formatter = options.formatter || function defaultMessageFormatter(messages, context) {
			// Prepend the logger's name to the log message for easy identification.
			if (context.name) {
				messages.unshift("[" + context.name + "]");
			}
		};

		// Map of timestamps by timer labels used to track `#time` and `#timeEnd()` invocations in environments
		// that don't offer a native console method.
		var timerStartTimeByLabelMap = {};

		// Support for IE8+ (and other, slightly more sane environments)
		var invokeConsoleMethod = function (hdlr, messages) {
			Function.prototype.apply.call(hdlr, console, messages);
		};

		// Check for the presence of a logger.
		if (typeof console === "undefined") {
			return function () { /* no console */ };
		}

		return function(messages, context) {
			// Convert arguments object to Array.
			messages = Array.prototype.slice.call(messages);

			var hdlr = console.log;
			var timerLabel;

			if (context.level === Logger.TIME) {
				timerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];

				if (messages[1] === 'start') {
					if (console.time) {
						console.time(timerLabel);
					}
					else {
						timerStartTimeByLabelMap[timerLabel] = new Date().getTime();
					}
				}
				else {
					if (console.timeEnd) {
						console.timeEnd(timerLabel);
					}
					else {
						invokeConsoleMethod(hdlr, [ timerLabel + ': ' +
							(new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms' ]);
					}
				}
			}
			else {
				// Delegate through to custom warn/error loggers if present on the console.
				if (context.level === Logger.WARN && console.warn) {
					hdlr = console.warn;
				} else if (context.level === Logger.ERROR && console.error) {
					hdlr = console.error;
				} else if (context.level === Logger.INFO && console.info) {
					hdlr = console.info;
				} else if (context.level === Logger.DEBUG && console.debug) {
					hdlr = console.debug;
				} else if (context.level === Logger.TRACE && console.trace) {
					hdlr = console.trace;
				}

				options.formatter(messages, context);
				invokeConsoleMethod(hdlr, messages);
			}
		};
	};

	// Configure and example a Default implementation which writes to the `window.console` (if present).  The
	// `options` hash can be used to configure the default logLevel and provide a custom message formatter.
	Logger.useDefaults = function(options) {
		Logger.setLevel(options && options.defaultLevel || Logger.DEBUG);
		Logger.setHandler(Logger.createDefaultHandler(options));
	};

	// Createa an alias to useDefaults to avoid reaking a react-hooks rule.
	Logger.setDefaults = Logger.useDefaults;

	// Export to popular environments boilerplate.
	if (module.exports) {
		module.exports = Logger;
	}
	else {
		Logger._prevLogger = global.Logger;

		Logger.noConflict = function () {
			global.Logger = Logger._prevLogger;
			return Logger;
		};

		global.Logger = Logger;
	}
}(commonjsGlobal));
}(logger));

var Logger = logger.exports;

Logger.useDefaults({
    defaultLevel: Logger.DEBUG,
    formatter: (messages, context) => {
        messages.unshift(`[${context.name}] `);
    },
});

function areNamedMediaGroupsEqual(left, right) {
    return left.type === right.type && left.value === right.value;
}

var MediaFamily;
(function (MediaFamily) {
    MediaFamily["Audio"] = "AUDIO";
    MediaFamily["Video"] = "VIDEO";
})(MediaFamily || (MediaFamily = {}));
var MediaContent;
(function (MediaContent) {
    MediaContent["Main"] = "MAIN";
    MediaContent["Slides"] = "SLIDES";
})(MediaContent || (MediaContent = {}));
var Policy;
(function (Policy) {
    Policy["ActiveSpeaker"] = "active-speaker";
    Policy["ReceiverSelected"] = "receiver-selected";
})(Policy || (Policy = {}));
var MediaType;
(function (MediaType) {
    MediaType["VideoMain"] = "VIDEO-MAIN";
    MediaType["VideoSlides"] = "VIDEO-SLIDES";
    MediaType["AudioMain"] = "AUDIO-MAIN";
    MediaType["AudioSlides"] = "AUDIO-SLIDES";
})(MediaType || (MediaType = {}));

function randomInteger(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
function generateSceneId() {
    return randomInteger(0, 0x7fffff);
}
function generateCsi(mediaFamily, sceneId) {
    let av;
    if (mediaFamily === MediaFamily.Audio) {
        av = 0;
    }
    else {
        av = 1;
    }
    return (sceneId << 8) | av;
}
function getMediaType(mediaFamily, mediaContent) {
    if (mediaFamily === MediaFamily.Video && mediaContent === MediaContent.Main) {
        return MediaType.VideoMain;
    }
    if (mediaFamily === MediaFamily.Video && mediaContent === MediaContent.Slides) {
        return MediaType.VideoSlides;
    }
    if (mediaFamily === MediaFamily.Audio && mediaContent === MediaContent.Main) {
        return MediaType.AudioMain;
    }
    return MediaType.AudioSlides;
}
function getMediaFamily(mediaType) {
    return [MediaType.VideoMain, MediaType.VideoSlides].includes(mediaType)
        ? MediaFamily.Video
        : MediaFamily.Audio;
}
function getMediaContent(mediaType) {
    return [MediaType.VideoMain, MediaType.AudioMain].includes(mediaType)
        ? MediaContent.Main
        : MediaContent.Slides;
}
const isTruthyOrZero = (value) => value === 0 || Boolean(value);
function areArraysEqual(left, right, predicate) {
    if (left.length !== right.length) {
        return false;
    }
    for (let i = 0; i < left.length; i += 1) {
        if (!predicate(left[i], right[i])) {
            return false;
        }
    }
    return true;
}

class ActiveSpeakerInfo {
    constructor(priority, crossPriorityDuplication, crossPolicyDuplication, preferLiveVideo, namedMediaGroups) {
        this.priority = priority;
        this.crossPriorityDuplication = crossPriorityDuplication;
        this.crossPolicyDuplication = crossPolicyDuplication;
        this.preferLiveVideo = preferLiveVideo;
        this.namedMediaGroups = namedMediaGroups;
    }
    toString() {
        return `ActiveSpeakerInfo(priority=${this.priority}, crossPriorityDuplication=${this.crossPriorityDuplication}, crossPolicyDuplication=${this.crossPolicyDuplication}, preferLiveVideo=${this.preferLiveVideo}), namedMediaGroups=${this.namedMediaGroups}`;
    }
}
function isValidActiveSpeakerInfo(msg) {
    const maybeActiveSpeakerInfo = msg;
    return Boolean('priority' in maybeActiveSpeakerInfo &&
        'crossPriorityDuplication' in maybeActiveSpeakerInfo &&
        'crossPolicyDuplication' in maybeActiveSpeakerInfo &&
        'preferLiveVideo' in maybeActiveSpeakerInfo);
}
function areActiveSpeakerInfosEqual(left, right) {
    return (left.priority === right.priority &&
        left.crossPriorityDuplication === right.crossPriorityDuplication &&
        left.crossPolicyDuplication === right.crossPolicyDuplication &&
        left.preferLiveVideo === right.preferLiveVideo &&
        areArraysEqual(left.namedMediaGroups || [], right.namedMediaGroups || [], areNamedMediaGroupsEqual));
}

class ActiveSpeakerNotificationMsg {
    constructor(seqNum, csis) {
        this.seqNum = seqNum;
        this.csis = csis;
    }
    toString() {
        return `ActiveSpeakerNotificationMsg(seqNum=${this.seqNum}, csis=[${this.csis}])`;
    }
}
function isValidActiveSpeakerNotificationMsg(msg) {
    const maybeActiveSpeakerNotificationMsg = msg;
    return Boolean(maybeActiveSpeakerNotificationMsg.seqNum && maybeActiveSpeakerNotificationMsg.csis);
}

class H264Codec {
    constructor(maxFs, maxFps, maxMbps, maxWidth, maxHeight) {
        this.maxFs = maxFs;
        this.maxFps = maxFps;
        this.maxMbps = maxMbps;
        this.maxWidth = maxWidth;
        this.maxHeight = maxHeight;
    }
}
function isValidH264Codec(msg) {
    const maybeH264Codec = msg;
    return Boolean(maybeH264Codec.maxFs && maybeH264Codec.maxFps && maybeH264Codec.maxMbps);
}
function areH264CodecsEqual(left, right) {
    if (left === undefined || right === undefined) {
        return left === right;
    }
    return (left.maxFs === right.maxFs &&
        left.maxFps === right.maxFps &&
        left.maxMbps === right.maxMbps &&
        left.maxWidth === right.maxWidth &&
        left.maxHeight === right.maxHeight);
}

class CodecInfo {
    constructor(payloadType, h264) {
        this.payloadType = payloadType;
        this.h264 = h264;
    }
}
function isValidCodecRequestInfo(msg) {
    const maybeCodecRequestInfo = msg;
    return Boolean(maybeCodecRequestInfo.payloadType && maybeCodecRequestInfo.h264);
}
function areCodecInfosEqual(left, right) {
    return left.payloadType === right.payloadType && areH264CodecsEqual(left.h264, right.h264);
}

var HomerMsgType;
(function (HomerMsgType) {
    HomerMsgType["Multistream"] = "multistream";
})(HomerMsgType || (HomerMsgType = {}));
class HomerMsg {
    constructor(msgType, payload) {
        this.msgType = msgType;
        this.payload = payload;
    }
    static fromJson(data) {
        if (!data.msgType || !data.payload) {
            return null;
        }
        return new HomerMsg(data.msgType, data.payload);
    }
}

var JmpMsgType;
(function (JmpMsgType) {
    JmpMsgType["MediaRequest"] = "mediaRequest";
    JmpMsgType["MediaRequestAck"] = "mediaRequestAck";
    JmpMsgType["MediaRequestStatus"] = "mediaRequestStatus";
    JmpMsgType["MediaRequestStatusAck"] = "mediaRequestStatusAck";
    JmpMsgType["SourceAdvertisement"] = "sourceAdvertisement";
    JmpMsgType["SourceAdvertisementAck"] = "sourceAdvertisementAck";
    JmpMsgType["ActiveSpeakerNotification"] = "activeSpeakerNotification";
})(JmpMsgType || (JmpMsgType = {}));
class JmpMsg {
    constructor(mediaFamily, mediaContent, payload) {
        this.mediaFamily = mediaFamily;
        this.mediaContent = mediaContent;
        this.payload = payload;
    }
    toString() {
        return `JmpMsg(mediaFamily=${this.mediaFamily}, mediaContent=${this.mediaContent}, payload=${this.payload})`;
    }
}
function isValidJmpMsgPayload(msg) {
    const maybeJmpMsgPayload = msg;
    return Boolean(maybeJmpMsgPayload.msgType && maybeJmpMsgPayload.payload);
}
function isValidJmpMsg(msg) {
    const maybeJmpMsg = msg;
    return Boolean(maybeJmpMsg.mediaContent &&
        maybeJmpMsg.mediaFamily &&
        maybeJmpMsg.payload &&
        isValidJmpMsgPayload(maybeJmpMsg.payload));
}

class MediaRequestMsg {
    constructor(seqNum, requests) {
        this.seqNum = seqNum;
        this.requests = requests;
    }
    toString() {
        return `JmpMediaMsg(seqNum=${this.seqNum}, requests=[${this.requests}])`;
    }
}
function isValidMediaRequestMsg(msg) {
    const maybeMediaRequestMsg = msg;
    return Boolean(maybeMediaRequestMsg.seqNum && maybeMediaRequestMsg.requests);
}

class MediaRequestAckMsg {
    constructor(mediaRequestSeqNum) {
        this.mediaRequestSeqNum = mediaRequestSeqNum;
    }
    toString() {
        return `MediaRequestAckMsg(seqNum=${this.mediaRequestSeqNum})`;
    }
}
function isValidMediaRequestAckMsg(msg) {
    const maybeMediaRequestAckMsg = msg;
    return Boolean(maybeMediaRequestAckMsg.mediaRequestSeqNum);
}

function isValidMidRidStreamId(obj) {
    if (typeof obj !== 'object' || obj === null)
        return false;
    const maybeMidRidStreamId = obj;
    return (typeof maybeMidRidStreamId.mid === 'string' &&
        (maybeMidRidStreamId.rid === undefined || typeof maybeMidRidStreamId.rid === 'string') &&
        !('ssrc' in maybeMidRidStreamId));
}
function isValidSsrcStreamId(obj) {
    if (typeof obj !== 'object' || obj === null)
        return false;
    const maybeSsrcStreamId = obj;
    return (typeof maybeSsrcStreamId.ssrc === 'number' &&
        (maybeSsrcStreamId.rtxSsrc === undefined || typeof maybeSsrcStreamId.rtxSsrc === 'number') &&
        !('mid' in maybeSsrcStreamId));
}
function isValidStreamId(obj) {
    return isValidMidRidStreamId(obj) || isValidSsrcStreamId(obj);
}
function areStreamIdsEqual(id1, id2) {
    const keys1 = Object.keys(id1);
    const keys2 = Object.keys(id2);
    if (keys1.length !== keys2.length) {
        return false;
    }
    return keys1.every((key) => id1[key] === id2[key]);
}

function isValidStreamInfo(obj) {
    const maybeStreamInfo = obj;
    return Boolean(maybeStreamInfo.id &&
        isValidStreamId(maybeStreamInfo.id) &&
        ['no source', 'invalid source', 'live', 'avatar', 'bandwidth disabled', 'away'].includes(maybeStreamInfo.state));
}
function areStreamInfosEqual(left, right) {
    return (areStreamIdsEqual(left.id, right.id) && left.state === right.state && left.csi === right.csi);
}

class MediaRequestStatusMsg {
    constructor(seqNum, streamStates) {
        this.seqNum = seqNum;
        this.streamStates = streamStates;
    }
}
function isValidMediaRequestStatusMsg(msg) {
    const maybeMediaRequestStatusMsg = msg;
    return (Boolean(maybeMediaRequestStatusMsg.seqNum) &&
        maybeMediaRequestStatusMsg.streamStates &&
        maybeMediaRequestStatusMsg.streamStates.every((streamInfo) => isValidStreamInfo(streamInfo)));
}

class MediaRequestStatusAckMsg {
    constructor(mediaRequestStatusSeqNum) {
        this.mediaRequestStatusSeqNum = mediaRequestStatusSeqNum;
    }
    toString() {
        return `MediaRequestStatusAckMsg(seqNum=${this.mediaRequestStatusSeqNum})`;
    }
}
function isValidMediaRequestStatusAckMsg(msg) {
    const maybeMediaRequestStatusAckMsg = msg;
    return Boolean(maybeMediaRequestStatusAckMsg.mediaRequestStatusSeqNum);
}

class ReceiverSelectedInfo {
    constructor(csi) {
        this.csi = csi;
    }
    toString() {
        return `ReceiverSelectedInfo(csi=${this.csi})`;
    }
}
function isValidReceiverSelectedInfo(msg) {
    const maybeReceiverSelectedInfo = msg;
    return Boolean(maybeReceiverSelectedInfo.csi);
}
function areReceiverSelectedInfosEqual(left, right) {
    return left.csi === right.csi;
}

function arePolicySpecificInfosEqual(left, right) {
    if (isValidActiveSpeakerInfo(left)) {
        if (!isValidActiveSpeakerInfo(right)) {
            return false;
        }
        return areActiveSpeakerInfosEqual(left, right);
    }
    if (isValidReceiverSelectedInfo(left)) {
        if (!isValidReceiverSelectedInfo(right)) {
            return false;
        }
        return areReceiverSelectedInfosEqual(left, right);
    }
    throw new Error('Invalid PolicySpecificInfo');
}

class SourceAdvertisementMsg {
    constructor(seqNum, numTotalSources, numLiveSources, namedMediaGroups, videoContentHint) {
        this.seqNum = seqNum;
        this.numTotalSources = numTotalSources;
        this.numLiveSources = numLiveSources;
        this.namedMediaGroups = namedMediaGroups;
        this.videoContentHint = videoContentHint;
    }
    toString() {
        return `SourceAdvertisement(seqNum=${this.seqNum}, numTotalSources=${this.numTotalSources}, numLiveSources=${this.numLiveSources}, namedMediaGroups=${this.namedMediaGroups}, videoContentHint=${this.videoContentHint}`;
    }
}
function isValidSourceAdvertisementMsg(msg) {
    const maybeSourceAdvertisementMsg = msg;
    return Boolean(maybeSourceAdvertisementMsg.seqNum &&
        isTruthyOrZero(maybeSourceAdvertisementMsg.numTotalSources) &&
        isTruthyOrZero(maybeSourceAdvertisementMsg.numLiveSources));
}
function areSourceAdvertisementMsgsEqual(sourceAdvertisementMsg1, sourceAdvertisementMsg2) {
    return (sourceAdvertisementMsg1.numLiveSources === sourceAdvertisementMsg2.numLiveSources &&
        sourceAdvertisementMsg1.numTotalSources === sourceAdvertisementMsg2.numTotalSources &&
        areArraysEqual(sourceAdvertisementMsg1.namedMediaGroups || [], sourceAdvertisementMsg2.namedMediaGroups || [], areNamedMediaGroupsEqual) &&
        sourceAdvertisementMsg1.videoContentHint === sourceAdvertisementMsg2.videoContentHint);
}

class SourceAdvertisementAckMsg {
    constructor(sourceAdvertisementSeqNum) {
        this.sourceAdvertisementSeqNum = sourceAdvertisementSeqNum;
    }
    toString() {
        return `SourceAdvertisementAckMsg(sourceAdvertisementSeqNum=${this.sourceAdvertisementSeqNum})`;
    }
}
function isValidSourceAdvertisementAckMsg(msg) {
    const maybeSourceAdvertisementAckMsg = msg;
    return Boolean(maybeSourceAdvertisementAckMsg.sourceAdvertisementSeqNum);
}

class StreamRequest {
    constructor(policy, policySpecificInfo, ids, maxPayloadBitsPerSecond, codecInfos = []) {
        this.policy = policy;
        this.policySpecificInfo = policySpecificInfo;
        this.ids = ids;
        this.maxPayloadBitsPerSecond = maxPayloadBitsPerSecond;
        this.codecInfos = codecInfos;
    }
    toString() {
        return `Request(policy=${this.policy}, info=${this.policySpecificInfo}, ids=[${this.ids}], maxPayloadBitsPerSecond=[${this.maxPayloadBitsPerSecond}], codecInfos=[${this.codecInfos}])`;
    }
}
function isValidStreamRequest(msg) {
    const maybeStreamRequest = msg;
    return Boolean(maybeStreamRequest.policy &&
        maybeStreamRequest.policySpecificInfo &&
        maybeStreamRequest.ids &&
        maybeStreamRequest.maxPayloadBitsPerSecond &&
        maybeStreamRequest.codecInfos);
}
function areStreamRequestsEqual(left, right) {
    if (left.policy !== right.policy) {
        return false;
    }
    if (!arePolicySpecificInfosEqual(left.policySpecificInfo, right.policySpecificInfo)) {
        return false;
    }
    if (!areArraysEqual(left.ids, right.ids, areStreamIdsEqual)) {
        return false;
    }
    if (left.maxPayloadBitsPerSecond !== right.maxPayloadBitsPerSecond) {
        return false;
    }
    return areArraysEqual(left.codecInfos, right.codecInfos, areCodecInfosEqual);
}

class RetransmitHandler {
    constructor(msg, maxNumRetransmits, retransmitIntervalMs, transmitCallback, expirationCallback) {
        this.timerHandle = undefined;
        this.msg = msg;
        this.numRetransmitsLeft = maxNumRetransmits;
        this.retransmitIntervalMs = retransmitIntervalMs;
        this.transmitCallback = transmitCallback;
        this.expirationCallback = expirationCallback;
        this.scheduleTimer();
    }
    onTimer() {
        var _a;
        if (this.numRetransmitsLeft > 0) {
            --this.numRetransmitsLeft;
            this.transmitCallback(this.msg);
            this.scheduleTimer();
        }
        else {
            (_a = this.expirationCallback) === null || _a === void 0 ? void 0 : _a.call(this, this.msg);
        }
    }
    scheduleTimer() {
        this.timerHandle = window.setTimeout(() => this.onTimer(), this.retransmitIntervalMs);
    }
    cancel() {
        if (this.timerHandle) {
            clearTimeout(this.timerHandle);
        }
        this.timerHandle = undefined;
    }
}

var JmpSessionEvents;
(function (JmpSessionEvents) {
    JmpSessionEvents["ActiveSpeaker"] = "active-speaker";
    JmpSessionEvents["MediaRequestReceived"] = "media-request-received";
    JmpSessionEvents["MediaRequestStatusReceived"] = "media-request-status-received";
    JmpSessionEvents["SourceAdvertisementReceived"] = "source-advertisement-received";
})(JmpSessionEvents || (JmpSessionEvents = {}));
class JmpSession extends EventEmitter {
    constructor(mediaFamily, mediaContent, maxNumRetransmits = 200, retransmitIntervalMs = 250) {
        super();
        this.currMediaRequestSeqNum = 1;
        this.currSourceAdvertisementSeqNum = 1;
        this.currMediaRequestStatusSeqNum = 1;
        this.txCallback = undefined;
        this.lastSentMediaRequest = undefined;
        this.lastSentMediaRequestAck = undefined;
        this.lastReceivedMediaRequest = undefined;
        this.mediaFamily = mediaFamily;
        this.mediaContent = mediaContent;
        this.logger = Logger.get(`JmpSession ${this.mediaFamily}-${this.mediaContent}`);
        this.maxNumRetransmits = maxNumRetransmits;
        this.retransmitIntervalMs = retransmitIntervalMs;
    }
    getLogger() {
        return this.logger;
    }
    sendRequests(requests) {
        var _a;
        const mediaRequestMsg = new MediaRequestMsg(this.currMediaRequestSeqNum, requests);
        if (!this.lastSentMediaRequest ||
            !areArraysEqual(this.lastSentMediaRequest.msg.requests, requests, areStreamRequestsEqual)) {
            this.sendJmpMsg(JmpMsgType.MediaRequest, mediaRequestMsg);
            (_a = this.lastSentMediaRequest) === null || _a === void 0 ? void 0 : _a.cancel();
            this.lastSentMediaRequest = new RetransmitHandler(mediaRequestMsg, this.maxNumRetransmits, this.retransmitIntervalMs, () => {
                this.logger.info(`Retransmitting previously sent MediaRequest...`);
                this.sendJmpMsg(JmpMsgType.MediaRequest, mediaRequestMsg);
            }, (expiredJmpMsg) => {
                this.logger.warn(`Retransmits for message expired: ${expiredJmpMsg}`);
            });
            this.currMediaRequestSeqNum++;
        }
        else {
            this.logger.info(`Duplicate MediaRequest detected and will not be sent: ${mediaRequestMsg}`);
        }
    }
    sendSourceAdvertisement(numTotalSources, numLiveSources, namedMediaGroups, videoContentHint) {
        var _a;
        const sourceAdvertisementMsg = new SourceAdvertisementMsg(this.currSourceAdvertisementSeqNum, numTotalSources, numLiveSources, namedMediaGroups, videoContentHint);
        if (!this.lastSentSourceAdvertisement ||
            !areSourceAdvertisementMsgsEqual(this.lastSentSourceAdvertisement.msg, sourceAdvertisementMsg)) {
            this.sendJmpMsg(JmpMsgType.SourceAdvertisement, sourceAdvertisementMsg);
            (_a = this.lastSentSourceAdvertisement) === null || _a === void 0 ? void 0 : _a.cancel();
            this.lastSentSourceAdvertisement = new RetransmitHandler(sourceAdvertisementMsg, this.maxNumRetransmits, this.retransmitIntervalMs, () => {
                this.logger.info(`Retransmitting previously sent SourceAdvertisement...`);
                this.sendJmpMsg(JmpMsgType.SourceAdvertisement, sourceAdvertisementMsg);
            }, (expiredMsg) => {
                this.logger.warn(`Retransmits for message expired: `, expiredMsg);
            });
            this.currSourceAdvertisementSeqNum++;
        }
        else {
            this.logger.info(`Duplicate SourceAdvertisement detected and will not be sent: `, sourceAdvertisementMsg);
        }
    }
    sendMediaRequestStatus(streamStates) {
        var _a, _b;
        const filteredStreamStates = streamStates.filter((streamState) => {
            var _a;
            return (_a = this.lastReceivedMediaRequest) === null || _a === void 0 ? void 0 : _a.requests.some((req) => req.ids.find((streamId) => areStreamIdsEqual(streamId, streamState.id)));
        });
        const mediaRequestStatus = new MediaRequestStatusMsg(this.currMediaRequestStatusSeqNum, filteredStreamStates);
        if (!((_a = this.lastSentMediaRequestStatus) === null || _a === void 0 ? void 0 : _a.msg.streamStates) ||
            !areArraysEqual(filteredStreamStates, this.lastSentMediaRequestStatus.msg.streamStates, areStreamInfosEqual)) {
            this.sendJmpMsg(JmpMsgType.MediaRequestStatus, mediaRequestStatus);
            (_b = this.lastSentMediaRequestStatus) === null || _b === void 0 ? void 0 : _b.cancel();
            this.lastSentMediaRequestStatus = new RetransmitHandler(mediaRequestStatus, this.maxNumRetransmits, this.retransmitIntervalMs, () => {
                this.logger.info(`Retransmitting previously sent MediaRequestStatus...`);
                this.sendJmpMsg(JmpMsgType.MediaRequestStatus, mediaRequestStatus);
            }, (expiredMsg) => {
                this.logger.warn(`Retransmits for message expired: `, expiredMsg);
            });
            this.currMediaRequestStatusSeqNum++;
        }
        else {
            this.logger.info(`Duplicate MediaRequestStatus detected and will not be sent: `, mediaRequestStatus);
        }
    }
    receive(jmpMsg) {
        if (jmpMsg.mediaContent !== this.mediaContent || jmpMsg.mediaFamily !== this.mediaFamily) {
            this.logger.error(`JmpMsg ${JSON.stringify(jmpMsg)} sent to incorrect JmpSession`);
            return;
        }
        this.logger.debug(`Received JmpMsg`, JSON.stringify(jmpMsg));
        const { payload } = jmpMsg;
        if (payload.msgType === JmpMsgType.MediaRequest) {
            const mediaRequestMsg = payload.payload;
            if (!isValidMediaRequestMsg(mediaRequestMsg)) {
                this.logger.error(`Received invalid MediaRequest:`, JSON.stringify(mediaRequestMsg));
                return;
            }
            this.handleIncomingMediaRequest(mediaRequestMsg);
        }
        else if (payload.msgType === JmpMsgType.MediaRequestAck) {
            const mediaRequestAckMsg = payload.payload;
            if (!isValidMediaRequestAckMsg(mediaRequestAckMsg)) {
                this.logger.error(`Received invalid MediaRequest ACK:`, JSON.stringify(mediaRequestAckMsg));
                return;
            }
            this.handleIncomingMediaRequestAck(mediaRequestAckMsg);
        }
        else if (payload.msgType === JmpMsgType.ActiveSpeakerNotification) {
            const activeSpeakerNotification = payload.payload;
            if (!isValidActiveSpeakerNotificationMsg(activeSpeakerNotification)) {
                this.logger.info(`Received invalid Active Speaker Notification:`, JSON.stringify(activeSpeakerNotification));
                return;
            }
            this.handleIncomingActiveSpeakerNotification(activeSpeakerNotification);
        }
        else if (payload.msgType === JmpMsgType.SourceAdvertisement) {
            const sourceAdvertisement = payload.payload;
            if (!isValidSourceAdvertisementMsg(sourceAdvertisement)) {
                this.logger.error(`Received invalid SourceAdvertisementMsg:`, JSON.stringify(sourceAdvertisement));
                return;
            }
            this.handleIncomingSourceAdvertisement(sourceAdvertisement);
        }
        else if (payload.msgType === JmpMsgType.SourceAdvertisementAck) {
            const sourceAdvertisementAck = payload.payload;
            if (!isValidSourceAdvertisementAckMsg(sourceAdvertisementAck)) {
                this.logger.error(`Received invalid SourceAdvertisementAckMsg:`, JSON.stringify(sourceAdvertisementAck));
                return;
            }
            this.handleIncomingSourceAdvertisementAck(sourceAdvertisementAck);
        }
        else if (payload.msgType === JmpMsgType.MediaRequestStatus) {
            const mediaRequestStatus = payload.payload;
            if (!isValidMediaRequestStatusMsg(mediaRequestStatus)) {
                this.logger.error(`Received invalid MediaRequestStatusMsg:`, JSON.stringify(mediaRequestStatus));
                return;
            }
            this.handleIncomingMediaRequestStatus(mediaRequestStatus);
        }
        else if (payload.msgType === JmpMsgType.MediaRequestStatusAck) {
            const mediaRequestStatusAck = payload.payload;
            if (!isValidMediaRequestStatusAckMsg(mediaRequestStatusAck)) {
                this.logger.error(`Received invalid MediaRequestStatusAckMsg:`, JSON.stringify(mediaRequestStatusAck));
                return;
            }
            this.handleIncomingMediaRequestStatusAck(mediaRequestStatusAck);
        }
        else {
            this.logger.error(`Received unknown JmpMsg`);
        }
    }
    setTxCallback(callback) {
        this.txCallback = callback;
    }
    close() {
        var _a, _b, _c;
        this.logger.info(`closing`);
        (_a = this.lastSentMediaRequest) === null || _a === void 0 ? void 0 : _a.cancel();
        (_b = this.lastSentMediaRequestStatus) === null || _b === void 0 ? void 0 : _b.cancel();
        (_c = this.lastSentSourceAdvertisement) === null || _c === void 0 ? void 0 : _c.cancel();
    }
    sendJmpMsg(msgType, payload) {
        var _a;
        const jmpMsg = new JmpMsg(this.mediaFamily, this.mediaContent, {
            msgType,
            payload,
        });
        const homerMsg = new HomerMsg(HomerMsgType.Multistream, jmpMsg);
        (_a = this.txCallback) === null || _a === void 0 ? void 0 : _a.call(this, JSON.stringify(homerMsg));
    }
    handleIncomingMediaRequest(mediaRequestMsg) {
        var _a;
        if (this.lastReceivedMediaRequest &&
            mediaRequestMsg.seqNum < ((_a = this.lastReceivedMediaRequest) === null || _a === void 0 ? void 0 : _a.seqNum)) {
            this.logger.info(`Received old MediaRequest, ignoring`);
        }
        else if (this.lastReceivedMediaRequest &&
            mediaRequestMsg.seqNum === this.lastReceivedMediaRequest.seqNum) {
            if (this.lastSentMediaRequestAck) {
                this.logger.info(`Received duplicate MediaRequest, re-sending ACK`);
                this.sendJmpMsg(JmpMsgType.MediaRequestAck, this.lastSentMediaRequestAck);
            }
            else {
                this.logger.warn(`Received duplicate MediaRequest, but there was no ACK previously sent`);
            }
        }
        else {
            this.logger.info(`Received new MediaRequest, sending ACK`);
            const mediaRequestAck = new MediaRequestAckMsg(mediaRequestMsg.seqNum);
            this.lastReceivedMediaRequest = mediaRequestMsg;
            this.lastSentMediaRequestAck = mediaRequestAck;
            this.sendJmpMsg(JmpMsgType.MediaRequestAck, mediaRequestAck);
            this.emit(JmpSessionEvents.MediaRequestReceived, mediaRequestMsg);
        }
    }
    handleIncomingMediaRequestAck(mediaRequestAckMsg) {
        var _a, _b, _c;
        if (mediaRequestAckMsg.mediaRequestSeqNum === ((_b = (_a = this.lastSentMediaRequest) === null || _a === void 0 ? void 0 : _a.msg) === null || _b === void 0 ? void 0 : _b.seqNum)) {
            this.logger.info(`Received ACK for last sent MediaRequest`);
            (_c = this.lastSentMediaRequest) === null || _c === void 0 ? void 0 : _c.cancel();
        }
        else {
            this.logger.info(`Received ACK for old MediaRequest`);
        }
    }
    handleIncomingActiveSpeakerNotification(activeSpeakerNotification) {
        this.logger.debug(`Received Active Speaker Notification:`, activeSpeakerNotification);
        this.emit(JmpSessionEvents.ActiveSpeaker, activeSpeakerNotification);
    }
    handleIncomingSourceAdvertisement(sourceAdvertisement) {
        if (this.lastReceivedSourceAdvertisement &&
            sourceAdvertisement.seqNum < this.lastReceivedSourceAdvertisement.seqNum) {
            this.logger.info(`Received old SourceAdvertisement, ignoring`);
        }
        else if (this.lastReceivedSourceAdvertisement &&
            sourceAdvertisement.seqNum === this.lastReceivedSourceAdvertisement.seqNum) {
            if (this.lastSentSourceAdvertisementAck) {
                this.logger.info(`Received duplicate SourceAdvertisement, re-sending ACK`);
                this.sendJmpMsg(JmpMsgType.SourceAdvertisementAck, this.lastSentSourceAdvertisementAck);
            }
            else {
                this.logger.warn(`Received duplicate SourceAdvertisement, but there was no ACK previously sent`);
            }
        }
        else {
            this.logger.info(`Received new SourceAdvertisement, sending ACK`);
            const sourceAdvertisementAck = new SourceAdvertisementAckMsg(sourceAdvertisement.seqNum);
            this.lastReceivedSourceAdvertisement = sourceAdvertisement;
            this.lastSentSourceAdvertisementAck = sourceAdvertisementAck;
            this.sendJmpMsg(JmpMsgType.SourceAdvertisementAck, sourceAdvertisementAck);
            this.emit(JmpSessionEvents.SourceAdvertisementReceived, sourceAdvertisement);
        }
    }
    handleIncomingSourceAdvertisementAck(sourceAdvertisementAck) {
        var _a, _b, _c;
        if (sourceAdvertisementAck.sourceAdvertisementSeqNum ===
            ((_b = (_a = this.lastSentSourceAdvertisement) === null || _a === void 0 ? void 0 : _a.msg) === null || _b === void 0 ? void 0 : _b.seqNum)) {
            this.logger.info(`Received ACK for last sent SourceAdvertisement`);
            (_c = this.lastSentSourceAdvertisement) === null || _c === void 0 ? void 0 : _c.cancel();
        }
        else {
            this.logger.info(`Received ACK for old SourceAdvertisement`);
        }
    }
    handleIncomingMediaRequestStatus(mediaRequestStatus) {
        if (this.lastReceivedMediaRequestStatus &&
            mediaRequestStatus.seqNum < this.lastReceivedMediaRequestStatus.seqNum) {
            this.logger.info(`Received old MediaRequestStatus, ignoring`);
        }
        else if (this.lastReceivedMediaRequestStatus &&
            mediaRequestStatus.seqNum === this.lastReceivedMediaRequestStatus.seqNum) {
            if (this.lastSentMediaRequestStatusAck) {
                this.logger.info(`Received duplicate MediaRequestStatus, re-sending ACK`);
                this.sendJmpMsg(JmpMsgType.MediaRequestStatusAck, this.lastSentMediaRequestStatusAck);
            }
            else {
                this.logger.warn(`Received duplicate MediaRequestStatus, but there was no ACK previously sent`);
            }
        }
        else {
            this.logger.info(`Received new MediaRequestStatus, sending ACK`);
            const mediaRequestStatusAck = new MediaRequestStatusAckMsg(mediaRequestStatus.seqNum);
            this.lastReceivedMediaRequestStatus = mediaRequestStatus;
            this.lastSentMediaRequestStatusAck = mediaRequestStatusAck;
            this.sendJmpMsg(JmpMsgType.MediaRequestStatusAck, mediaRequestStatusAck);
            this.emit(JmpSessionEvents.MediaRequestStatusReceived, mediaRequestStatus);
        }
    }
    handleIncomingMediaRequestStatusAck(mediaRequestStatusAck) {
        var _a, _b, _c;
        if (mediaRequestStatusAck.mediaRequestStatusSeqNum ===
            ((_b = (_a = this.lastSentMediaRequestStatus) === null || _a === void 0 ? void 0 : _a.msg) === null || _b === void 0 ? void 0 : _b.seqNum)) {
            this.logger.info(`Received ACK for last sent MediaRequestStatus`);
            (_c = this.lastSentMediaRequestStatus) === null || _c === void 0 ? void 0 : _c.cancel();
        }
        else {
            this.logger.info(`Received ACK for old MediaRequestStatus`);
        }
    }
}

export { ActiveSpeakerInfo, ActiveSpeakerNotificationMsg, CodecInfo, H264Codec, HomerMsg, HomerMsgType, JmpMsg, JmpMsgType, JmpSession, JmpSessionEvents, Logger, MediaContent, MediaFamily, MediaRequestAckMsg, MediaRequestMsg, MediaRequestStatusAckMsg, MediaRequestStatusMsg, MediaType, Policy, ReceiverSelectedInfo, SourceAdvertisementAckMsg, SourceAdvertisementMsg, StreamRequest, areActiveSpeakerInfosEqual, areArraysEqual, areCodecInfosEqual, areH264CodecsEqual, areNamedMediaGroupsEqual, arePolicySpecificInfosEqual, areReceiverSelectedInfosEqual, areSourceAdvertisementMsgsEqual, areStreamIdsEqual, areStreamInfosEqual, areStreamRequestsEqual, generateCsi, generateSceneId, getMediaContent, getMediaFamily, getMediaType, isTruthyOrZero, isValidActiveSpeakerInfo, isValidActiveSpeakerNotificationMsg, isValidCodecRequestInfo, isValidH264Codec, isValidJmpMsg, isValidJmpMsgPayload, isValidMediaRequestAckMsg, isValidMediaRequestMsg, isValidMediaRequestStatusAckMsg, isValidMediaRequestStatusMsg, isValidMidRidStreamId, isValidReceiverSelectedInfo, isValidSourceAdvertisementAckMsg, isValidSourceAdvertisementMsg, isValidSsrcStreamId, isValidStreamId, isValidStreamInfo, isValidStreamRequest };
