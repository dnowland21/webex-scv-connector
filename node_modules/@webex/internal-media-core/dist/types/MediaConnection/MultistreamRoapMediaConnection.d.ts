import { ReceiveSlot, TransceiverStats, SendSlot, StreamRequest, MediaType, MetricsCallback } from '@webex/web-client-media-engine';
import { EventEmitter } from '../EventEmitter';
import { ConnectionState, RoapMessage, MultistreamConnectionEvents, RoapEvents } from './eventTypes';
import { MultistreamConnectionConfig } from './config';
import { CloseCallback, SendMetricsCallback } from './types';
export { ReceiveSlot, ReceiveSlotEvents, SendSlot, StreamRequest, MetricsCallback, getAudioOutputDevices, getVideoInputDevices, setOnDeviceChangeHandler, WcmeError, WcmeErrorType, AudioDeviceConstraints, VideoDeviceConstraints, StreamEventNames, LocalStreamEventNames, LocalCameraStream, LocalDisplayStream, LocalSystemAudioStream, LocalMicrophoneStream, LocalStream, MediaStreamTrackKind, PeerConnection, RemoteStream, RemoteStreamEventNames, VideoContentHint, createCameraAndMicrophoneStreams, createCameraStream, createDisplayMedia, createDisplayStream, createDisplayStreamWithAudio, createMicrophoneStream, getDevices, getAudioInputDevices, ActiveSpeakerInfo, CodecInfo, getMediaFamily, H264Codec, MediaFamily, MediaType, NamedMediaGroup, StreamState, Policy, PolicySpecificInfo, ReceiverSelectedInfo, getRecommendedMaxBitrateForFrameSize, RecommendedOpusBitrates, } from '@webex/web-client-media-engine';
export declare class MultistreamRoapMediaConnection extends EventEmitter<MultistreamConnectionEvents | RoapEvents> {
    private id?;
    private debugId?;
    private multistreamConnection;
    private roap;
    private sdpNegotiationStarted;
    private closeCallback;
    private sendMetricsCallback;
    constructor(mediaConnectionConfig: MultistreamConnectionConfig, debugId?: string, metricsCallback?: MetricsCallback, closeCallback?: CloseCallback, sendMetricsCallback?: SendMetricsCallback);
    private log;
    private warn;
    private error;
    private createMultistreamConnection;
    private createRoap;
    private onNegotiationNeeded;
    initiateOffer(): Promise<void>;
    close(): void;
    forceRtcMetricsSend(): Promise<void>;
    private closeMediaConnection;
    private stopRoapSession;
    reconnect(iceServers: RTCIceServer[], initiateOffer?: boolean): Promise<void>;
    getConnectionState(): ConnectionState;
    getPeerConnectionState(): RTCPeerConnectionState;
    getIceConnectionState(): RTCIceConnectionState;
    getStats(): Promise<RTCStatsReport>;
    getTransceiverStats(): Promise<TransceiverStats>;
    roapMessageReceived(roapMessage: RoapMessage): void;
    createSendSlot(mediaType: MediaType, active?: boolean): SendSlot;
    createReceiveSlot(mediaType: MediaType): Promise<ReceiveSlot>;
    requestMedia(mediaType: MediaType, streamRequests: StreamRequest[]): void;
    private createLocalOffer;
    private handleRemoteOffer;
    private waitForIceCandidates;
    private handleRemoteAnswer;
    getIceGatheringState(): RTCIceGatheringState;
}
//# sourceMappingURL=MultistreamRoapMediaConnection.d.ts.map