"use strict";

var _Reflect$construct = require("@babel/runtime-corejs2/core-js/reflect/construct");
var _Object$keys = require("@babel/runtime-corejs2/core-js/object/keys");
var _Object$getOwnPropertySymbols = require("@babel/runtime-corejs2/core-js/object/get-own-property-symbols");
var _Object$getOwnPropertyDescriptor = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptor");
var _Object$getOwnPropertyDescriptors = require("@babel/runtime-corejs2/core-js/object/get-own-property-descriptors");
var _Object$defineProperties = require("@babel/runtime-corejs2/core-js/object/define-properties");
var _Object$defineProperty = require("@babel/runtime-corejs2/core-js/object/define-property");
var _interopRequireDefault = require("@babel/runtime-corejs2/helpers/interopRequireDefault");
_Object$defineProperty(exports, "__esModule", {
  value: true
});
exports.LocalCameraStreamEventNames = exports.LocalCameraStream = void 0;
_Object$defineProperty(exports, "LocalDisplayStream", {
  enumerable: true,
  get: function get() {
    return _internalMediaCore.LocalDisplayStream;
  }
});
exports.LocalMicrophoneStreamEventNames = exports.LocalMicrophoneStream = void 0;
_Object$defineProperty(exports, "LocalStream", {
  enumerable: true,
  get: function get() {
    return _internalMediaCore.LocalStream;
  }
});
_Object$defineProperty(exports, "LocalStreamEventNames", {
  enumerable: true,
  get: function get() {
    return _internalMediaCore.LocalStreamEventNames;
  }
});
_Object$defineProperty(exports, "LocalSystemAudioStream", {
  enumerable: true,
  get: function get() {
    return _internalMediaCore.LocalSystemAudioStream;
  }
});
_Object$defineProperty(exports, "RemoteStream", {
  enumerable: true,
  get: function get() {
    return _internalMediaCore.RemoteStream;
  }
});
_Object$defineProperty(exports, "RemoteStreamEventNames", {
  enumerable: true,
  get: function get() {
    return _internalMediaCore.RemoteStreamEventNames;
  }
});
_Object$defineProperty(exports, "StreamEventNames", {
  enumerable: true,
  get: function get() {
    return _internalMediaCore.StreamEventNames;
  }
});
exports.createMicrophoneStream = exports.createDisplayStreamWithAudio = exports.createDisplayStream = exports.createDisplayMedia = exports.createCameraStream = exports.createCameraAndMicrophoneStreams = void 0;
_Object$defineProperty(exports, "getDevices", {
  enumerable: true,
  get: function get() {
    return _internalMediaCore.getDevices;
  }
});
var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/classCallCheck"));
var _createClass2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/createClass"));
var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/assertThisInitialized"));
var _get2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/get"));
var _inherits2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/inherits"));
var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/possibleConstructorReturn"));
var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/getPrototypeOf"));
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime-corejs2/helpers/defineProperty"));
var _internalMediaCore = require("@webex/internal-media-core");
var _tsEvents = require("@webex/ts-events");
var _LocalMicrophoneStrea, _LocalCameraStreamEve;
/* eslint-disable @typescript-eslint/no-misused-new */
/* eslint-disable valid-jsdoc */
/* eslint-disable require-jsdoc */
function ownKeys(e, r) { var t = _Object$keys(e); if (_Object$getOwnPropertySymbols) { var o = _Object$getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return _Object$getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { (0, _defineProperty2.default)(e, r, t[r]); }) : _Object$getOwnPropertyDescriptors ? _Object$defineProperties(e, _Object$getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { _Object$defineProperty(e, r, _Object$getOwnPropertyDescriptor(t, r)); }); } return e; }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = _Reflect$construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !_Reflect$construct) return false; if (_Reflect$construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(_Reflect$construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
// server forced the client to be unmuted
// these events are in addition to WCME events. This will be properly typed once webrtc-core event types inheritance is fixed
var LocalMicrophoneStreamEventNames = exports.LocalMicrophoneStreamEventNames = /*#__PURE__*/function (LocalMicrophoneStreamEventNames) {
  LocalMicrophoneStreamEventNames["ServerMuted"] = "muted:byServer";
  return LocalMicrophoneStreamEventNames;
}({}); // these events are in addition to WCME events. This will be properly typed once webrtc-core event types inheritance is fixed
var LocalCameraStreamEventNames = exports.LocalCameraStreamEventNames = /*#__PURE__*/function (LocalCameraStreamEventNames) {
  LocalCameraStreamEventNames["ServerMuted"] = "muted:byServer";
  return LocalCameraStreamEventNames;
}({});
_LocalMicrophoneStrea = LocalMicrophoneStreamEventNames.ServerMuted;
var _LocalMicrophoneStream = /*#__PURE__*/function (_WcmeLocalMicrophoneS) {
  (0, _inherits2.default)(_LocalMicrophoneStream, _WcmeLocalMicrophoneS);
  var _super = _createSuper(_LocalMicrophoneStream);
  function _LocalMicrophoneStream() {
    var _this;
    (0, _classCallCheck2.default)(this, _LocalMicrophoneStream);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "unmuteAllowed", true);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), _LocalMicrophoneStrea, new _tsEvents.TypedEvent());
    return _this;
  }
  (0, _createClass2.default)(_LocalMicrophoneStream, [{
    key: "setUnmuteAllowed",
    value:
    /**
     * @internal
     */
    function setUnmuteAllowed(allowed) {
      this.unmuteAllowed = allowed;
    }

    /**
     * @returns true if user is allowed to unmute the track, false otherwise
     */
  }, {
    key: "isUnmuteAllowed",
    value: function isUnmuteAllowed() {
      return this.unmuteAllowed;
    }
  }, {
    key: "setUserMuted",
    value: function setUserMuted(muted) {
      if (!muted) {
        if (!this.isUnmuteAllowed()) {
          throw new Error('Unmute is not allowed');
        }
      }
      return (0, _get2.default)((0, _getPrototypeOf2.default)(_LocalMicrophoneStream.prototype), "setUserMuted", this).call(this, muted);
    }

    /**
     * @internal
     */
  }, {
    key: "setServerMuted",
    value: function setServerMuted(muted, reason) {
      if (muted !== this.userMuted) {
        this.setUserMuted(muted);
        this[LocalMicrophoneStreamEventNames.ServerMuted].emit(muted, reason);
      }
    }
  }]);
  return _LocalMicrophoneStream;
}(_internalMediaCore.LocalMicrophoneStream);
_LocalCameraStreamEve = LocalCameraStreamEventNames.ServerMuted;
var _LocalCameraStream = /*#__PURE__*/function (_WcmeLocalCameraStrea) {
  (0, _inherits2.default)(_LocalCameraStream, _WcmeLocalCameraStrea);
  var _super2 = _createSuper(_LocalCameraStream);
  function _LocalCameraStream() {
    var _this2;
    (0, _classCallCheck2.default)(this, _LocalCameraStream);
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "unmuteAllowed", true);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), _LocalCameraStreamEve, new _tsEvents.TypedEvent());
    return _this2;
  }
  (0, _createClass2.default)(_LocalCameraStream, [{
    key: "setUnmuteAllowed",
    value:
    /**
     * @internal
     */
    function setUnmuteAllowed(allowed) {
      this.unmuteAllowed = allowed;
    }

    /**
     * @returns true if user is allowed to unmute the track, false otherwise
     */
  }, {
    key: "isUnmuteAllowed",
    value: function isUnmuteAllowed() {
      return this.unmuteAllowed;
    }
  }, {
    key: "setUserMuted",
    value: function setUserMuted(muted) {
      if (!muted) {
        if (!this.isUnmuteAllowed()) {
          throw new Error('Unmute is not allowed');
        }
      }
      return (0, _get2.default)((0, _getPrototypeOf2.default)(_LocalCameraStream.prototype), "setUserMuted", this).call(this, muted);
    }

    /**
     * @internal
     */
  }, {
    key: "setServerMuted",
    value: function setServerMuted(muted, reason) {
      if (muted !== this.userMuted) {
        this.setUserMuted(muted);
        this[LocalCameraStreamEventNames.ServerMuted].emit(muted, reason);
      }
    }
  }]);
  return _LocalCameraStream;
}(_internalMediaCore.LocalCameraStream);
var LocalMicrophoneStream = exports.LocalMicrophoneStream = (0, _tsEvents.AddEvents)(_LocalMicrophoneStream);
var LocalCameraStream = exports.LocalCameraStream = (0, _tsEvents.AddEvents)(_LocalCameraStream);
var createMicrophoneStream = exports.createMicrophoneStream = function createMicrophoneStream(constraints) {
  return (0, _internalMediaCore.createMicrophoneStream)(LocalMicrophoneStream, constraints);
};
var createCameraStream = exports.createCameraStream = function createCameraStream(constraints) {
  return (0, _internalMediaCore.createCameraStream)(LocalCameraStream, constraints);
};
var createCameraAndMicrophoneStreams = exports.createCameraAndMicrophoneStreams = function createCameraAndMicrophoneStreams(constraints) {
  return (0, _internalMediaCore.createCameraAndMicrophoneStreams)(LocalCameraStream, LocalMicrophoneStream, constraints);
};
var createDisplayStream = exports.createDisplayStream = function createDisplayStream(videoContentHint) {
  return (0, _internalMediaCore.createDisplayStream)(_internalMediaCore.LocalDisplayStream, videoContentHint);
};
var createDisplayStreamWithAudio = exports.createDisplayStreamWithAudio = function createDisplayStreamWithAudio(videoContentHint) {
  return (0, _internalMediaCore.createDisplayStreamWithAudio)(_internalMediaCore.LocalDisplayStream, _internalMediaCore.LocalSystemAudioStream, videoContentHint);
};
var createDisplayMedia = exports.createDisplayMedia = function createDisplayMedia() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
    video: {}
  };
  return (0, _internalMediaCore.createDisplayMedia)({
    video: _objectSpread({
      displayStreamConstructor: _internalMediaCore.LocalDisplayStream
    }, options === null || options === void 0 ? void 0 : options.video),
    audio: options !== null && options !== void 0 && options.audio ? _objectSpread({
      systemAudioStreamConstructor: _internalMediaCore.LocalSystemAudioStream
    }, options.audio) : undefined
  });
};
//# sourceMappingURL=webrtc-core.js.map
