/**
 * Cisco Ladon-TS 
 * Copyright (c) Cisco Systems, Inc. All rights reserved. 
 * Build timestamp: June 17, 2025 at 03:35:16 PM UTC
 */
(function(){"use strict";var _documentCurrentScript=typeof document<"u"?document.currentScript:null;self.document={baseURI:location.origin};const originalConsoleLog=console.log,originalConsoleWarn=console.warn,originalConsoleError=console.error;console.log=(...e)=>{postMessage({type:"log",message:e.join(" "),severity:"log"}),originalConsoleLog(...e)},console.warn=(...e)=>{postMessage({type:"log",message:e.join(" "),severity:"warn"}),originalConsoleWarn(...e)},console.error=(...e)=>{postMessage({type:"log",message:e.join(" "),severity:"error"}),originalConsoleError(...e)};/*!
 * ONNX Runtime Web v1.20.1
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */var Hd=Object.create,an=Object.defineProperty,qd=Object.getOwnPropertyDescriptor,jd=Object.getOwnPropertyNames,Xd=Object.getPrototypeOf,Kd=Object.prototype.hasOwnProperty,Co=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(n,i)=>(typeof require<"u"?require:n)[i]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')}),O=(e,n)=>()=>(e&&(n=e(e=0)),n),mt=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports),Or=(e,n)=>{for(var i in n)an(e,i,{get:n[i],enumerable:!0})},Qa=(e,n,i,a)=>{if(n&&typeof n=="object"||typeof n=="function")for(let p of jd(n))!Kd.call(e,p)&&p!==i&&an(e,p,{get:()=>n[p],enumerable:!(a=qd(n,p))||a.enumerable});return e},rr=(e,n,i)=>(i=e!=null?Hd(Xd(e)):{},Qa(!e||!e.__esModule?an(i,"default",{value:e,enumerable:!0}):i,e)),sn=e=>Qa(an({},"__esModule",{value:!0}),e),un,ke,nr,Jd,ln,fn=O(()=>{un=new Map,ke=[],nr=(e,n,i)=>{if(n&&typeof n.init=="function"&&typeof n.createInferenceSessionHandler=="function"){let a=un.get(e);if(a===void 0)un.set(e,{backend:n,priority:i});else{if(a.priority>i)return;if(a.priority===i&&a.backend!==n)throw new Error(`cannot register backend "${e}" using priority ${i}`)}if(i>=0){let p=ke.indexOf(e);p!==-1&&ke.splice(p,1);for(let o=0;o<ke.length;o++)if(un.get(ke[o]).priority<=i){ke.splice(o,0,e);return}ke.push(e)}return}throw new TypeError("not a valid backend")},Jd=async e=>{let n=un.get(e);if(!n)return"backend not found.";if(n.initialized)return n.backend;if(n.aborted)return n.error;{let i=!!n.initPromise;try{return i||(n.initPromise=n.backend.init(e)),await n.initPromise,n.initialized=!0,n.backend}catch(a){return i||(n.error=`${a}`,n.aborted=!0),n.error}finally{delete n.initPromise}}},ln=async e=>{let n=e.executionProviders||[],i=n.map(c=>typeof c=="string"?c:c.name),a=i.length===0?ke:i,p,o=[],s=new Set;for(let c of a){let r=await Jd(c);typeof r=="string"?o.push({name:c,err:r}):(p||(p=r),p===r&&s.add(c))}if(!p)throw new Error(`no available backend found. ERR: ${o.map(c=>`[${c.name}] ${c.err}`).join(", ")}`);for(let{name:c,err:r}of o)i.includes(c)&&console.warn(`removing requested execution provider "${c}" from session options because it is not available: ${r}`);let d=n.filter(c=>s.has(typeof c=="string"?c:c.name));return[p,new Proxy(e,{get:(c,r)=>r==="executionProviders"?d:Reflect.get(c,r)})]}}),ts=O(()=>{fn()}),es,rs=O(()=>{es="1.20.1"}),ns,Gt,No=O(()=>{rs(),ns="warning",Gt={wasm:{},webgl:{},webgpu:{},versions:{common:es},set logLevel(e){if(e!==void 0){if(typeof e!="string"||["verbose","info","warning","error","fatal"].indexOf(e)===-1)throw new Error(`Unsupported logging level: ${e}`);ns=e}},get logLevel(){return ns}},Object.defineProperty(Gt,"logLevel",{enumerable:!0})}),z,os=O(()=>{No(),z=Gt}),is,as,ss=O(()=>{is=(e,n)=>{let i=typeof document<"u"?document.createElement("canvas"):new OffscreenCanvas(1,1);i.width=e.dims[3],i.height=e.dims[2];let a=i.getContext("2d");if(a!=null){let p,o;(n==null?void 0:n.tensorLayout)!==void 0&&n.tensorLayout==="NHWC"?(p=e.dims[2],o=e.dims[3]):(p=e.dims[3],o=e.dims[2]);let s=(n==null?void 0:n.format)!==void 0?n.format:"RGB",d=n==null?void 0:n.norm,c,r;d===void 0||d.mean===void 0?c=[255,255,255,255]:typeof d.mean=="number"?c=[d.mean,d.mean,d.mean,d.mean]:(c=[d.mean[0],d.mean[1],d.mean[2],0],d.mean[3]!==void 0&&(c[3]=d.mean[3])),d===void 0||d.bias===void 0?r=[0,0,0,0]:typeof d.bias=="number"?r=[d.bias,d.bias,d.bias,d.bias]:(r=[d.bias[0],d.bias[1],d.bias[2],0],d.bias[3]!==void 0&&(r[3]=d.bias[3]));let u=o*p,l=0,h=u,f=u*2,m=-1;s==="RGBA"?(l=0,h=u,f=u*2,m=u*3):s==="RGB"?(l=0,h=u,f=u*2):s==="RBG"&&(l=0,f=u,h=u*2);for(let y=0;y<o;y++)for(let _=0;_<p;_++){let I=(e.data[l++]-r[0])*c[0],x=(e.data[h++]-r[1])*c[1],P=(e.data[f++]-r[2])*c[2],N=m===-1?255:(e.data[m++]-r[3])*c[3];a.fillStyle="rgba("+I+","+x+","+P+","+N+")",a.fillRect(_,y,1,1)}if("toDataURL"in i)return i.toDataURL();throw new Error("toDataURL is not supported")}else throw new Error("Can not access image data")},as=(e,n)=>{let i=typeof document<"u"?document.createElement("canvas").getContext("2d"):new OffscreenCanvas(1,1).getContext("2d"),a;if(i!=null){let p,o,s;(n==null?void 0:n.tensorLayout)!==void 0&&n.tensorLayout==="NHWC"?(p=e.dims[2],o=e.dims[1],s=e.dims[3]):(p=e.dims[3],o=e.dims[2],s=e.dims[1]);let d=n!==void 0&&n.format!==void 0?n.format:"RGB",c=n==null?void 0:n.norm,r,u;c===void 0||c.mean===void 0?r=[255,255,255,255]:typeof c.mean=="number"?r=[c.mean,c.mean,c.mean,c.mean]:(r=[c.mean[0],c.mean[1],c.mean[2],255],c.mean[3]!==void 0&&(r[3]=c.mean[3])),c===void 0||c.bias===void 0?u=[0,0,0,0]:typeof c.bias=="number"?u=[c.bias,c.bias,c.bias,c.bias]:(u=[c.bias[0],c.bias[1],c.bias[2],0],c.bias[3]!==void 0&&(u[3]=c.bias[3]));let l=o*p;if(n!==void 0&&(n.format!==void 0&&s===4&&n.format!=="RGBA"||s===3&&n.format!=="RGB"&&n.format!=="BGR"))throw new Error("Tensor format doesn't match input tensor dims");let h=4,f=0,m=1,y=2,_=3,I=0,x=l,P=l*2,N=-1;d==="RGBA"?(I=0,x=l,P=l*2,N=l*3):d==="RGB"?(I=0,x=l,P=l*2):d==="RBG"&&(I=0,P=l,x=l*2),a=i.createImageData(p,o);for(let R=0;R<o*p;f+=h,m+=h,y+=h,_+=h,R++)a.data[f]=(e.data[I++]-u[0])*r[0],a.data[m]=(e.data[x++]-u[1])*r[1],a.data[y]=(e.data[P++]-u[2])*r[2],a.data[_]=N===-1?255:(e.data[N++]-u[3])*r[3]}else throw new Error("Can not access image data");return a}}),Ro,us,ls,fs,cs,ps,ds=O(()=>{cn(),Ro=(e,n)=>{if(e===void 0)throw new Error("Image buffer must be defined");if(n.height===void 0||n.width===void 0)throw new Error("Image height and width must be defined");if(n.tensorLayout==="NHWC")throw new Error("NHWC Tensor layout is not supported yet");let{height:i,width:a}=n,p=n.norm??{mean:255,bias:0},o,s;typeof p.mean=="number"?o=[p.mean,p.mean,p.mean,p.mean]:o=[p.mean[0],p.mean[1],p.mean[2],p.mean[3]??255],typeof p.bias=="number"?s=[p.bias,p.bias,p.bias,p.bias]:s=[p.bias[0],p.bias[1],p.bias[2],p.bias[3]??0];let d=n.format!==void 0?n.format:"RGBA",c=n.tensorFormat!==void 0&&n.tensorFormat!==void 0?n.tensorFormat:"RGB",r=i*a,u=c==="RGBA"?new Float32Array(r*4):new Float32Array(r*3),l=4,h=0,f=1,m=2,y=3,_=0,I=r,x=r*2,P=-1;d==="RGB"&&(l=3,h=0,f=1,m=2,y=-1),c==="RGBA"?P=r*3:c==="RBG"?(_=0,x=r,I=r*2):c==="BGR"&&(x=0,I=r,_=r*2);for(let N=0;N<r;N++,h+=l,m+=l,f+=l,y+=l)u[_++]=(e[h]+s[0])/o[0],u[I++]=(e[f]+s[1])/o[1],u[x++]=(e[m]+s[2])/o[2],P!==-1&&y!==-1&&(u[P++]=(e[y]+s[3])/o[3]);return c==="RGBA"?new St("float32",u,[1,4,i,a]):new St("float32",u,[1,3,i,a])},us=async(e,n)=>{let i=typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement,a=typeof ImageData<"u"&&e instanceof ImageData,p=typeof ImageBitmap<"u"&&e instanceof ImageBitmap,o=typeof e=="string",s,d=n??{},c=()=>{if(typeof document<"u")return document.createElement("canvas");if(typeof OffscreenCanvas<"u")return new OffscreenCanvas(1,1);throw new Error("Canvas is not supported")},r=u=>typeof HTMLCanvasElement<"u"&&u instanceof HTMLCanvasElement||u instanceof OffscreenCanvas?u.getContext("2d"):null;if(i){let u=c();u.width=e.width,u.height=e.height;let l=r(u);if(l!=null){let h=e.height,f=e.width;if(n!==void 0&&n.resizedHeight!==void 0&&n.resizedWidth!==void 0&&(h=n.resizedHeight,f=n.resizedWidth),n!==void 0){if(d=n,n.tensorFormat!==void 0)throw new Error("Image input config format must be RGBA for HTMLImageElement");d.tensorFormat="RGBA",d.height=h,d.width=f}else d.tensorFormat="RGBA",d.height=h,d.width=f;l.drawImage(e,0,0),s=l.getImageData(0,0,f,h).data}else throw new Error("Can not access image data")}else if(a){let u,l;if(n!==void 0&&n.resizedWidth!==void 0&&n.resizedHeight!==void 0?(u=n.resizedHeight,l=n.resizedWidth):(u=e.height,l=e.width),n!==void 0&&(d=n),d.format="RGBA",d.height=u,d.width=l,n!==void 0){let h=c();h.width=l,h.height=u;let f=r(h);if(f!=null)f.putImageData(e,0,0),s=f.getImageData(0,0,l,u).data;else throw new Error("Can not access image data")}else s=e.data}else if(p){if(n===void 0)throw new Error("Please provide image config with format for Imagebitmap");let u=c();u.width=e.width,u.height=e.height;let l=r(u);if(l!=null){let h=e.height,f=e.width;return l.drawImage(e,0,0,f,h),s=l.getImageData(0,0,f,h).data,d.height=h,d.width=f,Ro(s,d)}else throw new Error("Can not access image data")}else{if(o)return new Promise((u,l)=>{let h=c(),f=r(h);if(!e||!f)return l();let m=new Image;m.crossOrigin="Anonymous",m.src=e,m.onload=()=>{h.width=m.width,h.height=m.height,f.drawImage(m,0,0,h.width,h.height);let y=f.getImageData(0,0,h.width,h.height);d.height=h.height,d.width=h.width,u(Ro(y.data,d))}});throw new Error("Input data provided is not supported - aborted tensor creation")}if(s!==void 0)return Ro(s,d);throw new Error("Input data provided is not supported - aborted tensor creation")},ls=(e,n)=>{let{width:i,height:a,download:p,dispose:o}=n,s=[1,a,i,4];return new St({location:"texture",type:"float32",texture:e,dims:s,download:p,dispose:o})},fs=(e,n)=>{let{dataType:i,dims:a,download:p,dispose:o}=n;return new St({location:"gpu-buffer",type:i??"float32",gpuBuffer:e,dims:a,download:p,dispose:o})},cs=(e,n)=>{let{dataType:i,dims:a,download:p,dispose:o}=n;return new St({location:"ml-tensor",type:i??"float32",mlTensor:e,dims:a,download:p,dispose:o})},ps=(e,n,i)=>new St({location:"cpu-pinned",type:e,data:n,dims:i??[n.length]})}),Be,Sr,hs,ms,bs=O(()=>{Be=new Map([["float32",Float32Array],["uint8",Uint8Array],["int8",Int8Array],["uint16",Uint16Array],["int16",Int16Array],["int32",Int32Array],["bool",Uint8Array],["float64",Float64Array],["uint32",Uint32Array],["int4",Uint8Array],["uint4",Uint8Array]]),Sr=new Map([[Float32Array,"float32"],[Uint8Array,"uint8"],[Int8Array,"int8"],[Uint16Array,"uint16"],[Int16Array,"int16"],[Int32Array,"int32"],[Float64Array,"float64"],[Uint32Array,"uint32"]]),hs=!1,ms=()=>{if(!hs){hs=!0;let e=typeof BigInt64Array<"u"&&BigInt64Array.from,n=typeof BigUint64Array<"u"&&BigUint64Array.from,i=typeof Float16Array<"u"&&Float16Array.from;e&&(Be.set("int64",BigInt64Array),Sr.set(BigInt64Array,"int64")),n&&(Be.set("uint64",BigUint64Array),Sr.set(BigUint64Array,"uint64")),i?(Be.set("float16",Float16Array),Sr.set(Float16Array,"float16")):Be.set("float16",Uint16Array)}}}),gs,ys,xs=O(()=>{cn(),gs=e=>{let n=1;for(let i=0;i<e.length;i++){let a=e[i];if(typeof a!="number"||!Number.isSafeInteger(a))throw new TypeError(`dims[${i}] must be an integer, got: ${a}`);if(a<0)throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${a}`);n*=a}return n},ys=(e,n)=>{switch(e.location){case"cpu":return new St(e.type,e.data,n);case"cpu-pinned":return new St({location:"cpu-pinned",data:e.data,type:e.type,dims:n});case"texture":return new St({location:"texture",texture:e.texture,type:e.type,dims:n});case"gpu-buffer":return new St({location:"gpu-buffer",gpuBuffer:e.gpuBuffer,type:e.type,dims:n});case"ml-tensor":return new St({location:"ml-tensor",mlTensor:e.mlTensor,type:e.type,dims:n});default:throw new Error(`tensorReshape: tensor location ${e.location} is not supported`)}}}),St,cn=O(()=>{ss(),ds(),bs(),xs(),St=class{constructor(e,n,i){ms();let a,p;if(typeof e=="object"&&"location"in e)switch(this.dataLocation=e.location,a=e.type,p=e.dims,e.location){case"cpu-pinned":{let s=Be.get(a);if(!s)throw new TypeError(`unsupported type "${a}" to create tensor from pinned buffer`);if(!(e.data instanceof s))throw new TypeError(`buffer should be of type ${s.name}`);this.cpuData=e.data;break}case"texture":{if(a!=="float32")throw new TypeError(`unsupported type "${a}" to create tensor from texture`);this.gpuTextureData=e.texture,this.downloader=e.download,this.disposer=e.dispose;break}case"gpu-buffer":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="uint8"&&a!=="bool"&&a!=="uint4"&&a!=="int4")throw new TypeError(`unsupported type "${a}" to create tensor from gpu buffer`);this.gpuBufferData=e.gpuBuffer,this.downloader=e.download,this.disposer=e.dispose;break}case"ml-tensor":{if(a!=="float32"&&a!=="float16"&&a!=="int32"&&a!=="int64"&&a!=="uint32"&&a!=="uint64"&&a!=="int8"&&a!=="uint8"&&a!=="bool")throw new TypeError(`unsupported type "${a}" to create tensor from MLTensor`);this.mlTensorData=e.mlTensor,this.downloader=e.download,this.disposer=e.dispose;break}default:throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`)}else{let s,d;if(typeof e=="string")if(a=e,d=i,e==="string"){if(!Array.isArray(n))throw new TypeError("A string tensor's data must be a string array.");s=n}else{let c=Be.get(e);if(c===void 0)throw new TypeError(`Unsupported tensor type: ${e}.`);if(Array.isArray(n)){if(e==="float16"&&c===Uint16Array||e==="uint4"||e==="int4")throw new TypeError(`Creating a ${e} tensor from number array is not supported. Please use ${c.name} as data.`);e==="uint64"||e==="int64"?s=c.from(n,BigInt):s=c.from(n)}else if(n instanceof c)s=n;else if(n instanceof Uint8ClampedArray)if(e==="uint8")s=Uint8Array.from(n);else throw new TypeError("A Uint8ClampedArray tensor's data must be type of uint8");else throw new TypeError(`A ${a} tensor's data must be type of ${c}`)}else if(d=n,Array.isArray(e)){if(e.length===0)throw new TypeError("Tensor type cannot be inferred from an empty array.");let c=typeof e[0];if(c==="string")a="string",s=e;else if(c==="boolean")a="bool",s=Uint8Array.from(e);else throw new TypeError(`Invalid element type of data array: ${c}.`)}else if(e instanceof Uint8ClampedArray)a="uint8",s=Uint8Array.from(e);else{let c=Sr.get(e.constructor);if(c===void 0)throw new TypeError(`Unsupported type for tensor data: ${e.constructor}.`);a=c,s=e}if(d===void 0)d=[s.length];else if(!Array.isArray(d))throw new TypeError("A tensor's dims must be a number array");p=d,this.cpuData=s,this.dataLocation="cpu"}let o=gs(p);if(this.cpuData&&o!==this.cpuData.length&&!((a==="uint4"||a==="int4")&&Math.ceil(o/2)===this.cpuData.length))throw new Error(`Tensor's size(${o}) does not match data length(${this.cpuData.length}).`);this.type=a,this.dims=p,this.size=o}static async fromImage(e,n){return us(e,n)}static fromTexture(e,n){return ls(e,n)}static fromGpuBuffer(e,n){return fs(e,n)}static fromMLTensor(e,n){return cs(e,n)}static fromPinnedBuffer(e,n,i){return ps(e,n,i)}toDataURL(e){return is(this,e)}toImageData(e){return as(this,e)}get data(){if(this.ensureValid(),!this.cpuData)throw new Error("The data is not on CPU. Use `getData()` to download GPU data to CPU, or use `texture` or `gpuBuffer` property to access the GPU data directly.");return this.cpuData}get location(){return this.dataLocation}get texture(){if(this.ensureValid(),!this.gpuTextureData)throw new Error("The data is not stored as a WebGL texture.");return this.gpuTextureData}get gpuBuffer(){if(this.ensureValid(),!this.gpuBufferData)throw new Error("The data is not stored as a WebGPU buffer.");return this.gpuBufferData}get mlTensor(){if(this.ensureValid(),!this.mlTensorData)throw new Error("The data is not stored as a WebNN MLTensor.");return this.mlTensorData}async getData(e){switch(this.ensureValid(),this.dataLocation){case"cpu":case"cpu-pinned":return this.data;case"texture":case"gpu-buffer":case"ml-tensor":{if(!this.downloader)throw new Error("The current tensor is not created with a specified data downloader.");if(this.isDownloading)throw new Error("The current tensor is being downloaded.");try{this.isDownloading=!0;let n=await this.downloader();return this.downloader=void 0,this.dataLocation="cpu",this.cpuData=n,e&&this.disposer&&(this.disposer(),this.disposer=void 0),n}finally{this.isDownloading=!1}}default:throw new Error(`cannot get data from location: ${this.dataLocation}`)}}dispose(){if(this.isDownloading)throw new Error("The current tensor is being downloaded.");this.disposer&&(this.disposer(),this.disposer=void 0),this.cpuData=void 0,this.gpuTextureData=void 0,this.gpuBufferData=void 0,this.mlTensorData=void 0,this.downloader=void 0,this.isDownloading=void 0,this.dataLocation="none"}ensureValid(){if(this.dataLocation==="none")throw new Error("The tensor is disposed.")}reshape(e){if(this.ensureValid(),this.downloader||this.disposer)throw new Error("Cannot reshape a tensor that owns GPU resource.");return ys(this,e)}}}),yt,pn=O(()=>{cn(),yt=St}),Ts,ws,Fe,Ce,Go=O(()=>{No(),Ts=(e,n)=>{(typeof Gt.trace>"u"?!Gt.wasm.trace:!Gt.trace)||console.timeStamp(`${e}::ORT::${n}`)},ws=(e,n)=>{var p;let i=((p=new Error().stack)==null?void 0:p.split(/\r\n|\r|\n/g))||[],a=!1;for(let o=0;o<i.length;o++){if(a&&!i[o].includes("TRACE_FUNC")){let s=`FUNC_${e}::${i[o].trim().split(" ")[1]}`;n&&(s+=`::${n}`),Ts("CPU",s);return}i[o].includes("TRACE_FUNC")&&(a=!0)}},Fe=e=>{(typeof Gt.trace>"u"?!Gt.wasm.trace:!Gt.trace)||ws("BEGIN",e)},Ce=e=>{(typeof Gt.trace>"u"?!Gt.wasm.trace:!Gt.trace)||ws("END",e)}}),dn,vs=O(()=>{fn(),pn(),Go(),dn=class _a{constructor(n){this.handler=n}async run(n,i,a){Fe();let p={},o={};if(typeof n!="object"||n===null||n instanceof yt||Array.isArray(n))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let s=!0;if(typeof i=="object"){if(i===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(i instanceof yt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(i)){if(i.length===0)throw new TypeError("'fetches' cannot be an empty array.");s=!1;for(let r of i){if(typeof r!="string")throw new TypeError("'fetches' must be a string array or an object.");if(this.outputNames.indexOf(r)===-1)throw new RangeError(`'fetches' contains invalid output name: ${r}.`);p[r]=null}if(typeof a=="object"&&a!==null)o=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else{let r=!1,u=Object.getOwnPropertyNames(i);for(let l of this.outputNames)if(u.indexOf(l)!==-1){let h=i[l];(h===null||h instanceof yt)&&(r=!0,s=!1,p[l]=h)}if(r){if(typeof a=="object"&&a!==null)o=a;else if(typeof a<"u")throw new TypeError("'options' must be an object.")}else o=i}}else if(typeof i<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let r of this.inputNames)if(typeof n[r]>"u")throw new Error(`input '${r}' is missing in 'feeds'.`);if(s)for(let r of this.outputNames)p[r]=null;let d=await this.handler.run(n,p,o),c={};for(let r in d)if(Object.hasOwnProperty.call(d,r)){let u=d[r];u instanceof yt?c[r]=u:c[r]=new yt(u.type,u.data,u.dims)}return Ce(),c}async release(){return this.handler.dispose()}static async create(n,i,a,p){Fe();let o,s={};if(typeof n=="string"){if(o=n,typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(n instanceof Uint8Array){if(o=n,typeof i=="object"&&i!==null)s=i;else if(typeof i<"u")throw new TypeError("'options' must be an object.")}else if(n instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&n instanceof SharedArrayBuffer){let u=n,l=0,h=n.byteLength;if(typeof i=="object"&&i!==null)s=i;else if(typeof i=="number"){if(l=i,!Number.isSafeInteger(l))throw new RangeError("'byteOffset' must be an integer.");if(l<0||l>=u.byteLength)throw new RangeError(`'byteOffset' is out of range [0, ${u.byteLength}).`);if(h=n.byteLength-l,typeof a=="number"){if(h=a,!Number.isSafeInteger(h))throw new RangeError("'byteLength' must be an integer.");if(h<=0||l+h>u.byteLength)throw new RangeError(`'byteLength' is out of range (0, ${u.byteLength-l}].`);if(typeof p=="object"&&p!==null)s=p;else if(typeof p<"u")throw new TypeError("'options' must be an object.")}else if(typeof a<"u")throw new TypeError("'byteLength' must be a number.")}else if(typeof i<"u")throw new TypeError("'options' must be an object.");o=new Uint8Array(u,l,h)}else throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");let[d,c]=await ln(s),r=await d.createInferenceSessionHandler(o,c);return Ce(),new _a(r)}startProfiling(){this.handler.startProfiling()}endProfiling(){this.handler.endProfiling()}get inputNames(){return this.handler.inputNames}get outputNames(){return this.handler.outputNames}}}),Yd,Is=O(()=>{vs(),Yd=dn}),_s=O(()=>{}),Os=O(()=>{}),Ss=O(()=>{}),As=O(()=>{}),Zd,hn,Ps=O(()=>{fn(),pn(),Zd="Training backend could not be resolved. Make sure you're using the correct configuration & WebAssembly files.",hn=class Oa{constructor(n,i,a){this.handler=n,this.hasOptimizerModel=i,this.hasEvalModel=a}get trainingInputNames(){return this.handler.inputNames}get trainingOutputNames(){return this.handler.outputNames}get evalInputNames(){if(this.hasEvalModel)return this.handler.evalInputNames;throw new Error("This training session has no evalModel loaded.")}get evalOutputNames(){if(this.hasEvalModel)return this.handler.evalOutputNames;throw new Error("This training session has no evalModel loaded.")}static async create(n,i){let a=n.evalModel||"",p=n.optimizerModel||"",o=i||{},[s,d]=await ln(o);if(s.createTrainingSessionHandler){let c=await s.createTrainingSessionHandler(n.checkpointState,n.trainModel,a,p,d);return new Oa(c,!!n.optimizerModel,!!n.evalModel)}else throw new Error(Zd)}typeNarrowingForRunStep(n,i,a,p,o){let s={},d={};if(typeof a!="object"||a===null||a instanceof yt||Array.isArray(a))throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");let c=!0;if(typeof p=="object"){if(p===null)throw new TypeError("Unexpected argument[1]: cannot be null.");if(p instanceof yt)throw new TypeError("'fetches' cannot be a Tensor");if(Array.isArray(p)){if(p.length===0)throw new TypeError("'fetches' cannot be an empty array.");c=!1;for(let r of p){if(typeof r!="string")throw new TypeError("'fetches' must be a string array or an object.");if(i.indexOf(r)===-1)throw new RangeError(`'fetches' contains invalid output name: ${r}.`);s[r]=null}if(typeof o=="object"&&o!==null)d=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else{let r=!1,u=Object.getOwnPropertyNames(p);for(let l of i)if(u.indexOf(l)!==-1){let h=p[l];(h===null||h instanceof yt)&&(r=!0,c=!1,s[l]=h)}if(r){if(typeof o=="object"&&o!==null)d=o;else if(typeof o<"u")throw new TypeError("'options' must be an object.")}else d=p}}else if(typeof p<"u")throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");for(let r of n)if(typeof a[r]>"u")throw new Error(`input '${r}' is missing in 'feeds'.`);if(c)for(let r of i)s[r]=null;return[s,d]}convertHandlerReturnTypeToMapOfTensors(n){let i={};for(let a in n)if(Object.hasOwnProperty.call(n,a)){let p=n[a];p instanceof yt?i[a]=p:i[a]=new yt(p.type,p.data,p.dims)}return i}async lazyResetGrad(){await this.handler.lazyResetGrad()}async runTrainStep(n,i,a){let[p,o]=this.typeNarrowingForRunStep(this.trainingInputNames,this.trainingOutputNames,n,i,a),s=await this.handler.runTrainStep(n,p,o);return this.convertHandlerReturnTypeToMapOfTensors(s)}async runOptimizerStep(n){if(this.hasOptimizerModel)await this.handler.runOptimizerStep(n||{});else throw new Error("This TrainingSession has no OptimizerModel loaded.")}async runEvalStep(n,i,a){if(this.hasEvalModel){let[p,o]=this.typeNarrowingForRunStep(this.evalInputNames,this.evalOutputNames,n,i,a),s=await this.handler.runEvalStep(n,p,o);return this.convertHandlerReturnTypeToMapOfTensors(s)}else throw new Error("This TrainingSession has no EvalModel loaded.")}async getParametersSize(n=!0){return this.handler.getParametersSize(n)}async loadParametersBuffer(n,i=!0){let a=await this.getParametersSize(i);if(n.length!==4*a)throw new Error("Size of the buffer passed into loadParametersBuffer must match the number of parameters in the model. Please use getParametersSize method to check.");return this.handler.loadParametersBuffer(n,i)}async getContiguousParameters(n=!0){return this.handler.getContiguousParameters(n)}async release(){return this.handler.dispose()}}}),Qd,Es=O(()=>{Ps(),Qd=hn}),Mo={};Or(Mo,{InferenceSession:()=>Yd,TRACE:()=>Ts,TRACE_FUNC_BEGIN:()=>Fe,TRACE_FUNC_END:()=>Ce,Tensor:()=>yt,TrainingSession:()=>Qd,env:()=>z,registerBackend:()=>nr});var Yt=O(()=>{ts(),os(),Is(),pn(),_s(),Os(),Go(),Ss(),As(),Es()});function _e(e,n,i,a){if(n===void 0)return eh(e);if(i===void 0)mn(e,n);else if(typeof i=="number"&&a===void 0)mn(e,n);else if(typeof i=="string"&&a===void 0)mn(e,i,1,n);else if(typeof i=="string"&&typeof a=="number")mn(e,i,a,n);else throw new TypeError("input is valid")}function eh(e){return{verbose:_e.verbose.bind(null,e),info:_e.info.bind(null,e),warning:_e.warning.bind(null,e),error:_e.error.bind(null,e),fatal:_e.fatal.bind(null,e)}}function mn(e,n,i,a){let p=Ar[a||""]||Ar[""];Ls[e]<Ls[p.minimalSeverity]||(p.logDateTime&&(n=`${new Date().toISOString()}|${n}`),p.logSourceLocation,th[p.provider].log(e,n,a))}var Uo,Vo,Ls,th,$s,Ar,tt,gn,yn,xn,bn,Ut=O(()=>{Uo=class{log(e,n,i){}},Vo=class{log(e,n,i){console.log(`${this.color(e)} ${i?"\x1B[35m"+i+"\x1B[0m ":""}${n}`)}color(e){switch(e){case"verbose":return"\x1B[34;40mv\x1B[0m";case"info":return"\x1B[32mi\x1B[0m";case"warning":return"\x1B[30;43mw\x1B[0m";case"error":return"\x1B[31;40me\x1B[0m";case"fatal":return"\x1B[101mf\x1B[0m";default:throw new Error(`unsupported severity: ${e}`)}}},Ls={verbose:1e3,info:2e3,warning:4e3,error:5e3,fatal:6e3},th={none:new Uo,console:new Vo},$s={provider:"console",minimalSeverity:"warning",logDateTime:!0,logSourceLocation:!1},Ar={"":$s},(e=>{function n(r,u){e("verbose",r,u)}e.verbose=n;function i(r,u){e("info",r,u)}e.info=i;function a(r,u){e("warning",r,u)}e.warning=a;function p(r,u){e("error",r,u)}e.error=p;function o(r,u){e("fatal",r,u)}e.fatal=o;function s(r){Ar={},d("",r||{})}e.reset=s;function d(r,u){if(r==="*")s(u);else{let l=Ar[r]||$s;Ar[r]={provider:u.provider||l.provider,minimalSeverity:u.minimalSeverity||l.minimalSeverity,logDateTime:u.logDateTime===void 0?l.logDateTime:u.logDateTime,logSourceLocation:u.logSourceLocation===void 0?l.logSourceLocation:u.logSourceLocation}}}e.set=d;function c(r){let u={};r.logLevel&&(u.minimalSeverity=r.logLevel),d("",u)}e.setWithEnv=c})(_e||(_e={})),tt=_e,gn=class{constructor(e,n,i,a,p,o){this.category=e,this.name=n,this.startTime=i,this.endCallback=a,this.timer=p,this.ctx=o}async end(){return this.endCallback(this)}async checkTimer(){if(this.ctx===void 0||this.timer===void 0)throw new Error("No webgl timer found");return this.ctx.endTimer(),this.ctx.waitForQueryAndGetTime(this.timer)}},yn=class{constructor(e,n,i,a){this.category=e,this.name=n,this.startTime=i,this.endTime=a}},xn=class{constructor(e,n,i){this._started=!1,this._flushPointer=0,this._started=!1,this._maxNumberEvents=e===void 0?1e4:e,this._flushBatchSize=n===void 0?10:n,this._flushIntervalInMilliseconds=i===void 0?5e3:i}static create(e){return e===void 0?new this:new this(e.maxNumberEvents,e.flushBatchSize,e.flushIntervalInMilliseconds)}start(){this._started=!0,this._timingEvents=[],this._flushTime=bn(),this._flushPointer=0}stop(){for(this._started=!1;this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer])}event(e,n,i,a){let p=this._started?this.begin(e,n,a):void 0,o=!1,s=i();if(s&&typeof s.then=="function")return o=!0,new Promise((d,c)=>{s.then(async r=>{p&&await p.end(),d(r)},async r=>{p&&await p.end(),c(r)})});if(!o&&p){let d=p.end();if(d&&typeof d.then=="function")return new Promise((c,r)=>{d.then(()=>{c(s)},u=>{r(u)})})}return s}begin(e,n,i){if(!this._started)throw new Error("profiler is not started yet");if(i===void 0){let a=bn();return this.flush(a),new gn(e,n,a,p=>this.endSync(p))}else{let a=i.beginTimer();return new gn(e,n,0,async p=>this.end(p),a,i)}}async end(e){let n=await e.checkTimer();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new yn(e.category,e.name,e.startTime,n)),this.flush(n))}endSync(e){let n=bn();this._timingEvents.length<this._maxNumberEvents&&(this._timingEvents.push(new yn(e.category,e.name,e.startTime,n)),this.flush(n))}logOneEvent(e){tt.verbose(`Profiler.${e.category}`,`${(e.endTime-e.startTime).toFixed(2)}ms on event '${e.name}' at ${e.endTime.toFixed(2)}`)}flush(e){if(this._timingEvents.length-this._flushPointer>=this._flushBatchSize||e-this._flushTime>=this._flushIntervalInMilliseconds){for(let n=this._flushPointer;this._flushPointer<n+this._flushBatchSize&&this._flushPointer<this._timingEvents.length;this._flushPointer++)this.logOneEvent(this._timingEvents[this._flushPointer]);this._flushTime=bn()}}get started(){return this._started}},bn=typeof performance<"u"&&performance.now?()=>performance.now():Date.now});function ks(e,n,i){for(let a of i){let p=a[0],o=a[1],s=a[2],d=a[3],c=a[4];if(e.opType===p){for(let r of n)if((r.domain===o||r.domain==="ai.onnx"&&o==="")&&rh(r.version,s))return{opImpl:d,opInit:c}}}throw new TypeError(`cannot resolve operator '${e.opType}' with opsets: ${n.map(a=>`${a.domain||"ai.onnx"} v${a.version}`).join(", ")}`)}function rh(e,n){if(n.endsWith("+")){let i=Number.parseInt(n.substring(0,n.length-1),10);return!isNaN(i)&&i<=e}else if(n.split("-").length===2){let i=n.split("-"),a=Number.parseInt(i[0],10),p=Number.parseInt(i[1],10);return!isNaN(a)&&!isNaN(p)&&a<=e&&e<=p}else return Number.parseInt(n,10)===e}var Bs=O(()=>{}),Fs=mt(e=>{e.__esModule=!0;var n=function(){function i(a){if(!a)throw new TypeError("Invalid argument; `value` has no value.");this.value=i.EMPTY,a&&i.isGuid(a)&&(this.value=a)}return i.isGuid=function(a){var p=a.toString();return a&&(a instanceof i||i.validator.test(p))},i.create=function(){return new i([i.gen(2),i.gen(1),i.gen(1),i.gen(1),i.gen(3)].join("-"))},i.createEmpty=function(){return new i("emptyguid")},i.parse=function(a){return new i(a)},i.raw=function(){return[i.gen(2),i.gen(1),i.gen(1),i.gen(1),i.gen(3)].join("-")},i.gen=function(a){for(var p="",o=0;o<a;o++)p+=((1+Math.random())*65536|0).toString(16).substring(1);return p},i.prototype.equals=function(a){return i.isGuid(a)&&this.value===a.toString()},i.prototype.isEmpty=function(){return this.value===i.EMPTY},i.prototype.toString=function(){return this.value},i.prototype.toJSON=function(){return{value:this.value}},i.validator=new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),i.EMPTY="00000000-0000-0000-0000-000000000000",i}();e.Guid=n});function rt(e,n,i){this.low=e|0,this.high=n|0,this.unsigned=!!i}function Et(e){return(e&&e.__isLong__)===!0}function Cs(e){var n=Math.clz32(e&-e);return e?31-n:n}function Ne(e,n){var i,a,p;return n?(e>>>=0,(p=0<=e&&e<256)&&(a=Rs[e],a)?a:(i=J(e,0,!0),p&&(Rs[e]=i),i)):(e|=0,(p=-128<=e&&e<128)&&(a=Ns[e],a)?a:(i=J(e,e<0?-1:0,!1),p&&(Ns[e]=i),i))}function zt(e,n){if(isNaN(e))return n?ye:Zt;if(n){if(e<0)return ye;if(e>=Vs)return Hs}else{if(e<=-Ms)return Ct;if(e+1>=Ms)return Ws}return e<0?zt(-e,n).neg():J(e%ir|0,e/ir|0,n)}function J(e,n,i){return new rt(e,n,i)}function Ho(e,n,i){if(e.length===0)throw Error("empty string");if(typeof n=="number"?(i=n,n=!1):n=!!n,e==="NaN"||e==="Infinity"||e==="+Infinity"||e==="-Infinity")return n?ye:Zt;if(i=i||10,i<2||36<i)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(a===0)return Ho(e.substring(1),n,i).neg();for(var p=zt(Tn(i,8)),o=Zt,s=0;s<e.length;s+=8){var d=Math.min(8,e.length-s),c=parseInt(e.substring(s,s+d),i);if(d<8){var r=zt(Tn(i,d));o=o.mul(r).add(zt(c))}else o=o.mul(p),o=o.add(zt(c))}return o.unsigned=n,o}function Qt(e,n){return typeof e=="number"?zt(e,n):typeof e=="string"?Ho(e,n):J(e.low,e.high,typeof n=="boolean"?n:e.unsigned)}var Vt,Ns,Rs,Tn,Gs,oh,ir,Vs,Ms,Us,Zt,ye,or,zs,Wo,Ws,Hs,Ct,D,xe,qo=O(()=>{Vt=null;try{Vt=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}rt.prototype.__isLong__,Object.defineProperty(rt.prototype,"__isLong__",{value:!0}),rt.isLong=Et,Ns={},Rs={},rt.fromInt=Ne,rt.fromNumber=zt,rt.fromBits=J,Tn=Math.pow,rt.fromString=Ho,rt.fromValue=Qt,Gs=65536,oh=1<<24,ir=Gs*Gs,Vs=ir*ir,Ms=Vs/2,Us=Ne(oh),Zt=Ne(0),rt.ZERO=Zt,ye=Ne(0,!0),rt.UZERO=ye,or=Ne(1),rt.ONE=or,zs=Ne(1,!0),rt.UONE=zs,Wo=Ne(-1),rt.NEG_ONE=Wo,Ws=J(-1,2147483647,!1),rt.MAX_VALUE=Ws,Hs=J(-1,-1,!0),rt.MAX_UNSIGNED_VALUE=Hs,Ct=J(0,-2147483648,!1),rt.MIN_VALUE=Ct,D=rt.prototype,D.toInt=function(){return this.unsigned?this.low>>>0:this.low},D.toNumber=function(){return this.unsigned?(this.high>>>0)*ir+(this.low>>>0):this.high*ir+(this.low>>>0)},D.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Ct)){var n=zt(e),i=this.div(n),a=i.mul(n).sub(this);return i.toString(e)+a.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var p=zt(Tn(e,6),this.unsigned),o=this,s="";;){var d=o.div(p),c=o.sub(d.mul(p)).toInt()>>>0,r=c.toString(e);if(o=d,o.isZero())return r+s;for(;r.length<6;)r="0"+r;s=""+r+s}},D.getHighBits=function(){return this.high},D.getHighBitsUnsigned=function(){return this.high>>>0},D.getLowBits=function(){return this.low},D.getLowBitsUnsigned=function(){return this.low>>>0},D.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Ct)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&!(e&1<<n);n--);return this.high!=0?n+33:n+1},D.isZero=function(){return this.high===0&&this.low===0},D.eqz=D.isZero,D.isNegative=function(){return!this.unsigned&&this.high<0},D.isPositive=function(){return this.unsigned||this.high>=0},D.isOdd=function(){return(this.low&1)===1},D.isEven=function(){return(this.low&1)===0},D.equals=function(e){return Et(e)||(e=Qt(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low},D.eq=D.equals,D.notEquals=function(e){return!this.eq(e)},D.neq=D.notEquals,D.ne=D.notEquals,D.lessThan=function(e){return this.comp(e)<0},D.lt=D.lessThan,D.lessThanOrEqual=function(e){return this.comp(e)<=0},D.lte=D.lessThanOrEqual,D.le=D.lessThanOrEqual,D.greaterThan=function(e){return this.comp(e)>0},D.gt=D.greaterThan,D.greaterThanOrEqual=function(e){return this.comp(e)>=0},D.gte=D.greaterThanOrEqual,D.ge=D.greaterThanOrEqual,D.compare=function(e){if(Et(e)||(e=Qt(e)),this.eq(e))return 0;var n=this.isNegative(),i=e.isNegative();return n&&!i?-1:!n&&i?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},D.comp=D.compare,D.negate=function(){return!this.unsigned&&this.eq(Ct)?Ct:this.not().add(or)},D.neg=D.negate,D.add=function(e){Et(e)||(e=Qt(e));var n=this.high>>>16,i=this.high&65535,a=this.low>>>16,p=this.low&65535,o=e.high>>>16,s=e.high&65535,d=e.low>>>16,c=e.low&65535,r=0,u=0,l=0,h=0;return h+=p+c,l+=h>>>16,h&=65535,l+=a+d,u+=l>>>16,l&=65535,u+=i+s,r+=u>>>16,u&=65535,r+=n+o,r&=65535,J(l<<16|h,r<<16|u,this.unsigned)},D.subtract=function(e){return Et(e)||(e=Qt(e)),this.add(e.neg())},D.sub=D.subtract,D.multiply=function(e){if(this.isZero())return this;if(Et(e)||(e=Qt(e)),Vt){var n=Vt.mul(this.low,this.high,e.low,e.high);return J(n,Vt.get_high(),this.unsigned)}if(e.isZero())return this.unsigned?ye:Zt;if(this.eq(Ct))return e.isOdd()?Ct:Zt;if(e.eq(Ct))return this.isOdd()?Ct:Zt;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(Us)&&e.lt(Us))return zt(this.toNumber()*e.toNumber(),this.unsigned);var i=this.high>>>16,a=this.high&65535,p=this.low>>>16,o=this.low&65535,s=e.high>>>16,d=e.high&65535,c=e.low>>>16,r=e.low&65535,u=0,l=0,h=0,f=0;return f+=o*r,h+=f>>>16,f&=65535,h+=p*r,l+=h>>>16,h&=65535,h+=o*c,l+=h>>>16,h&=65535,l+=a*r,u+=l>>>16,l&=65535,l+=p*c,u+=l>>>16,l&=65535,l+=o*d,u+=l>>>16,l&=65535,u+=i*r+a*c+p*d+o*s,u&=65535,J(h<<16|f,u<<16|l,this.unsigned)},D.mul=D.multiply,D.divide=function(e){if(Et(e)||(e=Qt(e)),e.isZero())throw Error("division by zero");if(Vt){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?Vt.div_u:Vt.div_s)(this.low,this.high,e.low,e.high);return J(n,Vt.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?ye:Zt;var i,a,p;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return ye;if(e.gt(this.shru(1)))return zs;p=ye}else{if(this.eq(Ct)){if(e.eq(or)||e.eq(Wo))return Ct;if(e.eq(Ct))return or;var o=this.shr(1);return i=o.div(e).shl(1),i.eq(Zt)?e.isNegative()?or:Wo:(a=this.sub(e.mul(i)),p=i.add(a.div(e)),p)}else if(e.eq(Ct))return this.unsigned?ye:Zt;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();p=Zt}for(a=this;a.gte(e);){i=Math.max(1,Math.floor(a.toNumber()/e.toNumber()));for(var s=Math.ceil(Math.log(i)/Math.LN2),d=s<=48?1:Tn(2,s-48),c=zt(i),r=c.mul(e);r.isNegative()||r.gt(a);)i-=d,c=zt(i,this.unsigned),r=c.mul(e);c.isZero()&&(c=or),p=p.add(c),a=a.sub(r)}return p},D.div=D.divide,D.modulo=function(e){if(Et(e)||(e=Qt(e)),Vt){var n=(this.unsigned?Vt.rem_u:Vt.rem_s)(this.low,this.high,e.low,e.high);return J(n,Vt.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))},D.mod=D.modulo,D.rem=D.modulo,D.not=function(){return J(~this.low,~this.high,this.unsigned)},D.countLeadingZeros=function(){return this.high?Math.clz32(this.high):Math.clz32(this.low)+32},D.clz=D.countLeadingZeros,D.countTrailingZeros=function(){return this.low?Cs(this.low):Cs(this.high)+32},D.ctz=D.countTrailingZeros,D.and=function(e){return Et(e)||(e=Qt(e)),J(this.low&e.low,this.high&e.high,this.unsigned)},D.or=function(e){return Et(e)||(e=Qt(e)),J(this.low|e.low,this.high|e.high,this.unsigned)},D.xor=function(e){return Et(e)||(e=Qt(e)),J(this.low^e.low,this.high^e.high,this.unsigned)},D.shiftLeft=function(e){return Et(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?J(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):J(0,this.low<<e-32,this.unsigned)},D.shl=D.shiftLeft,D.shiftRight=function(e){return Et(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?J(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):J(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},D.shr=D.shiftRight,D.shiftRightUnsigned=function(e){return Et(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?J(this.low>>>e|this.high<<32-e,this.high>>>e,this.unsigned):e===32?J(this.high,0,this.unsigned):J(this.high>>>e-32,0,this.unsigned)},D.shru=D.shiftRightUnsigned,D.shr_u=D.shiftRightUnsigned,D.rotateLeft=function(e){var n;return Et(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?J(this.high,this.low,this.unsigned):e<32?(n=32-e,J(this.low<<e|this.high>>>n,this.high<<e|this.low>>>n,this.unsigned)):(e-=32,n=32-e,J(this.high<<e|this.low>>>n,this.low<<e|this.high>>>n,this.unsigned))},D.rotl=D.rotateLeft,D.rotateRight=function(e){var n;return Et(e)&&(e=e.toInt()),(e&=63)===0?this:e===32?J(this.high,this.low,this.unsigned):e<32?(n=32-e,J(this.high<<n|this.low>>>e,this.low<<n|this.high>>>e,this.unsigned)):(e-=32,n=32-e,J(this.low<<n|this.high>>>e,this.high<<n|this.low>>>e,this.unsigned))},D.rotr=D.rotateRight,D.toSigned=function(){return this.unsigned?J(this.low,this.high,!1):this},D.toUnsigned=function(){return this.unsigned?this:J(this.low,this.high,!0)},D.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},D.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]},D.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]},rt.fromBytes=function(e,n,i){return i?rt.fromBytesLE(e,n):rt.fromBytesBE(e,n)},rt.fromBytesLE=function(e,n){return new rt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)},rt.fromBytesBE=function(e,n){return new rt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)},xe=rt}),w,wn=O(()=>{w={},w.Offset,w.Table,w.SIZEOF_SHORT=2,w.SIZEOF_INT=4,w.FILE_IDENTIFIER_LENGTH=4,w.SIZE_PREFIX_LENGTH=4,w.Encoding={UTF8_BYTES:1,UTF16_STRING:2},w.int32=new Int32Array(2),w.float32=new Float32Array(w.int32.buffer),w.float64=new Float64Array(w.int32.buffer),w.isLittleEndian=new Uint16Array(new Uint8Array([1,0]).buffer)[0]===1,w.Long=function(e,n){this.low=e|0,this.high=n|0},w.Long.create=function(e,n){return e==0&&n==0?w.Long.ZERO:new w.Long(e,n)},w.Long.prototype.toFloat64=function(){return(this.low>>>0)+this.high*4294967296},w.Long.prototype.equals=function(e){return this.low==e.low&&this.high==e.high},w.Long.ZERO=new w.Long(0,0),w.Builder=function(e){if(e)var n=e;else var n=1024;this.bb=w.ByteBuffer.allocate(n),this.space=n,this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},w.Builder.prototype.clear=function(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1},w.Builder.prototype.forceDefaults=function(e){this.force_defaults=e},w.Builder.prototype.dataBuffer=function(){return this.bb},w.Builder.prototype.asUint8Array=function(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())},w.Builder.prototype.prep=function(e,n){e>this.minalign&&(this.minalign=e);for(var i=~(this.bb.capacity()-this.space+n)+1&e-1;this.space<i+e+n;){var a=this.bb.capacity();this.bb=w.Builder.growByteBuffer(this.bb),this.space+=this.bb.capacity()-a}this.pad(i)},w.Builder.prototype.pad=function(e){for(var n=0;n<e;n++)this.bb.writeInt8(--this.space,0)},w.Builder.prototype.writeInt8=function(e){this.bb.writeInt8(this.space-=1,e)},w.Builder.prototype.writeInt16=function(e){this.bb.writeInt16(this.space-=2,e)},w.Builder.prototype.writeInt32=function(e){this.bb.writeInt32(this.space-=4,e)},w.Builder.prototype.writeInt64=function(e){this.bb.writeInt64(this.space-=8,e)},w.Builder.prototype.writeFloat32=function(e){this.bb.writeFloat32(this.space-=4,e)},w.Builder.prototype.writeFloat64=function(e){this.bb.writeFloat64(this.space-=8,e)},w.Builder.prototype.addInt8=function(e){this.prep(1,0),this.writeInt8(e)},w.Builder.prototype.addInt16=function(e){this.prep(2,0),this.writeInt16(e)},w.Builder.prototype.addInt32=function(e){this.prep(4,0),this.writeInt32(e)},w.Builder.prototype.addInt64=function(e){this.prep(8,0),this.writeInt64(e)},w.Builder.prototype.addFloat32=function(e){this.prep(4,0),this.writeFloat32(e)},w.Builder.prototype.addFloat64=function(e){this.prep(8,0),this.writeFloat64(e)},w.Builder.prototype.addFieldInt8=function(e,n,i){(this.force_defaults||n!=i)&&(this.addInt8(n),this.slot(e))},w.Builder.prototype.addFieldInt16=function(e,n,i){(this.force_defaults||n!=i)&&(this.addInt16(n),this.slot(e))},w.Builder.prototype.addFieldInt32=function(e,n,i){(this.force_defaults||n!=i)&&(this.addInt32(n),this.slot(e))},w.Builder.prototype.addFieldInt64=function(e,n,i){(this.force_defaults||!n.equals(i))&&(this.addInt64(n),this.slot(e))},w.Builder.prototype.addFieldFloat32=function(e,n,i){(this.force_defaults||n!=i)&&(this.addFloat32(n),this.slot(e))},w.Builder.prototype.addFieldFloat64=function(e,n,i){(this.force_defaults||n!=i)&&(this.addFloat64(n),this.slot(e))},w.Builder.prototype.addFieldOffset=function(e,n,i){(this.force_defaults||n!=i)&&(this.addOffset(n),this.slot(e))},w.Builder.prototype.addFieldStruct=function(e,n,i){n!=i&&(this.nested(n),this.slot(e))},w.Builder.prototype.nested=function(e){if(e!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")},w.Builder.prototype.notNested=function(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")},w.Builder.prototype.slot=function(e){this.vtable[e]=this.offset()},w.Builder.prototype.offset=function(){return this.bb.capacity()-this.space},w.Builder.growByteBuffer=function(e){var n=e.capacity();if(n&3221225472)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");var i=n<<1,a=w.ByteBuffer.allocate(i);return a.setPosition(i-n),a.bytes().set(e.bytes(),i-n),a},w.Builder.prototype.addOffset=function(e){this.prep(w.SIZEOF_INT,0),this.writeInt32(this.offset()-e+w.SIZEOF_INT)},w.Builder.prototype.startObject=function(e){this.notNested(),this.vtable==null&&(this.vtable=[]),this.vtable_in_use=e;for(var n=0;n<e;n++)this.vtable[n]=0;this.isNested=!0,this.object_start=this.offset()},w.Builder.prototype.endObject=function(){if(this.vtable==null||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);for(var e=this.offset(),n=this.vtable_in_use-1;n>=0&&this.vtable[n]==0;n--);for(var i=n+1;n>=0;n--)this.addInt16(this.vtable[n]!=0?e-this.vtable[n]:0);var a=2;this.addInt16(e-this.object_start);var p=(i+a)*w.SIZEOF_SHORT;this.addInt16(p);var o=0,s=this.space;t:for(n=0;n<this.vtables.length;n++){var d=this.bb.capacity()-this.vtables[n];if(p==this.bb.readInt16(d)){for(var c=w.SIZEOF_SHORT;c<p;c+=w.SIZEOF_SHORT)if(this.bb.readInt16(s+c)!=this.bb.readInt16(d+c))continue t;o=this.vtables[n];break}}return o?(this.space=this.bb.capacity()-e,this.bb.writeInt32(this.space,o-e)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-e,this.offset()-e)),this.isNested=!1,e},w.Builder.prototype.finish=function(e,n,i){var a=i?w.SIZE_PREFIX_LENGTH:0;if(n){var p=n;if(this.prep(this.minalign,w.SIZEOF_INT+w.FILE_IDENTIFIER_LENGTH+a),p.length!=w.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+w.FILE_IDENTIFIER_LENGTH);for(var o=w.FILE_IDENTIFIER_LENGTH-1;o>=0;o--)this.writeInt8(p.charCodeAt(o))}this.prep(this.minalign,w.SIZEOF_INT+a),this.addOffset(e),a&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)},w.Builder.prototype.finishSizePrefixed=function(e,n){this.finish(e,n,!0)},w.Builder.prototype.requiredField=function(e,n){var i=this.bb.capacity()-e,a=i-this.bb.readInt32(i),p=this.bb.readInt16(a+n)!=0;if(!p)throw new Error("FlatBuffers: field "+n+" must be set")},w.Builder.prototype.startVector=function(e,n,i){this.notNested(),this.vector_num_elems=n,this.prep(w.SIZEOF_INT,e*n),this.prep(i,e*n)},w.Builder.prototype.endVector=function(){return this.writeInt32(this.vector_num_elems),this.offset()},w.Builder.prototype.createString=function(e){if(e instanceof Uint8Array)var n=e;else for(var n=[],i=0;i<e.length;){var a,p=e.charCodeAt(i++);if(p<55296||p>=56320)a=p;else{var o=e.charCodeAt(i++);a=(p<<10)+o+-56613888}a<128?n.push(a):(a<2048?n.push(a>>6&31|192):(a<65536?n.push(a>>12&15|224):n.push(a>>18&7|240,a>>12&63|128),n.push(a>>6&63|128)),n.push(a&63|128))}this.addInt8(0),this.startVector(1,n.length,1),this.bb.setPosition(this.space-=n.length);for(var i=0,s=this.space,d=this.bb.bytes();i<n.length;i++)d[s++]=n[i];return this.endVector()},w.Builder.prototype.createLong=function(e,n){return w.Long.create(e,n)},w.ByteBuffer=function(e){this.bytes_=e,this.position_=0},w.ByteBuffer.allocate=function(e){return new w.ByteBuffer(new Uint8Array(e))},w.ByteBuffer.prototype.clear=function(){this.position_=0},w.ByteBuffer.prototype.bytes=function(){return this.bytes_},w.ByteBuffer.prototype.position=function(){return this.position_},w.ByteBuffer.prototype.setPosition=function(e){this.position_=e},w.ByteBuffer.prototype.capacity=function(){return this.bytes_.length},w.ByteBuffer.prototype.readInt8=function(e){return this.readUint8(e)<<24>>24},w.ByteBuffer.prototype.readUint8=function(e){return this.bytes_[e]},w.ByteBuffer.prototype.readInt16=function(e){return this.readUint16(e)<<16>>16},w.ByteBuffer.prototype.readUint16=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8},w.ByteBuffer.prototype.readInt32=function(e){return this.bytes_[e]|this.bytes_[e+1]<<8|this.bytes_[e+2]<<16|this.bytes_[e+3]<<24},w.ByteBuffer.prototype.readUint32=function(e){return this.readInt32(e)>>>0},w.ByteBuffer.prototype.readInt64=function(e){return new w.Long(this.readInt32(e),this.readInt32(e+4))},w.ByteBuffer.prototype.readUint64=function(e){return new w.Long(this.readUint32(e),this.readUint32(e+4))},w.ByteBuffer.prototype.readFloat32=function(e){return w.int32[0]=this.readInt32(e),w.float32[0]},w.ByteBuffer.prototype.readFloat64=function(e){return w.int32[w.isLittleEndian?0:1]=this.readInt32(e),w.int32[w.isLittleEndian?1:0]=this.readInt32(e+4),w.float64[0]},w.ByteBuffer.prototype.writeInt8=function(e,n){this.bytes_[e]=n},w.ByteBuffer.prototype.writeUint8=function(e,n){this.bytes_[e]=n},w.ByteBuffer.prototype.writeInt16=function(e,n){this.bytes_[e]=n,this.bytes_[e+1]=n>>8},w.ByteBuffer.prototype.writeUint16=function(e,n){this.bytes_[e]=n,this.bytes_[e+1]=n>>8},w.ByteBuffer.prototype.writeInt32=function(e,n){this.bytes_[e]=n,this.bytes_[e+1]=n>>8,this.bytes_[e+2]=n>>16,this.bytes_[e+3]=n>>24},w.ByteBuffer.prototype.writeUint32=function(e,n){this.bytes_[e]=n,this.bytes_[e+1]=n>>8,this.bytes_[e+2]=n>>16,this.bytes_[e+3]=n>>24},w.ByteBuffer.prototype.writeInt64=function(e,n){this.writeInt32(e,n.low),this.writeInt32(e+4,n.high)},w.ByteBuffer.prototype.writeUint64=function(e,n){this.writeUint32(e,n.low),this.writeUint32(e+4,n.high)},w.ByteBuffer.prototype.writeFloat32=function(e,n){w.float32[0]=n,this.writeInt32(e,w.int32[0])},w.ByteBuffer.prototype.writeFloat64=function(e,n){w.float64[0]=n,this.writeInt32(e,w.int32[w.isLittleEndian?0:1]),this.writeInt32(e+4,w.int32[w.isLittleEndian?1:0])},w.ByteBuffer.prototype.getBufferIdentifier=function(){if(this.bytes_.length<this.position_+w.SIZEOF_INT+w.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");for(var e="",n=0;n<w.FILE_IDENTIFIER_LENGTH;n++)e+=String.fromCharCode(this.readInt8(this.position_+w.SIZEOF_INT+n));return e},w.ByteBuffer.prototype.__offset=function(e,n){var i=e-this.readInt32(e);return n<this.readInt16(i)?this.readInt16(i+n):0},w.ByteBuffer.prototype.__union=function(e,n){return e.bb_pos=n+this.readInt32(n),e.bb=this,e},w.ByteBuffer.prototype.__string=function(e,n){e+=this.readInt32(e);var i=this.readInt32(e),a="",p=0;if(e+=w.SIZEOF_INT,n===w.Encoding.UTF8_BYTES)return this.bytes_.subarray(e,e+i);for(;p<i;){var o,s=this.readUint8(e+p++);if(s<192)o=s;else{var d=this.readUint8(e+p++);if(s<224)o=(s&31)<<6|d&63;else{var c=this.readUint8(e+p++);if(s<240)o=(s&15)<<12|(d&63)<<6|c&63;else{var r=this.readUint8(e+p++);o=(s&7)<<18|(d&63)<<12|(c&63)<<6|r&63}}}o<65536?a+=String.fromCharCode(o):(o-=65536,a+=String.fromCharCode((o>>10)+55296,(o&1023)+56320))}return a},w.ByteBuffer.prototype.__indirect=function(e){return e+this.readInt32(e)},w.ByteBuffer.prototype.__vector=function(e){return e+this.readInt32(e)+w.SIZEOF_INT},w.ByteBuffer.prototype.__vector_len=function(e){return this.readInt32(e+this.readInt32(e))},w.ByteBuffer.prototype.__has_identifier=function(e){if(e.length!=w.FILE_IDENTIFIER_LENGTH)throw new Error("FlatBuffers: file identifier must be length "+w.FILE_IDENTIFIER_LENGTH);for(var n=0;n<w.FILE_IDENTIFIER_LENGTH;n++)if(e.charCodeAt(n)!=this.readInt8(this.position_+w.SIZEOF_INT+n))return!1;return!0},w.ByteBuffer.prototype.createLong=function(e,n){return w.Long.create(e,n)}}),F,Pr=O(()=>{wn(),(e=>{(n=>{(i=>{(a=>(a[a.UNDEFINED=0]="UNDEFINED",a[a.FLOAT=1]="FLOAT",a[a.INT=2]="INT",a[a.STRING=3]="STRING",a[a.TENSOR=4]="TENSOR",a[a.GRAPH=5]="GRAPH",a[a.FLOATS=6]="FLOATS",a[a.INTS=7]="INTS",a[a.STRINGS=8]="STRINGS",a[a.TENSORS=9]="TENSORS",a[a.GRAPHS=10]="GRAPHS",a[a.SPARSE_TENSOR=11]="SPARSE_TENSOR",a[a.SPARSE_TENSORS=12]="SPARSE_TENSORS"))(i.AttributeType||(i.AttributeType={}))})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{(a=>(a[a.UNKNOWN=0]="UNKNOWN",a[a.VALUE=1]="VALUE",a[a.PARAM=2]="PARAM"))(i.DimensionValueType||(i.DimensionValueType={}))})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{(a=>(a[a.UNDEFINED=0]="UNDEFINED",a[a.FLOAT=1]="FLOAT",a[a.UINT8=2]="UINT8",a[a.INT8=3]="INT8",a[a.UINT16=4]="UINT16",a[a.INT16=5]="INT16",a[a.INT32=6]="INT32",a[a.INT64=7]="INT64",a[a.STRING=8]="STRING",a[a.BOOL=9]="BOOL",a[a.FLOAT16=10]="FLOAT16",a[a.DOUBLE=11]="DOUBLE",a[a.UINT32=12]="UINT32",a[a.UINT64=13]="UINT64",a[a.COMPLEX64=14]="COMPLEX64",a[a.COMPLEX128=15]="COMPLEX128",a[a.BFLOAT16=16]="BFLOAT16",a[a.FLOAT8E4M3FN=17]="FLOAT8E4M3FN",a[a.FLOAT8E4M3FNUZ=18]="FLOAT8E4M3FNUZ",a[a.FLOAT8E5M2=19]="FLOAT8E5M2",a[a.FLOAT8E5M2FNUZ=20]="FLOAT8E5M2FNUZ"))(i.TensorDataType||(i.TensorDataType={}))})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{(a=>(a[a.Primitive=0]="Primitive",a[a.Fused=1]="Fused"))(i.NodeType||(i.NodeType={}))})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{(a=>(a[a.NONE=0]="NONE",a[a.tensor_type=1]="tensor_type",a[a.sequence_type=2]="sequence_type",a[a.map_type=3]="map_type"))(i.TypeInfoValue||(i.TypeInfoValue={}))})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsShape(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsShape(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}dim(o,s){let d=this.bb.__offset(this.bb_pos,4);return d?(s||new e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}dimLength(){let o=this.bb.__offset(this.bb_pos,4);return o?this.bb.__vector_len(this.bb_pos+o):0}static startShape(o){o.startObject(1)}static addDim(o,s){o.addFieldOffset(0,s,0)}static createDimVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startDimVector(o,s){o.startVector(4,s,4)}static endShape(o){return o.endObject()}static createShape(o,s){return a.startShape(o),a.addDim(o,s),a.endShape(o)}}i.Shape=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsDimension(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsDimension(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}value(o){let s=this.bb.__offset(this.bb_pos,4);return s?(o||new e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}denotation(o){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,o):null}static startDimension(o){o.startObject(2)}static addValue(o,s){o.addFieldOffset(0,s,0)}static addDenotation(o,s){o.addFieldOffset(1,s,0)}static endDimension(o){return o.endObject()}static createDimension(o,s,d){return a.startDimension(o),a.addValue(o,s),a.addDenotation(o,d),a.endDimension(o)}}i.Dimension=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsDimensionValue(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsDimensionValue(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}dimType(){let o=this.bb.__offset(this.bb_pos,4);return o?this.bb.readInt8(this.bb_pos+o):0}dimValue(){let o=this.bb.__offset(this.bb_pos,6);return o?this.bb.readInt64(this.bb_pos+o):this.bb.createLong(0,0)}dimParam(o){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,o):null}static startDimensionValue(o){o.startObject(3)}static addDimType(o,s){o.addFieldInt8(0,s,0)}static addDimValue(o,s){o.addFieldInt64(1,s,o.createLong(0,0))}static addDimParam(o,s){o.addFieldOffset(2,s,0)}static endDimensionValue(o){return o.endObject()}static createDimensionValue(o,s,d,c){return a.startDimensionValue(o),a.addDimType(o,s),a.addDimValue(o,d),a.addDimParam(o,c),a.endDimensionValue(o)}}i.DimensionValue=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsTensorTypeAndShape(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsTensorTypeAndShape(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}elemType(){let o=this.bb.__offset(this.bb_pos,4);return o?this.bb.readInt32(this.bb_pos+o):0}shape(o){let s=this.bb.__offset(this.bb_pos,6);return s?(o||new e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startTensorTypeAndShape(o){o.startObject(2)}static addElemType(o,s){o.addFieldInt32(0,s,0)}static addShape(o,s){o.addFieldOffset(1,s,0)}static endTensorTypeAndShape(o){return o.endObject()}static createTensorTypeAndShape(o,s,d){return a.startTensorTypeAndShape(o),a.addElemType(o,s),a.addShape(o,d),a.endTensorTypeAndShape(o)}}i.TensorTypeAndShape=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsMapType(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsMapType(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}keyType(){let o=this.bb.__offset(this.bb_pos,4);return o?this.bb.readInt32(this.bb_pos+o):0}valueType(o){let s=this.bb.__offset(this.bb_pos,6);return s?(o||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startMapType(o){o.startObject(2)}static addKeyType(o,s){o.addFieldInt32(0,s,0)}static addValueType(o,s){o.addFieldOffset(1,s,0)}static endMapType(o){return o.endObject()}static createMapType(o,s,d){return a.startMapType(o),a.addKeyType(o,s),a.addValueType(o,d),a.endMapType(o)}}i.MapType=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsSequenceType(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsSequenceType(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}elemType(o){let s=this.bb.__offset(this.bb_pos,4);return s?(o||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startSequenceType(o){o.startObject(1)}static addElemType(o,s){o.addFieldOffset(0,s,0)}static endSequenceType(o){return o.endObject()}static createSequenceType(o,s){return a.startSequenceType(o),a.addElemType(o,s),a.endSequenceType(o)}}i.SequenceType=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}nodeIndex(){return this.bb.readUint32(this.bb_pos)}srcArgIndex(){return this.bb.readInt32(this.bb_pos+4)}dstArgIndex(){return this.bb.readInt32(this.bb_pos+8)}static createEdgeEnd(o,s,d,c){return o.prep(4,12),o.writeInt32(c),o.writeInt32(d),o.writeInt32(s),o.offset()}}i.EdgeEnd=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsNodeEdge(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsNodeEdge(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}nodeIndex(){let o=this.bb.__offset(this.bb_pos,4);return o?this.bb.readUint32(this.bb_pos+o):0}inputEdges(o,s){let d=this.bb.__offset(this.bb_pos,6);return d?(s||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+d)+o*12,this.bb):null}inputEdgesLength(){let o=this.bb.__offset(this.bb_pos,6);return o?this.bb.__vector_len(this.bb_pos+o):0}outputEdges(o,s){let d=this.bb.__offset(this.bb_pos,8);return d?(s||new e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos+d)+o*12,this.bb):null}outputEdgesLength(){let o=this.bb.__offset(this.bb_pos,8);return o?this.bb.__vector_len(this.bb_pos+o):0}static startNodeEdge(o){o.startObject(3)}static addNodeIndex(o,s){o.addFieldInt32(0,s,0)}static addInputEdges(o,s){o.addFieldOffset(1,s,0)}static startInputEdgesVector(o,s){o.startVector(12,s,4)}static addOutputEdges(o,s){o.addFieldOffset(2,s,0)}static startOutputEdgesVector(o,s){o.startVector(12,s,4)}static endNodeEdge(o){return o.endObject()}static createNodeEdge(o,s,d,c){return a.startNodeEdge(o),a.addNodeIndex(o,s),a.addInputEdges(o,d),a.addOutputEdges(o,c),a.endNodeEdge(o)}}i.NodeEdge=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsNode(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsNode(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}name(o){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,o):null}docString(o){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,o):null}domain(o){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,o):null}sinceVersion(){let o=this.bb.__offset(this.bb_pos,10);return o?this.bb.readInt32(this.bb_pos+o):0}index(){let o=this.bb.__offset(this.bb_pos,12);return o?this.bb.readUint32(this.bb_pos+o):0}opType(o){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb_pos+s,o):null}type(){let o=this.bb.__offset(this.bb_pos,16);return o?this.bb.readInt32(this.bb_pos+o):0}executionProviderType(o){let s=this.bb.__offset(this.bb_pos,18);return s?this.bb.__string(this.bb_pos+s,o):null}inputs(o,s){let d=this.bb.__offset(this.bb_pos,20);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+o*4,s):null}inputsLength(){let o=this.bb.__offset(this.bb_pos,20);return o?this.bb.__vector_len(this.bb_pos+o):0}outputs(o,s){let d=this.bb.__offset(this.bb_pos,22);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+o*4,s):null}outputsLength(){let o=this.bb.__offset(this.bb_pos,22);return o?this.bb.__vector_len(this.bb_pos+o):0}attributes(o,s){let d=this.bb.__offset(this.bb_pos,24);return d?(s||new e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}attributesLength(){let o=this.bb.__offset(this.bb_pos,24);return o?this.bb.__vector_len(this.bb_pos+o):0}inputArgCounts(o){let s=this.bb.__offset(this.bb_pos,26);return s?this.bb.readInt32(this.bb.__vector(this.bb_pos+s)+o*4):0}inputArgCountsLength(){let o=this.bb.__offset(this.bb_pos,26);return o?this.bb.__vector_len(this.bb_pos+o):0}inputArgCountsArray(){let o=this.bb.__offset(this.bb_pos,26);return o?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+o),this.bb.__vector_len(this.bb_pos+o)):null}implicitInputs(o,s){let d=this.bb.__offset(this.bb_pos,28);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+o*4,s):null}implicitInputsLength(){let o=this.bb.__offset(this.bb_pos,28);return o?this.bb.__vector_len(this.bb_pos+o):0}static startNode(o){o.startObject(13)}static addName(o,s){o.addFieldOffset(0,s,0)}static addDocString(o,s){o.addFieldOffset(1,s,0)}static addDomain(o,s){o.addFieldOffset(2,s,0)}static addSinceVersion(o,s){o.addFieldInt32(3,s,0)}static addIndex(o,s){o.addFieldInt32(4,s,0)}static addOpType(o,s){o.addFieldOffset(5,s,0)}static addType(o,s){o.addFieldInt32(6,s,0)}static addExecutionProviderType(o,s){o.addFieldOffset(7,s,0)}static addInputs(o,s){o.addFieldOffset(8,s,0)}static createInputsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startInputsVector(o,s){o.startVector(4,s,4)}static addOutputs(o,s){o.addFieldOffset(9,s,0)}static createOutputsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startOutputsVector(o,s){o.startVector(4,s,4)}static addAttributes(o,s){o.addFieldOffset(10,s,0)}static createAttributesVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startAttributesVector(o,s){o.startVector(4,s,4)}static addInputArgCounts(o,s){o.addFieldOffset(11,s,0)}static createInputArgCountsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addInt32(s[d]);return o.endVector()}static startInputArgCountsVector(o,s){o.startVector(4,s,4)}static addImplicitInputs(o,s){o.addFieldOffset(12,s,0)}static createImplicitInputsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startImplicitInputsVector(o,s){o.startVector(4,s,4)}static endNode(o){return o.endObject()}static createNode(o,s,d,c,r,u,l,h,f,m,y,_,I,x){return a.startNode(o),a.addName(o,s),a.addDocString(o,d),a.addDomain(o,c),a.addSinceVersion(o,r),a.addIndex(o,u),a.addOpType(o,l),a.addType(o,h),a.addExecutionProviderType(o,f),a.addInputs(o,m),a.addOutputs(o,y),a.addAttributes(o,_),a.addInputArgCounts(o,I),a.addImplicitInputs(o,x),a.endNode(o)}}i.Node=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsValueInfo(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsValueInfo(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}name(o){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,o):null}docString(o){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,o):null}type(o){let s=this.bb.__offset(this.bb_pos,8);return s?(o||new e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startValueInfo(o){o.startObject(3)}static addName(o,s){o.addFieldOffset(0,s,0)}static addDocString(o,s){o.addFieldOffset(1,s,0)}static addType(o,s){o.addFieldOffset(2,s,0)}static endValueInfo(o){return o.endObject()}static createValueInfo(o,s,d,c){return a.startValueInfo(o),a.addName(o,s),a.addDocString(o,d),a.addType(o,c),a.endValueInfo(o)}}i.ValueInfo=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsTypeInfo(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsTypeInfo(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}denotation(o){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,o):null}valueType(){let o=this.bb.__offset(this.bb_pos,6);return o?this.bb.readUint8(this.bb_pos+o):0}value(o){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__union(o,this.bb_pos+s):null}static startTypeInfo(o){o.startObject(3)}static addDenotation(o,s){o.addFieldOffset(0,s,0)}static addValueType(o,s){o.addFieldInt8(1,s,0)}static addValue(o,s){o.addFieldOffset(2,s,0)}static endTypeInfo(o){return o.endObject()}static createTypeInfo(o,s,d,c){return a.startTypeInfo(o),a.addDenotation(o,s),a.addValueType(o,d),a.addValue(o,c),a.endTypeInfo(o)}}i.TypeInfo=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsOperatorSetId(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsOperatorSetId(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}domain(o){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,o):null}version(){let o=this.bb.__offset(this.bb_pos,6);return o?this.bb.readInt64(this.bb_pos+o):this.bb.createLong(0,0)}static startOperatorSetId(o){o.startObject(2)}static addDomain(o,s){o.addFieldOffset(0,s,0)}static addVersion(o,s){o.addFieldInt64(1,s,o.createLong(0,0))}static endOperatorSetId(o){return o.endObject()}static createOperatorSetId(o,s,d){return a.startOperatorSetId(o),a.addDomain(o,s),a.addVersion(o,d),a.endOperatorSetId(o)}}i.OperatorSetId=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsTensor(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsTensor(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}name(o){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,o):null}docString(o){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,o):null}dims(o){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+o*8):this.bb.createLong(0,0)}dimsLength(){let o=this.bb.__offset(this.bb_pos,8);return o?this.bb.__vector_len(this.bb_pos+o):0}dataType(){let o=this.bb.__offset(this.bb_pos,10);return o?this.bb.readInt32(this.bb_pos+o):0}rawData(o){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.readUint8(this.bb.__vector(this.bb_pos+s)+o):0}rawDataLength(){let o=this.bb.__offset(this.bb_pos,12);return o?this.bb.__vector_len(this.bb_pos+o):0}rawDataArray(){let o=this.bb.__offset(this.bb_pos,12);return o?new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+o),this.bb.__vector_len(this.bb_pos+o)):null}stringData(o,s){let d=this.bb.__offset(this.bb_pos,14);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+o*4,s):null}stringDataLength(){let o=this.bb.__offset(this.bb_pos,14);return o?this.bb.__vector_len(this.bb_pos+o):0}static startTensor(o){o.startObject(6)}static addName(o,s){o.addFieldOffset(0,s,0)}static addDocString(o,s){o.addFieldOffset(1,s,0)}static addDims(o,s){o.addFieldOffset(2,s,0)}static createDimsVector(o,s){o.startVector(8,s.length,8);for(let d=s.length-1;d>=0;d--)o.addInt64(s[d]);return o.endVector()}static startDimsVector(o,s){o.startVector(8,s,8)}static addDataType(o,s){o.addFieldInt32(3,s,0)}static addRawData(o,s){o.addFieldOffset(4,s,0)}static createRawDataVector(o,s){o.startVector(1,s.length,1);for(let d=s.length-1;d>=0;d--)o.addInt8(s[d]);return o.endVector()}static startRawDataVector(o,s){o.startVector(1,s,1)}static addStringData(o,s){o.addFieldOffset(5,s,0)}static createStringDataVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startStringDataVector(o,s){o.startVector(4,s,4)}static endTensor(o){return o.endObject()}static createTensor(o,s,d,c,r,u,l){return a.startTensor(o),a.addName(o,s),a.addDocString(o,d),a.addDims(o,c),a.addDataType(o,r),a.addRawData(o,u),a.addStringData(o,l),a.endTensor(o)}}i.Tensor=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsSparseTensor(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsSparseTensor(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}values(o){let s=this.bb.__offset(this.bb_pos,4);return s?(o||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}indices(o){let s=this.bb.__offset(this.bb_pos,6);return s?(o||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}dims(o){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+o*8):this.bb.createLong(0,0)}dimsLength(){let o=this.bb.__offset(this.bb_pos,8);return o?this.bb.__vector_len(this.bb_pos+o):0}static startSparseTensor(o){o.startObject(3)}static addValues(o,s){o.addFieldOffset(0,s,0)}static addIndices(o,s){o.addFieldOffset(1,s,0)}static addDims(o,s){o.addFieldOffset(2,s,0)}static createDimsVector(o,s){o.startVector(8,s.length,8);for(let d=s.length-1;d>=0;d--)o.addInt64(s[d]);return o.endVector()}static startDimsVector(o,s){o.startVector(8,s,8)}static endSparseTensor(o){return o.endObject()}static createSparseTensor(o,s,d,c){return a.startSparseTensor(o),a.addValues(o,s),a.addIndices(o,d),a.addDims(o,c),a.endSparseTensor(o)}}i.SparseTensor=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsAttribute(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsAttribute(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}name(o){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,o):null}docString(o){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.__string(this.bb_pos+s,o):null}type(){let o=this.bb.__offset(this.bb_pos,8);return o?this.bb.readInt32(this.bb_pos+o):0}f(){let o=this.bb.__offset(this.bb_pos,10);return o?this.bb.readFloat32(this.bb_pos+o):0}i(){let o=this.bb.__offset(this.bb_pos,12);return o?this.bb.readInt64(this.bb_pos+o):this.bb.createLong(0,0)}s(o){let s=this.bb.__offset(this.bb_pos,14);return s?this.bb.__string(this.bb_pos+s,o):null}t(o){let s=this.bb.__offset(this.bb_pos,16);return s?(o||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}g(o){let s=this.bb.__offset(this.bb_pos,18);return s?(o||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}floats(o){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.readFloat32(this.bb.__vector(this.bb_pos+s)+o*4):0}floatsLength(){let o=this.bb.__offset(this.bb_pos,20);return o?this.bb.__vector_len(this.bb_pos+o):0}floatsArray(){let o=this.bb.__offset(this.bb_pos,20);return o?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+o),this.bb.__vector_len(this.bb_pos+o)):null}ints(o){let s=this.bb.__offset(this.bb_pos,22);return s?this.bb.readInt64(this.bb.__vector(this.bb_pos+s)+o*8):this.bb.createLong(0,0)}intsLength(){let o=this.bb.__offset(this.bb_pos,22);return o?this.bb.__vector_len(this.bb_pos+o):0}strings(o,s){let d=this.bb.__offset(this.bb_pos,24);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+o*4,s):null}stringsLength(){let o=this.bb.__offset(this.bb_pos,24);return o?this.bb.__vector_len(this.bb_pos+o):0}tensors(o,s){let d=this.bb.__offset(this.bb_pos,26);return d?(s||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}tensorsLength(){let o=this.bb.__offset(this.bb_pos,26);return o?this.bb.__vector_len(this.bb_pos+o):0}graphs(o,s){let d=this.bb.__offset(this.bb_pos,28);return d?(s||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}graphsLength(){let o=this.bb.__offset(this.bb_pos,28);return o?this.bb.__vector_len(this.bb_pos+o):0}static startAttribute(o){o.startObject(13)}static addName(o,s){o.addFieldOffset(0,s,0)}static addDocString(o,s){o.addFieldOffset(1,s,0)}static addType(o,s){o.addFieldInt32(2,s,0)}static addF(o,s){o.addFieldFloat32(3,s,0)}static addI(o,s){o.addFieldInt64(4,s,o.createLong(0,0))}static addS(o,s){o.addFieldOffset(5,s,0)}static addT(o,s){o.addFieldOffset(6,s,0)}static addG(o,s){o.addFieldOffset(7,s,0)}static addFloats(o,s){o.addFieldOffset(8,s,0)}static createFloatsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addFloat32(s[d]);return o.endVector()}static startFloatsVector(o,s){o.startVector(4,s,4)}static addInts(o,s){o.addFieldOffset(9,s,0)}static createIntsVector(o,s){o.startVector(8,s.length,8);for(let d=s.length-1;d>=0;d--)o.addInt64(s[d]);return o.endVector()}static startIntsVector(o,s){o.startVector(8,s,8)}static addStrings(o,s){o.addFieldOffset(10,s,0)}static createStringsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startStringsVector(o,s){o.startVector(4,s,4)}static addTensors(o,s){o.addFieldOffset(11,s,0)}static createTensorsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startTensorsVector(o,s){o.startVector(4,s,4)}static addGraphs(o,s){o.addFieldOffset(12,s,0)}static createGraphsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startGraphsVector(o,s){o.startVector(4,s,4)}static endAttribute(o){return o.endObject()}static createAttribute(o,s,d,c,r,u,l,h,f,m,y,_,I,x){return a.startAttribute(o),a.addName(o,s),a.addDocString(o,d),a.addType(o,c),a.addF(o,r),a.addI(o,u),a.addS(o,l),a.addT(o,h),a.addG(o,f),a.addFloats(o,m),a.addInts(o,y),a.addStrings(o,_),a.addTensors(o,I),a.addGraphs(o,x),a.endAttribute(o)}}i.Attribute=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsGraph(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsGraph(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}initializers(o,s){let d=this.bb.__offset(this.bb_pos,4);return d?(s||new e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}initializersLength(){let o=this.bb.__offset(this.bb_pos,4);return o?this.bb.__vector_len(this.bb_pos+o):0}nodeArgs(o,s){let d=this.bb.__offset(this.bb_pos,6);return d?(s||new e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}nodeArgsLength(){let o=this.bb.__offset(this.bb_pos,6);return o?this.bb.__vector_len(this.bb_pos+o):0}nodes(o,s){let d=this.bb.__offset(this.bb_pos,8);return d?(s||new e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}nodesLength(){let o=this.bb.__offset(this.bb_pos,8);return o?this.bb.__vector_len(this.bb_pos+o):0}maxNodeIndex(){let o=this.bb.__offset(this.bb_pos,10);return o?this.bb.readUint32(this.bb_pos+o):0}nodeEdges(o,s){let d=this.bb.__offset(this.bb_pos,12);return d?(s||new e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}nodeEdgesLength(){let o=this.bb.__offset(this.bb_pos,12);return o?this.bb.__vector_len(this.bb_pos+o):0}inputs(o,s){let d=this.bb.__offset(this.bb_pos,14);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+o*4,s):null}inputsLength(){let o=this.bb.__offset(this.bb_pos,14);return o?this.bb.__vector_len(this.bb_pos+o):0}outputs(o,s){let d=this.bb.__offset(this.bb_pos,16);return d?this.bb.__string(this.bb.__vector(this.bb_pos+d)+o*4,s):null}outputsLength(){let o=this.bb.__offset(this.bb_pos,16);return o?this.bb.__vector_len(this.bb_pos+o):0}sparseInitializers(o,s){let d=this.bb.__offset(this.bb_pos,18);return d?(s||new e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}sparseInitializersLength(){let o=this.bb.__offset(this.bb_pos,18);return o?this.bb.__vector_len(this.bb_pos+o):0}static startGraph(o){o.startObject(8)}static addInitializers(o,s){o.addFieldOffset(0,s,0)}static createInitializersVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startInitializersVector(o,s){o.startVector(4,s,4)}static addNodeArgs(o,s){o.addFieldOffset(1,s,0)}static createNodeArgsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startNodeArgsVector(o,s){o.startVector(4,s,4)}static addNodes(o,s){o.addFieldOffset(2,s,0)}static createNodesVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startNodesVector(o,s){o.startVector(4,s,4)}static addMaxNodeIndex(o,s){o.addFieldInt32(3,s,0)}static addNodeEdges(o,s){o.addFieldOffset(4,s,0)}static createNodeEdgesVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startNodeEdgesVector(o,s){o.startVector(4,s,4)}static addInputs(o,s){o.addFieldOffset(5,s,0)}static createInputsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startInputsVector(o,s){o.startVector(4,s,4)}static addOutputs(o,s){o.addFieldOffset(6,s,0)}static createOutputsVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startOutputsVector(o,s){o.startVector(4,s,4)}static addSparseInitializers(o,s){o.addFieldOffset(7,s,0)}static createSparseInitializersVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startSparseInitializersVector(o,s){o.startVector(4,s,4)}static endGraph(o){return o.endObject()}static createGraph(o,s,d,c,r,u,l,h,f){return a.startGraph(o),a.addInitializers(o,s),a.addNodeArgs(o,d),a.addNodes(o,c),a.addMaxNodeIndex(o,r),a.addNodeEdges(o,u),a.addInputs(o,l),a.addOutputs(o,h),a.addSparseInitializers(o,f),a.endGraph(o)}}i.Graph=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsModel(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsModel(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}irVersion(){let o=this.bb.__offset(this.bb_pos,4);return o?this.bb.readInt64(this.bb_pos+o):this.bb.createLong(0,0)}opsetImport(o,s){let d=this.bb.__offset(this.bb_pos,6);return d?(s||new e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}opsetImportLength(){let o=this.bb.__offset(this.bb_pos,6);return o?this.bb.__vector_len(this.bb_pos+o):0}producerName(o){let s=this.bb.__offset(this.bb_pos,8);return s?this.bb.__string(this.bb_pos+s,o):null}producerVersion(o){let s=this.bb.__offset(this.bb_pos,10);return s?this.bb.__string(this.bb_pos+s,o):null}domain(o){let s=this.bb.__offset(this.bb_pos,12);return s?this.bb.__string(this.bb_pos+s,o):null}modelVersion(){let o=this.bb.__offset(this.bb_pos,14);return o?this.bb.readInt64(this.bb_pos+o):this.bb.createLong(0,0)}docString(o){let s=this.bb.__offset(this.bb_pos,16);return s?this.bb.__string(this.bb_pos+s,o):null}graph(o){let s=this.bb.__offset(this.bb_pos,18);return s?(o||new e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}graphDocString(o){let s=this.bb.__offset(this.bb_pos,20);return s?this.bb.__string(this.bb_pos+s,o):null}static startModel(o){o.startObject(9)}static addIrVersion(o,s){o.addFieldInt64(0,s,o.createLong(0,0))}static addOpsetImport(o,s){o.addFieldOffset(1,s,0)}static createOpsetImportVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startOpsetImportVector(o,s){o.startVector(4,s,4)}static addProducerName(o,s){o.addFieldOffset(2,s,0)}static addProducerVersion(o,s){o.addFieldOffset(3,s,0)}static addDomain(o,s){o.addFieldOffset(4,s,0)}static addModelVersion(o,s){o.addFieldInt64(5,s,o.createLong(0,0))}static addDocString(o,s){o.addFieldOffset(6,s,0)}static addGraph(o,s){o.addFieldOffset(7,s,0)}static addGraphDocString(o,s){o.addFieldOffset(8,s,0)}static endModel(o){return o.endObject()}static createModel(o,s,d,c,r,u,l,h,f,m){return a.startModel(o),a.addIrVersion(o,s),a.addOpsetImport(o,d),a.addProducerName(o,c),a.addProducerVersion(o,r),a.addDomain(o,u),a.addModelVersion(o,l),a.addDocString(o,h),a.addGraph(o,f),a.addGraphDocString(o,m),a.endModel(o)}}i.Model=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsKernelCreateInfos(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsKernelCreateInfos(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}nodeIndices(o){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.readUint32(this.bb.__vector(this.bb_pos+s)+o*4):0}nodeIndicesLength(){let o=this.bb.__offset(this.bb_pos,4);return o?this.bb.__vector_len(this.bb_pos+o):0}nodeIndicesArray(){let o=this.bb.__offset(this.bb_pos,4);return o?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+o),this.bb.__vector_len(this.bb_pos+o)):null}kernelDefHashes(o){let s=this.bb.__offset(this.bb_pos,6);return s?this.bb.readUint64(this.bb.__vector(this.bb_pos+s)+o*8):this.bb.createLong(0,0)}kernelDefHashesLength(){let o=this.bb.__offset(this.bb_pos,6);return o?this.bb.__vector_len(this.bb_pos+o):0}static startKernelCreateInfos(o){o.startObject(2)}static addNodeIndices(o,s){o.addFieldOffset(0,s,0)}static createNodeIndicesVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addInt32(s[d]);return o.endVector()}static startNodeIndicesVector(o,s){o.startVector(4,s,4)}static addKernelDefHashes(o,s){o.addFieldOffset(1,s,0)}static createKernelDefHashesVector(o,s){o.startVector(8,s.length,8);for(let d=s.length-1;d>=0;d--)o.addInt64(s[d]);return o.endVector()}static startKernelDefHashesVector(o,s){o.startVector(8,s,8)}static endKernelCreateInfos(o){return o.endObject()}static createKernelCreateInfos(o,s,d){return a.startKernelCreateInfos(o),a.addNodeIndices(o,s),a.addKernelDefHashes(o,d),a.endKernelCreateInfos(o)}}i.KernelCreateInfos=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsSubGraphSessionState(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsSubGraphSessionState(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}graphId(o){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,o):null}sessionState(o){let s=this.bb.__offset(this.bb_pos,6);return s?(o||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startSubGraphSessionState(o){o.startObject(2)}static addGraphId(o,s){o.addFieldOffset(0,s,0)}static addSessionState(o,s){o.addFieldOffset(1,s,0)}static endSubGraphSessionState(o){let s=o.endObject();return o.requiredField(s,4),s}static createSubGraphSessionState(o,s,d){return a.startSubGraphSessionState(o),a.addGraphId(o,s),a.addSessionState(o,d),a.endSubGraphSessionState(o)}}i.SubGraphSessionState=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsSessionState(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsSessionState(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}kernels(o){let s=this.bb.__offset(this.bb_pos,4);return s?(o||new e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}subGraphSessionStates(o,s){let d=this.bb.__offset(this.bb_pos,6);return d?(s||new e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+d)+o*4),this.bb):null}subGraphSessionStatesLength(){let o=this.bb.__offset(this.bb_pos,6);return o?this.bb.__vector_len(this.bb_pos+o):0}static startSessionState(o){o.startObject(2)}static addKernels(o,s){o.addFieldOffset(0,s,0)}static addSubGraphSessionStates(o,s){o.addFieldOffset(1,s,0)}static createSubGraphSessionStatesVector(o,s){o.startVector(4,s.length,4);for(let d=s.length-1;d>=0;d--)o.addOffset(s[d]);return o.endVector()}static startSubGraphSessionStatesVector(o,s){o.startVector(4,s,4)}static endSessionState(o){return o.endObject()}static createSessionState(o,s,d){return a.startSessionState(o),a.addKernels(o,s),a.addSubGraphSessionStates(o,d),a.endSessionState(o)}}i.SessionState=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={})),(e=>{(n=>{(i=>{class a{constructor(){this.bb=null,this.bb_pos=0}__init(o,s){return this.bb_pos=o,this.bb=s,this}static getRootAsInferenceSession(o,s){return(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static getSizePrefixedRootAsInferenceSession(o,s){return o.setPosition(o.position()+w.SIZE_PREFIX_LENGTH),(s||new a).__init(o.readInt32(o.position())+o.position(),o)}static bufferHasIdentifier(o){return o.__has_identifier("ORTM")}ortVersion(o){let s=this.bb.__offset(this.bb_pos,4);return s?this.bb.__string(this.bb_pos+s,o):null}model(o){let s=this.bb.__offset(this.bb_pos,6);return s?(o||new e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}sessionState(o){let s=this.bb.__offset(this.bb_pos,8);return s?(o||new e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos+s),this.bb):null}static startInferenceSession(o){o.startObject(3)}static addOrtVersion(o,s){o.addFieldOffset(0,s,0)}static addModel(o,s){o.addFieldOffset(1,s,0)}static addSessionState(o,s){o.addFieldOffset(2,s,0)}static endInferenceSession(o){return o.endObject()}static finishInferenceSessionBuffer(o,s){o.finish(s,"ORTM")}static finishSizePrefixedInferenceSessionBuffer(o,s){o.finish(s,"ORTM",!0)}static createInferenceSession(o,s,d,c){return a.startInferenceSession(o),a.addOrtVersion(o,s),a.addModel(o,d),a.addSessionState(o,c),a.endInferenceSession(o)}}i.InferenceSession=a})(n.fbs||(n.fbs={}))})(e.experimental||(e.experimental={}))})(F||(F={}))}),js=mt((e,n)=>{n.exports=i;function i(a,p){for(var o=new Array(arguments.length-1),s=0,d=2,c=!0;d<arguments.length;)o[s++]=arguments[d++];return new Promise(function(r,u){o[s]=function(l){if(c)if(c=!1,l)u(l);else{for(var h=new Array(arguments.length-1),f=0;f<h.length;)h[f++]=arguments[f];r.apply(null,h)}};try{a.apply(p||null,o)}catch(l){c&&(c=!1,u(l))}})}}),Ys=mt(e=>{var n=e;n.length=function(s){var d=s.length;if(!d)return 0;for(var c=0;--d%4>1&&s.charAt(d)==="=";)++c;return Math.ceil(s.length*3)/4-c};var i=new Array(64),a=new Array(123);for(p=0;p<64;)a[i[p]=p<26?p+65:p<52?p+71:p<62?p-4:p-59|43]=p++;var p;n.encode=function(s,d,c){for(var r=null,u=[],l=0,h=0,f;d<c;){var m=s[d++];switch(h){case 0:u[l++]=i[m>>2],f=(m&3)<<4,h=1;break;case 1:u[l++]=i[f|m>>4],f=(m&15)<<2,h=2;break;case 2:u[l++]=i[f|m>>6],u[l++]=i[m&63],h=0;break}l>8191&&((r||(r=[])).push(String.fromCharCode.apply(String,u)),l=0)}return h&&(u[l++]=i[f],u[l++]=61,h===1&&(u[l++]=61)),r?(l&&r.push(String.fromCharCode.apply(String,u.slice(0,l))),r.join("")):String.fromCharCode.apply(String,u.slice(0,l))};var o="invalid encoding";n.decode=function(s,d,c){for(var r=c,u=0,l,h=0;h<s.length;){var f=s.charCodeAt(h++);if(f===61&&u>1)break;if((f=a[f])===void 0)throw Error(o);switch(u){case 0:l=f,u=1;break;case 1:d[c++]=l<<2|(f&48)>>4,l=f,u=2;break;case 2:d[c++]=(l&15)<<4|(f&60)>>2,l=f,u=3;break;case 3:d[c++]=(l&3)<<6|f,u=0;break}}if(u===1)throw Error(o);return c-r},n.test=function(s){return/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(s)}}),Qs=mt((e,n)=>{n.exports=i;function i(){this._listeners={}}i.prototype.on=function(a,p,o){return(this._listeners[a]||(this._listeners[a]=[])).push({fn:p,ctx:o||this}),this},i.prototype.off=function(a,p){if(a===void 0)this._listeners={};else if(p===void 0)this._listeners[a]=[];else for(var o=this._listeners[a],s=0;s<o.length;)o[s].fn===p?o.splice(s,1):++s;return this},i.prototype.emit=function(a){var p=this._listeners[a];if(p){for(var o=[],s=1;s<arguments.length;)o.push(arguments[s++]);for(s=0;s<p.length;)p[s].fn.apply(p[s++].ctx,o)}return this}}),au=mt((e,n)=>{n.exports=i(i);function i(d){return typeof Float32Array<"u"?function(){var c=new Float32Array([-0]),r=new Uint8Array(c.buffer),u=r[3]===128;function l(y,_,I){c[0]=y,_[I]=r[0],_[I+1]=r[1],_[I+2]=r[2],_[I+3]=r[3]}function h(y,_,I){c[0]=y,_[I]=r[3],_[I+1]=r[2],_[I+2]=r[1],_[I+3]=r[0]}d.writeFloatLE=u?l:h,d.writeFloatBE=u?h:l;function f(y,_){return r[0]=y[_],r[1]=y[_+1],r[2]=y[_+2],r[3]=y[_+3],c[0]}function m(y,_){return r[3]=y[_],r[2]=y[_+1],r[1]=y[_+2],r[0]=y[_+3],c[0]}d.readFloatLE=u?f:m,d.readFloatBE=u?m:f}():function(){function c(u,l,h,f){var m=l<0?1:0;if(m&&(l=-l),l===0)u(1/l>0?0:2147483648,h,f);else if(isNaN(l))u(2143289344,h,f);else if(l>34028234663852886e22)u((m<<31|2139095040)>>>0,h,f);else if(l<11754943508222875e-54)u((m<<31|Math.round(l/1401298464324817e-60))>>>0,h,f);else{var y=Math.floor(Math.log(l)/Math.LN2),_=Math.round(l*Math.pow(2,-y)*8388608)&8388607;u((m<<31|y+127<<23|_)>>>0,h,f)}}d.writeFloatLE=c.bind(null,a),d.writeFloatBE=c.bind(null,p);function r(u,l,h){var f=u(l,h),m=(f>>31)*2+1,y=f>>>23&255,_=f&8388607;return y===255?_?NaN:m*(1/0):y===0?m*1401298464324817e-60*_:m*Math.pow(2,y-150)*(_+8388608)}d.readFloatLE=r.bind(null,o),d.readFloatBE=r.bind(null,s)}(),typeof Float64Array<"u"?function(){var c=new Float64Array([-0]),r=new Uint8Array(c.buffer),u=r[7]===128;function l(y,_,I){c[0]=y,_[I]=r[0],_[I+1]=r[1],_[I+2]=r[2],_[I+3]=r[3],_[I+4]=r[4],_[I+5]=r[5],_[I+6]=r[6],_[I+7]=r[7]}function h(y,_,I){c[0]=y,_[I]=r[7],_[I+1]=r[6],_[I+2]=r[5],_[I+3]=r[4],_[I+4]=r[3],_[I+5]=r[2],_[I+6]=r[1],_[I+7]=r[0]}d.writeDoubleLE=u?l:h,d.writeDoubleBE=u?h:l;function f(y,_){return r[0]=y[_],r[1]=y[_+1],r[2]=y[_+2],r[3]=y[_+3],r[4]=y[_+4],r[5]=y[_+5],r[6]=y[_+6],r[7]=y[_+7],c[0]}function m(y,_){return r[7]=y[_],r[6]=y[_+1],r[5]=y[_+2],r[4]=y[_+3],r[3]=y[_+4],r[2]=y[_+5],r[1]=y[_+6],r[0]=y[_+7],c[0]}d.readDoubleLE=u?f:m,d.readDoubleBE=u?m:f}():function(){function c(u,l,h,f,m,y){var _=f<0?1:0;if(_&&(f=-f),f===0)u(0,m,y+l),u(1/f>0?0:2147483648,m,y+h);else if(isNaN(f))u(0,m,y+l),u(2146959360,m,y+h);else if(f>17976931348623157e292)u(0,m,y+l),u((_<<31|2146435072)>>>0,m,y+h);else{var I;if(f<22250738585072014e-324)I=f/5e-324,u(I>>>0,m,y+l),u((_<<31|I/4294967296)>>>0,m,y+h);else{var x=Math.floor(Math.log(f)/Math.LN2);x===1024&&(x=1023),I=f*Math.pow(2,-x),u(I*4503599627370496>>>0,m,y+l),u((_<<31|x+1023<<20|I*1048576&1048575)>>>0,m,y+h)}}}d.writeDoubleLE=c.bind(null,a,0,4),d.writeDoubleBE=c.bind(null,p,4,0);function r(u,l,h,f,m){var y=u(f,m+l),_=u(f,m+h),I=(_>>31)*2+1,x=_>>>20&2047,P=4294967296*(_&1048575)+y;return x===2047?P?NaN:I*(1/0):x===0?I*5e-324*P:I*Math.pow(2,x-1075)*(P+4503599627370496)}d.readDoubleLE=r.bind(null,o,0,4),d.readDoubleBE=r.bind(null,s,4,0)}(),d}function a(d,c,r){c[r]=d&255,c[r+1]=d>>>8&255,c[r+2]=d>>>16&255,c[r+3]=d>>>24}function p(d,c,r){c[r]=d>>>24,c[r+1]=d>>>16&255,c[r+2]=d>>>8&255,c[r+3]=d&255}function o(d,c){return(d[c]|d[c+1]<<8|d[c+2]<<16|d[c+3]<<24)>>>0}function s(d,c){return(d[c]<<24|d[c+1]<<16|d[c+2]<<8|d[c+3])>>>0}}),su=mt((exports,module)=>{module.exports=inquire;function inquire(moduleName){try{var mod=eval("quire".replace(/^/,"re"))(moduleName);if(mod&&(mod.length||Object.keys(mod).length))return mod}catch(e){}return null}}),lu=mt(e=>{var n=e;n.length=function(i){for(var a=0,p=0,o=0;o<i.length;++o)p=i.charCodeAt(o),p<128?a+=1:p<2048?a+=2:(p&64512)===55296&&(i.charCodeAt(o+1)&64512)===56320?(++o,a+=4):a+=3;return a},n.read=function(i,a,p){var o=p-a;if(o<1)return"";for(var s=null,d=[],c=0,r;a<p;)r=i[a++],r<128?d[c++]=r:r>191&&r<224?d[c++]=(r&31)<<6|i[a++]&63:r>239&&r<365?(r=((r&7)<<18|(i[a++]&63)<<12|(i[a++]&63)<<6|i[a++]&63)-65536,d[c++]=55296+(r>>10),d[c++]=56320+(r&1023)):d[c++]=(r&15)<<12|(i[a++]&63)<<6|i[a++]&63,c>8191&&((s||(s=[])).push(String.fromCharCode.apply(String,d)),c=0);return s?(c&&s.push(String.fromCharCode.apply(String,d.slice(0,c))),s.join("")):String.fromCharCode.apply(String,d.slice(0,c))},n.write=function(i,a,p){for(var o=p,s,d,c=0;c<i.length;++c)s=i.charCodeAt(c),s<128?a[p++]=s:s<2048?(a[p++]=s>>6|192,a[p++]=s&63|128):(s&64512)===55296&&((d=i.charCodeAt(c+1))&64512)===56320?(s=65536+((s&1023)<<10)+(d&1023),++c,a[p++]=s>>18|240,a[p++]=s>>12&63|128,a[p++]=s>>6&63|128,a[p++]=s&63|128):(a[p++]=s>>12|224,a[p++]=s>>6&63|128,a[p++]=s&63|128);return p-o}}),cu=mt((e,n)=>{n.exports=i;function i(a,p,o){var s=o||8192,d=s>>>1,c=null,r=s;return function(u){if(u<1||u>d)return a(u);r+u>s&&(c=a(s),r=0);var l=p.call(c,r,r+=u);return r&7&&(r=(r|7)+1),l}}}),du=mt((e,n)=>{n.exports=a;var i=Se();function a(d,c){this.lo=d>>>0,this.hi=c>>>0}var p=a.zero=new a(0,0);p.toNumber=function(){return 0},p.zzEncode=p.zzDecode=function(){return this},p.length=function(){return 1};var o=a.zeroHash="\0\0\0\0\0\0\0\0";a.fromNumber=function(d){if(d===0)return p;var c=d<0;c&&(d=-d);var r=d>>>0,u=(d-r)/4294967296>>>0;return c&&(u=~u>>>0,r=~r>>>0,++r>4294967295&&(r=0,++u>4294967295&&(u=0))),new a(r,u)},a.from=function(d){if(typeof d=="number")return a.fromNumber(d);if(i.isString(d))if(i.Long)d=i.Long.fromString(d);else return a.fromNumber(parseInt(d,10));return d.low||d.high?new a(d.low>>>0,d.high>>>0):p},a.prototype.toNumber=function(d){if(!d&&this.hi>>>31){var c=~this.lo+1>>>0,r=~this.hi>>>0;return c||(r=r+1>>>0),-(c+r*4294967296)}return this.lo+this.hi*4294967296},a.prototype.toLong=function(d){return i.Long?new i.Long(this.lo|0,this.hi|0,!!d):{low:this.lo|0,high:this.hi|0,unsigned:!!d}};var s=String.prototype.charCodeAt;a.fromHash=function(d){return d===o?p:new a((s.call(d,0)|s.call(d,1)<<8|s.call(d,2)<<16|s.call(d,3)<<24)>>>0,(s.call(d,4)|s.call(d,5)<<8|s.call(d,6)<<16|s.call(d,7)<<24)>>>0)},a.prototype.toHash=function(){return String.fromCharCode(this.lo&255,this.lo>>>8&255,this.lo>>>16&255,this.lo>>>24,this.hi&255,this.hi>>>8&255,this.hi>>>16&255,this.hi>>>24)},a.prototype.zzEncode=function(){var d=this.hi>>31;return this.hi=((this.hi<<1|this.lo>>>31)^d)>>>0,this.lo=(this.lo<<1^d)>>>0,this},a.prototype.zzDecode=function(){var d=-(this.lo&1);return this.lo=((this.lo>>>1|this.hi<<31)^d)>>>0,this.hi=(this.hi>>>1^d)>>>0,this},a.prototype.length=function(){var d=this.lo,c=(this.lo>>>28|this.hi<<4)>>>0,r=this.hi>>>24;return r===0?c===0?d<16384?d<128?1:2:d<2097152?3:4:c<16384?c<128?5:6:c<2097152?7:8:r<128?9:10}}),Se=mt(e=>{var n=e;n.asPromise=js(),n.base64=Ys(),n.EventEmitter=Qs(),n.float=au(),n.inquire=su(),n.utf8=lu(),n.pool=cu(),n.LongBits=du(),n.isNode=!!(typeof global<"u"&&global&&global.process&&global.process.versions&&global.process.versions.node),n.global=n.isNode&&global||typeof window<"u"&&window||typeof self<"u"&&self||e,n.emptyArray=Object.freeze?Object.freeze([]):[],n.emptyObject=Object.freeze?Object.freeze({}):{},n.isInteger=Number.isInteger||function(p){return typeof p=="number"&&isFinite(p)&&Math.floor(p)===p},n.isString=function(p){return typeof p=="string"||p instanceof String},n.isObject=function(p){return p&&typeof p=="object"},n.isset=n.isSet=function(p,o){var s=p[o];return s!=null&&p.hasOwnProperty(o)?typeof s!="object"||(Array.isArray(s)?s.length:Object.keys(s).length)>0:!1},n.Buffer=function(){try{var p=n.inquire("buffer").Buffer;return p.prototype.utf8Write?p:null}catch{return null}}(),n._Buffer_from=null,n._Buffer_allocUnsafe=null,n.newBuffer=function(p){return typeof p=="number"?n.Buffer?n._Buffer_allocUnsafe(p):new n.Array(p):n.Buffer?n._Buffer_from(p):typeof Uint8Array>"u"?p:new Uint8Array(p)},n.Array=typeof Uint8Array<"u"?Uint8Array:Array,n.Long=n.global.dcodeIO&&n.global.dcodeIO.Long||n.global.Long||n.inquire("long"),n.key2Re=/^true|false|0|1$/,n.key32Re=/^-?(?:0|[1-9][0-9]*)$/,n.key64Re=/^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,n.longToHash=function(p){return p?n.LongBits.from(p).toHash():n.LongBits.zeroHash},n.longFromHash=function(p,o){var s=n.LongBits.fromHash(p);return n.Long?n.Long.fromBits(s.lo,s.hi,o):s.toNumber(!!o)};function i(p,o,s){for(var d=Object.keys(o),c=0;c<d.length;++c)(p[d[c]]===void 0||!s)&&(p[d[c]]=o[d[c]]);return p}n.merge=i,n.lcFirst=function(p){return p.charAt(0).toLowerCase()+p.substring(1)};function a(p){function o(s,d){if(!(this instanceof o))return new o(s,d);Object.defineProperty(this,"message",{get:function(){return s}}),Error.captureStackTrace?Error.captureStackTrace(this,o):Object.defineProperty(this,"stack",{value:new Error().stack||""}),d&&i(this,d)}return o.prototype=Object.create(Error.prototype,{constructor:{value:o,writable:!0,enumerable:!1,configurable:!0},name:{get:function(){return p},set:void 0,enumerable:!1,configurable:!0},toString:{value:function(){return this.name+": "+this.message},writable:!0,enumerable:!1,configurable:!0}}),o}n.newError=a,n.ProtocolError=a("ProtocolError"),n.oneOfGetter=function(p){for(var o={},s=0;s<p.length;++s)o[p[s]]=1;return function(){for(var d=Object.keys(this),c=d.length-1;c>-1;--c)if(o[d[c]]===1&&this[d[c]]!==void 0&&this[d[c]]!==null)return d[c]}},n.oneOfSetter=function(p){return function(o){for(var s=0;s<p.length;++s)p[s]!==o&&delete this[p[s]]}},n.toJSONOptions={longs:String,enums:String,bytes:String,json:!0},n._configure=function(){var p=n.Buffer;if(!p){n._Buffer_from=n._Buffer_allocUnsafe=null;return}n._Buffer_from=p.from!==Uint8Array.from&&p.from||function(o,s){return new p(o,s)},n._Buffer_allocUnsafe=p.allocUnsafe||function(o){return new p(o)}}}),ei=mt((e,n)=>{n.exports=u;var i=Se(),a,p=i.LongBits,o=i.base64,s=i.utf8;function d(x,P,N){this.fn=x,this.len=P,this.next=void 0,this.val=N}function c(){}function r(x){this.head=x.head,this.tail=x.tail,this.len=x.len,this.next=x.states}function u(){this.len=0,this.head=new d(c,0,0),this.tail=this.head,this.states=null}var l=function(){return i.Buffer?function(){return(u.create=function(){return new a})()}:function(){return new u}};u.create=l(),u.alloc=function(x){return new i.Array(x)},i.Array!==Array&&(u.alloc=i.pool(u.alloc,i.Array.prototype.subarray)),u.prototype._push=function(x,P,N){return this.tail=this.tail.next=new d(x,P,N),this.len+=P,this};function h(x,P,N){P[N]=x&255}function f(x,P,N){for(;x>127;)P[N++]=x&127|128,x>>>=7;P[N]=x}function m(x,P){this.len=x,this.next=void 0,this.val=P}m.prototype=Object.create(d.prototype),m.prototype.fn=f,u.prototype.uint32=function(x){return this.len+=(this.tail=this.tail.next=new m((x=x>>>0)<128?1:x<16384?2:x<2097152?3:x<268435456?4:5,x)).len,this},u.prototype.int32=function(x){return x<0?this._push(y,10,p.fromNumber(x)):this.uint32(x)},u.prototype.sint32=function(x){return this.uint32((x<<1^x>>31)>>>0)};function y(x,P,N){for(;x.hi;)P[N++]=x.lo&127|128,x.lo=(x.lo>>>7|x.hi<<25)>>>0,x.hi>>>=7;for(;x.lo>127;)P[N++]=x.lo&127|128,x.lo=x.lo>>>7;P[N++]=x.lo}u.prototype.uint64=function(x){var P=p.from(x);return this._push(y,P.length(),P)},u.prototype.int64=u.prototype.uint64,u.prototype.sint64=function(x){var P=p.from(x).zzEncode();return this._push(y,P.length(),P)},u.prototype.bool=function(x){return this._push(h,1,x?1:0)};function _(x,P,N){P[N]=x&255,P[N+1]=x>>>8&255,P[N+2]=x>>>16&255,P[N+3]=x>>>24}u.prototype.fixed32=function(x){return this._push(_,4,x>>>0)},u.prototype.sfixed32=u.prototype.fixed32,u.prototype.fixed64=function(x){var P=p.from(x);return this._push(_,4,P.lo)._push(_,4,P.hi)},u.prototype.sfixed64=u.prototype.fixed64,u.prototype.float=function(x){return this._push(i.float.writeFloatLE,4,x)},u.prototype.double=function(x){return this._push(i.float.writeDoubleLE,8,x)};var I=i.Array.prototype.set?function(x,P,N){P.set(x,N)}:function(x,P,N){for(var R=0;R<x.length;++R)P[N+R]=x[R]};u.prototype.bytes=function(x){var P=x.length>>>0;if(!P)return this._push(h,1,0);if(i.isString(x)){var N=u.alloc(P=o.length(x));o.decode(x,N,0),x=N}return this.uint32(P)._push(I,P,x)},u.prototype.string=function(x){var P=s.length(x);return P?this.uint32(P)._push(s.write,P,x):this._push(h,1,0)},u.prototype.fork=function(){return this.states=new r(this),this.head=this.tail=new d(c,0,0),this.len=0,this},u.prototype.reset=function(){return this.states?(this.head=this.states.head,this.tail=this.states.tail,this.len=this.states.len,this.states=this.states.next):(this.head=this.tail=new d(c,0,0),this.len=0),this},u.prototype.ldelim=function(){var x=this.head,P=this.tail,N=this.len;return this.reset().uint32(N),N&&(this.tail.next=x.next,this.tail=P,this.len+=N),this},u.prototype.finish=function(){for(var x=this.head.next,P=this.constructor.alloc(this.len),N=0;x;)x.fn(x.val,P,N),N+=x.len,x=x.next;return P},u._configure=function(x){a=x,u.create=l(),a._configure()}}),vu=mt((e,n)=>{n.exports=p;var i=ei();(p.prototype=Object.create(i.prototype)).constructor=p;var a=Se();function p(){i.call(this)}p._configure=function(){p.alloc=a._Buffer_allocUnsafe,p.writeBytesBuffer=a.Buffer&&a.Buffer.prototype instanceof Uint8Array&&a.Buffer.prototype.set.name==="set"?function(s,d,c){d.set(s,c)}:function(s,d,c){if(s.copy)s.copy(d,c,0,s.length);else for(var r=0;r<s.length;)d[c++]=s[r++]}},p.prototype.bytes=function(s){a.isString(s)&&(s=a._Buffer_from(s,"base64"));var d=s.length>>>0;return this.uint32(d),d&&this._push(p.writeBytesBuffer,d,s),this};function o(s,d,c){s.length<40?a.utf8.write(s,d,c):d.utf8Write?d.utf8Write(s,c):d.write(s,c)}p.prototype.string=function(s){var d=a.Buffer.byteLength(s);return this.uint32(d),d&&this._push(o,d,s),this},p._configure()}),oi=mt((e,n)=>{n.exports=d;var i=Se(),a,p=i.LongBits,o=i.utf8;function s(f,m){return RangeError("index out of range: "+f.pos+" + "+(m||1)+" > "+f.len)}function d(f){this.buf=f,this.pos=0,this.len=f.length}var c=typeof Uint8Array<"u"?function(f){if(f instanceof Uint8Array||Array.isArray(f))return new d(f);throw Error("illegal buffer")}:function(f){if(Array.isArray(f))return new d(f);throw Error("illegal buffer")},r=function(){return i.Buffer?function(f){return(d.create=function(m){return i.Buffer.isBuffer(m)?new a(m):c(m)})(f)}:c};d.create=r(),d.prototype._slice=i.Array.prototype.subarray||i.Array.prototype.slice,d.prototype.uint32=function(){var f=4294967295;return function(){if(f=(this.buf[this.pos]&127)>>>0,this.buf[this.pos++]<128||(f=(f|(this.buf[this.pos]&127)<<7)>>>0,this.buf[this.pos++]<128)||(f=(f|(this.buf[this.pos]&127)<<14)>>>0,this.buf[this.pos++]<128)||(f=(f|(this.buf[this.pos]&127)<<21)>>>0,this.buf[this.pos++]<128)||(f=(f|(this.buf[this.pos]&15)<<28)>>>0,this.buf[this.pos++]<128))return f;if((this.pos+=5)>this.len)throw this.pos=this.len,s(this,10);return f}}(),d.prototype.int32=function(){return this.uint32()|0},d.prototype.sint32=function(){var f=this.uint32();return f>>>1^-(f&1)|0};function u(){var f=new p(0,0),m=0;if(this.len-this.pos>4){for(;m<4;++m)if(f.lo=(f.lo|(this.buf[this.pos]&127)<<m*7)>>>0,this.buf[this.pos++]<128)return f;if(f.lo=(f.lo|(this.buf[this.pos]&127)<<28)>>>0,f.hi=(f.hi|(this.buf[this.pos]&127)>>4)>>>0,this.buf[this.pos++]<128)return f;m=0}else{for(;m<3;++m){if(this.pos>=this.len)throw s(this);if(f.lo=(f.lo|(this.buf[this.pos]&127)<<m*7)>>>0,this.buf[this.pos++]<128)return f}return f.lo=(f.lo|(this.buf[this.pos++]&127)<<m*7)>>>0,f}if(this.len-this.pos>4){for(;m<5;++m)if(f.hi=(f.hi|(this.buf[this.pos]&127)<<m*7+3)>>>0,this.buf[this.pos++]<128)return f}else for(;m<5;++m){if(this.pos>=this.len)throw s(this);if(f.hi=(f.hi|(this.buf[this.pos]&127)<<m*7+3)>>>0,this.buf[this.pos++]<128)return f}throw Error("invalid varint encoding")}d.prototype.bool=function(){return this.uint32()!==0};function l(f,m){return(f[m-4]|f[m-3]<<8|f[m-2]<<16|f[m-1]<<24)>>>0}d.prototype.fixed32=function(){if(this.pos+4>this.len)throw s(this,4);return l(this.buf,this.pos+=4)},d.prototype.sfixed32=function(){if(this.pos+4>this.len)throw s(this,4);return l(this.buf,this.pos+=4)|0};function h(){if(this.pos+8>this.len)throw s(this,8);return new p(l(this.buf,this.pos+=4),l(this.buf,this.pos+=4))}d.prototype.float=function(){if(this.pos+4>this.len)throw s(this,4);var f=i.float.readFloatLE(this.buf,this.pos);return this.pos+=4,f},d.prototype.double=function(){if(this.pos+8>this.len)throw s(this,4);var f=i.float.readDoubleLE(this.buf,this.pos);return this.pos+=8,f},d.prototype.bytes=function(){var f=this.uint32(),m=this.pos,y=this.pos+f;if(y>this.len)throw s(this,f);if(this.pos+=f,Array.isArray(this.buf))return this.buf.slice(m,y);if(m===y){var _=i.Buffer;return _?_.alloc(0):new this.buf.constructor(0)}return this._slice.call(this.buf,m,y)},d.prototype.string=function(){var f=this.bytes();return o.read(f,0,f.length)},d.prototype.skip=function(f){if(typeof f=="number"){if(this.pos+f>this.len)throw s(this,f);this.pos+=f}else do if(this.pos>=this.len)throw s(this);while(this.buf[this.pos++]&128);return this},d.prototype.skipType=function(f){switch(f){case 0:this.skip();break;case 1:this.skip(8);break;case 2:this.skip(this.uint32());break;case 3:for(;(f=this.uint32()&7)!==4;)this.skipType(f);break;case 5:this.skip(4);break;default:throw Error("invalid wire type "+f+" at offset "+this.pos)}return this},d._configure=function(f){a=f,d.create=r(),a._configure();var m=i.Long?"toLong":"toNumber";i.merge(d.prototype,{int64:function(){return u.call(this)[m](!1)},uint64:function(){return u.call(this)[m](!0)},sint64:function(){return u.call(this).zzDecode()[m](!1)},fixed64:function(){return h.call(this)[m](!0)},sfixed64:function(){return h.call(this)[m](!1)}})}}),Lu=mt((e,n)=>{n.exports=p;var i=oi();(p.prototype=Object.create(i.prototype)).constructor=p;var a=Se();function p(o){i.call(this,o)}p._configure=function(){a.Buffer&&(p.prototype._slice=a.Buffer.prototype.slice)},p.prototype.string=function(){var o=this.uint32();return this.buf.utf8Slice?this.buf.utf8Slice(this.pos,this.pos=Math.min(this.pos+o,this.len)):this.buf.toString("utf-8",this.pos,this.pos=Math.min(this.pos+o,this.len))},p._configure()}),ku=mt((e,n)=>{n.exports=a;var i=Se();(a.prototype=Object.create(i.EventEmitter.prototype)).constructor=a;function a(p,o,s){if(typeof p!="function")throw TypeError("rpcImpl must be a function");i.EventEmitter.call(this),this.rpcImpl=p,this.requestDelimited=!!o,this.responseDelimited=!!s}a.prototype.rpcCall=function p(o,s,d,c,r){if(!c)throw TypeError("request must be specified");var u=this;if(!r)return i.asPromise(p,u,o,s,d,c);if(!u.rpcImpl){setTimeout(function(){r(Error("already ended"))},0);return}try{return u.rpcImpl(o,s[u.requestDelimited?"encodeDelimited":"encode"](c).finish(),function(l,h){if(l)return u.emit("error",l,o),r(l);if(h===null){u.end(!0);return}if(!(h instanceof d))try{h=d[u.responseDelimited?"decodeDelimited":"decode"](h)}catch(f){return u.emit("error",f,o),r(f)}return u.emit("data",h,o),r(null,h)})}catch(l){u.emit("error",l,o),setTimeout(function(){r(l)},0);return}},a.prototype.end=function(p){return this.rpcImpl&&(p||this.rpcImpl(null,null,null),this.rpcImpl=null,this.emit("end").off()),this}}),Fu=mt(e=>{var n=e;n.Service=ku()}),Nu=mt((e,n)=>{n.exports={}}),Mu=mt(e=>{var n=e;n.build="minimal",n.Writer=ei(),n.BufferWriter=vu(),n.Reader=oi(),n.BufferReader=Lu(),n.util=Se(),n.rpc=Fu(),n.roots=Nu(),n.configure=i;function i(){n.util._configure(),n.Writer._configure(n.BufferWriter),n.Reader._configure(n.BufferReader)}i()}),Vu=mt((e,n)=>{n.exports=Mu()}),sr=mt((e,n)=>{var i=Vu(),a=i.Reader,p=i.Writer,o=i.util,s=i.roots.default||(i.roots.default={});s.onnx=function(){var d={};return d.Version=function(){var c={},r=Object.create(c);return r[c[0]="_START_VERSION"]=0,r[c[1]="IR_VERSION_2017_10_10"]=1,r[c[2]="IR_VERSION_2017_10_30"]=2,r[c[3]="IR_VERSION_2017_11_3"]=3,r[c[4]="IR_VERSION_2019_1_22"]=4,r[c[5]="IR_VERSION_2019_3_18"]=5,r[c[6]="IR_VERSION_2019_9_19"]=6,r[c[7]="IR_VERSION_2020_5_8"]=7,r[c[8]="IR_VERSION_2021_7_30"]=8,r[c[9]="IR_VERSION"]=9,r}(),d.AttributeProto=function(){function c(r){if(this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.graphs=[],this.sparseTensors=[],this.typeProtos=[],r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.name="",c.prototype.refAttrName="",c.prototype.docString="",c.prototype.type=0,c.prototype.f=0,c.prototype.i=o.Long?o.Long.fromBits(0,0,!1):0,c.prototype.s=o.newBuffer([]),c.prototype.t=null,c.prototype.g=null,c.prototype.sparseTensor=null,c.prototype.tp=null,c.prototype.floats=o.emptyArray,c.prototype.ints=o.emptyArray,c.prototype.strings=o.emptyArray,c.prototype.tensors=o.emptyArray,c.prototype.graphs=o.emptyArray,c.prototype.sparseTensors=o.emptyArray,c.prototype.typeProtos=o.emptyArray,c.create=function(r){return new c(r)},c.encode=function(r,u){if(u||(u=p.create()),r.name!=null&&Object.hasOwnProperty.call(r,"name")&&u.uint32(10).string(r.name),r.f!=null&&Object.hasOwnProperty.call(r,"f")&&u.uint32(21).float(r.f),r.i!=null&&Object.hasOwnProperty.call(r,"i")&&u.uint32(24).int64(r.i),r.s!=null&&Object.hasOwnProperty.call(r,"s")&&u.uint32(34).bytes(r.s),r.t!=null&&Object.hasOwnProperty.call(r,"t")&&s.onnx.TensorProto.encode(r.t,u.uint32(42).fork()).ldelim(),r.g!=null&&Object.hasOwnProperty.call(r,"g")&&s.onnx.GraphProto.encode(r.g,u.uint32(50).fork()).ldelim(),r.floats!=null&&r.floats.length){u.uint32(58).fork();for(var l=0;l<r.floats.length;++l)u.float(r.floats[l]);u.ldelim()}if(r.ints!=null&&r.ints.length){u.uint32(66).fork();for(var l=0;l<r.ints.length;++l)u.int64(r.ints[l]);u.ldelim()}if(r.strings!=null&&r.strings.length)for(var l=0;l<r.strings.length;++l)u.uint32(74).bytes(r.strings[l]);if(r.tensors!=null&&r.tensors.length)for(var l=0;l<r.tensors.length;++l)s.onnx.TensorProto.encode(r.tensors[l],u.uint32(82).fork()).ldelim();if(r.graphs!=null&&r.graphs.length)for(var l=0;l<r.graphs.length;++l)s.onnx.GraphProto.encode(r.graphs[l],u.uint32(90).fork()).ldelim();if(r.docString!=null&&Object.hasOwnProperty.call(r,"docString")&&u.uint32(106).string(r.docString),r.tp!=null&&Object.hasOwnProperty.call(r,"tp")&&s.onnx.TypeProto.encode(r.tp,u.uint32(114).fork()).ldelim(),r.typeProtos!=null&&r.typeProtos.length)for(var l=0;l<r.typeProtos.length;++l)s.onnx.TypeProto.encode(r.typeProtos[l],u.uint32(122).fork()).ldelim();if(r.type!=null&&Object.hasOwnProperty.call(r,"type")&&u.uint32(160).int32(r.type),r.refAttrName!=null&&Object.hasOwnProperty.call(r,"refAttrName")&&u.uint32(170).string(r.refAttrName),r.sparseTensor!=null&&Object.hasOwnProperty.call(r,"sparseTensor")&&s.onnx.SparseTensorProto.encode(r.sparseTensor,u.uint32(178).fork()).ldelim(),r.sparseTensors!=null&&r.sparseTensors.length)for(var l=0;l<r.sparseTensors.length;++l)s.onnx.SparseTensorProto.encode(r.sparseTensors[l],u.uint32(186).fork()).ldelim();return u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.AttributeProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.name=r.string();break}case 21:{h.refAttrName=r.string();break}case 13:{h.docString=r.string();break}case 20:{h.type=r.int32();break}case 2:{h.f=r.float();break}case 3:{h.i=r.int64();break}case 4:{h.s=r.bytes();break}case 5:{h.t=s.onnx.TensorProto.decode(r,r.uint32());break}case 6:{h.g=s.onnx.GraphProto.decode(r,r.uint32());break}case 22:{h.sparseTensor=s.onnx.SparseTensorProto.decode(r,r.uint32());break}case 14:{h.tp=s.onnx.TypeProto.decode(r,r.uint32());break}case 7:{if(h.floats&&h.floats.length||(h.floats=[]),(f&7)===2)for(var m=r.uint32()+r.pos;r.pos<m;)h.floats.push(r.float());else h.floats.push(r.float());break}case 8:{if(h.ints&&h.ints.length||(h.ints=[]),(f&7)===2)for(var m=r.uint32()+r.pos;r.pos<m;)h.ints.push(r.int64());else h.ints.push(r.int64());break}case 9:{h.strings&&h.strings.length||(h.strings=[]),h.strings.push(r.bytes());break}case 10:{h.tensors&&h.tensors.length||(h.tensors=[]),h.tensors.push(s.onnx.TensorProto.decode(r,r.uint32()));break}case 11:{h.graphs&&h.graphs.length||(h.graphs=[]),h.graphs.push(s.onnx.GraphProto.decode(r,r.uint32()));break}case 23:{h.sparseTensors&&h.sparseTensors.length||(h.sparseTensors=[]),h.sparseTensors.push(s.onnx.SparseTensorProto.decode(r,r.uint32()));break}case 15:{h.typeProtos&&h.typeProtos.length||(h.typeProtos=[]),h.typeProtos.push(s.onnx.TypeProto.decode(r,r.uint32()));break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.name!=null&&r.hasOwnProperty("name")&&!o.isString(r.name))return"name: string expected";if(r.refAttrName!=null&&r.hasOwnProperty("refAttrName")&&!o.isString(r.refAttrName))return"refAttrName: string expected";if(r.docString!=null&&r.hasOwnProperty("docString")&&!o.isString(r.docString))return"docString: string expected";if(r.type!=null&&r.hasOwnProperty("type"))switch(r.type){default:return"type: enum value expected";case 0:case 1:case 2:case 3:case 4:case 5:case 11:case 13:case 6:case 7:case 8:case 9:case 10:case 12:case 14:break}if(r.f!=null&&r.hasOwnProperty("f")&&typeof r.f!="number")return"f: number expected";if(r.i!=null&&r.hasOwnProperty("i")&&!o.isInteger(r.i)&&!(r.i&&o.isInteger(r.i.low)&&o.isInteger(r.i.high)))return"i: integer|Long expected";if(r.s!=null&&r.hasOwnProperty("s")&&!(r.s&&typeof r.s.length=="number"||o.isString(r.s)))return"s: buffer expected";if(r.t!=null&&r.hasOwnProperty("t")){var u=s.onnx.TensorProto.verify(r.t);if(u)return"t."+u}if(r.g!=null&&r.hasOwnProperty("g")){var u=s.onnx.GraphProto.verify(r.g);if(u)return"g."+u}if(r.sparseTensor!=null&&r.hasOwnProperty("sparseTensor")){var u=s.onnx.SparseTensorProto.verify(r.sparseTensor);if(u)return"sparseTensor."+u}if(r.tp!=null&&r.hasOwnProperty("tp")){var u=s.onnx.TypeProto.verify(r.tp);if(u)return"tp."+u}if(r.floats!=null&&r.hasOwnProperty("floats")){if(!Array.isArray(r.floats))return"floats: array expected";for(var l=0;l<r.floats.length;++l)if(typeof r.floats[l]!="number")return"floats: number[] expected"}if(r.ints!=null&&r.hasOwnProperty("ints")){if(!Array.isArray(r.ints))return"ints: array expected";for(var l=0;l<r.ints.length;++l)if(!o.isInteger(r.ints[l])&&!(r.ints[l]&&o.isInteger(r.ints[l].low)&&o.isInteger(r.ints[l].high)))return"ints: integer|Long[] expected"}if(r.strings!=null&&r.hasOwnProperty("strings")){if(!Array.isArray(r.strings))return"strings: array expected";for(var l=0;l<r.strings.length;++l)if(!(r.strings[l]&&typeof r.strings[l].length=="number"||o.isString(r.strings[l])))return"strings: buffer[] expected"}if(r.tensors!=null&&r.hasOwnProperty("tensors")){if(!Array.isArray(r.tensors))return"tensors: array expected";for(var l=0;l<r.tensors.length;++l){var u=s.onnx.TensorProto.verify(r.tensors[l]);if(u)return"tensors."+u}}if(r.graphs!=null&&r.hasOwnProperty("graphs")){if(!Array.isArray(r.graphs))return"graphs: array expected";for(var l=0;l<r.graphs.length;++l){var u=s.onnx.GraphProto.verify(r.graphs[l]);if(u)return"graphs."+u}}if(r.sparseTensors!=null&&r.hasOwnProperty("sparseTensors")){if(!Array.isArray(r.sparseTensors))return"sparseTensors: array expected";for(var l=0;l<r.sparseTensors.length;++l){var u=s.onnx.SparseTensorProto.verify(r.sparseTensors[l]);if(u)return"sparseTensors."+u}}if(r.typeProtos!=null&&r.hasOwnProperty("typeProtos")){if(!Array.isArray(r.typeProtos))return"typeProtos: array expected";for(var l=0;l<r.typeProtos.length;++l){var u=s.onnx.TypeProto.verify(r.typeProtos[l]);if(u)return"typeProtos."+u}}return null},c.fromObject=function(r){if(r instanceof s.onnx.AttributeProto)return r;var u=new s.onnx.AttributeProto;switch(r.name!=null&&(u.name=String(r.name)),r.refAttrName!=null&&(u.refAttrName=String(r.refAttrName)),r.docString!=null&&(u.docString=String(r.docString)),r.type){default:if(typeof r.type=="number"){u.type=r.type;break}break;case"UNDEFINED":case 0:u.type=0;break;case"FLOAT":case 1:u.type=1;break;case"INT":case 2:u.type=2;break;case"STRING":case 3:u.type=3;break;case"TENSOR":case 4:u.type=4;break;case"GRAPH":case 5:u.type=5;break;case"SPARSE_TENSOR":case 11:u.type=11;break;case"TYPE_PROTO":case 13:u.type=13;break;case"FLOATS":case 6:u.type=6;break;case"INTS":case 7:u.type=7;break;case"STRINGS":case 8:u.type=8;break;case"TENSORS":case 9:u.type=9;break;case"GRAPHS":case 10:u.type=10;break;case"SPARSE_TENSORS":case 12:u.type=12;break;case"TYPE_PROTOS":case 14:u.type=14;break}if(r.f!=null&&(u.f=Number(r.f)),r.i!=null&&(o.Long?(u.i=o.Long.fromValue(r.i)).unsigned=!1:typeof r.i=="string"?u.i=parseInt(r.i,10):typeof r.i=="number"?u.i=r.i:typeof r.i=="object"&&(u.i=new o.LongBits(r.i.low>>>0,r.i.high>>>0).toNumber())),r.s!=null&&(typeof r.s=="string"?o.base64.decode(r.s,u.s=o.newBuffer(o.base64.length(r.s)),0):r.s.length>=0&&(u.s=r.s)),r.t!=null){if(typeof r.t!="object")throw TypeError(".onnx.AttributeProto.t: object expected");u.t=s.onnx.TensorProto.fromObject(r.t)}if(r.g!=null){if(typeof r.g!="object")throw TypeError(".onnx.AttributeProto.g: object expected");u.g=s.onnx.GraphProto.fromObject(r.g)}if(r.sparseTensor!=null){if(typeof r.sparseTensor!="object")throw TypeError(".onnx.AttributeProto.sparseTensor: object expected");u.sparseTensor=s.onnx.SparseTensorProto.fromObject(r.sparseTensor)}if(r.tp!=null){if(typeof r.tp!="object")throw TypeError(".onnx.AttributeProto.tp: object expected");u.tp=s.onnx.TypeProto.fromObject(r.tp)}if(r.floats){if(!Array.isArray(r.floats))throw TypeError(".onnx.AttributeProto.floats: array expected");u.floats=[];for(var l=0;l<r.floats.length;++l)u.floats[l]=Number(r.floats[l])}if(r.ints){if(!Array.isArray(r.ints))throw TypeError(".onnx.AttributeProto.ints: array expected");u.ints=[];for(var l=0;l<r.ints.length;++l)o.Long?(u.ints[l]=o.Long.fromValue(r.ints[l])).unsigned=!1:typeof r.ints[l]=="string"?u.ints[l]=parseInt(r.ints[l],10):typeof r.ints[l]=="number"?u.ints[l]=r.ints[l]:typeof r.ints[l]=="object"&&(u.ints[l]=new o.LongBits(r.ints[l].low>>>0,r.ints[l].high>>>0).toNumber())}if(r.strings){if(!Array.isArray(r.strings))throw TypeError(".onnx.AttributeProto.strings: array expected");u.strings=[];for(var l=0;l<r.strings.length;++l)typeof r.strings[l]=="string"?o.base64.decode(r.strings[l],u.strings[l]=o.newBuffer(o.base64.length(r.strings[l])),0):r.strings[l].length>=0&&(u.strings[l]=r.strings[l])}if(r.tensors){if(!Array.isArray(r.tensors))throw TypeError(".onnx.AttributeProto.tensors: array expected");u.tensors=[];for(var l=0;l<r.tensors.length;++l){if(typeof r.tensors[l]!="object")throw TypeError(".onnx.AttributeProto.tensors: object expected");u.tensors[l]=s.onnx.TensorProto.fromObject(r.tensors[l])}}if(r.graphs){if(!Array.isArray(r.graphs))throw TypeError(".onnx.AttributeProto.graphs: array expected");u.graphs=[];for(var l=0;l<r.graphs.length;++l){if(typeof r.graphs[l]!="object")throw TypeError(".onnx.AttributeProto.graphs: object expected");u.graphs[l]=s.onnx.GraphProto.fromObject(r.graphs[l])}}if(r.sparseTensors){if(!Array.isArray(r.sparseTensors))throw TypeError(".onnx.AttributeProto.sparseTensors: array expected");u.sparseTensors=[];for(var l=0;l<r.sparseTensors.length;++l){if(typeof r.sparseTensors[l]!="object")throw TypeError(".onnx.AttributeProto.sparseTensors: object expected");u.sparseTensors[l]=s.onnx.SparseTensorProto.fromObject(r.sparseTensors[l])}}if(r.typeProtos){if(!Array.isArray(r.typeProtos))throw TypeError(".onnx.AttributeProto.typeProtos: array expected");u.typeProtos=[];for(var l=0;l<r.typeProtos.length;++l){if(typeof r.typeProtos[l]!="object")throw TypeError(".onnx.AttributeProto.typeProtos: object expected");u.typeProtos[l]=s.onnx.TypeProto.fromObject(r.typeProtos[l])}}return u},c.toObject=function(r,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.floats=[],l.ints=[],l.strings=[],l.tensors=[],l.graphs=[],l.typeProtos=[],l.sparseTensors=[]),u.defaults){if(l.name="",l.f=0,o.Long){var h=new o.Long(0,0,!1);l.i=u.longs===String?h.toString():u.longs===Number?h.toNumber():h}else l.i=u.longs===String?"0":0;u.bytes===String?l.s="":(l.s=[],u.bytes!==Array&&(l.s=o.newBuffer(l.s))),l.t=null,l.g=null,l.docString="",l.tp=null,l.type=u.enums===String?"UNDEFINED":0,l.refAttrName="",l.sparseTensor=null}if(r.name!=null&&r.hasOwnProperty("name")&&(l.name=r.name),r.f!=null&&r.hasOwnProperty("f")&&(l.f=u.json&&!isFinite(r.f)?String(r.f):r.f),r.i!=null&&r.hasOwnProperty("i")&&(typeof r.i=="number"?l.i=u.longs===String?String(r.i):r.i:l.i=u.longs===String?o.Long.prototype.toString.call(r.i):u.longs===Number?new o.LongBits(r.i.low>>>0,r.i.high>>>0).toNumber():r.i),r.s!=null&&r.hasOwnProperty("s")&&(l.s=u.bytes===String?o.base64.encode(r.s,0,r.s.length):u.bytes===Array?Array.prototype.slice.call(r.s):r.s),r.t!=null&&r.hasOwnProperty("t")&&(l.t=s.onnx.TensorProto.toObject(r.t,u)),r.g!=null&&r.hasOwnProperty("g")&&(l.g=s.onnx.GraphProto.toObject(r.g,u)),r.floats&&r.floats.length){l.floats=[];for(var f=0;f<r.floats.length;++f)l.floats[f]=u.json&&!isFinite(r.floats[f])?String(r.floats[f]):r.floats[f]}if(r.ints&&r.ints.length){l.ints=[];for(var f=0;f<r.ints.length;++f)typeof r.ints[f]=="number"?l.ints[f]=u.longs===String?String(r.ints[f]):r.ints[f]:l.ints[f]=u.longs===String?o.Long.prototype.toString.call(r.ints[f]):u.longs===Number?new o.LongBits(r.ints[f].low>>>0,r.ints[f].high>>>0).toNumber():r.ints[f]}if(r.strings&&r.strings.length){l.strings=[];for(var f=0;f<r.strings.length;++f)l.strings[f]=u.bytes===String?o.base64.encode(r.strings[f],0,r.strings[f].length):u.bytes===Array?Array.prototype.slice.call(r.strings[f]):r.strings[f]}if(r.tensors&&r.tensors.length){l.tensors=[];for(var f=0;f<r.tensors.length;++f)l.tensors[f]=s.onnx.TensorProto.toObject(r.tensors[f],u)}if(r.graphs&&r.graphs.length){l.graphs=[];for(var f=0;f<r.graphs.length;++f)l.graphs[f]=s.onnx.GraphProto.toObject(r.graphs[f],u)}if(r.docString!=null&&r.hasOwnProperty("docString")&&(l.docString=r.docString),r.tp!=null&&r.hasOwnProperty("tp")&&(l.tp=s.onnx.TypeProto.toObject(r.tp,u)),r.typeProtos&&r.typeProtos.length){l.typeProtos=[];for(var f=0;f<r.typeProtos.length;++f)l.typeProtos[f]=s.onnx.TypeProto.toObject(r.typeProtos[f],u)}if(r.type!=null&&r.hasOwnProperty("type")&&(l.type=u.enums===String?s.onnx.AttributeProto.AttributeType[r.type]===void 0?r.type:s.onnx.AttributeProto.AttributeType[r.type]:r.type),r.refAttrName!=null&&r.hasOwnProperty("refAttrName")&&(l.refAttrName=r.refAttrName),r.sparseTensor!=null&&r.hasOwnProperty("sparseTensor")&&(l.sparseTensor=s.onnx.SparseTensorProto.toObject(r.sparseTensor,u)),r.sparseTensors&&r.sparseTensors.length){l.sparseTensors=[];for(var f=0;f<r.sparseTensors.length;++f)l.sparseTensors[f]=s.onnx.SparseTensorProto.toObject(r.sparseTensors[f],u)}return l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.AttributeProto"},c.AttributeType=function(){var r={},u=Object.create(r);return u[r[0]="UNDEFINED"]=0,u[r[1]="FLOAT"]=1,u[r[2]="INT"]=2,u[r[3]="STRING"]=3,u[r[4]="TENSOR"]=4,u[r[5]="GRAPH"]=5,u[r[11]="SPARSE_TENSOR"]=11,u[r[13]="TYPE_PROTO"]=13,u[r[6]="FLOATS"]=6,u[r[7]="INTS"]=7,u[r[8]="STRINGS"]=8,u[r[9]="TENSORS"]=9,u[r[10]="GRAPHS"]=10,u[r[12]="SPARSE_TENSORS"]=12,u[r[14]="TYPE_PROTOS"]=14,u}(),c}(),d.ValueInfoProto=function(){function c(r){if(r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.name="",c.prototype.type=null,c.prototype.docString="",c.create=function(r){return new c(r)},c.encode=function(r,u){return u||(u=p.create()),r.name!=null&&Object.hasOwnProperty.call(r,"name")&&u.uint32(10).string(r.name),r.type!=null&&Object.hasOwnProperty.call(r,"type")&&s.onnx.TypeProto.encode(r.type,u.uint32(18).fork()).ldelim(),r.docString!=null&&Object.hasOwnProperty.call(r,"docString")&&u.uint32(26).string(r.docString),u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.ValueInfoProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.name=r.string();break}case 2:{h.type=s.onnx.TypeProto.decode(r,r.uint32());break}case 3:{h.docString=r.string();break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.name!=null&&r.hasOwnProperty("name")&&!o.isString(r.name))return"name: string expected";if(r.type!=null&&r.hasOwnProperty("type")){var u=s.onnx.TypeProto.verify(r.type);if(u)return"type."+u}return r.docString!=null&&r.hasOwnProperty("docString")&&!o.isString(r.docString)?"docString: string expected":null},c.fromObject=function(r){if(r instanceof s.onnx.ValueInfoProto)return r;var u=new s.onnx.ValueInfoProto;if(r.name!=null&&(u.name=String(r.name)),r.type!=null){if(typeof r.type!="object")throw TypeError(".onnx.ValueInfoProto.type: object expected");u.type=s.onnx.TypeProto.fromObject(r.type)}return r.docString!=null&&(u.docString=String(r.docString)),u},c.toObject=function(r,u){u||(u={});var l={};return u.defaults&&(l.name="",l.type=null,l.docString=""),r.name!=null&&r.hasOwnProperty("name")&&(l.name=r.name),r.type!=null&&r.hasOwnProperty("type")&&(l.type=s.onnx.TypeProto.toObject(r.type,u)),r.docString!=null&&r.hasOwnProperty("docString")&&(l.docString=r.docString),l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.ValueInfoProto"},c}(),d.NodeProto=function(){function c(r){if(this.input=[],this.output=[],this.attribute=[],r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.input=o.emptyArray,c.prototype.output=o.emptyArray,c.prototype.name="",c.prototype.opType="",c.prototype.domain="",c.prototype.attribute=o.emptyArray,c.prototype.docString="",c.create=function(r){return new c(r)},c.encode=function(r,u){if(u||(u=p.create()),r.input!=null&&r.input.length)for(var l=0;l<r.input.length;++l)u.uint32(10).string(r.input[l]);if(r.output!=null&&r.output.length)for(var l=0;l<r.output.length;++l)u.uint32(18).string(r.output[l]);if(r.name!=null&&Object.hasOwnProperty.call(r,"name")&&u.uint32(26).string(r.name),r.opType!=null&&Object.hasOwnProperty.call(r,"opType")&&u.uint32(34).string(r.opType),r.attribute!=null&&r.attribute.length)for(var l=0;l<r.attribute.length;++l)s.onnx.AttributeProto.encode(r.attribute[l],u.uint32(42).fork()).ldelim();return r.docString!=null&&Object.hasOwnProperty.call(r,"docString")&&u.uint32(50).string(r.docString),r.domain!=null&&Object.hasOwnProperty.call(r,"domain")&&u.uint32(58).string(r.domain),u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.NodeProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.input&&h.input.length||(h.input=[]),h.input.push(r.string());break}case 2:{h.output&&h.output.length||(h.output=[]),h.output.push(r.string());break}case 3:{h.name=r.string();break}case 4:{h.opType=r.string();break}case 7:{h.domain=r.string();break}case 5:{h.attribute&&h.attribute.length||(h.attribute=[]),h.attribute.push(s.onnx.AttributeProto.decode(r,r.uint32()));break}case 6:{h.docString=r.string();break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.input!=null&&r.hasOwnProperty("input")){if(!Array.isArray(r.input))return"input: array expected";for(var u=0;u<r.input.length;++u)if(!o.isString(r.input[u]))return"input: string[] expected"}if(r.output!=null&&r.hasOwnProperty("output")){if(!Array.isArray(r.output))return"output: array expected";for(var u=0;u<r.output.length;++u)if(!o.isString(r.output[u]))return"output: string[] expected"}if(r.name!=null&&r.hasOwnProperty("name")&&!o.isString(r.name))return"name: string expected";if(r.opType!=null&&r.hasOwnProperty("opType")&&!o.isString(r.opType))return"opType: string expected";if(r.domain!=null&&r.hasOwnProperty("domain")&&!o.isString(r.domain))return"domain: string expected";if(r.attribute!=null&&r.hasOwnProperty("attribute")){if(!Array.isArray(r.attribute))return"attribute: array expected";for(var u=0;u<r.attribute.length;++u){var l=s.onnx.AttributeProto.verify(r.attribute[u]);if(l)return"attribute."+l}}return r.docString!=null&&r.hasOwnProperty("docString")&&!o.isString(r.docString)?"docString: string expected":null},c.fromObject=function(r){if(r instanceof s.onnx.NodeProto)return r;var u=new s.onnx.NodeProto;if(r.input){if(!Array.isArray(r.input))throw TypeError(".onnx.NodeProto.input: array expected");u.input=[];for(var l=0;l<r.input.length;++l)u.input[l]=String(r.input[l])}if(r.output){if(!Array.isArray(r.output))throw TypeError(".onnx.NodeProto.output: array expected");u.output=[];for(var l=0;l<r.output.length;++l)u.output[l]=String(r.output[l])}if(r.name!=null&&(u.name=String(r.name)),r.opType!=null&&(u.opType=String(r.opType)),r.domain!=null&&(u.domain=String(r.domain)),r.attribute){if(!Array.isArray(r.attribute))throw TypeError(".onnx.NodeProto.attribute: array expected");u.attribute=[];for(var l=0;l<r.attribute.length;++l){if(typeof r.attribute[l]!="object")throw TypeError(".onnx.NodeProto.attribute: object expected");u.attribute[l]=s.onnx.AttributeProto.fromObject(r.attribute[l])}}return r.docString!=null&&(u.docString=String(r.docString)),u},c.toObject=function(r,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.input=[],l.output=[],l.attribute=[]),u.defaults&&(l.name="",l.opType="",l.docString="",l.domain=""),r.input&&r.input.length){l.input=[];for(var h=0;h<r.input.length;++h)l.input[h]=r.input[h]}if(r.output&&r.output.length){l.output=[];for(var h=0;h<r.output.length;++h)l.output[h]=r.output[h]}if(r.name!=null&&r.hasOwnProperty("name")&&(l.name=r.name),r.opType!=null&&r.hasOwnProperty("opType")&&(l.opType=r.opType),r.attribute&&r.attribute.length){l.attribute=[];for(var h=0;h<r.attribute.length;++h)l.attribute[h]=s.onnx.AttributeProto.toObject(r.attribute[h],u)}return r.docString!=null&&r.hasOwnProperty("docString")&&(l.docString=r.docString),r.domain!=null&&r.hasOwnProperty("domain")&&(l.domain=r.domain),l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.NodeProto"},c}(),d.TrainingInfoProto=function(){function c(r){if(this.initializationBinding=[],this.updateBinding=[],r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.initialization=null,c.prototype.algorithm=null,c.prototype.initializationBinding=o.emptyArray,c.prototype.updateBinding=o.emptyArray,c.create=function(r){return new c(r)},c.encode=function(r,u){if(u||(u=p.create()),r.initialization!=null&&Object.hasOwnProperty.call(r,"initialization")&&s.onnx.GraphProto.encode(r.initialization,u.uint32(10).fork()).ldelim(),r.algorithm!=null&&Object.hasOwnProperty.call(r,"algorithm")&&s.onnx.GraphProto.encode(r.algorithm,u.uint32(18).fork()).ldelim(),r.initializationBinding!=null&&r.initializationBinding.length)for(var l=0;l<r.initializationBinding.length;++l)s.onnx.StringStringEntryProto.encode(r.initializationBinding[l],u.uint32(26).fork()).ldelim();if(r.updateBinding!=null&&r.updateBinding.length)for(var l=0;l<r.updateBinding.length;++l)s.onnx.StringStringEntryProto.encode(r.updateBinding[l],u.uint32(34).fork()).ldelim();return u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.TrainingInfoProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.initialization=s.onnx.GraphProto.decode(r,r.uint32());break}case 2:{h.algorithm=s.onnx.GraphProto.decode(r,r.uint32());break}case 3:{h.initializationBinding&&h.initializationBinding.length||(h.initializationBinding=[]),h.initializationBinding.push(s.onnx.StringStringEntryProto.decode(r,r.uint32()));break}case 4:{h.updateBinding&&h.updateBinding.length||(h.updateBinding=[]),h.updateBinding.push(s.onnx.StringStringEntryProto.decode(r,r.uint32()));break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.initialization!=null&&r.hasOwnProperty("initialization")){var u=s.onnx.GraphProto.verify(r.initialization);if(u)return"initialization."+u}if(r.algorithm!=null&&r.hasOwnProperty("algorithm")){var u=s.onnx.GraphProto.verify(r.algorithm);if(u)return"algorithm."+u}if(r.initializationBinding!=null&&r.hasOwnProperty("initializationBinding")){if(!Array.isArray(r.initializationBinding))return"initializationBinding: array expected";for(var l=0;l<r.initializationBinding.length;++l){var u=s.onnx.StringStringEntryProto.verify(r.initializationBinding[l]);if(u)return"initializationBinding."+u}}if(r.updateBinding!=null&&r.hasOwnProperty("updateBinding")){if(!Array.isArray(r.updateBinding))return"updateBinding: array expected";for(var l=0;l<r.updateBinding.length;++l){var u=s.onnx.StringStringEntryProto.verify(r.updateBinding[l]);if(u)return"updateBinding."+u}}return null},c.fromObject=function(r){if(r instanceof s.onnx.TrainingInfoProto)return r;var u=new s.onnx.TrainingInfoProto;if(r.initialization!=null){if(typeof r.initialization!="object")throw TypeError(".onnx.TrainingInfoProto.initialization: object expected");u.initialization=s.onnx.GraphProto.fromObject(r.initialization)}if(r.algorithm!=null){if(typeof r.algorithm!="object")throw TypeError(".onnx.TrainingInfoProto.algorithm: object expected");u.algorithm=s.onnx.GraphProto.fromObject(r.algorithm)}if(r.initializationBinding){if(!Array.isArray(r.initializationBinding))throw TypeError(".onnx.TrainingInfoProto.initializationBinding: array expected");u.initializationBinding=[];for(var l=0;l<r.initializationBinding.length;++l){if(typeof r.initializationBinding[l]!="object")throw TypeError(".onnx.TrainingInfoProto.initializationBinding: object expected");u.initializationBinding[l]=s.onnx.StringStringEntryProto.fromObject(r.initializationBinding[l])}}if(r.updateBinding){if(!Array.isArray(r.updateBinding))throw TypeError(".onnx.TrainingInfoProto.updateBinding: array expected");u.updateBinding=[];for(var l=0;l<r.updateBinding.length;++l){if(typeof r.updateBinding[l]!="object")throw TypeError(".onnx.TrainingInfoProto.updateBinding: object expected");u.updateBinding[l]=s.onnx.StringStringEntryProto.fromObject(r.updateBinding[l])}}return u},c.toObject=function(r,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.initializationBinding=[],l.updateBinding=[]),u.defaults&&(l.initialization=null,l.algorithm=null),r.initialization!=null&&r.hasOwnProperty("initialization")&&(l.initialization=s.onnx.GraphProto.toObject(r.initialization,u)),r.algorithm!=null&&r.hasOwnProperty("algorithm")&&(l.algorithm=s.onnx.GraphProto.toObject(r.algorithm,u)),r.initializationBinding&&r.initializationBinding.length){l.initializationBinding=[];for(var h=0;h<r.initializationBinding.length;++h)l.initializationBinding[h]=s.onnx.StringStringEntryProto.toObject(r.initializationBinding[h],u)}if(r.updateBinding&&r.updateBinding.length){l.updateBinding=[];for(var h=0;h<r.updateBinding.length;++h)l.updateBinding[h]=s.onnx.StringStringEntryProto.toObject(r.updateBinding[h],u)}return l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TrainingInfoProto"},c}(),d.ModelProto=function(){function c(r){if(this.opsetImport=[],this.metadataProps=[],this.trainingInfo=[],this.functions=[],r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.irVersion=o.Long?o.Long.fromBits(0,0,!1):0,c.prototype.opsetImport=o.emptyArray,c.prototype.producerName="",c.prototype.producerVersion="",c.prototype.domain="",c.prototype.modelVersion=o.Long?o.Long.fromBits(0,0,!1):0,c.prototype.docString="",c.prototype.graph=null,c.prototype.metadataProps=o.emptyArray,c.prototype.trainingInfo=o.emptyArray,c.prototype.functions=o.emptyArray,c.create=function(r){return new c(r)},c.encode=function(r,u){if(u||(u=p.create()),r.irVersion!=null&&Object.hasOwnProperty.call(r,"irVersion")&&u.uint32(8).int64(r.irVersion),r.producerName!=null&&Object.hasOwnProperty.call(r,"producerName")&&u.uint32(18).string(r.producerName),r.producerVersion!=null&&Object.hasOwnProperty.call(r,"producerVersion")&&u.uint32(26).string(r.producerVersion),r.domain!=null&&Object.hasOwnProperty.call(r,"domain")&&u.uint32(34).string(r.domain),r.modelVersion!=null&&Object.hasOwnProperty.call(r,"modelVersion")&&u.uint32(40).int64(r.modelVersion),r.docString!=null&&Object.hasOwnProperty.call(r,"docString")&&u.uint32(50).string(r.docString),r.graph!=null&&Object.hasOwnProperty.call(r,"graph")&&s.onnx.GraphProto.encode(r.graph,u.uint32(58).fork()).ldelim(),r.opsetImport!=null&&r.opsetImport.length)for(var l=0;l<r.opsetImport.length;++l)s.onnx.OperatorSetIdProto.encode(r.opsetImport[l],u.uint32(66).fork()).ldelim();if(r.metadataProps!=null&&r.metadataProps.length)for(var l=0;l<r.metadataProps.length;++l)s.onnx.StringStringEntryProto.encode(r.metadataProps[l],u.uint32(114).fork()).ldelim();if(r.trainingInfo!=null&&r.trainingInfo.length)for(var l=0;l<r.trainingInfo.length;++l)s.onnx.TrainingInfoProto.encode(r.trainingInfo[l],u.uint32(162).fork()).ldelim();if(r.functions!=null&&r.functions.length)for(var l=0;l<r.functions.length;++l)s.onnx.FunctionProto.encode(r.functions[l],u.uint32(202).fork()).ldelim();return u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.ModelProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.irVersion=r.int64();break}case 8:{h.opsetImport&&h.opsetImport.length||(h.opsetImport=[]),h.opsetImport.push(s.onnx.OperatorSetIdProto.decode(r,r.uint32()));break}case 2:{h.producerName=r.string();break}case 3:{h.producerVersion=r.string();break}case 4:{h.domain=r.string();break}case 5:{h.modelVersion=r.int64();break}case 6:{h.docString=r.string();break}case 7:{h.graph=s.onnx.GraphProto.decode(r,r.uint32());break}case 14:{h.metadataProps&&h.metadataProps.length||(h.metadataProps=[]),h.metadataProps.push(s.onnx.StringStringEntryProto.decode(r,r.uint32()));break}case 20:{h.trainingInfo&&h.trainingInfo.length||(h.trainingInfo=[]),h.trainingInfo.push(s.onnx.TrainingInfoProto.decode(r,r.uint32()));break}case 25:{h.functions&&h.functions.length||(h.functions=[]),h.functions.push(s.onnx.FunctionProto.decode(r,r.uint32()));break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.irVersion!=null&&r.hasOwnProperty("irVersion")&&!o.isInteger(r.irVersion)&&!(r.irVersion&&o.isInteger(r.irVersion.low)&&o.isInteger(r.irVersion.high)))return"irVersion: integer|Long expected";if(r.opsetImport!=null&&r.hasOwnProperty("opsetImport")){if(!Array.isArray(r.opsetImport))return"opsetImport: array expected";for(var u=0;u<r.opsetImport.length;++u){var l=s.onnx.OperatorSetIdProto.verify(r.opsetImport[u]);if(l)return"opsetImport."+l}}if(r.producerName!=null&&r.hasOwnProperty("producerName")&&!o.isString(r.producerName))return"producerName: string expected";if(r.producerVersion!=null&&r.hasOwnProperty("producerVersion")&&!o.isString(r.producerVersion))return"producerVersion: string expected";if(r.domain!=null&&r.hasOwnProperty("domain")&&!o.isString(r.domain))return"domain: string expected";if(r.modelVersion!=null&&r.hasOwnProperty("modelVersion")&&!o.isInteger(r.modelVersion)&&!(r.modelVersion&&o.isInteger(r.modelVersion.low)&&o.isInteger(r.modelVersion.high)))return"modelVersion: integer|Long expected";if(r.docString!=null&&r.hasOwnProperty("docString")&&!o.isString(r.docString))return"docString: string expected";if(r.graph!=null&&r.hasOwnProperty("graph")){var l=s.onnx.GraphProto.verify(r.graph);if(l)return"graph."+l}if(r.metadataProps!=null&&r.hasOwnProperty("metadataProps")){if(!Array.isArray(r.metadataProps))return"metadataProps: array expected";for(var u=0;u<r.metadataProps.length;++u){var l=s.onnx.StringStringEntryProto.verify(r.metadataProps[u]);if(l)return"metadataProps."+l}}if(r.trainingInfo!=null&&r.hasOwnProperty("trainingInfo")){if(!Array.isArray(r.trainingInfo))return"trainingInfo: array expected";for(var u=0;u<r.trainingInfo.length;++u){var l=s.onnx.TrainingInfoProto.verify(r.trainingInfo[u]);if(l)return"trainingInfo."+l}}if(r.functions!=null&&r.hasOwnProperty("functions")){if(!Array.isArray(r.functions))return"functions: array expected";for(var u=0;u<r.functions.length;++u){var l=s.onnx.FunctionProto.verify(r.functions[u]);if(l)return"functions."+l}}return null},c.fromObject=function(r){if(r instanceof s.onnx.ModelProto)return r;var u=new s.onnx.ModelProto;if(r.irVersion!=null&&(o.Long?(u.irVersion=o.Long.fromValue(r.irVersion)).unsigned=!1:typeof r.irVersion=="string"?u.irVersion=parseInt(r.irVersion,10):typeof r.irVersion=="number"?u.irVersion=r.irVersion:typeof r.irVersion=="object"&&(u.irVersion=new o.LongBits(r.irVersion.low>>>0,r.irVersion.high>>>0).toNumber())),r.opsetImport){if(!Array.isArray(r.opsetImport))throw TypeError(".onnx.ModelProto.opsetImport: array expected");u.opsetImport=[];for(var l=0;l<r.opsetImport.length;++l){if(typeof r.opsetImport[l]!="object")throw TypeError(".onnx.ModelProto.opsetImport: object expected");u.opsetImport[l]=s.onnx.OperatorSetIdProto.fromObject(r.opsetImport[l])}}if(r.producerName!=null&&(u.producerName=String(r.producerName)),r.producerVersion!=null&&(u.producerVersion=String(r.producerVersion)),r.domain!=null&&(u.domain=String(r.domain)),r.modelVersion!=null&&(o.Long?(u.modelVersion=o.Long.fromValue(r.modelVersion)).unsigned=!1:typeof r.modelVersion=="string"?u.modelVersion=parseInt(r.modelVersion,10):typeof r.modelVersion=="number"?u.modelVersion=r.modelVersion:typeof r.modelVersion=="object"&&(u.modelVersion=new o.LongBits(r.modelVersion.low>>>0,r.modelVersion.high>>>0).toNumber())),r.docString!=null&&(u.docString=String(r.docString)),r.graph!=null){if(typeof r.graph!="object")throw TypeError(".onnx.ModelProto.graph: object expected");u.graph=s.onnx.GraphProto.fromObject(r.graph)}if(r.metadataProps){if(!Array.isArray(r.metadataProps))throw TypeError(".onnx.ModelProto.metadataProps: array expected");u.metadataProps=[];for(var l=0;l<r.metadataProps.length;++l){if(typeof r.metadataProps[l]!="object")throw TypeError(".onnx.ModelProto.metadataProps: object expected");u.metadataProps[l]=s.onnx.StringStringEntryProto.fromObject(r.metadataProps[l])}}if(r.trainingInfo){if(!Array.isArray(r.trainingInfo))throw TypeError(".onnx.ModelProto.trainingInfo: array expected");u.trainingInfo=[];for(var l=0;l<r.trainingInfo.length;++l){if(typeof r.trainingInfo[l]!="object")throw TypeError(".onnx.ModelProto.trainingInfo: object expected");u.trainingInfo[l]=s.onnx.TrainingInfoProto.fromObject(r.trainingInfo[l])}}if(r.functions){if(!Array.isArray(r.functions))throw TypeError(".onnx.ModelProto.functions: array expected");u.functions=[];for(var l=0;l<r.functions.length;++l){if(typeof r.functions[l]!="object")throw TypeError(".onnx.ModelProto.functions: object expected");u.functions[l]=s.onnx.FunctionProto.fromObject(r.functions[l])}}return u},c.toObject=function(r,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.opsetImport=[],l.metadataProps=[],l.trainingInfo=[],l.functions=[]),u.defaults){if(o.Long){var h=new o.Long(0,0,!1);l.irVersion=u.longs===String?h.toString():u.longs===Number?h.toNumber():h}else l.irVersion=u.longs===String?"0":0;if(l.producerName="",l.producerVersion="",l.domain="",o.Long){var h=new o.Long(0,0,!1);l.modelVersion=u.longs===String?h.toString():u.longs===Number?h.toNumber():h}else l.modelVersion=u.longs===String?"0":0;l.docString="",l.graph=null}if(r.irVersion!=null&&r.hasOwnProperty("irVersion")&&(typeof r.irVersion=="number"?l.irVersion=u.longs===String?String(r.irVersion):r.irVersion:l.irVersion=u.longs===String?o.Long.prototype.toString.call(r.irVersion):u.longs===Number?new o.LongBits(r.irVersion.low>>>0,r.irVersion.high>>>0).toNumber():r.irVersion),r.producerName!=null&&r.hasOwnProperty("producerName")&&(l.producerName=r.producerName),r.producerVersion!=null&&r.hasOwnProperty("producerVersion")&&(l.producerVersion=r.producerVersion),r.domain!=null&&r.hasOwnProperty("domain")&&(l.domain=r.domain),r.modelVersion!=null&&r.hasOwnProperty("modelVersion")&&(typeof r.modelVersion=="number"?l.modelVersion=u.longs===String?String(r.modelVersion):r.modelVersion:l.modelVersion=u.longs===String?o.Long.prototype.toString.call(r.modelVersion):u.longs===Number?new o.LongBits(r.modelVersion.low>>>0,r.modelVersion.high>>>0).toNumber():r.modelVersion),r.docString!=null&&r.hasOwnProperty("docString")&&(l.docString=r.docString),r.graph!=null&&r.hasOwnProperty("graph")&&(l.graph=s.onnx.GraphProto.toObject(r.graph,u)),r.opsetImport&&r.opsetImport.length){l.opsetImport=[];for(var f=0;f<r.opsetImport.length;++f)l.opsetImport[f]=s.onnx.OperatorSetIdProto.toObject(r.opsetImport[f],u)}if(r.metadataProps&&r.metadataProps.length){l.metadataProps=[];for(var f=0;f<r.metadataProps.length;++f)l.metadataProps[f]=s.onnx.StringStringEntryProto.toObject(r.metadataProps[f],u)}if(r.trainingInfo&&r.trainingInfo.length){l.trainingInfo=[];for(var f=0;f<r.trainingInfo.length;++f)l.trainingInfo[f]=s.onnx.TrainingInfoProto.toObject(r.trainingInfo[f],u)}if(r.functions&&r.functions.length){l.functions=[];for(var f=0;f<r.functions.length;++f)l.functions[f]=s.onnx.FunctionProto.toObject(r.functions[f],u)}return l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.ModelProto"},c}(),d.StringStringEntryProto=function(){function c(r){if(r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.key="",c.prototype.value="",c.create=function(r){return new c(r)},c.encode=function(r,u){return u||(u=p.create()),r.key!=null&&Object.hasOwnProperty.call(r,"key")&&u.uint32(10).string(r.key),r.value!=null&&Object.hasOwnProperty.call(r,"value")&&u.uint32(18).string(r.value),u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.StringStringEntryProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.key=r.string();break}case 2:{h.value=r.string();break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){return typeof r!="object"||r===null?"object expected":r.key!=null&&r.hasOwnProperty("key")&&!o.isString(r.key)?"key: string expected":r.value!=null&&r.hasOwnProperty("value")&&!o.isString(r.value)?"value: string expected":null},c.fromObject=function(r){if(r instanceof s.onnx.StringStringEntryProto)return r;var u=new s.onnx.StringStringEntryProto;return r.key!=null&&(u.key=String(r.key)),r.value!=null&&(u.value=String(r.value)),u},c.toObject=function(r,u){u||(u={});var l={};return u.defaults&&(l.key="",l.value=""),r.key!=null&&r.hasOwnProperty("key")&&(l.key=r.key),r.value!=null&&r.hasOwnProperty("value")&&(l.value=r.value),l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.StringStringEntryProto"},c}(),d.TensorAnnotation=function(){function c(r){if(this.quantParameterTensorNames=[],r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.tensorName="",c.prototype.quantParameterTensorNames=o.emptyArray,c.create=function(r){return new c(r)},c.encode=function(r,u){if(u||(u=p.create()),r.tensorName!=null&&Object.hasOwnProperty.call(r,"tensorName")&&u.uint32(10).string(r.tensorName),r.quantParameterTensorNames!=null&&r.quantParameterTensorNames.length)for(var l=0;l<r.quantParameterTensorNames.length;++l)s.onnx.StringStringEntryProto.encode(r.quantParameterTensorNames[l],u.uint32(18).fork()).ldelim();return u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.TensorAnnotation;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.tensorName=r.string();break}case 2:{h.quantParameterTensorNames&&h.quantParameterTensorNames.length||(h.quantParameterTensorNames=[]),h.quantParameterTensorNames.push(s.onnx.StringStringEntryProto.decode(r,r.uint32()));break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.tensorName!=null&&r.hasOwnProperty("tensorName")&&!o.isString(r.tensorName))return"tensorName: string expected";if(r.quantParameterTensorNames!=null&&r.hasOwnProperty("quantParameterTensorNames")){if(!Array.isArray(r.quantParameterTensorNames))return"quantParameterTensorNames: array expected";for(var u=0;u<r.quantParameterTensorNames.length;++u){var l=s.onnx.StringStringEntryProto.verify(r.quantParameterTensorNames[u]);if(l)return"quantParameterTensorNames."+l}}return null},c.fromObject=function(r){if(r instanceof s.onnx.TensorAnnotation)return r;var u=new s.onnx.TensorAnnotation;if(r.tensorName!=null&&(u.tensorName=String(r.tensorName)),r.quantParameterTensorNames){if(!Array.isArray(r.quantParameterTensorNames))throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");u.quantParameterTensorNames=[];for(var l=0;l<r.quantParameterTensorNames.length;++l){if(typeof r.quantParameterTensorNames[l]!="object")throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");u.quantParameterTensorNames[l]=s.onnx.StringStringEntryProto.fromObject(r.quantParameterTensorNames[l])}}return u},c.toObject=function(r,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.quantParameterTensorNames=[]),u.defaults&&(l.tensorName=""),r.tensorName!=null&&r.hasOwnProperty("tensorName")&&(l.tensorName=r.tensorName),r.quantParameterTensorNames&&r.quantParameterTensorNames.length){l.quantParameterTensorNames=[];for(var h=0;h<r.quantParameterTensorNames.length;++h)l.quantParameterTensorNames[h]=s.onnx.StringStringEntryProto.toObject(r.quantParameterTensorNames[h],u)}return l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TensorAnnotation"},c}(),d.GraphProto=function(){function c(r){if(this.node=[],this.initializer=[],this.sparseInitializer=[],this.input=[],this.output=[],this.valueInfo=[],this.quantizationAnnotation=[],r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.node=o.emptyArray,c.prototype.name="",c.prototype.initializer=o.emptyArray,c.prototype.sparseInitializer=o.emptyArray,c.prototype.docString="",c.prototype.input=o.emptyArray,c.prototype.output=o.emptyArray,c.prototype.valueInfo=o.emptyArray,c.prototype.quantizationAnnotation=o.emptyArray,c.create=function(r){return new c(r)},c.encode=function(r,u){if(u||(u=p.create()),r.node!=null&&r.node.length)for(var l=0;l<r.node.length;++l)s.onnx.NodeProto.encode(r.node[l],u.uint32(10).fork()).ldelim();if(r.name!=null&&Object.hasOwnProperty.call(r,"name")&&u.uint32(18).string(r.name),r.initializer!=null&&r.initializer.length)for(var l=0;l<r.initializer.length;++l)s.onnx.TensorProto.encode(r.initializer[l],u.uint32(42).fork()).ldelim();if(r.docString!=null&&Object.hasOwnProperty.call(r,"docString")&&u.uint32(82).string(r.docString),r.input!=null&&r.input.length)for(var l=0;l<r.input.length;++l)s.onnx.ValueInfoProto.encode(r.input[l],u.uint32(90).fork()).ldelim();if(r.output!=null&&r.output.length)for(var l=0;l<r.output.length;++l)s.onnx.ValueInfoProto.encode(r.output[l],u.uint32(98).fork()).ldelim();if(r.valueInfo!=null&&r.valueInfo.length)for(var l=0;l<r.valueInfo.length;++l)s.onnx.ValueInfoProto.encode(r.valueInfo[l],u.uint32(106).fork()).ldelim();if(r.quantizationAnnotation!=null&&r.quantizationAnnotation.length)for(var l=0;l<r.quantizationAnnotation.length;++l)s.onnx.TensorAnnotation.encode(r.quantizationAnnotation[l],u.uint32(114).fork()).ldelim();if(r.sparseInitializer!=null&&r.sparseInitializer.length)for(var l=0;l<r.sparseInitializer.length;++l)s.onnx.SparseTensorProto.encode(r.sparseInitializer[l],u.uint32(122).fork()).ldelim();return u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.GraphProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.node&&h.node.length||(h.node=[]),h.node.push(s.onnx.NodeProto.decode(r,r.uint32()));break}case 2:{h.name=r.string();break}case 5:{h.initializer&&h.initializer.length||(h.initializer=[]),h.initializer.push(s.onnx.TensorProto.decode(r,r.uint32()));break}case 15:{h.sparseInitializer&&h.sparseInitializer.length||(h.sparseInitializer=[]),h.sparseInitializer.push(s.onnx.SparseTensorProto.decode(r,r.uint32()));break}case 10:{h.docString=r.string();break}case 11:{h.input&&h.input.length||(h.input=[]),h.input.push(s.onnx.ValueInfoProto.decode(r,r.uint32()));break}case 12:{h.output&&h.output.length||(h.output=[]),h.output.push(s.onnx.ValueInfoProto.decode(r,r.uint32()));break}case 13:{h.valueInfo&&h.valueInfo.length||(h.valueInfo=[]),h.valueInfo.push(s.onnx.ValueInfoProto.decode(r,r.uint32()));break}case 14:{h.quantizationAnnotation&&h.quantizationAnnotation.length||(h.quantizationAnnotation=[]),h.quantizationAnnotation.push(s.onnx.TensorAnnotation.decode(r,r.uint32()));break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.node!=null&&r.hasOwnProperty("node")){if(!Array.isArray(r.node))return"node: array expected";for(var u=0;u<r.node.length;++u){var l=s.onnx.NodeProto.verify(r.node[u]);if(l)return"node."+l}}if(r.name!=null&&r.hasOwnProperty("name")&&!o.isString(r.name))return"name: string expected";if(r.initializer!=null&&r.hasOwnProperty("initializer")){if(!Array.isArray(r.initializer))return"initializer: array expected";for(var u=0;u<r.initializer.length;++u){var l=s.onnx.TensorProto.verify(r.initializer[u]);if(l)return"initializer."+l}}if(r.sparseInitializer!=null&&r.hasOwnProperty("sparseInitializer")){if(!Array.isArray(r.sparseInitializer))return"sparseInitializer: array expected";for(var u=0;u<r.sparseInitializer.length;++u){var l=s.onnx.SparseTensorProto.verify(r.sparseInitializer[u]);if(l)return"sparseInitializer."+l}}if(r.docString!=null&&r.hasOwnProperty("docString")&&!o.isString(r.docString))return"docString: string expected";if(r.input!=null&&r.hasOwnProperty("input")){if(!Array.isArray(r.input))return"input: array expected";for(var u=0;u<r.input.length;++u){var l=s.onnx.ValueInfoProto.verify(r.input[u]);if(l)return"input."+l}}if(r.output!=null&&r.hasOwnProperty("output")){if(!Array.isArray(r.output))return"output: array expected";for(var u=0;u<r.output.length;++u){var l=s.onnx.ValueInfoProto.verify(r.output[u]);if(l)return"output."+l}}if(r.valueInfo!=null&&r.hasOwnProperty("valueInfo")){if(!Array.isArray(r.valueInfo))return"valueInfo: array expected";for(var u=0;u<r.valueInfo.length;++u){var l=s.onnx.ValueInfoProto.verify(r.valueInfo[u]);if(l)return"valueInfo."+l}}if(r.quantizationAnnotation!=null&&r.hasOwnProperty("quantizationAnnotation")){if(!Array.isArray(r.quantizationAnnotation))return"quantizationAnnotation: array expected";for(var u=0;u<r.quantizationAnnotation.length;++u){var l=s.onnx.TensorAnnotation.verify(r.quantizationAnnotation[u]);if(l)return"quantizationAnnotation."+l}}return null},c.fromObject=function(r){if(r instanceof s.onnx.GraphProto)return r;var u=new s.onnx.GraphProto;if(r.node){if(!Array.isArray(r.node))throw TypeError(".onnx.GraphProto.node: array expected");u.node=[];for(var l=0;l<r.node.length;++l){if(typeof r.node[l]!="object")throw TypeError(".onnx.GraphProto.node: object expected");u.node[l]=s.onnx.NodeProto.fromObject(r.node[l])}}if(r.name!=null&&(u.name=String(r.name)),r.initializer){if(!Array.isArray(r.initializer))throw TypeError(".onnx.GraphProto.initializer: array expected");u.initializer=[];for(var l=0;l<r.initializer.length;++l){if(typeof r.initializer[l]!="object")throw TypeError(".onnx.GraphProto.initializer: object expected");u.initializer[l]=s.onnx.TensorProto.fromObject(r.initializer[l])}}if(r.sparseInitializer){if(!Array.isArray(r.sparseInitializer))throw TypeError(".onnx.GraphProto.sparseInitializer: array expected");u.sparseInitializer=[];for(var l=0;l<r.sparseInitializer.length;++l){if(typeof r.sparseInitializer[l]!="object")throw TypeError(".onnx.GraphProto.sparseInitializer: object expected");u.sparseInitializer[l]=s.onnx.SparseTensorProto.fromObject(r.sparseInitializer[l])}}if(r.docString!=null&&(u.docString=String(r.docString)),r.input){if(!Array.isArray(r.input))throw TypeError(".onnx.GraphProto.input: array expected");u.input=[];for(var l=0;l<r.input.length;++l){if(typeof r.input[l]!="object")throw TypeError(".onnx.GraphProto.input: object expected");u.input[l]=s.onnx.ValueInfoProto.fromObject(r.input[l])}}if(r.output){if(!Array.isArray(r.output))throw TypeError(".onnx.GraphProto.output: array expected");u.output=[];for(var l=0;l<r.output.length;++l){if(typeof r.output[l]!="object")throw TypeError(".onnx.GraphProto.output: object expected");u.output[l]=s.onnx.ValueInfoProto.fromObject(r.output[l])}}if(r.valueInfo){if(!Array.isArray(r.valueInfo))throw TypeError(".onnx.GraphProto.valueInfo: array expected");u.valueInfo=[];for(var l=0;l<r.valueInfo.length;++l){if(typeof r.valueInfo[l]!="object")throw TypeError(".onnx.GraphProto.valueInfo: object expected");u.valueInfo[l]=s.onnx.ValueInfoProto.fromObject(r.valueInfo[l])}}if(r.quantizationAnnotation){if(!Array.isArray(r.quantizationAnnotation))throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");u.quantizationAnnotation=[];for(var l=0;l<r.quantizationAnnotation.length;++l){if(typeof r.quantizationAnnotation[l]!="object")throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");u.quantizationAnnotation[l]=s.onnx.TensorAnnotation.fromObject(r.quantizationAnnotation[l])}}return u},c.toObject=function(r,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.node=[],l.initializer=[],l.input=[],l.output=[],l.valueInfo=[],l.quantizationAnnotation=[],l.sparseInitializer=[]),u.defaults&&(l.name="",l.docString=""),r.node&&r.node.length){l.node=[];for(var h=0;h<r.node.length;++h)l.node[h]=s.onnx.NodeProto.toObject(r.node[h],u)}if(r.name!=null&&r.hasOwnProperty("name")&&(l.name=r.name),r.initializer&&r.initializer.length){l.initializer=[];for(var h=0;h<r.initializer.length;++h)l.initializer[h]=s.onnx.TensorProto.toObject(r.initializer[h],u)}if(r.docString!=null&&r.hasOwnProperty("docString")&&(l.docString=r.docString),r.input&&r.input.length){l.input=[];for(var h=0;h<r.input.length;++h)l.input[h]=s.onnx.ValueInfoProto.toObject(r.input[h],u)}if(r.output&&r.output.length){l.output=[];for(var h=0;h<r.output.length;++h)l.output[h]=s.onnx.ValueInfoProto.toObject(r.output[h],u)}if(r.valueInfo&&r.valueInfo.length){l.valueInfo=[];for(var h=0;h<r.valueInfo.length;++h)l.valueInfo[h]=s.onnx.ValueInfoProto.toObject(r.valueInfo[h],u)}if(r.quantizationAnnotation&&r.quantizationAnnotation.length){l.quantizationAnnotation=[];for(var h=0;h<r.quantizationAnnotation.length;++h)l.quantizationAnnotation[h]=s.onnx.TensorAnnotation.toObject(r.quantizationAnnotation[h],u)}if(r.sparseInitializer&&r.sparseInitializer.length){l.sparseInitializer=[];for(var h=0;h<r.sparseInitializer.length;++h)l.sparseInitializer[h]=s.onnx.SparseTensorProto.toObject(r.sparseInitializer[h],u)}return l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.GraphProto"},c}(),d.TensorProto=function(){function c(r){if(this.dims=[],this.floatData=[],this.int32Data=[],this.stringData=[],this.int64Data=[],this.externalData=[],this.doubleData=[],this.uint64Data=[],r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.dims=o.emptyArray,c.prototype.dataType=0,c.prototype.segment=null,c.prototype.floatData=o.emptyArray,c.prototype.int32Data=o.emptyArray,c.prototype.stringData=o.emptyArray,c.prototype.int64Data=o.emptyArray,c.prototype.name="",c.prototype.docString="",c.prototype.rawData=o.newBuffer([]),c.prototype.externalData=o.emptyArray,c.prototype.dataLocation=0,c.prototype.doubleData=o.emptyArray,c.prototype.uint64Data=o.emptyArray,c.create=function(r){return new c(r)},c.encode=function(r,u){if(u||(u=p.create()),r.dims!=null&&r.dims.length){u.uint32(10).fork();for(var l=0;l<r.dims.length;++l)u.int64(r.dims[l]);u.ldelim()}if(r.dataType!=null&&Object.hasOwnProperty.call(r,"dataType")&&u.uint32(16).int32(r.dataType),r.segment!=null&&Object.hasOwnProperty.call(r,"segment")&&s.onnx.TensorProto.Segment.encode(r.segment,u.uint32(26).fork()).ldelim(),r.floatData!=null&&r.floatData.length){u.uint32(34).fork();for(var l=0;l<r.floatData.length;++l)u.float(r.floatData[l]);u.ldelim()}if(r.int32Data!=null&&r.int32Data.length){u.uint32(42).fork();for(var l=0;l<r.int32Data.length;++l)u.int32(r.int32Data[l]);u.ldelim()}if(r.stringData!=null&&r.stringData.length)for(var l=0;l<r.stringData.length;++l)u.uint32(50).bytes(r.stringData[l]);if(r.int64Data!=null&&r.int64Data.length){u.uint32(58).fork();for(var l=0;l<r.int64Data.length;++l)u.int64(r.int64Data[l]);u.ldelim()}if(r.name!=null&&Object.hasOwnProperty.call(r,"name")&&u.uint32(66).string(r.name),r.rawData!=null&&Object.hasOwnProperty.call(r,"rawData")&&u.uint32(74).bytes(r.rawData),r.doubleData!=null&&r.doubleData.length){u.uint32(82).fork();for(var l=0;l<r.doubleData.length;++l)u.double(r.doubleData[l]);u.ldelim()}if(r.uint64Data!=null&&r.uint64Data.length){u.uint32(90).fork();for(var l=0;l<r.uint64Data.length;++l)u.uint64(r.uint64Data[l]);u.ldelim()}if(r.docString!=null&&Object.hasOwnProperty.call(r,"docString")&&u.uint32(98).string(r.docString),r.externalData!=null&&r.externalData.length)for(var l=0;l<r.externalData.length;++l)s.onnx.StringStringEntryProto.encode(r.externalData[l],u.uint32(106).fork()).ldelim();return r.dataLocation!=null&&Object.hasOwnProperty.call(r,"dataLocation")&&u.uint32(112).int32(r.dataLocation),u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.TensorProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{if(h.dims&&h.dims.length||(h.dims=[]),(f&7)===2)for(var m=r.uint32()+r.pos;r.pos<m;)h.dims.push(r.int64());else h.dims.push(r.int64());break}case 2:{h.dataType=r.int32();break}case 3:{h.segment=s.onnx.TensorProto.Segment.decode(r,r.uint32());break}case 4:{if(h.floatData&&h.floatData.length||(h.floatData=[]),(f&7)===2)for(var m=r.uint32()+r.pos;r.pos<m;)h.floatData.push(r.float());else h.floatData.push(r.float());break}case 5:{if(h.int32Data&&h.int32Data.length||(h.int32Data=[]),(f&7)===2)for(var m=r.uint32()+r.pos;r.pos<m;)h.int32Data.push(r.int32());else h.int32Data.push(r.int32());break}case 6:{h.stringData&&h.stringData.length||(h.stringData=[]),h.stringData.push(r.bytes());break}case 7:{if(h.int64Data&&h.int64Data.length||(h.int64Data=[]),(f&7)===2)for(var m=r.uint32()+r.pos;r.pos<m;)h.int64Data.push(r.int64());else h.int64Data.push(r.int64());break}case 8:{h.name=r.string();break}case 12:{h.docString=r.string();break}case 9:{h.rawData=r.bytes();break}case 13:{h.externalData&&h.externalData.length||(h.externalData=[]),h.externalData.push(s.onnx.StringStringEntryProto.decode(r,r.uint32()));break}case 14:{h.dataLocation=r.int32();break}case 10:{if(h.doubleData&&h.doubleData.length||(h.doubleData=[]),(f&7)===2)for(var m=r.uint32()+r.pos;r.pos<m;)h.doubleData.push(r.double());else h.doubleData.push(r.double());break}case 11:{if(h.uint64Data&&h.uint64Data.length||(h.uint64Data=[]),(f&7)===2)for(var m=r.uint32()+r.pos;r.pos<m;)h.uint64Data.push(r.uint64());else h.uint64Data.push(r.uint64());break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.dims!=null&&r.hasOwnProperty("dims")){if(!Array.isArray(r.dims))return"dims: array expected";for(var u=0;u<r.dims.length;++u)if(!o.isInteger(r.dims[u])&&!(r.dims[u]&&o.isInteger(r.dims[u].low)&&o.isInteger(r.dims[u].high)))return"dims: integer|Long[] expected"}if(r.dataType!=null&&r.hasOwnProperty("dataType")&&!o.isInteger(r.dataType))return"dataType: integer expected";if(r.segment!=null&&r.hasOwnProperty("segment")){var l=s.onnx.TensorProto.Segment.verify(r.segment);if(l)return"segment."+l}if(r.floatData!=null&&r.hasOwnProperty("floatData")){if(!Array.isArray(r.floatData))return"floatData: array expected";for(var u=0;u<r.floatData.length;++u)if(typeof r.floatData[u]!="number")return"floatData: number[] expected"}if(r.int32Data!=null&&r.hasOwnProperty("int32Data")){if(!Array.isArray(r.int32Data))return"int32Data: array expected";for(var u=0;u<r.int32Data.length;++u)if(!o.isInteger(r.int32Data[u]))return"int32Data: integer[] expected"}if(r.stringData!=null&&r.hasOwnProperty("stringData")){if(!Array.isArray(r.stringData))return"stringData: array expected";for(var u=0;u<r.stringData.length;++u)if(!(r.stringData[u]&&typeof r.stringData[u].length=="number"||o.isString(r.stringData[u])))return"stringData: buffer[] expected"}if(r.int64Data!=null&&r.hasOwnProperty("int64Data")){if(!Array.isArray(r.int64Data))return"int64Data: array expected";for(var u=0;u<r.int64Data.length;++u)if(!o.isInteger(r.int64Data[u])&&!(r.int64Data[u]&&o.isInteger(r.int64Data[u].low)&&o.isInteger(r.int64Data[u].high)))return"int64Data: integer|Long[] expected"}if(r.name!=null&&r.hasOwnProperty("name")&&!o.isString(r.name))return"name: string expected";if(r.docString!=null&&r.hasOwnProperty("docString")&&!o.isString(r.docString))return"docString: string expected";if(r.rawData!=null&&r.hasOwnProperty("rawData")&&!(r.rawData&&typeof r.rawData.length=="number"||o.isString(r.rawData)))return"rawData: buffer expected";if(r.externalData!=null&&r.hasOwnProperty("externalData")){if(!Array.isArray(r.externalData))return"externalData: array expected";for(var u=0;u<r.externalData.length;++u){var l=s.onnx.StringStringEntryProto.verify(r.externalData[u]);if(l)return"externalData."+l}}if(r.dataLocation!=null&&r.hasOwnProperty("dataLocation"))switch(r.dataLocation){default:return"dataLocation: enum value expected";case 0:case 1:break}if(r.doubleData!=null&&r.hasOwnProperty("doubleData")){if(!Array.isArray(r.doubleData))return"doubleData: array expected";for(var u=0;u<r.doubleData.length;++u)if(typeof r.doubleData[u]!="number")return"doubleData: number[] expected"}if(r.uint64Data!=null&&r.hasOwnProperty("uint64Data")){if(!Array.isArray(r.uint64Data))return"uint64Data: array expected";for(var u=0;u<r.uint64Data.length;++u)if(!o.isInteger(r.uint64Data[u])&&!(r.uint64Data[u]&&o.isInteger(r.uint64Data[u].low)&&o.isInteger(r.uint64Data[u].high)))return"uint64Data: integer|Long[] expected"}return null},c.fromObject=function(r){if(r instanceof s.onnx.TensorProto)return r;var u=new s.onnx.TensorProto;if(r.dims){if(!Array.isArray(r.dims))throw TypeError(".onnx.TensorProto.dims: array expected");u.dims=[];for(var l=0;l<r.dims.length;++l)o.Long?(u.dims[l]=o.Long.fromValue(r.dims[l])).unsigned=!1:typeof r.dims[l]=="string"?u.dims[l]=parseInt(r.dims[l],10):typeof r.dims[l]=="number"?u.dims[l]=r.dims[l]:typeof r.dims[l]=="object"&&(u.dims[l]=new o.LongBits(r.dims[l].low>>>0,r.dims[l].high>>>0).toNumber())}if(r.dataType!=null&&(u.dataType=r.dataType|0),r.segment!=null){if(typeof r.segment!="object")throw TypeError(".onnx.TensorProto.segment: object expected");u.segment=s.onnx.TensorProto.Segment.fromObject(r.segment)}if(r.floatData){if(!Array.isArray(r.floatData))throw TypeError(".onnx.TensorProto.floatData: array expected");u.floatData=[];for(var l=0;l<r.floatData.length;++l)u.floatData[l]=Number(r.floatData[l])}if(r.int32Data){if(!Array.isArray(r.int32Data))throw TypeError(".onnx.TensorProto.int32Data: array expected");u.int32Data=[];for(var l=0;l<r.int32Data.length;++l)u.int32Data[l]=r.int32Data[l]|0}if(r.stringData){if(!Array.isArray(r.stringData))throw TypeError(".onnx.TensorProto.stringData: array expected");u.stringData=[];for(var l=0;l<r.stringData.length;++l)typeof r.stringData[l]=="string"?o.base64.decode(r.stringData[l],u.stringData[l]=o.newBuffer(o.base64.length(r.stringData[l])),0):r.stringData[l].length>=0&&(u.stringData[l]=r.stringData[l])}if(r.int64Data){if(!Array.isArray(r.int64Data))throw TypeError(".onnx.TensorProto.int64Data: array expected");u.int64Data=[];for(var l=0;l<r.int64Data.length;++l)o.Long?(u.int64Data[l]=o.Long.fromValue(r.int64Data[l])).unsigned=!1:typeof r.int64Data[l]=="string"?u.int64Data[l]=parseInt(r.int64Data[l],10):typeof r.int64Data[l]=="number"?u.int64Data[l]=r.int64Data[l]:typeof r.int64Data[l]=="object"&&(u.int64Data[l]=new o.LongBits(r.int64Data[l].low>>>0,r.int64Data[l].high>>>0).toNumber())}if(r.name!=null&&(u.name=String(r.name)),r.docString!=null&&(u.docString=String(r.docString)),r.rawData!=null&&(typeof r.rawData=="string"?o.base64.decode(r.rawData,u.rawData=o.newBuffer(o.base64.length(r.rawData)),0):r.rawData.length>=0&&(u.rawData=r.rawData)),r.externalData){if(!Array.isArray(r.externalData))throw TypeError(".onnx.TensorProto.externalData: array expected");u.externalData=[];for(var l=0;l<r.externalData.length;++l){if(typeof r.externalData[l]!="object")throw TypeError(".onnx.TensorProto.externalData: object expected");u.externalData[l]=s.onnx.StringStringEntryProto.fromObject(r.externalData[l])}}switch(r.dataLocation){default:if(typeof r.dataLocation=="number"){u.dataLocation=r.dataLocation;break}break;case"DEFAULT":case 0:u.dataLocation=0;break;case"EXTERNAL":case 1:u.dataLocation=1;break}if(r.doubleData){if(!Array.isArray(r.doubleData))throw TypeError(".onnx.TensorProto.doubleData: array expected");u.doubleData=[];for(var l=0;l<r.doubleData.length;++l)u.doubleData[l]=Number(r.doubleData[l])}if(r.uint64Data){if(!Array.isArray(r.uint64Data))throw TypeError(".onnx.TensorProto.uint64Data: array expected");u.uint64Data=[];for(var l=0;l<r.uint64Data.length;++l)o.Long?(u.uint64Data[l]=o.Long.fromValue(r.uint64Data[l])).unsigned=!0:typeof r.uint64Data[l]=="string"?u.uint64Data[l]=parseInt(r.uint64Data[l],10):typeof r.uint64Data[l]=="number"?u.uint64Data[l]=r.uint64Data[l]:typeof r.uint64Data[l]=="object"&&(u.uint64Data[l]=new o.LongBits(r.uint64Data[l].low>>>0,r.uint64Data[l].high>>>0).toNumber(!0))}return u},c.toObject=function(r,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.dims=[],l.floatData=[],l.int32Data=[],l.stringData=[],l.int64Data=[],l.doubleData=[],l.uint64Data=[],l.externalData=[]),u.defaults&&(l.dataType=0,l.segment=null,l.name="",u.bytes===String?l.rawData="":(l.rawData=[],u.bytes!==Array&&(l.rawData=o.newBuffer(l.rawData))),l.docString="",l.dataLocation=u.enums===String?"DEFAULT":0),r.dims&&r.dims.length){l.dims=[];for(var h=0;h<r.dims.length;++h)typeof r.dims[h]=="number"?l.dims[h]=u.longs===String?String(r.dims[h]):r.dims[h]:l.dims[h]=u.longs===String?o.Long.prototype.toString.call(r.dims[h]):u.longs===Number?new o.LongBits(r.dims[h].low>>>0,r.dims[h].high>>>0).toNumber():r.dims[h]}if(r.dataType!=null&&r.hasOwnProperty("dataType")&&(l.dataType=r.dataType),r.segment!=null&&r.hasOwnProperty("segment")&&(l.segment=s.onnx.TensorProto.Segment.toObject(r.segment,u)),r.floatData&&r.floatData.length){l.floatData=[];for(var h=0;h<r.floatData.length;++h)l.floatData[h]=u.json&&!isFinite(r.floatData[h])?String(r.floatData[h]):r.floatData[h]}if(r.int32Data&&r.int32Data.length){l.int32Data=[];for(var h=0;h<r.int32Data.length;++h)l.int32Data[h]=r.int32Data[h]}if(r.stringData&&r.stringData.length){l.stringData=[];for(var h=0;h<r.stringData.length;++h)l.stringData[h]=u.bytes===String?o.base64.encode(r.stringData[h],0,r.stringData[h].length):u.bytes===Array?Array.prototype.slice.call(r.stringData[h]):r.stringData[h]}if(r.int64Data&&r.int64Data.length){l.int64Data=[];for(var h=0;h<r.int64Data.length;++h)typeof r.int64Data[h]=="number"?l.int64Data[h]=u.longs===String?String(r.int64Data[h]):r.int64Data[h]:l.int64Data[h]=u.longs===String?o.Long.prototype.toString.call(r.int64Data[h]):u.longs===Number?new o.LongBits(r.int64Data[h].low>>>0,r.int64Data[h].high>>>0).toNumber():r.int64Data[h]}if(r.name!=null&&r.hasOwnProperty("name")&&(l.name=r.name),r.rawData!=null&&r.hasOwnProperty("rawData")&&(l.rawData=u.bytes===String?o.base64.encode(r.rawData,0,r.rawData.length):u.bytes===Array?Array.prototype.slice.call(r.rawData):r.rawData),r.doubleData&&r.doubleData.length){l.doubleData=[];for(var h=0;h<r.doubleData.length;++h)l.doubleData[h]=u.json&&!isFinite(r.doubleData[h])?String(r.doubleData[h]):r.doubleData[h]}if(r.uint64Data&&r.uint64Data.length){l.uint64Data=[];for(var h=0;h<r.uint64Data.length;++h)typeof r.uint64Data[h]=="number"?l.uint64Data[h]=u.longs===String?String(r.uint64Data[h]):r.uint64Data[h]:l.uint64Data[h]=u.longs===String?o.Long.prototype.toString.call(r.uint64Data[h]):u.longs===Number?new o.LongBits(r.uint64Data[h].low>>>0,r.uint64Data[h].high>>>0).toNumber(!0):r.uint64Data[h]}if(r.docString!=null&&r.hasOwnProperty("docString")&&(l.docString=r.docString),r.externalData&&r.externalData.length){l.externalData=[];for(var h=0;h<r.externalData.length;++h)l.externalData[h]=s.onnx.StringStringEntryProto.toObject(r.externalData[h],u)}return r.dataLocation!=null&&r.hasOwnProperty("dataLocation")&&(l.dataLocation=u.enums===String?s.onnx.TensorProto.DataLocation[r.dataLocation]===void 0?r.dataLocation:s.onnx.TensorProto.DataLocation[r.dataLocation]:r.dataLocation),l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TensorProto"},c.DataType=function(){var r={},u=Object.create(r);return u[r[0]="UNDEFINED"]=0,u[r[1]="FLOAT"]=1,u[r[2]="UINT8"]=2,u[r[3]="INT8"]=3,u[r[4]="UINT16"]=4,u[r[5]="INT16"]=5,u[r[6]="INT32"]=6,u[r[7]="INT64"]=7,u[r[8]="STRING"]=8,u[r[9]="BOOL"]=9,u[r[10]="FLOAT16"]=10,u[r[11]="DOUBLE"]=11,u[r[12]="UINT32"]=12,u[r[13]="UINT64"]=13,u[r[14]="COMPLEX64"]=14,u[r[15]="COMPLEX128"]=15,u[r[16]="BFLOAT16"]=16,u[r[17]="FLOAT8E4M3FN"]=17,u[r[18]="FLOAT8E4M3FNUZ"]=18,u[r[19]="FLOAT8E5M2"]=19,u[r[20]="FLOAT8E5M2FNUZ"]=20,u}(),c.Segment=function(){function r(u){if(u)for(var l=Object.keys(u),h=0;h<l.length;++h)u[l[h]]!=null&&(this[l[h]]=u[l[h]])}return r.prototype.begin=o.Long?o.Long.fromBits(0,0,!1):0,r.prototype.end=o.Long?o.Long.fromBits(0,0,!1):0,r.create=function(u){return new r(u)},r.encode=function(u,l){return l||(l=p.create()),u.begin!=null&&Object.hasOwnProperty.call(u,"begin")&&l.uint32(8).int64(u.begin),u.end!=null&&Object.hasOwnProperty.call(u,"end")&&l.uint32(16).int64(u.end),l},r.encodeDelimited=function(u,l){return this.encode(u,l).ldelim()},r.decode=function(u,l){u instanceof a||(u=a.create(u));for(var h=l===void 0?u.len:u.pos+l,f=new s.onnx.TensorProto.Segment;u.pos<h;){var m=u.uint32();switch(m>>>3){case 1:{f.begin=u.int64();break}case 2:{f.end=u.int64();break}default:u.skipType(m&7);break}}return f},r.decodeDelimited=function(u){return u instanceof a||(u=new a(u)),this.decode(u,u.uint32())},r.verify=function(u){return typeof u!="object"||u===null?"object expected":u.begin!=null&&u.hasOwnProperty("begin")&&!o.isInteger(u.begin)&&!(u.begin&&o.isInteger(u.begin.low)&&o.isInteger(u.begin.high))?"begin: integer|Long expected":u.end!=null&&u.hasOwnProperty("end")&&!o.isInteger(u.end)&&!(u.end&&o.isInteger(u.end.low)&&o.isInteger(u.end.high))?"end: integer|Long expected":null},r.fromObject=function(u){if(u instanceof s.onnx.TensorProto.Segment)return u;var l=new s.onnx.TensorProto.Segment;return u.begin!=null&&(o.Long?(l.begin=o.Long.fromValue(u.begin)).unsigned=!1:typeof u.begin=="string"?l.begin=parseInt(u.begin,10):typeof u.begin=="number"?l.begin=u.begin:typeof u.begin=="object"&&(l.begin=new o.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber())),u.end!=null&&(o.Long?(l.end=o.Long.fromValue(u.end)).unsigned=!1:typeof u.end=="string"?l.end=parseInt(u.end,10):typeof u.end=="number"?l.end=u.end:typeof u.end=="object"&&(l.end=new o.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber())),l},r.toObject=function(u,l){l||(l={});var h={};if(l.defaults){if(o.Long){var f=new o.Long(0,0,!1);h.begin=l.longs===String?f.toString():l.longs===Number?f.toNumber():f}else h.begin=l.longs===String?"0":0;if(o.Long){var f=new o.Long(0,0,!1);h.end=l.longs===String?f.toString():l.longs===Number?f.toNumber():f}else h.end=l.longs===String?"0":0}return u.begin!=null&&u.hasOwnProperty("begin")&&(typeof u.begin=="number"?h.begin=l.longs===String?String(u.begin):u.begin:h.begin=l.longs===String?o.Long.prototype.toString.call(u.begin):l.longs===Number?new o.LongBits(u.begin.low>>>0,u.begin.high>>>0).toNumber():u.begin),u.end!=null&&u.hasOwnProperty("end")&&(typeof u.end=="number"?h.end=l.longs===String?String(u.end):u.end:h.end=l.longs===String?o.Long.prototype.toString.call(u.end):l.longs===Number?new o.LongBits(u.end.low>>>0,u.end.high>>>0).toNumber():u.end),h},r.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},r.getTypeUrl=function(u){return u===void 0&&(u="type.googleapis.com"),u+"/onnx.TensorProto.Segment"},r}(),c.DataLocation=function(){var r={},u=Object.create(r);return u[r[0]="DEFAULT"]=0,u[r[1]="EXTERNAL"]=1,u}(),c}(),d.SparseTensorProto=function(){function c(r){if(this.dims=[],r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.values=null,c.prototype.indices=null,c.prototype.dims=o.emptyArray,c.create=function(r){return new c(r)},c.encode=function(r,u){if(u||(u=p.create()),r.values!=null&&Object.hasOwnProperty.call(r,"values")&&s.onnx.TensorProto.encode(r.values,u.uint32(10).fork()).ldelim(),r.indices!=null&&Object.hasOwnProperty.call(r,"indices")&&s.onnx.TensorProto.encode(r.indices,u.uint32(18).fork()).ldelim(),r.dims!=null&&r.dims.length){u.uint32(26).fork();for(var l=0;l<r.dims.length;++l)u.int64(r.dims[l]);u.ldelim()}return u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.SparseTensorProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.values=s.onnx.TensorProto.decode(r,r.uint32());break}case 2:{h.indices=s.onnx.TensorProto.decode(r,r.uint32());break}case 3:{if(h.dims&&h.dims.length||(h.dims=[]),(f&7)===2)for(var m=r.uint32()+r.pos;r.pos<m;)h.dims.push(r.int64());else h.dims.push(r.int64());break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.values!=null&&r.hasOwnProperty("values")){var u=s.onnx.TensorProto.verify(r.values);if(u)return"values."+u}if(r.indices!=null&&r.hasOwnProperty("indices")){var u=s.onnx.TensorProto.verify(r.indices);if(u)return"indices."+u}if(r.dims!=null&&r.hasOwnProperty("dims")){if(!Array.isArray(r.dims))return"dims: array expected";for(var l=0;l<r.dims.length;++l)if(!o.isInteger(r.dims[l])&&!(r.dims[l]&&o.isInteger(r.dims[l].low)&&o.isInteger(r.dims[l].high)))return"dims: integer|Long[] expected"}return null},c.fromObject=function(r){if(r instanceof s.onnx.SparseTensorProto)return r;var u=new s.onnx.SparseTensorProto;if(r.values!=null){if(typeof r.values!="object")throw TypeError(".onnx.SparseTensorProto.values: object expected");u.values=s.onnx.TensorProto.fromObject(r.values)}if(r.indices!=null){if(typeof r.indices!="object")throw TypeError(".onnx.SparseTensorProto.indices: object expected");u.indices=s.onnx.TensorProto.fromObject(r.indices)}if(r.dims){if(!Array.isArray(r.dims))throw TypeError(".onnx.SparseTensorProto.dims: array expected");u.dims=[];for(var l=0;l<r.dims.length;++l)o.Long?(u.dims[l]=o.Long.fromValue(r.dims[l])).unsigned=!1:typeof r.dims[l]=="string"?u.dims[l]=parseInt(r.dims[l],10):typeof r.dims[l]=="number"?u.dims[l]=r.dims[l]:typeof r.dims[l]=="object"&&(u.dims[l]=new o.LongBits(r.dims[l].low>>>0,r.dims[l].high>>>0).toNumber())}return u},c.toObject=function(r,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.dims=[]),u.defaults&&(l.values=null,l.indices=null),r.values!=null&&r.hasOwnProperty("values")&&(l.values=s.onnx.TensorProto.toObject(r.values,u)),r.indices!=null&&r.hasOwnProperty("indices")&&(l.indices=s.onnx.TensorProto.toObject(r.indices,u)),r.dims&&r.dims.length){l.dims=[];for(var h=0;h<r.dims.length;++h)typeof r.dims[h]=="number"?l.dims[h]=u.longs===String?String(r.dims[h]):r.dims[h]:l.dims[h]=u.longs===String?o.Long.prototype.toString.call(r.dims[h]):u.longs===Number?new o.LongBits(r.dims[h].low>>>0,r.dims[h].high>>>0).toNumber():r.dims[h]}return l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.SparseTensorProto"},c}(),d.TensorShapeProto=function(){function c(r){if(this.dim=[],r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.dim=o.emptyArray,c.create=function(r){return new c(r)},c.encode=function(r,u){if(u||(u=p.create()),r.dim!=null&&r.dim.length)for(var l=0;l<r.dim.length;++l)s.onnx.TensorShapeProto.Dimension.encode(r.dim[l],u.uint32(10).fork()).ldelim();return u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.TensorShapeProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.dim&&h.dim.length||(h.dim=[]),h.dim.push(s.onnx.TensorShapeProto.Dimension.decode(r,r.uint32()));break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.dim!=null&&r.hasOwnProperty("dim")){if(!Array.isArray(r.dim))return"dim: array expected";for(var u=0;u<r.dim.length;++u){var l=s.onnx.TensorShapeProto.Dimension.verify(r.dim[u]);if(l)return"dim."+l}}return null},c.fromObject=function(r){if(r instanceof s.onnx.TensorShapeProto)return r;var u=new s.onnx.TensorShapeProto;if(r.dim){if(!Array.isArray(r.dim))throw TypeError(".onnx.TensorShapeProto.dim: array expected");u.dim=[];for(var l=0;l<r.dim.length;++l){if(typeof r.dim[l]!="object")throw TypeError(".onnx.TensorShapeProto.dim: object expected");u.dim[l]=s.onnx.TensorShapeProto.Dimension.fromObject(r.dim[l])}}return u},c.toObject=function(r,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.dim=[]),r.dim&&r.dim.length){l.dim=[];for(var h=0;h<r.dim.length;++h)l.dim[h]=s.onnx.TensorShapeProto.Dimension.toObject(r.dim[h],u)}return l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.TensorShapeProto"},c.Dimension=function(){function r(l){if(l)for(var h=Object.keys(l),f=0;f<h.length;++f)l[h[f]]!=null&&(this[h[f]]=l[h[f]])}r.prototype.dimValue=null,r.prototype.dimParam=null,r.prototype.denotation="";var u;return Object.defineProperty(r.prototype,"value",{get:o.oneOfGetter(u=["dimValue","dimParam"]),set:o.oneOfSetter(u)}),r.create=function(l){return new r(l)},r.encode=function(l,h){return h||(h=p.create()),l.dimValue!=null&&Object.hasOwnProperty.call(l,"dimValue")&&h.uint32(8).int64(l.dimValue),l.dimParam!=null&&Object.hasOwnProperty.call(l,"dimParam")&&h.uint32(18).string(l.dimParam),l.denotation!=null&&Object.hasOwnProperty.call(l,"denotation")&&h.uint32(26).string(l.denotation),h},r.encodeDelimited=function(l,h){return this.encode(l,h).ldelim()},r.decode=function(l,h){l instanceof a||(l=a.create(l));for(var f=h===void 0?l.len:l.pos+h,m=new s.onnx.TensorShapeProto.Dimension;l.pos<f;){var y=l.uint32();switch(y>>>3){case 1:{m.dimValue=l.int64();break}case 2:{m.dimParam=l.string();break}case 3:{m.denotation=l.string();break}default:l.skipType(y&7);break}}return m},r.decodeDelimited=function(l){return l instanceof a||(l=new a(l)),this.decode(l,l.uint32())},r.verify=function(l){if(typeof l!="object"||l===null)return"object expected";var h={};if(l.dimValue!=null&&l.hasOwnProperty("dimValue")&&(h.value=1,!o.isInteger(l.dimValue)&&!(l.dimValue&&o.isInteger(l.dimValue.low)&&o.isInteger(l.dimValue.high))))return"dimValue: integer|Long expected";if(l.dimParam!=null&&l.hasOwnProperty("dimParam")){if(h.value===1)return"value: multiple values";if(h.value=1,!o.isString(l.dimParam))return"dimParam: string expected"}return l.denotation!=null&&l.hasOwnProperty("denotation")&&!o.isString(l.denotation)?"denotation: string expected":null},r.fromObject=function(l){if(l instanceof s.onnx.TensorShapeProto.Dimension)return l;var h=new s.onnx.TensorShapeProto.Dimension;return l.dimValue!=null&&(o.Long?(h.dimValue=o.Long.fromValue(l.dimValue)).unsigned=!1:typeof l.dimValue=="string"?h.dimValue=parseInt(l.dimValue,10):typeof l.dimValue=="number"?h.dimValue=l.dimValue:typeof l.dimValue=="object"&&(h.dimValue=new o.LongBits(l.dimValue.low>>>0,l.dimValue.high>>>0).toNumber())),l.dimParam!=null&&(h.dimParam=String(l.dimParam)),l.denotation!=null&&(h.denotation=String(l.denotation)),h},r.toObject=function(l,h){h||(h={});var f={};return h.defaults&&(f.denotation=""),l.dimValue!=null&&l.hasOwnProperty("dimValue")&&(typeof l.dimValue=="number"?f.dimValue=h.longs===String?String(l.dimValue):l.dimValue:f.dimValue=h.longs===String?o.Long.prototype.toString.call(l.dimValue):h.longs===Number?new o.LongBits(l.dimValue.low>>>0,l.dimValue.high>>>0).toNumber():l.dimValue,h.oneofs&&(f.value="dimValue")),l.dimParam!=null&&l.hasOwnProperty("dimParam")&&(f.dimParam=l.dimParam,h.oneofs&&(f.value="dimParam")),l.denotation!=null&&l.hasOwnProperty("denotation")&&(f.denotation=l.denotation),f},r.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},r.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TensorShapeProto.Dimension"},r}(),c}(),d.TypeProto=function(){function c(u){if(u)for(var l=Object.keys(u),h=0;h<l.length;++h)u[l[h]]!=null&&(this[l[h]]=u[l[h]])}c.prototype.tensorType=null,c.prototype.sequenceType=null,c.prototype.mapType=null,c.prototype.optionalType=null,c.prototype.sparseTensorType=null,c.prototype.denotation="";var r;return Object.defineProperty(c.prototype,"value",{get:o.oneOfGetter(r=["tensorType","sequenceType","mapType","optionalType","sparseTensorType"]),set:o.oneOfSetter(r)}),c.create=function(u){return new c(u)},c.encode=function(u,l){return l||(l=p.create()),u.tensorType!=null&&Object.hasOwnProperty.call(u,"tensorType")&&s.onnx.TypeProto.Tensor.encode(u.tensorType,l.uint32(10).fork()).ldelim(),u.sequenceType!=null&&Object.hasOwnProperty.call(u,"sequenceType")&&s.onnx.TypeProto.Sequence.encode(u.sequenceType,l.uint32(34).fork()).ldelim(),u.mapType!=null&&Object.hasOwnProperty.call(u,"mapType")&&s.onnx.TypeProto.Map.encode(u.mapType,l.uint32(42).fork()).ldelim(),u.denotation!=null&&Object.hasOwnProperty.call(u,"denotation")&&l.uint32(50).string(u.denotation),u.sparseTensorType!=null&&Object.hasOwnProperty.call(u,"sparseTensorType")&&s.onnx.TypeProto.SparseTensor.encode(u.sparseTensorType,l.uint32(66).fork()).ldelim(),u.optionalType!=null&&Object.hasOwnProperty.call(u,"optionalType")&&s.onnx.TypeProto.Optional.encode(u.optionalType,l.uint32(74).fork()).ldelim(),l},c.encodeDelimited=function(u,l){return this.encode(u,l).ldelim()},c.decode=function(u,l){u instanceof a||(u=a.create(u));for(var h=l===void 0?u.len:u.pos+l,f=new s.onnx.TypeProto;u.pos<h;){var m=u.uint32();switch(m>>>3){case 1:{f.tensorType=s.onnx.TypeProto.Tensor.decode(u,u.uint32());break}case 4:{f.sequenceType=s.onnx.TypeProto.Sequence.decode(u,u.uint32());break}case 5:{f.mapType=s.onnx.TypeProto.Map.decode(u,u.uint32());break}case 9:{f.optionalType=s.onnx.TypeProto.Optional.decode(u,u.uint32());break}case 8:{f.sparseTensorType=s.onnx.TypeProto.SparseTensor.decode(u,u.uint32());break}case 6:{f.denotation=u.string();break}default:u.skipType(m&7);break}}return f},c.decodeDelimited=function(u){return u instanceof a||(u=new a(u)),this.decode(u,u.uint32())},c.verify=function(u){if(typeof u!="object"||u===null)return"object expected";var l={};if(u.tensorType!=null&&u.hasOwnProperty("tensorType")){l.value=1;{var h=s.onnx.TypeProto.Tensor.verify(u.tensorType);if(h)return"tensorType."+h}}if(u.sequenceType!=null&&u.hasOwnProperty("sequenceType")){if(l.value===1)return"value: multiple values";l.value=1;{var h=s.onnx.TypeProto.Sequence.verify(u.sequenceType);if(h)return"sequenceType."+h}}if(u.mapType!=null&&u.hasOwnProperty("mapType")){if(l.value===1)return"value: multiple values";l.value=1;{var h=s.onnx.TypeProto.Map.verify(u.mapType);if(h)return"mapType."+h}}if(u.optionalType!=null&&u.hasOwnProperty("optionalType")){if(l.value===1)return"value: multiple values";l.value=1;{var h=s.onnx.TypeProto.Optional.verify(u.optionalType);if(h)return"optionalType."+h}}if(u.sparseTensorType!=null&&u.hasOwnProperty("sparseTensorType")){if(l.value===1)return"value: multiple values";l.value=1;{var h=s.onnx.TypeProto.SparseTensor.verify(u.sparseTensorType);if(h)return"sparseTensorType."+h}}return u.denotation!=null&&u.hasOwnProperty("denotation")&&!o.isString(u.denotation)?"denotation: string expected":null},c.fromObject=function(u){if(u instanceof s.onnx.TypeProto)return u;var l=new s.onnx.TypeProto;if(u.tensorType!=null){if(typeof u.tensorType!="object")throw TypeError(".onnx.TypeProto.tensorType: object expected");l.tensorType=s.onnx.TypeProto.Tensor.fromObject(u.tensorType)}if(u.sequenceType!=null){if(typeof u.sequenceType!="object")throw TypeError(".onnx.TypeProto.sequenceType: object expected");l.sequenceType=s.onnx.TypeProto.Sequence.fromObject(u.sequenceType)}if(u.mapType!=null){if(typeof u.mapType!="object")throw TypeError(".onnx.TypeProto.mapType: object expected");l.mapType=s.onnx.TypeProto.Map.fromObject(u.mapType)}if(u.optionalType!=null){if(typeof u.optionalType!="object")throw TypeError(".onnx.TypeProto.optionalType: object expected");l.optionalType=s.onnx.TypeProto.Optional.fromObject(u.optionalType)}if(u.sparseTensorType!=null){if(typeof u.sparseTensorType!="object")throw TypeError(".onnx.TypeProto.sparseTensorType: object expected");l.sparseTensorType=s.onnx.TypeProto.SparseTensor.fromObject(u.sparseTensorType)}return u.denotation!=null&&(l.denotation=String(u.denotation)),l},c.toObject=function(u,l){l||(l={});var h={};return l.defaults&&(h.denotation=""),u.tensorType!=null&&u.hasOwnProperty("tensorType")&&(h.tensorType=s.onnx.TypeProto.Tensor.toObject(u.tensorType,l),l.oneofs&&(h.value="tensorType")),u.sequenceType!=null&&u.hasOwnProperty("sequenceType")&&(h.sequenceType=s.onnx.TypeProto.Sequence.toObject(u.sequenceType,l),l.oneofs&&(h.value="sequenceType")),u.mapType!=null&&u.hasOwnProperty("mapType")&&(h.mapType=s.onnx.TypeProto.Map.toObject(u.mapType,l),l.oneofs&&(h.value="mapType")),u.denotation!=null&&u.hasOwnProperty("denotation")&&(h.denotation=u.denotation),u.sparseTensorType!=null&&u.hasOwnProperty("sparseTensorType")&&(h.sparseTensorType=s.onnx.TypeProto.SparseTensor.toObject(u.sparseTensorType,l),l.oneofs&&(h.value="sparseTensorType")),u.optionalType!=null&&u.hasOwnProperty("optionalType")&&(h.optionalType=s.onnx.TypeProto.Optional.toObject(u.optionalType,l),l.oneofs&&(h.value="optionalType")),h},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(u){return u===void 0&&(u="type.googleapis.com"),u+"/onnx.TypeProto"},c.Tensor=function(){function u(l){if(l)for(var h=Object.keys(l),f=0;f<h.length;++f)l[h[f]]!=null&&(this[h[f]]=l[h[f]])}return u.prototype.elemType=0,u.prototype.shape=null,u.create=function(l){return new u(l)},u.encode=function(l,h){return h||(h=p.create()),l.elemType!=null&&Object.hasOwnProperty.call(l,"elemType")&&h.uint32(8).int32(l.elemType),l.shape!=null&&Object.hasOwnProperty.call(l,"shape")&&s.onnx.TensorShapeProto.encode(l.shape,h.uint32(18).fork()).ldelim(),h},u.encodeDelimited=function(l,h){return this.encode(l,h).ldelim()},u.decode=function(l,h){l instanceof a||(l=a.create(l));for(var f=h===void 0?l.len:l.pos+h,m=new s.onnx.TypeProto.Tensor;l.pos<f;){var y=l.uint32();switch(y>>>3){case 1:{m.elemType=l.int32();break}case 2:{m.shape=s.onnx.TensorShapeProto.decode(l,l.uint32());break}default:l.skipType(y&7);break}}return m},u.decodeDelimited=function(l){return l instanceof a||(l=new a(l)),this.decode(l,l.uint32())},u.verify=function(l){if(typeof l!="object"||l===null)return"object expected";if(l.elemType!=null&&l.hasOwnProperty("elemType")&&!o.isInteger(l.elemType))return"elemType: integer expected";if(l.shape!=null&&l.hasOwnProperty("shape")){var h=s.onnx.TensorShapeProto.verify(l.shape);if(h)return"shape."+h}return null},u.fromObject=function(l){if(l instanceof s.onnx.TypeProto.Tensor)return l;var h=new s.onnx.TypeProto.Tensor;if(l.elemType!=null&&(h.elemType=l.elemType|0),l.shape!=null){if(typeof l.shape!="object")throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");h.shape=s.onnx.TensorShapeProto.fromObject(l.shape)}return h},u.toObject=function(l,h){h||(h={});var f={};return h.defaults&&(f.elemType=0,f.shape=null),l.elemType!=null&&l.hasOwnProperty("elemType")&&(f.elemType=l.elemType),l.shape!=null&&l.hasOwnProperty("shape")&&(f.shape=s.onnx.TensorShapeProto.toObject(l.shape,h)),f},u.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},u.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto.Tensor"},u}(),c.Sequence=function(){function u(l){if(l)for(var h=Object.keys(l),f=0;f<h.length;++f)l[h[f]]!=null&&(this[h[f]]=l[h[f]])}return u.prototype.elemType=null,u.create=function(l){return new u(l)},u.encode=function(l,h){return h||(h=p.create()),l.elemType!=null&&Object.hasOwnProperty.call(l,"elemType")&&s.onnx.TypeProto.encode(l.elemType,h.uint32(10).fork()).ldelim(),h},u.encodeDelimited=function(l,h){return this.encode(l,h).ldelim()},u.decode=function(l,h){l instanceof a||(l=a.create(l));for(var f=h===void 0?l.len:l.pos+h,m=new s.onnx.TypeProto.Sequence;l.pos<f;){var y=l.uint32();switch(y>>>3){case 1:{m.elemType=s.onnx.TypeProto.decode(l,l.uint32());break}default:l.skipType(y&7);break}}return m},u.decodeDelimited=function(l){return l instanceof a||(l=new a(l)),this.decode(l,l.uint32())},u.verify=function(l){if(typeof l!="object"||l===null)return"object expected";if(l.elemType!=null&&l.hasOwnProperty("elemType")){var h=s.onnx.TypeProto.verify(l.elemType);if(h)return"elemType."+h}return null},u.fromObject=function(l){if(l instanceof s.onnx.TypeProto.Sequence)return l;var h=new s.onnx.TypeProto.Sequence;if(l.elemType!=null){if(typeof l.elemType!="object")throw TypeError(".onnx.TypeProto.Sequence.elemType: object expected");h.elemType=s.onnx.TypeProto.fromObject(l.elemType)}return h},u.toObject=function(l,h){h||(h={});var f={};return h.defaults&&(f.elemType=null),l.elemType!=null&&l.hasOwnProperty("elemType")&&(f.elemType=s.onnx.TypeProto.toObject(l.elemType,h)),f},u.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},u.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto.Sequence"},u}(),c.Map=function(){function u(l){if(l)for(var h=Object.keys(l),f=0;f<h.length;++f)l[h[f]]!=null&&(this[h[f]]=l[h[f]])}return u.prototype.keyType=0,u.prototype.valueType=null,u.create=function(l){return new u(l)},u.encode=function(l,h){return h||(h=p.create()),l.keyType!=null&&Object.hasOwnProperty.call(l,"keyType")&&h.uint32(8).int32(l.keyType),l.valueType!=null&&Object.hasOwnProperty.call(l,"valueType")&&s.onnx.TypeProto.encode(l.valueType,h.uint32(18).fork()).ldelim(),h},u.encodeDelimited=function(l,h){return this.encode(l,h).ldelim()},u.decode=function(l,h){l instanceof a||(l=a.create(l));for(var f=h===void 0?l.len:l.pos+h,m=new s.onnx.TypeProto.Map;l.pos<f;){var y=l.uint32();switch(y>>>3){case 1:{m.keyType=l.int32();break}case 2:{m.valueType=s.onnx.TypeProto.decode(l,l.uint32());break}default:l.skipType(y&7);break}}return m},u.decodeDelimited=function(l){return l instanceof a||(l=new a(l)),this.decode(l,l.uint32())},u.verify=function(l){if(typeof l!="object"||l===null)return"object expected";if(l.keyType!=null&&l.hasOwnProperty("keyType")&&!o.isInteger(l.keyType))return"keyType: integer expected";if(l.valueType!=null&&l.hasOwnProperty("valueType")){var h=s.onnx.TypeProto.verify(l.valueType);if(h)return"valueType."+h}return null},u.fromObject=function(l){if(l instanceof s.onnx.TypeProto.Map)return l;var h=new s.onnx.TypeProto.Map;if(l.keyType!=null&&(h.keyType=l.keyType|0),l.valueType!=null){if(typeof l.valueType!="object")throw TypeError(".onnx.TypeProto.Map.valueType: object expected");h.valueType=s.onnx.TypeProto.fromObject(l.valueType)}return h},u.toObject=function(l,h){h||(h={});var f={};return h.defaults&&(f.keyType=0,f.valueType=null),l.keyType!=null&&l.hasOwnProperty("keyType")&&(f.keyType=l.keyType),l.valueType!=null&&l.hasOwnProperty("valueType")&&(f.valueType=s.onnx.TypeProto.toObject(l.valueType,h)),f},u.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},u.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto.Map"},u}(),c.Optional=function(){function u(l){if(l)for(var h=Object.keys(l),f=0;f<h.length;++f)l[h[f]]!=null&&(this[h[f]]=l[h[f]])}return u.prototype.elemType=null,u.create=function(l){return new u(l)},u.encode=function(l,h){return h||(h=p.create()),l.elemType!=null&&Object.hasOwnProperty.call(l,"elemType")&&s.onnx.TypeProto.encode(l.elemType,h.uint32(10).fork()).ldelim(),h},u.encodeDelimited=function(l,h){return this.encode(l,h).ldelim()},u.decode=function(l,h){l instanceof a||(l=a.create(l));for(var f=h===void 0?l.len:l.pos+h,m=new s.onnx.TypeProto.Optional;l.pos<f;){var y=l.uint32();switch(y>>>3){case 1:{m.elemType=s.onnx.TypeProto.decode(l,l.uint32());break}default:l.skipType(y&7);break}}return m},u.decodeDelimited=function(l){return l instanceof a||(l=new a(l)),this.decode(l,l.uint32())},u.verify=function(l){if(typeof l!="object"||l===null)return"object expected";if(l.elemType!=null&&l.hasOwnProperty("elemType")){var h=s.onnx.TypeProto.verify(l.elemType);if(h)return"elemType."+h}return null},u.fromObject=function(l){if(l instanceof s.onnx.TypeProto.Optional)return l;var h=new s.onnx.TypeProto.Optional;if(l.elemType!=null){if(typeof l.elemType!="object")throw TypeError(".onnx.TypeProto.Optional.elemType: object expected");h.elemType=s.onnx.TypeProto.fromObject(l.elemType)}return h},u.toObject=function(l,h){h||(h={});var f={};return h.defaults&&(f.elemType=null),l.elemType!=null&&l.hasOwnProperty("elemType")&&(f.elemType=s.onnx.TypeProto.toObject(l.elemType,h)),f},u.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},u.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto.Optional"},u}(),c.SparseTensor=function(){function u(l){if(l)for(var h=Object.keys(l),f=0;f<h.length;++f)l[h[f]]!=null&&(this[h[f]]=l[h[f]])}return u.prototype.elemType=0,u.prototype.shape=null,u.create=function(l){return new u(l)},u.encode=function(l,h){return h||(h=p.create()),l.elemType!=null&&Object.hasOwnProperty.call(l,"elemType")&&h.uint32(8).int32(l.elemType),l.shape!=null&&Object.hasOwnProperty.call(l,"shape")&&s.onnx.TensorShapeProto.encode(l.shape,h.uint32(18).fork()).ldelim(),h},u.encodeDelimited=function(l,h){return this.encode(l,h).ldelim()},u.decode=function(l,h){l instanceof a||(l=a.create(l));for(var f=h===void 0?l.len:l.pos+h,m=new s.onnx.TypeProto.SparseTensor;l.pos<f;){var y=l.uint32();switch(y>>>3){case 1:{m.elemType=l.int32();break}case 2:{m.shape=s.onnx.TensorShapeProto.decode(l,l.uint32());break}default:l.skipType(y&7);break}}return m},u.decodeDelimited=function(l){return l instanceof a||(l=new a(l)),this.decode(l,l.uint32())},u.verify=function(l){if(typeof l!="object"||l===null)return"object expected";if(l.elemType!=null&&l.hasOwnProperty("elemType")&&!o.isInteger(l.elemType))return"elemType: integer expected";if(l.shape!=null&&l.hasOwnProperty("shape")){var h=s.onnx.TensorShapeProto.verify(l.shape);if(h)return"shape."+h}return null},u.fromObject=function(l){if(l instanceof s.onnx.TypeProto.SparseTensor)return l;var h=new s.onnx.TypeProto.SparseTensor;if(l.elemType!=null&&(h.elemType=l.elemType|0),l.shape!=null){if(typeof l.shape!="object")throw TypeError(".onnx.TypeProto.SparseTensor.shape: object expected");h.shape=s.onnx.TensorShapeProto.fromObject(l.shape)}return h},u.toObject=function(l,h){h||(h={});var f={};return h.defaults&&(f.elemType=0,f.shape=null),l.elemType!=null&&l.hasOwnProperty("elemType")&&(f.elemType=l.elemType),l.shape!=null&&l.hasOwnProperty("shape")&&(f.shape=s.onnx.TensorShapeProto.toObject(l.shape,h)),f},u.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},u.getTypeUrl=function(l){return l===void 0&&(l="type.googleapis.com"),l+"/onnx.TypeProto.SparseTensor"},u}(),c}(),d.OperatorSetIdProto=function(){function c(r){if(r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.domain="",c.prototype.version=o.Long?o.Long.fromBits(0,0,!1):0,c.create=function(r){return new c(r)},c.encode=function(r,u){return u||(u=p.create()),r.domain!=null&&Object.hasOwnProperty.call(r,"domain")&&u.uint32(10).string(r.domain),r.version!=null&&Object.hasOwnProperty.call(r,"version")&&u.uint32(16).int64(r.version),u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.OperatorSetIdProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.domain=r.string();break}case 2:{h.version=r.int64();break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){return typeof r!="object"||r===null?"object expected":r.domain!=null&&r.hasOwnProperty("domain")&&!o.isString(r.domain)?"domain: string expected":r.version!=null&&r.hasOwnProperty("version")&&!o.isInteger(r.version)&&!(r.version&&o.isInteger(r.version.low)&&o.isInteger(r.version.high))?"version: integer|Long expected":null},c.fromObject=function(r){if(r instanceof s.onnx.OperatorSetIdProto)return r;var u=new s.onnx.OperatorSetIdProto;return r.domain!=null&&(u.domain=String(r.domain)),r.version!=null&&(o.Long?(u.version=o.Long.fromValue(r.version)).unsigned=!1:typeof r.version=="string"?u.version=parseInt(r.version,10):typeof r.version=="number"?u.version=r.version:typeof r.version=="object"&&(u.version=new o.LongBits(r.version.low>>>0,r.version.high>>>0).toNumber())),u},c.toObject=function(r,u){u||(u={});var l={};if(u.defaults)if(l.domain="",o.Long){var h=new o.Long(0,0,!1);l.version=u.longs===String?h.toString():u.longs===Number?h.toNumber():h}else l.version=u.longs===String?"0":0;return r.domain!=null&&r.hasOwnProperty("domain")&&(l.domain=r.domain),r.version!=null&&r.hasOwnProperty("version")&&(typeof r.version=="number"?l.version=u.longs===String?String(r.version):r.version:l.version=u.longs===String?o.Long.prototype.toString.call(r.version):u.longs===Number?new o.LongBits(r.version.low>>>0,r.version.high>>>0).toNumber():r.version),l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.OperatorSetIdProto"},c}(),d.OperatorStatus=function(){var c={},r=Object.create(c);return r[c[0]="EXPERIMENTAL"]=0,r[c[1]="STABLE"]=1,r}(),d.FunctionProto=function(){function c(r){if(this.input=[],this.output=[],this.attribute=[],this.attributeProto=[],this.node=[],this.opsetImport=[],r)for(var u=Object.keys(r),l=0;l<u.length;++l)r[u[l]]!=null&&(this[u[l]]=r[u[l]])}return c.prototype.name="",c.prototype.input=o.emptyArray,c.prototype.output=o.emptyArray,c.prototype.attribute=o.emptyArray,c.prototype.attributeProto=o.emptyArray,c.prototype.node=o.emptyArray,c.prototype.docString="",c.prototype.opsetImport=o.emptyArray,c.prototype.domain="",c.create=function(r){return new c(r)},c.encode=function(r,u){if(u||(u=p.create()),r.name!=null&&Object.hasOwnProperty.call(r,"name")&&u.uint32(10).string(r.name),r.input!=null&&r.input.length)for(var l=0;l<r.input.length;++l)u.uint32(34).string(r.input[l]);if(r.output!=null&&r.output.length)for(var l=0;l<r.output.length;++l)u.uint32(42).string(r.output[l]);if(r.attribute!=null&&r.attribute.length)for(var l=0;l<r.attribute.length;++l)u.uint32(50).string(r.attribute[l]);if(r.node!=null&&r.node.length)for(var l=0;l<r.node.length;++l)s.onnx.NodeProto.encode(r.node[l],u.uint32(58).fork()).ldelim();if(r.docString!=null&&Object.hasOwnProperty.call(r,"docString")&&u.uint32(66).string(r.docString),r.opsetImport!=null&&r.opsetImport.length)for(var l=0;l<r.opsetImport.length;++l)s.onnx.OperatorSetIdProto.encode(r.opsetImport[l],u.uint32(74).fork()).ldelim();if(r.domain!=null&&Object.hasOwnProperty.call(r,"domain")&&u.uint32(82).string(r.domain),r.attributeProto!=null&&r.attributeProto.length)for(var l=0;l<r.attributeProto.length;++l)s.onnx.AttributeProto.encode(r.attributeProto[l],u.uint32(90).fork()).ldelim();return u},c.encodeDelimited=function(r,u){return this.encode(r,u).ldelim()},c.decode=function(r,u){r instanceof a||(r=a.create(r));for(var l=u===void 0?r.len:r.pos+u,h=new s.onnx.FunctionProto;r.pos<l;){var f=r.uint32();switch(f>>>3){case 1:{h.name=r.string();break}case 4:{h.input&&h.input.length||(h.input=[]),h.input.push(r.string());break}case 5:{h.output&&h.output.length||(h.output=[]),h.output.push(r.string());break}case 6:{h.attribute&&h.attribute.length||(h.attribute=[]),h.attribute.push(r.string());break}case 11:{h.attributeProto&&h.attributeProto.length||(h.attributeProto=[]),h.attributeProto.push(s.onnx.AttributeProto.decode(r,r.uint32()));break}case 7:{h.node&&h.node.length||(h.node=[]),h.node.push(s.onnx.NodeProto.decode(r,r.uint32()));break}case 8:{h.docString=r.string();break}case 9:{h.opsetImport&&h.opsetImport.length||(h.opsetImport=[]),h.opsetImport.push(s.onnx.OperatorSetIdProto.decode(r,r.uint32()));break}case 10:{h.domain=r.string();break}default:r.skipType(f&7);break}}return h},c.decodeDelimited=function(r){return r instanceof a||(r=new a(r)),this.decode(r,r.uint32())},c.verify=function(r){if(typeof r!="object"||r===null)return"object expected";if(r.name!=null&&r.hasOwnProperty("name")&&!o.isString(r.name))return"name: string expected";if(r.input!=null&&r.hasOwnProperty("input")){if(!Array.isArray(r.input))return"input: array expected";for(var u=0;u<r.input.length;++u)if(!o.isString(r.input[u]))return"input: string[] expected"}if(r.output!=null&&r.hasOwnProperty("output")){if(!Array.isArray(r.output))return"output: array expected";for(var u=0;u<r.output.length;++u)if(!o.isString(r.output[u]))return"output: string[] expected"}if(r.attribute!=null&&r.hasOwnProperty("attribute")){if(!Array.isArray(r.attribute))return"attribute: array expected";for(var u=0;u<r.attribute.length;++u)if(!o.isString(r.attribute[u]))return"attribute: string[] expected"}if(r.attributeProto!=null&&r.hasOwnProperty("attributeProto")){if(!Array.isArray(r.attributeProto))return"attributeProto: array expected";for(var u=0;u<r.attributeProto.length;++u){var l=s.onnx.AttributeProto.verify(r.attributeProto[u]);if(l)return"attributeProto."+l}}if(r.node!=null&&r.hasOwnProperty("node")){if(!Array.isArray(r.node))return"node: array expected";for(var u=0;u<r.node.length;++u){var l=s.onnx.NodeProto.verify(r.node[u]);if(l)return"node."+l}}if(r.docString!=null&&r.hasOwnProperty("docString")&&!o.isString(r.docString))return"docString: string expected";if(r.opsetImport!=null&&r.hasOwnProperty("opsetImport")){if(!Array.isArray(r.opsetImport))return"opsetImport: array expected";for(var u=0;u<r.opsetImport.length;++u){var l=s.onnx.OperatorSetIdProto.verify(r.opsetImport[u]);if(l)return"opsetImport."+l}}return r.domain!=null&&r.hasOwnProperty("domain")&&!o.isString(r.domain)?"domain: string expected":null},c.fromObject=function(r){if(r instanceof s.onnx.FunctionProto)return r;var u=new s.onnx.FunctionProto;if(r.name!=null&&(u.name=String(r.name)),r.input){if(!Array.isArray(r.input))throw TypeError(".onnx.FunctionProto.input: array expected");u.input=[];for(var l=0;l<r.input.length;++l)u.input[l]=String(r.input[l])}if(r.output){if(!Array.isArray(r.output))throw TypeError(".onnx.FunctionProto.output: array expected");u.output=[];for(var l=0;l<r.output.length;++l)u.output[l]=String(r.output[l])}if(r.attribute){if(!Array.isArray(r.attribute))throw TypeError(".onnx.FunctionProto.attribute: array expected");u.attribute=[];for(var l=0;l<r.attribute.length;++l)u.attribute[l]=String(r.attribute[l])}if(r.attributeProto){if(!Array.isArray(r.attributeProto))throw TypeError(".onnx.FunctionProto.attributeProto: array expected");u.attributeProto=[];for(var l=0;l<r.attributeProto.length;++l){if(typeof r.attributeProto[l]!="object")throw TypeError(".onnx.FunctionProto.attributeProto: object expected");u.attributeProto[l]=s.onnx.AttributeProto.fromObject(r.attributeProto[l])}}if(r.node){if(!Array.isArray(r.node))throw TypeError(".onnx.FunctionProto.node: array expected");u.node=[];for(var l=0;l<r.node.length;++l){if(typeof r.node[l]!="object")throw TypeError(".onnx.FunctionProto.node: object expected");u.node[l]=s.onnx.NodeProto.fromObject(r.node[l])}}if(r.docString!=null&&(u.docString=String(r.docString)),r.opsetImport){if(!Array.isArray(r.opsetImport))throw TypeError(".onnx.FunctionProto.opsetImport: array expected");u.opsetImport=[];for(var l=0;l<r.opsetImport.length;++l){if(typeof r.opsetImport[l]!="object")throw TypeError(".onnx.FunctionProto.opsetImport: object expected");u.opsetImport[l]=s.onnx.OperatorSetIdProto.fromObject(r.opsetImport[l])}}return r.domain!=null&&(u.domain=String(r.domain)),u},c.toObject=function(r,u){u||(u={});var l={};if((u.arrays||u.defaults)&&(l.input=[],l.output=[],l.attribute=[],l.node=[],l.opsetImport=[],l.attributeProto=[]),u.defaults&&(l.name="",l.docString="",l.domain=""),r.name!=null&&r.hasOwnProperty("name")&&(l.name=r.name),r.input&&r.input.length){l.input=[];for(var h=0;h<r.input.length;++h)l.input[h]=r.input[h]}if(r.output&&r.output.length){l.output=[];for(var h=0;h<r.output.length;++h)l.output[h]=r.output[h]}if(r.attribute&&r.attribute.length){l.attribute=[];for(var h=0;h<r.attribute.length;++h)l.attribute[h]=r.attribute[h]}if(r.node&&r.node.length){l.node=[];for(var h=0;h<r.node.length;++h)l.node[h]=s.onnx.NodeProto.toObject(r.node[h],u)}if(r.docString!=null&&r.hasOwnProperty("docString")&&(l.docString=r.docString),r.opsetImport&&r.opsetImport.length){l.opsetImport=[];for(var h=0;h<r.opsetImport.length;++h)l.opsetImport[h]=s.onnx.OperatorSetIdProto.toObject(r.opsetImport[h],u)}if(r.domain!=null&&r.hasOwnProperty("domain")&&(l.domain=r.domain),r.attributeProto&&r.attributeProto.length){l.attributeProto=[];for(var h=0;h<r.attributeProto.length;++h)l.attributeProto[h]=s.onnx.AttributeProto.toObject(r.attributeProto[h],u)}return l},c.prototype.toJSON=function(){return this.constructor.toObject(this,i.util.toJSONOptions)},c.getTypeUrl=function(r){return r===void 0&&(r="type.googleapis.com"),r+"/onnx.FunctionProto"},c}(),d}(),n.exports=s});function ur(e,n){if(!e)throw new Error(typeof n=="string"?n:n())}function kr(e){return new TextDecoder().decode(e)}var ot,Me,ai,kt,Sn,At,Rt,B,$r,Ue,Ve,ze,Y=O(()=>{wn(),qo(),ot=rr(sr()),We(),Me=class{static arraysEqual(e,n){if(e.length!==n.length)return!1;for(let i=0;i<e.length;i++)if(e[i]!==n[i])return!1;return!0}},ai=class{static preprocessInputShapes(e,n){let i=e.length===1?[1,e[0]]:e,a=n.length===1?[n[0],1]:n;return[i,a]}static postprocessOutputShape(e,n,i){n===1&&e.splice(e.length-2,1),i===1&&e.pop()}static calcMatMulShape(e,n){return e[1]!==n[0]?void 0:[e[0],n[1]]}},kt=class we{static calcShape(n,i,a=!1){let p=n.length,o=i.length;if(p===0)return i;if(o===0)return n;let s=Math.max(n.length,i.length),d=new Array(s);if(a){if(p<2||o<2)return;let c=ai.calcMatMulShape([n[p-2],n[p-1]],[i[o-2],i[o-1]]);if(c===void 0)return;[d[s-2],d[s-1]]=c}for(let c=a?3:1;c<=s;c++){let r=p-c<0?1:n[p-c],u=o-c<0?1:i[o-c];if(r!==u&&r>1&&u>1)return;d[s-c]=Math.max(r,u)}return d}static index(n,i){let a=new Array(i.length);return we.fillIndex(n,i,a),a}static fillIndex(n,i,a){let p=n.length-i.length;for(let o=0;o<i.length;o++)a[o]=n[p+o]%i[o]}static calc(n,i,a,p,o){let s=we.calcShape(n.dims,i.dims);if(s){if(p&&!B.areEqual(s,n.dims))return;let d=B.size(s),c=p?n:new bt(s,o||n.type);if(s.length===0)c.set([],a(n.get([]),i.get([])));else{let r=new Array(s.length),u=new Array(n.dims.length),l=new Array(i.dims.length),h=0,f=0,m=!1,y=!1;n.dims.length===0&&(h=n.get([]),m=!0),i.dims.length===0&&(f=i.get([]),y=!0);let _;for(let I=0;I<d;I++){_=I;for(let x=s.length-1;x>=0;x--)r[x]=_%s[x],_=Math.floor(_/s[x]);m||(we.fillIndex(r,n.dims,u),h=n.get(u)),y||(we.fillIndex(r,i.dims,l),f=i.get(l)),c.set(r,a(h,f))}}return c}}static isValidBroadcast(n,i){let a=n.length,p=i.length;if(a>p)return!1;for(let o=1;o<=a;o++)if(n[a-o]!==1&&n[a-o]!==i[p-o])return!1;return!0}static getBroadcastDims(n,i){let a=n.length,p=[];for(let o=0;o<a;o++){let s=a-1-o,d=n[s]||1;(i[i.length-1-o]||1)>1&&d===1&&p.unshift(s)}return p}},Sn=class{static getShapeOfGemmResult(e,n,i,a,p){if(e.length!==2||i.length!==2)throw new Error("shape need to be of size 2");let o,s,d;n?(o=e[1],s=e[0]):(o=e[0],s=e[1]);let c=-1;if(a?(d=i[0],c=1):(d=i[1],c=0),i[c]!==s)throw new Error("dimension mismatch");if(o<=0||d<=0||s<=0)throw new Error("invalid shape specified");if(p&&!kt.isValidBroadcast(p,[o,d]))throw new Error("gemm: invalid bias shape for broadcast");return[o,d,s]}},At=class en{static tensorDataTypeFromProto(n){switch(n){case ot.onnx.TensorProto.DataType.INT8:return"int8";case ot.onnx.TensorProto.DataType.UINT8:return"uint8";case ot.onnx.TensorProto.DataType.BOOL:return"bool";case ot.onnx.TensorProto.DataType.INT16:return"int16";case ot.onnx.TensorProto.DataType.UINT16:return"uint16";case ot.onnx.TensorProto.DataType.INT32:return"int32";case ot.onnx.TensorProto.DataType.UINT32:return"uint32";case ot.onnx.TensorProto.DataType.FLOAT:return"float32";case ot.onnx.TensorProto.DataType.DOUBLE:return"float64";case ot.onnx.TensorProto.DataType.STRING:return"string";case ot.onnx.TensorProto.DataType.INT64:return"int32";case ot.onnx.TensorProto.DataType.UINT64:return"uint32";default:throw new Error(`unsupported data type: ${ot.onnx.TensorProto.DataType[n]}`)}}static tensorDataTypeStringToEnum(n){switch(n){case"int8":return ot.onnx.TensorProto.DataType.INT8;case"uint8":return ot.onnx.TensorProto.DataType.UINT8;case"bool":return ot.onnx.TensorProto.DataType.BOOL;case"int16":return ot.onnx.TensorProto.DataType.INT16;case"uint16":return ot.onnx.TensorProto.DataType.UINT16;case"int32":return ot.onnx.TensorProto.DataType.INT32;case"uint32":return ot.onnx.TensorProto.DataType.UINT32;case"float32":return ot.onnx.TensorProto.DataType.FLOAT;case"float64":return ot.onnx.TensorProto.DataType.DOUBLE;case"string":return ot.onnx.TensorProto.DataType.STRING;case"int64":return ot.onnx.TensorProto.DataType.INT64;case"uint64":return ot.onnx.TensorProto.DataType.UINT64;default:throw new Error(`unsupported data type: ${n}`)}}static tensorDimsFromProto(n){return n.map(i=>xe.isLong(i)?i.toNumber():i)}static tensorValueTypeFromProto(n){return{tensorType:en.tensorDataTypeFromProto(n.elemType),shape:{dims:en.tensorDimsFromProto(n.shape.dim.map(i=>i.dimValue))}}}static tensorDimsFromORTFormat(n){let i=[];for(let a=0;a<n.dimsLength();a++)i.push(Rt.longToNumber(n.dims(a)));return i}static tensorAttributesFromORTFormat(n){let i=[];for(let a=0;a<n.attributesLength();a++)i.push(n.attributes(a));return i}},Rt=class{static longToNumber(e,n){return xe.isLong(e)?e.toNumber():e instanceof w.Long?xe.fromValue({low:e.low,high:e.high,unsigned:n??!1}).toNumber():e}static isLong(e){return xe.isLong(e)||e instanceof w.Long}},B=class te{static size(n){return te.getSizeFromDimensionRange(n,0,n.length)}static sizeFromDimension(n,i){if(i<0||i>n.length)throw new Error(`invalid dimension of ${i} for sizeFromDimension as Tensor has ${n.length} dimensions.`);return te.getSizeFromDimensionRange(n,i,n.length)}static sizeToDimension(n,i){if(i<0||i>n.length)throw new Error(`invalid dimension of ${i} for sizeToDimension as Tensor has ${n.length} dimensions.`);return te.getSizeFromDimensionRange(n,0,i)}static getSizeFromDimensionRange(n,i,a){let p=1;for(let o=i;o<a;o++){if(n[o]<=0)throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");p*=n[o]}return p}static computeStrides(n){let i=n.length;if(i===0)return[];if(i===1)return[1];let a=new Array(i);a[i-1]=1,a[i-2]=n[i-1];for(let p=i-3;p>=0;--p)a[p]=a[p+1]*n[p+1];return a}static transpose(n){return n.slice().reverse()}static indicesToOffset(n,i,a){a===void 0&&(a=n.length);let p=0;for(let o=0;o<a;++o)p+=i[o]*n[o];return p}static offsetToIndices(n,i){let a=i.length;if(a===0)return[];if(a===1)return[n*i[0]];let p=new Array(i.length);for(let o=0;o<p.length-1;++o)p[o]=Math.floor(n/i[o]),n-=p[o]*i[o];return p[p.length-1]=n,p}static normalizeAxis(n,i){if(n<-i&&n>=i)throw new Error("unsupported axis for this operation.");return n<0?n+i:n}static normalizeAxes(n,i){return n.map(a=>this.normalizeAxis(a,i))}static incrementIndex(n,i,a){if(i.length===0||n.length===0)throw new Error("Index incrementing unsupported for scalar Tensor");if(a===void 0)a=i.length;else if(a<=0||a>i.length)throw new Error("Incorrect axis to increment on");for(let p=a-1;p>=0&&(n[p]++,!(n[p]<i[p]));--p)n[p]=0}static calculateReshapedDims(n,i){if(i.length===0){if(n.length===0||te.size(n)===1)return[];throw new Error("cannot reshape to a scalar Tensor")}let a=i.length,p=new Array(a),o=-1,s=1;for(let c=0;c<a;c++){if(i[c]<-1)throw new Error("a dimension in shape hints cannot be less than -1");if(i[c]===-1){if(o!==-1)throw new Error("at most one dimension in shape hints can be -1");o=c}else{if(i[c]===0){if(c>=n.length)throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");p[c]=n[c]}else p[c]=i[c];s*=p[c]}}let d=te.size(n);if(o!==-1){if(d%s!==0)throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${n}] Output shape: [${i}]`);p[o]=d/s}else if(s!==d)throw new Error("reshapedDims and originalDims don't have matching sizes");return p}static sortBasedOnPerm(n,i){return i?i.map(a=>n[a]):n.slice().reverse()}static padShape(n,i){let a=n.length;return n.map((p,o)=>p+i[o]+i[o+a])}static areEqual(n,i){return n.length!==i.length?!1:n.every((a,p)=>a===i[p])}static validateDimsAndCalcSize(n){if(n.length>6)throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");let i=1;for(let a of n){if(!Number.isInteger(a))throw new TypeError(`Invalid shape: ${a} is not an integer`);if(a<0||a>2147483647)throw new TypeError(`Invalid shape: length ${a} is not allowed`);i*=a}return i}static flattenShape(n,i){i<0&&(i+=n.length);let a=n.reduce((o,s)=>o*s,1),p=n.slice(i).reduce((o,s)=>o*s,1);return[a/p,p]}static squeezeShape(n,i){let a=new Array;i=te.normalizeAxes(i,n.length);for(let p=0;p<n.length;p++){let o=i.indexOf(p)>=0;if(o&&n[p]!==1)throw new Error("squeeze an axis of size different than 1");(i.length===0&&n[p]>1||i.length>0&&!o)&&a.push(n[p])}return a}static unsqueezeShape(n,i){let a=new Array(n.length+i.length);a.fill(0);for(let o=0;o<i.length;o++){let s=te.normalizeAxis(i[o],a.length);if(s>=a.length)throw new Error("'axes' has an out of range axis");if(a[s]!==0)throw new Error("'axes' has a duplicate axis");a[s]=1}let p=0;for(let o=0;o<a.length;o++)a[o]===0&&(a[o]=n[p++]);if(p!==n.length)throw new Error("the unsqueezed dimension could not be established");return a}},$r=class Sa{static splitShape(n,i,a,p){if(a.length===0){if(!p)throw new Error("need to know number of outputs when the 'split' attribute is not specified");Sa.determineSplit(n[i],p,a)}let o=[],s=[0];for(let d=0;d<a.length;++d){d!==0&&s.push(s[d-1]+a[d-1]);let c=n.slice();c[i]=a[d],o.push(c)}return[o,s]}static determineSplit(n,i,a){if(n%i!==0)throw new Error("cannot split tensor to equal sized parts");for(let p=0;p<i;++p)a.push(n/i)}},Ue=class ve{static adjustPoolAttributes(n,i,a,p,o,s){if(!n&&a.length!==i.length-2)throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");if(n)for(let d=0;d<i.length-2;d++)d>=a.length?a.push(i[d+2]):a[d]=i[d+2];for(let d=0;d<a.length;d++)if(d<p.length){if(p[d]<0)throw new Error("strides should be greater than or equal to 1")}else p.push(1);for(let d=0;d<a.length;d++)if(d<o.length){if(o[d]<0)throw new Error("dilations should be greater than or equal to 1")}else o.push(1);for(let d=0;d<a.length*2;d++)if(d<s.length){if(s[d]<0)throw new Error("pad should be greater than or equal to 1")}else s.push(0);for(let d=0;d<a.length;d++){if(a[d]<=0)throw new Error("kernel shapes need to be greater than 0");if(s[d]>=a[d]||s[d+a.length]>=a[d])throw new Error("pads should be smaller than kernel")}}static adjustPadsBasedOnAutoPad(n,i,a,p,o,s){if(s){if(o.length!==2*(n.length-2))throw new Error("length of pads should be twice the length of data dimensions");if(i.length!==n.length-2)throw new Error("length of strides should be the length of data dimensions");if(p.length!==n.length-2)throw new Error("length of kernel shapes should be the length of data dimensions");for(let d=0;d<n.length-2;d++)ve.adjustPadAndReturnShape(n[d+2],i[d],a[d],p[d],o,d,d+n.length-2,s)}}static computePoolOutputShape(n,i,a,p,o,s,d){if(i.length<=0)throw new Error("input shape must be of size greater than 0");let c=[i[0],i[1]];return ve.computeShapeHelper(n,i,c,a,p,o,s,d),c}static computeConvOutputShape(n,i,a,p,o,s,d){if(n.length<=0||i.length<=0)throw new Error("invalid input tensor dims or invalid filter tensor dims");let c=[n[0],i[0]];return ve.computeShapeHelper(!1,n,c,a,p,o,s,d),c}static computeShapeHelper(n,i,a,p,o,s,d,c){if(n)for(let r=0;r<i.length-2;r++)a.push(1);else for(let r=0;r<i.length-2;r++)a.push(ve.adjustPadAndReturnShape(i[r+2],p[r],o[r],s[r],d,r,r+i.length-2,c))}static adjustPadAndReturnShape(n,i,a,p,o,s,d,c){let r=a*(p-1)+1;if(c&&c!=="NOTSET")switch(c){case"VALID":return o[s]=0,o[d]=0,Math.floor((n-r)/i+1);case"SAME_LOWER":case"SAME_UPPER":if(a!==1)throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");{let u=((n+i-1)/i-1)*i+p-n;return o[s]=Math.floor(c==="SAME_LOWER"?(u+1)/2:u/2),o[d]=u-o[s],Math.floor((n+u-p)/i+1)}default:throw new Error("Unsupported AutoPad type")}else return Math.floor((n+o[s]+o[d]-r)/i+1)}},Ve=-34028234663852886e22,ze=34028234663852886e22});function hh(e){switch(e){case"bool":case"int8":case"uint8":return 1;case"int16":case"uint16":return 2;case"int32":case"uint32":case"float32":return 4;case"float64":return 8;default:throw new Error(`cannot calculate sizeof() on type ${e}`)}}function Wu(e){switch(e){case H.onnx.TensorProto.DataType.UINT8:case H.onnx.TensorProto.DataType.INT8:case H.onnx.TensorProto.DataType.BOOL:return 1;case H.onnx.TensorProto.DataType.UINT16:case H.onnx.TensorProto.DataType.INT16:return 2;case H.onnx.TensorProto.DataType.FLOAT:case H.onnx.TensorProto.DataType.INT32:case H.onnx.TensorProto.DataType.UINT32:return 4;case H.onnx.TensorProto.DataType.INT64:case H.onnx.TensorProto.DataType.DOUBLE:case H.onnx.TensorProto.DataType.UINT64:return 8;default:throw new Error(`cannot calculate sizeof() on type ${H.onnx.TensorProto.DataType[e]}`)}}function mh(e,n){return new(ju(n))(e)}function ju(e){switch(e){case"bool":case"uint8":return Uint8Array;case"int8":return Int8Array;case"int16":return Int16Array;case"uint16":return Uint16Array;case"int32":return Int32Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"float32":return Float32Array;case"float64":return Float64Array;default:throw new Error("unspecified error")}}function ui(e,n){if(n===H.onnx.TensorProto.DataType.INT64||n===si.TensorDataType.INT64){if(e.greaterThanOrEqual(2147483648)||e.lessThan(-2147483648))throw new TypeError("int64 is not supported")}else if(n===H.onnx.TensorProto.DataType.UINT32||n===si.TensorDataType.UINT32||n===H.onnx.TensorProto.DataType.UINT64||n===si.TensorDataType.UINT64){if(e.greaterThanOrEqual(4294967296)||e.lessThan(0))throw new TypeError("uint64 is not supported")}else throw new TypeError(`not a LONG type: ${H.onnx.TensorProto.DataType[n]}`);return e.toNumber()}function Hu(e,n,i){switch(n){case H.onnx.TensorProto.DataType.BOOL:case H.onnx.TensorProto.DataType.UINT8:return e.getUint8(i);case H.onnx.TensorProto.DataType.INT8:return e.getInt8(i);case H.onnx.TensorProto.DataType.UINT16:return e.getUint16(i,!0);case H.onnx.TensorProto.DataType.INT16:return e.getInt16(i,!0);case H.onnx.TensorProto.DataType.FLOAT:return e.getFloat32(i,!0);case H.onnx.TensorProto.DataType.INT32:return e.getInt32(i,!0);case H.onnx.TensorProto.DataType.UINT32:return e.getUint32(i,!0);case H.onnx.TensorProto.DataType.INT64:return ui(xe.fromBits(e.getUint32(i,!0),e.getUint32(i+4,!0),!1),n);case H.onnx.TensorProto.DataType.DOUBLE:return e.getFloat64(i,!0);case H.onnx.TensorProto.DataType.UINT64:return ui(xe.fromBits(e.getUint32(i,!0),e.getUint32(i+4,!0),!0),n);default:throw new Error(`cannot read from DataView for type ${H.onnx.TensorProto.DataType[n]}`)}}var qu,H,si,bt,We=O(()=>{qu=rr(Fs()),qo(),Pr(),H=rr(sr()),Y(),si=F.experimental.fbs,bt=class gr{constructor(n,i,a,p,o,s=qu.Guid.create()){this.dims=n,this.type=i,this.dataProvider=a,this.asyncDataProvider=p,this.cache=o,this.dataId=s,this.size=B.validateDimsAndCalcSize(n);let d=this.size,c=a===void 0&&p===void 0&&o===void 0;if(o!==void 0&&o.length!==d)throw new RangeError("Input dims doesn't match data length.");if(i==="string"){if(o!==void 0&&(!Array.isArray(o)||!o.every(r=>typeof r=="string")))throw new TypeError("cache should be a string array");c&&(this.cache=new Array(d))}else{if(o!==void 0){let r=ju(i);if(!(o instanceof r))throw new TypeError(`cache should be type ${r.name}`)}if(c){let r=new ArrayBuffer(d*hh(i));this.cache=mh(r,i)}}}get data(){if(this.cache===void 0){let n=this.dataProvider(this.dataId);if(n.length!==this.size)throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");this.cache=n}return this.cache}get stringData(){if(this.type!=="string")throw new TypeError("data type is not string");return this.data}get integerData(){switch(this.type){case"uint8":case"int8":case"uint16":case"int16":case"int32":case"uint32":case"bool":return this.data;default:throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")}}get floatData(){switch(this.type){case"float32":case"float64":return this.data;default:throw new TypeError("data type is not float (float32, float64)")}}get numberData(){if(this.type!=="string")return this.data;throw new TypeError("type cannot be non-number (string)")}get(n){return this.data[B.indicesToOffset(n,this.strides)]}set(n,i){this.data[B.indicesToOffset(n,this.strides)]=i}async getData(){return this.cache===void 0&&(this.cache=await this.asyncDataProvider(this.dataId)),this.cache}get strides(){return this._strides||(this._strides=B.computeStrides(this.dims)),this._strides}static fromProto(n){if(!n)throw new Error("cannot construct Value from an empty tensor");let i=At.tensorDataTypeFromProto(n.dataType),a=At.tensorDimsFromProto(n.dims),p=new gr(a,i);if(i==="string")n.stringData.forEach((o,s)=>{p.data[s]=kr(o)});else if(n.rawData&&typeof n.rawData.byteLength=="number"&&n.rawData.byteLength>0){let o=p.data,s=new DataView(n.rawData.buffer,n.rawData.byteOffset,n.rawData.byteLength),d=Wu(n.dataType),c=n.rawData.byteLength/d;if(n.rawData.byteLength%d!==0)throw new Error("invalid buffer length");if(o.length!==c)throw new Error("buffer length mismatch");for(let r=0;r<c;r++){let u=Hu(s,n.dataType,r*d);o[r]=u}}else{let o;switch(n.dataType){case H.onnx.TensorProto.DataType.FLOAT:o=n.floatData;break;case H.onnx.TensorProto.DataType.INT32:case H.onnx.TensorProto.DataType.INT16:case H.onnx.TensorProto.DataType.UINT16:case H.onnx.TensorProto.DataType.INT8:case H.onnx.TensorProto.DataType.UINT8:case H.onnx.TensorProto.DataType.BOOL:o=n.int32Data;break;case H.onnx.TensorProto.DataType.INT64:o=n.int64Data;break;case H.onnx.TensorProto.DataType.DOUBLE:o=n.doubleData;break;case H.onnx.TensorProto.DataType.UINT32:case H.onnx.TensorProto.DataType.UINT64:o=n.uint64Data;break;default:throw new Error("unspecific error")}if(o==null)throw new Error("failed to populate data from a tensorproto value");let s=p.data;if(s.length!==o.length)throw new Error("array length mismatch");for(let d=0;d<o.length;d++){let c=o[d];xe.isLong(c)?s[d]=ui(c,n.dataType):s[d]=c}}return p}static fromData(n,i,a){return new gr(i,a,void 0,void 0,n)}static fromOrtTensor(n){if(!n)throw new Error("cannot construct Value from an empty tensor");let i=At.tensorDimsFromORTFormat(n),a=At.tensorDataTypeFromProto(n.dataType()),p=new gr(i,a);if(a==="string")for(let o=0;o<n.stringDataLength();o++)p.data[o]=n.stringData(o);else if(n.rawDataArray()&&typeof n.rawDataLength()=="number"&&n.rawDataLength()>0){let o=p.data,s=new DataView(n.rawDataArray().buffer,n.rawDataArray().byteOffset,n.rawDataLength()),d=Wu(n.dataType()),c=n.rawDataLength()/d;if(n.rawDataLength()%d!==0)throw new Error("invalid buffer length");if(o.length!==c)throw new Error("buffer length mismatch");for(let r=0;r<c;r++){let u=Hu(s,n.dataType(),r*d);o[r]=u}}return p}}});function G(e){return e===1?bh:gh}function Xu(e){let n=G(e);return`${n.version}
      precision highp float;
      ${n.attribute} vec3 position;
      ${n.attribute} vec2 textureCoord;

      ${n.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`}function Ku(e){let n=G(e);return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFrag} vec2 TexCoords;
    ${n.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `}function Ju(e,n){let i=G(e);return`
  void main() {
    int indices[${n}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i.output} = result;
  }
  `}var bh,gh,ut=O(()=>{bh={version:"",attribute:"attribute",varyingVertex:"varying",varyingFrag:"varying",texture2D:"texture2D",output:"gl_FragColor",outputDeclaration:""},gh={version:"#version 300 es",attribute:"in",varyingVertex:"out",varyingFrag:"in",texture2D:"texture",output:"outputColor",outputDeclaration:"out vec4 outputColor;"}}),j=O(()=>{});async function li(e,n=a=>0,i){return new Promise((a,p)=>{let o=0,s=()=>{if(e()){a();return}o++;let d=n(o);setTimeout(s,d)};s()})}function An(e){return ur(typeof e<"u"&&e.length!==0,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)}function Yu(e){return ur(typeof e<"u"&&e.length!==0,()=>"empty string found for sampler name"),"get"+e.charAt(0).toUpperCase()+e.slice(1)+"AtOutCoords"}function lr(e,n){let i=JSON.parse(JSON.stringify(e));return i=n,i}function fr(e,n){return n.map(i=>e[i]).join(", ")}function Bt(e){if(e<=1)return"int";if(e===2)return"ivec2";if(e===3)return"ivec3";if(e===4)return"ivec4";if(e===5)return"ivec5";if(e===6)return"ivec6";throw Error(`GPU for rank ${e} is not yet supported`)}function ne(e=6){return["x","y","z","w","u","v"].slice(0,e)}var pe=O(()=>{Y()});function yh(e,n){return ne(n).map(i=>`${e}.${i}`)}function cr(e,n){return n===1?[e]:yh(e,n)}function de(){return`
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `}var He=O(()=>{pe()});function Th(e,n,i){if(e===0)return"false";if(e===1)return`rc > ${n[0]}`;let a="";for(let p=e-2;p<e;p++)a+=`${i[p]} >= ${n[p-e+2]}`,p<e-1&&(a+="||");return a}function wh(e,n){let i=e.length;if(i===0)return"getA(), 0, 0, 0";if(i===1)return`getA(rc),
            rc + 1 >= ${e[0]} ? 0. : getA(rc + 1),
            0, 0`;let a="r, c",p="r, cp1",o="rp1, c",s="rp1, cp1",d="";if(i>2)for(let c=0;c<i-2;++c)d=d+`${n[c]},`;return`getA(${d}${a}),
          rEdge ? 0. : getA(${d}${o}),
          cEdge ? 0. : getA(${d}${p}),
          rEdge || cEdge ? 0. : getA(${d}${s})`}function vh(e,n,i,a){return e===0||e===1?"":`
    int r = ${n[e-2]};
    int c = ${n[e-1]};
    int rp1 = ${n[e-2]} + 1;
    int cp1 = ${n[e-1]} + 1;
    bool rEdge = rp1 >= ${a};
    bool cEdge = cp1 >= ${i};
    `}var Zu,xh,Qu,tl=O(()=>{ut(),j(),pe(),He(),Zu={name:"pack",inputNames:["A"],inputTypes:[1]},xh=(e,n)=>{let i=G(e.session.backend.glContext.version),a=n.dims,p=a.length,o=n.dims.length,s=Bt(o),d=cr("rc",o),c=vh(o,d,a[a.length-2],a[a.length-1]),r;p===0?r=[1,1]:p===1?r=[a[0],1]:r=[a[o-1],a[o-2]];let u=Th(o,r,d),l=wh(a,d),h=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${u}) {
            ${i.output} = vec4(0);
          } else {
            ${c}

            ${i.output} = vec4(${l});
          }
        }
      `;return{...Zu,hasMain:!0,output:{dims:n.dims,type:n.type,textureType:2},shaderSource:h}},Qu=(e,n)=>({...Zu,get:()=>xh(e,n)})});function fi(e){if(e.length===0)return[1,1,1];let n=1;for(let i=0;i<e.length-2;++i)n*=e[i];return[n,e.length>1?e[e.length-2]:1,e[e.length-1]]}function rl(e,n){let i=!1;return e.length===0||n.length===0?i=!0:e.length<2||n.length<2?i=e[e.length-1]===n[n.length-1]:i=e[e.length-1]===n[n.length-1]&&e[e.length-2]===n[n.length-2],i}function Oh(e){let n=B.computeStrides(e),i=["b","r","c"],a="index";return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${n.map((p,o)=>{let s=`int ${i[o]} = ${a} / ${p}`,d=o===n.length-1?`int ${i[o+1]} = ${a} - ${i[o]} * ${p}`:`index -= ${i[o]} * ${p}`;return`${s}; ${d};`}).join("")}
      return ivec3(b, r, c);
    }
  `}function Sh(e){let n=B.computeStrides(e);return`
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${n[0]} + coords.z * ${n[1]} + coords.y;
  }
`}var Ih,_h,el,nl=O(()=>{Y(),ut(),j(),He(),Ih=e=>({name:"Reshape (packed)",inputTypes:[2],inputNames:["A"],cacheHint:`${e}`}),_h=(e,n,i,a)=>{let p=n.dims,o=a,s="";for(let r=0;r<4;r++){let u="";switch(r){case 0:u="outputCoords = rc;";break;case 1:u="outputCoords = ivec3(rc.x, rc.y+1, rc.z);";break;case 2:u="outputCoords = ivec3(rc.x, rc.y, rc.z+1);";break;case 3:u="outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";break;default:throw new Error}s+=`
        ${u}
        ${r>0?"if(outputCoords.y < rows && outputCoords.z < cols){":""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${r>0?"}":""}
      `}let d=G(e.session.backend.glContext.version),c=`
      ${Oh(p)}
      ${Sh(o)}
      ${de()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${o[2]};
        int cols = ${o[1]};

        ${s}
        ${d.output} = result;
      }
    `;return{...i,output:{dims:o,type:n.type,textureType:2},shaderSource:c,hasMain:!0}},el=(e,n,i)=>{let a=Ih(i);return{...a,get:()=>_h(e,n,a,i)}}}),ci,ol=O(()=>{ut(),j(),ci=(e,n)=>{let i=n.shape,a=G(e.session.backend.glContext.version),p=`
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${a.texture2D}(X,TexCoords).r;
      ${a.output} = encodeAsUint8(value);
    }`,o={name:"Uint8Encode",inputTypes:[0],inputNames:["X"],output:{dims:i,type:n.tensor.type,textureType:3},shaderSource:p,hasMain:!0};return e.executeProgram(o,[n.tensor])}});function Ph(e,n){if(e===1)return"rc";let i="";for(let a=0;a<e;a++)i+=n[a],a<e-1&&(i+=",");return i}var il,Ah,al,sl=O(()=>{ut(),j(),pe(),He(),il={name:"unpack",inputNames:["A"],inputTypes:[2]},Ah=(e,n)=>{let i=n.dims.length,a=cr("rc",i),p=a.slice(-2),o=Bt(i),s=de(),d=n.dims.length===0?"":Ph(i,a),c=i<=1?"rc":`vec2(${p.join(",")})`,r=G(e.session.backend.glContext.version),u=`
    ${s}
    void main() {
      ${o} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${d});

       ${r.output} = vec4(getChannel(packedInput, ${c}), 0, 0, 0);
     }
   `;return{...il,hasMain:!0,output:{dims:n.dims,type:n.type,textureType:0},shaderSource:u}},al=(e,n)=>({...il,get:()=>Ah(e,n)})}),Pn,Br,En,Fr=O(()=>{Ut(),Pn=class{constructor(e,n=1){if(n===1)this.internalFormat=e.R32F,this.format=e.RED,this.textureType=e.FLOAT,this.channelSize=n;else if(n===4)this.internalFormat=e.RGBA32F,this.format=e.RGBA,this.textureType=e.FLOAT,this.channelSize=n;else throw new Error(`Invalid number of channels: ${n}`)}encode(e,n){let i,a;return e.constructor!==Float32Array&&(tt.warning("Encoder","data was not of type Float32; creating new Float32Array"),a=new Float32Array(e)),n*this.channelSize>e.length?(tt.warning("Encoder","Source data too small. Allocating larger array"),a=e,i=this.allocate(n*this.channelSize),a.forEach((p,o)=>i[o]=p)):(a=e,i=a),i}allocate(e){return new Float32Array(e*4)}decode(e,n){return this.channelSize===1?e.filter((i,a)=>a%4===0).subarray(0,n):e.subarray(0,n)}},Br=class{constructor(e,n=1,i){if(n!==1&&n!==4)throw new Error(`Invalid number of channels: ${n}`);this.internalFormat=e.RGBA,this.format=e.RGBA,this.channelSize=n,this.textureType=i||e.FLOAT}encode(e,n){let i=e;return this.channelSize===1&&(tt.verbose("Encoder","Exploding into a larger array"),i=this.allocate(n),e.forEach((a,p)=>i[p*4]=a)),i}allocate(e){return new Float32Array(e*4)}decode(e,n){return this.channelSize===1?e.filter((i,a)=>a%4===0).subarray(0,n):e.subarray(0,n)}},En=class{constructor(e,n=1){if(this.channelSize=4,n===1)this.internalFormat=e.ALPHA,this.format=e.ALPHA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=n;else if(n===4)this.internalFormat=e.RGBA,this.format=e.RGBA,this.textureType=e.UNSIGNED_BYTE,this.channelSize=n;else throw new Error(`Invalid number of channels: ${n}`)}encode(e,n){return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}allocate(e){return new Uint8Array(e*this.channelSize)}decode(e,n){if(e instanceof Uint8Array)return e.subarray(0,n);throw new Error(`Invalid array type: ${e.constructor}`)}}}),Cr,ul,pi,ll=O(()=>{Y(),j(),Cr=(e,n,i)=>{let a=i===0||i===1?1:4,p=i===2,o=i===1||i===2,s=i===4?n.length-1:void 0,d=i===4?n.map((c,r)=>r===n.length-1?c*4:c):void 0;return pi(e,n,a,d,{isPacked:p,reverseWH:o,breakAxis:s})},ul=(e,n,i)=>{let a=Cr(e,n,i);return[a.width,a.height]},pi=(e,n,i=1,a,p)=>{let o=!!(p&&p.isPacked),[s,d]=e.computeTextureWH(o&&a||n,p),c=n.length,r=n.slice(0);if(c===0&&(r=[1]),i===1)a=n;else if(o){if(i!==4)throw new Error("a packed texture must be 4-channel");a=n,c>0&&(r[c-1]=Math.ceil(r[c-1]/2)),c>1&&(r[c-2]=Math.ceil(r[c-2]/2))}else if(!a)throw new Error("Unpacked shape is needed when using channels > 1");return{width:s,height:d,channels:i,isPacked:o,shape:r,strides:B.computeStrides(r),unpackedShape:a,reversedWH:p&&p.reverseWH}}}),Dh,Dn,cl=O(()=>{Ut(),We(),Y(),tl(),nl(),ol(),sl(),Fr(),ll(),j(),Dh=(e,n)=>{let i=n.map(p=>`${p.unpackedShape.join(",")};${p.width}x${p.height}`).join("_"),a=e.name;return e.cacheHint&&(a+="["+e.cacheHint+"]"),a+=":"+i,a},Dn=class{constructor(e){this.session=e,this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map}calculateTextureWidthAndHeight(e,n){return ul(this.session.layoutStrategy,e,n)}executeProgram(e,n){if(n.length<e.inputNames.length)throw new Error(`Input size mustn't be less than ${e.inputNames.length}.`);if(e.inputNames.length!==e.inputTypes.length)throw new Error("input names size does not match input types");let i=[];for(let c=0;c<e.inputNames.length;++c)i[c]=this.getOrCreateTextureData(n[c],e.inputTypes[c]);let a=Dh(e,i),p=this.session.programManager.getArtifact(a),o=p?p.programInfo:typeof e.get=="function"?e.get():e,s=Cr(this.session.layoutStrategy,o.output.dims,o.output.textureType),d=this.createTextureData(s,o.output.type);return p||(p=this.session.programManager.build(o,i,d),this.session.programManager.setArtifact(a,p)),this.runProgram(p,i,d),d}run(e,n){return this.executeProgram(e,n).tensor}runProgram(e,n,i){for(let a=0;a<n.length;++a)if(!!n[a].isPacked!=(e.programInfo.inputTypes[a]===2))throw new Error(`input[${a}] property packed inconsistent`);if(!!i.isPacked!=(e.programInfo.output.textureType===2))throw new Error("output property packed inconsistent");this.session.programManager.run(e,n,i)}getOrCreateTextureData(e,n){let i=this.getTextureData(e.dataId,n===2);if(!i&&(i=this.getTextureData(e.dataId,n!==2),i))return n===2?this.pack(i):this.unpack(i);if(!i){let a=Cr(this.session.layoutStrategy,e.dims,n);if(n===4){let p=e.dims;if(p.length===4){let o=[p[0],Math.ceil(p[1]*p[2]*p[3]/4)],s=Cr(this.session.layoutStrategy,o,n),d=e.numberData;if(p[1]*p[2]*p[3]%4!==0){let c=p[0],r=p[1]*p[2]*p[3],u=Math.ceil(r*1/4)*4,l=c*u;d=new Float32Array(l);for(let h=0;h<c;++h){let f=h*r,m=h*u+h%1*r;d.set(e.numberData.subarray(f,f+r),m)}}return this.createTextureData(s,e.type,d,e,1)}}if(n===2){let p=pi(this.session.layoutStrategy,e.dims,1,[],{reverseWH:!0}),o=this.createTextureData(p,e.type,e.numberData,e,1);i=this.pack(o)}else i=this.createTextureData(a,e.type,e.numberData,e,1)}return i}createTextureDataFromLayoutBindTensor(e,n,i,a){return this.createTextureData(e,n,i,a,1)}createTextureData(e,n,i,a,p){tt.verbose("InferenceHandler",`Creating TextureData: layout:[${JSON.stringify(e)}]`);let o=this.session.textureManager.createTextureFromLayout(n,e,i,p);return this.createTextureDataFromTexture(e,n,o,a)}reshapeUnpacked(e,n){let i=this.getOrCreateTextureData(e,0),a={channels:i.channels,height:i.height,width:i.width,shape:n.length!==0?n:[1],strides:B.computeStrides(n),unpackedShape:n};return this.createTextureDataFromTexture(a,e.type,i.texture).tensor}reshapePacked(e,n){let i=this.getOrCreateTextureData(e,2);if(rl(e.dims,n)){let d={channels:i.channels,height:i.height,width:i.width,shape:n.length!==0?n:[1],strides:B.computeStrides(n),unpackedShape:n,isPacked:!0};return this.createTextureDataFromTexture(d,e.type,i.texture).tensor}let a=fi(e.dims),p=fi(n),o=this.reshapePacked(e,a),s=this.run(el(this,o,p),[o]);return this.reshapePacked(s,n)}cast(e,n){let i=this.getOrCreateTextureData(e,0);return this.createTextureDataFromTexture(i,n,i.texture).tensor}createTextureDataFromTexture(e,n,i,a,p){let o={...e,tensor:a||new bt(e.unpackedShape,n,s=>this.readTexture(o),async s=>this.readTextureAsync(o),void 0,p),texture:i};return this.setTextureData(o.tensor.dataId,o,e.isPacked),o}getTextureData(e,n=!1){return this.session.isInitializer(e)?this.session.getTextureData(e,n):n?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,n,i=!1){this.session.isInitializer(e)?this.session.setTextureData(e,n,i):(i?this.packedTextureDataCache:this.unpackedTextureDataCache).set(e,n)}isTextureLayoutCached(e,n=!1){return!!this.getTextureData(e.dataId,n)}dispose(){this.session.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.session.textureManager.releaseTexture(e)),this.unpackedTextureDataCache=new Map}readTexture(e){return e.isPacked?this.readTexture(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTexture(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(ci(this,e))}async readTextureAsync(e){return e.isPacked?this.readTextureAsync(this.unpack(e)):this.session.backend.glContext.isFloat32DownloadSupported?this.session.textureManager.readTextureAsync(e,e.tensor.type,e.channels):this.session.textureManager.readUint8TextureAsFloat(ci(this,e))}pack(e){return this.executeProgram(Qu(this,e.tensor),[e.tensor])}unpack(e){return this.executeProgram(al(this,e.tensor),[e.tensor])}}}),di,W,It=O(()=>{di=class{constructor(e){Object.assign(this,e)}get cacheKey(){return this.key||(this.key=Object.getOwnPropertyNames(this).sort().map(e=>`${this[e]}`).join(";")),this.key}},W=e=>new di(e)}),pl,dl,hl,Lh,$h,ml=O(()=>{It(),ut(),j(),pl={name:"BatchNormalization",inputNames:["A","Scale","B","Mean","Variance"],inputTypes:[0,0,0,0,0]},dl=(e,n,i)=>($h(n),[e.run({...pl,cacheHint:i.cacheKey,get:()=>Lh(e,n,i)},n)]),hl=e=>{let n=e.attributes.getFloat("epsilon",1e-5),i=e.attributes.getFloat("momentum",.9),a=e.attributes.getInt("spatial",1);return W({epsilon:n,momentum:i,spatial:a})},Lh=(e,n,i)=>{let a=G(e.session.backend.glContext.version),p=n[0].dims.length,[o,s]=e.calculateTextureWidthAndHeight(n[1].dims,0),d=`
  float process(int[${p}] indices) {
    vec2 position = offsetToCoords(indices[1], ${o}, ${s});
    float scale = getColorAsFloat(${a.texture2D}(Scale, position));
    float mean = getColorAsFloat(${a.texture2D}(Mean, position));
    float variance = getColorAsFloat(${a.texture2D}(Variance, position));
    float b = getColorAsFloat(${a.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${i.epsilon})) ) + b;
  }`;return{...pl,output:{dims:n[0].dims,type:n[0].type,textureType:0},shaderSource:d}},$h=e=>{if(!e||e.length!==5)throw new Error("BatchNormalization requires 5 inputs.");let n=e[0],i=e[1],a=e[2],p=e[3],o=e[4];if(n.dims.length<3||i.dims.length!==1||a.dims.length!==1||p.dims.length!==1||o.dims.length!==1)throw new Error("invalid input shape.");if(i.dims[0]!==n.dims[1]||a.dims[0]!==n.dims[1]||p.dims[0]!==n.dims[1]||o.dims[0]!==n.dims[1])throw new Error("invalid input shape.");if(n.type!=="float32"&&n.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||a.type!=="float32"&&a.type!=="float64"||p.type!=="float32"&&p.type!=="float64"||o.type!=="float32"&&o.type!=="float64")throw new Error("invalid input tensor types.")}}),Ln,Ht,k,Nr,$n,Te=O(()=>{Ln=class{constructor(e,n,i,a){this.glContext=e,this.programInfo=n,this.inputTextureLayouts=i,this.outputTextureLayout=a}},Ht=class{constructor(e){this.context=e}},k=class{constructor(e,n){this.routineBody=e,this.dependencies=n}},Nr=class{constructor(e,n,i){this.name=e,i?this.dependencies=i:this.dependencies=[],n&&(this.routineBody=n)}addDependency(e){e&&this.dependencies.push(e)}},$n=class{static returnOrderedNodes(e){if(!e||e.length===0)return[];if(e.length===1)return e;let n=new Set,i=new Set,a=new Array;return this.createOrderedNodes(e,n,i,a),a}static createOrderedNodes(e,n,i,a){for(let p=0;p<e.length;++p)this.dfsTraverse(e[p],n,i,a)}static dfsTraverse(e,n,i,a){if(!e||i.has(e.name))return;if(n.has(e.name))throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");n.add(e.name);let p=e.dependencies;if(p&&p.length>0)for(let o=0;o<p.length;++o)this.dfsTraverse(p[o],n,i,a);a.push(e),i.add(e.name),n.delete(e.name)}}});function Bh(){let e="add_";return{body:`
  float ${e}(float a, float b) {
    return a + b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,name:e,type:0}}function Fh(){let e="div_";return{body:`
  float ${e}(float a, float b) {
    return a / b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,name:e,type:0}}function Ch(){let e="mul_";return{body:`
  float ${e}(float a, float b) {
    return a * b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,name:e,type:0}}function Nh(){let e="sub_";return{body:`
  float ${e}(float a, float b) {
    return a - b;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,name:e,type:0}}function Rh(){let e="equal_";return{body:`
  float ${e}(float a, float b) {
    return float(a == b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,name:e,type:0}}function Gh(){let e="greater_";return{body:`
  float ${e}(float a, float b) {
    return float(a > b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,name:e,type:0}}function Mh(){let e="less_";return{body:`
  float ${e}(float a, float b) {
    return float(a < b);
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,name:e,type:0}}function Uh(){let e="and_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,name:e,type:0}}function Vh(){let e="or_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,name:e,type:0}}function zh(){let e="xor_";return{body:`
  float ${e}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,name:e,type:0}}function Wh(){return qh("pow")}function Hh(){let e="prelu_";return{body:`
  float ${e}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${e}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,name:e,type:0}}function qh(e){let n=`${e}_`;return{body:`
  float ${n}(float a, float b) {
    return ${e}(a, b);
  }
  vec4 ${n}(vec4 v1, vec4 v2) {
    return ${e}(v1, v2);
  }
  `,name:n,type:0}}var qt,jh,bl,gl,yl,xl,Tl,wl,vl,Il,_l,Ol,Sl,Al,Pl=O(()=>{Y(),Te(),ut(),j(),qt=(e,n,i,a=n[0].type,p)=>{let o=e.session.pack?2:0;return{name:i.name,inputNames:["A","B"],inputTypes:[o,o],cacheHint:p,get:()=>jh(e,n,i,a)}},jh=(e,n,i,a=n[0].type)=>{let p=e.session.pack?2:0,o=!B.areEqual(n[0].dims,n[1].dims),s=n[0].dims,d=e.session.pack;if(o){let u=kt.calcShape(n[0].dims,n[1].dims,!1);if(!u)throw new Error("Can't perform binary op on the given tensors");s=u;let l=s.length,h=n[0].dims.length!==0?n[0].dims.length:1,f=n[1].dims.length!==0?n[1].dims.length:1,m=n[0].dims.length!==0?"bcastIndices_A(indices, aindices);":"aindices[0] = 0;",y=n[1].dims.length!==0?"bcastIndices_B(indices, bindices);":"bindices[0] = 0;",_=G(e.session.backend.glContext.version),I=d?`
      ${i.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${i.name}(a, b);
        ${_.output} = result;
      }`:`
      ${i.body}
      float process(int indices[${l}]) {
        int aindices[${h}];
        int bindices[${f}];
        ${m}
        ${y}
        return ${i.name}(_A(aindices), _B(bindices));
      }`;return{name:i.name,inputNames:["A","B"],inputTypes:[p,p],output:{dims:s,type:a,textureType:p},shaderSource:I,hasMain:d}}let c=G(e.session.backend.glContext.version),r=`
    ${i.body}
    void main() {
      vec4 v1 = ${c.texture2D}(A, TexCoords);
      vec4 v2 = ${c.texture2D}(B, TexCoords);
      vec4 result = ${i.name}(v1, v2);
      ${c.output} = result;
    }
    `;return{name:i.name,inputNames:["A","B"],inputTypes:[p,p],output:{dims:n[0].dims,type:a,textureType:p},shaderSource:r,hasMain:!0}},bl=(e,n)=>[e.run(qt(e,n,Bh()),n)],gl=(e,n)=>[e.run(qt(e,n,Uh(),"bool"),n)],yl=(e,n)=>[e.run(qt(e,n,Fh()),n)],xl=(e,n)=>[e.run(qt(e,n,Rh(),"bool"),n)],Tl=(e,n)=>[e.run(qt(e,n,Gh(),"bool"),n)],wl=(e,n)=>[e.run(qt(e,n,Mh(),"bool"),n)],vl=(e,n)=>[e.run(qt(e,n,Ch()),n)],Il=(e,n)=>[e.run(qt(e,n,Vh(),"bool"),n)],_l=(e,n)=>[e.run(qt(e,n,Wh()),n)],Ol=(e,n)=>[e.run(qt(e,n,Hh()),n)],Sl=(e,n)=>[e.run(qt(e,n,Nh()),n)],Al=(e,n)=>[e.run(qt(e,n,zh(),"bool"),n)]}),El,Dl,Kh,Ll=O(()=>{Y(),El=(e,n,i)=>(Kh(n),[e.cast(n[0],i)]),Dl=e=>At.tensorDataTypeFromProto(e.attributes.getInt("to")),Kh=e=>{if(!e||e.length!==1)throw new Error("Cast requires 1 input.");if(e[0].type==="string")throw new Error("Invalid input type.")}}),Jh,Yh,$l,kn,kl=O(()=>{ut(),j(),pe(),He(),Jh=(e,n)=>({name:"Concat (packed)",inputNames:Array.from({length:e},(i,a)=>`X${a}`),inputTypes:Array(e).fill(2),cacheHint:n}),Yh=(e,n,i,a)=>{let p=i[0].dims.slice();if(a>=p.length||a<-1*p.length)throw new Error("axis specified for concat doesn't match input dimensionality");a<0&&(a=p.length+a);let o=p.slice(0);for(let R=1;R<i.length;R++){let ct=i[R].dims.slice();for(let st=0;st<p.length;st++)if(st===a)o[a]+=ct[st];else if(p[st]!==ct[st])throw new Error("non concat dimensions must match")}let s=o.length,d=cr("coords",s),c=Bt(s),r=de(),u=i.map(R=>R.dims),l=ne(s),h=new Array(u.length-1);h[0]=u[0][a];for(let R=1;R<h.length;R++)h[R]=h[R-1]+u[R][a];let f=l[a],m=l.slice(-2),y=l.join(),_=`if (${f} < ${h[0]}) {
        return getChannel(
            getX0(${y}), vec2(${m.join()}));
        }`;for(let R=1;R<h.length;R++){let ct=h[R-1];_+=`
            if (${f} < ${h[R]}  && ${f} >= ${h[R-1]}) {
              return getChannel(
                getX${R}(${kn(l,f,ct)}),
                vec2(${kn(m,f,ct)}));
            }`}let I=h.length,x=h[h.length-1];_+=`
            return getChannel(
              getX${I}(${kn(l,f,x)}),
              vec2(${kn(m,f,x)}));`;let P=G(e.session.backend.glContext.version),N=`
          ${r}
          float getValue(${l.map(R=>"int "+R)}) {
            ${_}
          }

          void main() {
            ${c} coords = getOutputCoords();
            int lastDim = coords.${l[s-1]};
            coords.${l[s-1]} = coords.${l[s-2]};
            coords.${l[s-2]} = lastDim;

            vec4 result = vec4(getValue(${d}), 0., 0., 0.);

            ${d[s-1]} = ${d[s-1]} + 1;
            if (${d[s-1]} < ${o[s-1]}) {
              result.g = getValue(${d});
            }

            ${d[s-2]} = ${d[s-2]} + 1;
            if (${d[s-2]} < ${o[s-2]}) {
              result.a = getValue(${d});
            }

            ${d[s-1]} = ${d[s-1]} - 1;
            if (${d[s-2]} < ${o[s-2]} &&
                ${d[s-1]} < ${o[s-1]}) {
              result.b = getValue(${d});
            }
            ${P.output} = result;
          }
        `;return{...n,output:{dims:o,type:i[0].type,textureType:2},shaderSource:N,hasMain:!0}},$l=(e,n,i)=>{let a=Jh(n.length,i.cacheKey);return{...a,get:()=>Yh(e,a,n,i.axis)}},kn=(e,n,i)=>{let a=e.indexOf(n);return e.map((p,o)=>o===a?`${p} - ${i}`:p).join()}}),Bl,Zh,Qh,tm,Fl,em,rm,nm,Cl,om,Nl=O(()=>{It(),j(),kl(),Bl=(e,n,i)=>(om(n),e.session.pack&&n[0].dims.length>1?[e.run($l(e,n,i),n)]:[e.run(tm(e,n,i),n)]),Zh=(e,n)=>({name:"Concat",inputNames:Array.from({length:e},(i,a)=>`X${a}`),inputTypes:Array(e).fill(0),cacheHint:n}),Qh=(e,n,i,a)=>{let p=i[0].dims.slice();if(a>=p.length||a<-1*p.length)throw new Error("axis specified for concat doesn't match input dimensionality");a<0&&(a=p.length+a);let o=p.slice(0);for(let f=1;f<i.length;f++){let m=i[f].dims.slice();for(let y=0;y<p.length;y++)if(y===a)o[a]+=m[y];else if(p[y]!==m[y])throw new Error("non concat dimensions must match")}let s=o.length,d=new Array(i.length),c=0;for(let f=0;f<d.length;++f)c+=i[f].dims[a],d[f]=c;let r="";i.length<5?r=Fl(d):r=em(d);let u=rm(i.length,s),l=nm(d),h=`
        ${u}
        ${l}
        ${r}
        float process(int indices[${s}]) {
          int textureIndex = getTextureWhereDataResides (indices[${a}]);

          if(textureIndex != 0) {
            indices[${a}] = indices[${a}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;return{...n,output:{dims:o,type:i[0].type,textureType:0},shaderSource:h}},tm=(e,n,i)=>{let a=Zh(n.length,i.cacheKey);return{...a,get:()=>Qh(e,a,n,i.axis)}},Fl=e=>`int getTextureWhereDataResides(int index) {
      ${e.map((n,i)=>`if(index<${n}) {return ${i};}
`).join("")}
    }`,em=e=>Fl(e),rm=(e,n)=>{let i=[`float fetchDataFromCorrectTexture(int textureIndex, int indices[${n}]) {`];for(let a=0;a<e;++a)a===0?i.push(`	if (textureIndex == ${a}) { return _X${a}(indices); }`):a===e-1?i.push(`	else { return _X${a}(indices); }`):i.push(`	else if (textureIndex == ${a}) { return _X${a}(indices); }`);return i.push("	}"),i.join(`
`)},nm=e=>{let n=["int getSizeInConcatAxisValueFromIndex(int index) {"];for(let i=0;i<e.length;++i)i===0?n.push(`	if (index == ${i}) { return ${e[i]}; }`):i===e.length-1?n.push(`	else { return ${e[i]}; }`):n.push(`	else if (index == ${i}) { return ${e[i]}; }`);return n.push("	}"),n.join(`
`)},Cl=e=>W({axis:e.attributes.getInt("axis")}),om=e=>{if(!e||e.length<1)throw new Error("too few inputs");let n=e[0].type,i=e[0].dims.length;if(n==="string")throw new Error("string tensor is not supported yet");for(let a of e){if(a.type!==n)throw new Error("input tensors should be one type");if(a.dims.length!==i)throw new Error("input tensors should have the same shape")}}});function im(){return jt("abs")}function am(){return jt("acos")}function sm(){return jt("asin")}function um(){return jt("atan")}function lm(){return jt("ceil")}function fm(){return jt("cos")}function cm(e){let n="elu";return{body:`
  const float alpha = float(${e});

  float ${n}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${n}_(vec4 v) {
    return vec4(${n}_(v.x), ${n}_(v.y), ${n}_(v.z), ${n}_(v.w));
  }
  `,name:n,type:0}}function pm(){return jt("exp")}function dm(){return jt("floor")}function hi(e,n){let i="clip";return{body:`
  const float min = float(${e});
  const float max = float(${n});

  float ${i}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${i}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,name:i,type:0}}function hm(){let e="indentity";return{body:`
  float ${e}_(float a) {
    return a;
  }
  vec4 ${e}_(vec4 v) {
    return v;
  }
  `,name:e,type:0}}function mm(e){let n="leakyRelu";return{body:`
  const float alpha = float(${e});

  float ${n}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${n}_(vec4 v) {
    return vec4(${n}_(v.x), ${n}_(v.y), ${n}_(v.z), ${n}_(v.w));
  }
  `,name:n,type:0}}function bm(){return jt("log")}function gm(){let e="neg";return{body:`
  float ${e}_(float a) {
    return -a;
  }
  vec4 ${e}_(vec4 v) {
    return -v;
  }
  `,name:e,type:0}}function ym(){let e="not";return{body:`
  float ${e}_(float a) {
    return float( ! bool(a) );
  }
  bool ${e}_(bool a) {
    return !a;
  }
  vec4 ${e}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${e}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,name:e,type:0}}function xm(){return jt("sin")}function mi(){let e="relu";return{body:`
  float ${e}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${e}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,name:e,type:0}}function bi(){let e="sigmoid";return{body:`
  float ${e}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${e}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,name:e,type:0}}function Tm(){return jt("sqrt")}function wm(){return jt("tan")}function vm(){let e="tanh";return{body:`
  float ${e}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${e}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,name:e,type:0}}function jt(e){return{body:`
  float ${e}_(float a) {
    return ${e}(a);
  }
  vec4 ${e}_(vec4 v) {
    return ${e}(v);
  }
  `,name:e,type:0}}var Im,dt,Rl,Gl,Ml,Ul,gi,Vl,zl,_m,Wl,Hl,ql,jl,Xl,Kl,yi,Jl,Yl,Zl,Ql,tf,ef,rf,nf,of,af,sf,xi=O(()=>{It(),Y(),Te(),ut(),j(),Im=(e,n,i,a)=>{let p=e.session.pack?2:0,o=G(e.session.backend.glContext.version);return{...n,output:{dims:i.dims,type:i.type,textureType:p},shaderSource:`
     ${a.body}
     void main() {
       vec4 v = ${o.texture2D}(A, TexCoords);
       v = ${a.name}_(v);
       ${o.output} = v;
     }
     `,hasMain:!0}},dt=(e,n,i,a)=>{let p=e.session.pack?2:0,o={name:i.name,inputTypes:[p],inputNames:["A"],cacheHint:a};return{...o,get:()=>Im(e,o,n,i)}},Rl=(e,n)=>[e.run(dt(e,n[0],im()),n)],Gl=(e,n)=>[e.run(dt(e,n[0],am()),n)],Ml=(e,n)=>[e.run(dt(e,n[0],sm()),n)],Ul=(e,n)=>[e.run(dt(e,n[0],um()),n)],gi=(e,n,i)=>[e.run(dt(e,n[0],hi(i.min,i.max),i.cacheKey),n)],Vl=e=>W({min:e.attributes.getFloat("min",Ve),max:e.attributes.getFloat("max",ze)}),zl=(e,n)=>{let i=_m(e,n);return gi(e,[n[0]],i)},_m=(e,n)=>{if(n.length>=3&&(!e.session.isInitializer(n[1].dataId)||!e.session.isInitializer(n[2].dataId)))throw new Error("dynamic clip attributes are not allowed");let i=n.length>=3?n[1].numberData[0]:Ve,a=n.length>=3?n[2].numberData[0]:ze;return W({min:i,max:a})},Wl=(e,n)=>[e.run(dt(e,n[0],lm()),n)],Hl=(e,n)=>[e.run(dt(e,n[0],fm()),n)],ql=(e,n,i)=>[e.run(dt(e,n[0],cm(i.alpha),i.cacheKey),n)],jl=e=>W({alpha:e.attributes.getFloat("alpha",1)}),Xl=(e,n)=>[e.run(dt(e,n[0],pm()),n)],Kl=(e,n)=>[e.run(dt(e,n[0],dm()),n)],yi=(e,n)=>[e.run(dt(e,n[0],hm()),n)],Jl=(e,n,i)=>[e.run(dt(e,n[0],mm(i.alpha),i.cacheKey),n)],Yl=e=>W({alpha:e.attributes.getFloat("alpha",.01)}),Zl=(e,n)=>[e.run(dt(e,n[0],bm()),n)],Ql=(e,n)=>[e.run(dt(e,n[0],gm()),n)],tf=(e,n)=>[e.run(dt(e,n[0],ym()),n)],ef=(e,n)=>[e.run(dt(e,n[0],mi()),n)],rf=(e,n)=>[e.run(dt(e,n[0],bi()),n)],nf=(e,n)=>[e.run(dt(e,n[0],xm()),n)],of=(e,n)=>[e.run(dt(e,n[0],Tm()),n)],af=(e,n)=>[e.run(dt(e,n[0],wm()),n)],sf=(e,n)=>[e.run(dt(e,n[0],vm()),n)]});function he(e){let n;switch(e.activation){case"Relu":n=mi();break;case"Sigmoid":n=bi();break;case"Clip":n=hi(e.clipMin,e.clipMax);break;default:return{activationFunction:"",applyActivation:""}}let i=n.name,a=n.body,p=`value = ${i}_(value);`;return{activationFunction:a,applyActivation:p}}var pr,qe=O(()=>{Y(),xi(),pr=e=>{let n=e.getString("activation","");if(n==="Clip"){let[i,a]=e.getFloats("activation_params",[Ve,ze]);return{activation:n,clipMax:a,clipMin:i,activationCacheKey:`${n}:${i},${a}`}}return{activation:n,activationCacheKey:n}}}),Sm,Am,uf,lf=O(()=>{Ut(),ut(),j(),Bn(),qe(),Sm=(e,n)=>({name:"GroupedConv",inputNames:e?["X","W","Bias"]:["X","W"],inputTypes:e?[0,0,0]:[0,0],cacheHint:n}),Am=(e,n,i,a)=>{let p=n.length>2?"value += getBias(output_channel);":"",o=n[0].dims.slice(),s=n[1].dims.slice(),d=s[0]/a.group;tt.verbose("GroupedConv",`autpPad:${a.autoPad}, dilations:${a.dilations}, group:${a.group}, kernelShape:${a.kernelShape}, pads:${a.pads}, strides:${a.strides}`);let c=dr(o,s,a.dilations,a.pads,a.strides),r=G(e.session.backend.glContext.version),{activationFunction:u,applyActivation:l}=he(a),h=`
  const ivec2 strides = ivec2(${a.strides[0]}, ${a.strides[1]});
  const ivec2 pads = ivec2(${a.pads[0]}, ${a.pads[1]});
  ${u}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${d};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${s[1]}; wInChannel++) {
      int input_channel = group_id * ${s[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${s[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${a.dilations[0]};

        if (xHeight < 0 || xHeight >= ${o[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${s[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${a.dilations[1]};
          if (xWidth < 0 || xWidth >= ${o[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${p}
    ${l}
    ${r.output} = vec4(value, .0, .0, .0);
  }
`;return{...i,output:{dims:c,type:n[0].type,textureType:0},shaderSource:h,hasMain:!0}},uf=(e,n,i)=>{let a=Sm(n.length>2,i.cacheKey);return{...a,get:()=>Am(e,n,a,i)}}}),Pm,Em,ff,cf=O(()=>{ut(),j(),He(),Pm=e=>({name:"Im2Col (packed)",inputNames:["A"],inputTypes:[2],cacheHint:e}),Em=(e,n,i,a,p,o)=>{let s=i.dims,d=a.dims,c=2,r=3,u=p.length,l=[d[1]*d[2]*d[3],p[2]*p[3]],h=d[2]*d[3],f=de(),m=G(e.session.backend.glContext.version),y="";for(let I=0;I<=1;I++)for(let x=0;x<=1;x++)y+=`
            blockIndex = rc.x + ${x};
            pos = rc.y + ${I};

            if(blockIndex < ${l[1]} && pos < ${l[0]}) {
              offsetY = int(blockIndex / (${p[u-1]})) * ${o.strides[0]} -
                ${o.pads[0]};
              d0 = offsetY + ${o.dilations[0]} * (imod(pos, ${h}) / ${d[2]});

              if(d0 < ${s[c]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${p[u-1]}) * ${o.strides[1]} -
                  ${o.pads[1]};
                d1 = offsetX + ${o.dilations[1]} * imod(imod(pos, ${h}), ${d[2]});

                if(d1 < ${s[r]} && d1 >= 0) {

                  ch = int(float(pos)/ ${h}.);
                    innerDims = vec2(d0, d1);
                    result[${I*2+x}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;let _=`
      ${f}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${y}
          ${m.output} = result;
      }
            `;return{...n,output:{dims:l,type:i.type,textureType:2},shaderSource:_,hasMain:!0}},ff=(e,n,i,a,p)=>{let o=Pm(p.cacheKey);return{...o,get:()=>Em(e,o,n,i,a,p)}}});function Lm(e,n,i){let a=n[0].dims,p=n[1].dims,o=kt.calcShape(a,p,!0);if(!o)throw new Error("Can't use matmul on the given tensors");let s=Bt(o.length),d=ne(),{activationFunction:c,applyActivation:r}=he(i),u=n.length>2,l=u?"value += getBiasForMatmul();":"",h=u?`${wi(s,d,n[2].dims,o,!1)}`:"",f=o.length,m=a.length,y=p.length,_=a[a.length-1],I=`
    ${c}
    ${h}
    float process(int indices[${f}]) {
        int a[${m}];
        int b[${y}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${_}; ++k) {
            a[${m-1}] = k;
            b[${y-2}] = k;
            value += _A(a) * _B(b);
        }
        ${l}
        ${r}
        return value;
    }`;return{...e,output:{dims:o,type:n[0].type,textureType:0},shaderSource:I}}function Ti(e,n){let i=Dm(e.length>2,n.activationCacheKey);return{...i,get:()=>Lm(i,e,n)}}function wi(e,n,i,a,p){let o="",s=i.length,d=a.length,c=d-s;d<2&&s>0?o="coords":o=i.map((h,f)=>`coords.${n[f+c]}`).join(", ");let r=kt.getBroadcastDims(i,a).map(h=>`coords.${n[h+c]} = 0;`).join(`
`),u=B.size(i)===1,l="vec4(outputValue.xx, outputValue.yy)";return u&&(l="vec4(outputValue.x)"),p?`
vec4 getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${r}
  vec4 outputValue = getBias(${o});
  return ${l};
}`:`
float getBiasForMatmul() {
  ${e} coords = getOutputCoords();
  ${r}
  return getBias(coords.x);
}`}var pf,df,Dm,$m,Fn=O(()=>{Y(),j(),pe(),qe(),vi(),pf=(e,n,i)=>($m(n),e.session.pack?[e.run(Cn(e,n,i),n)]:[e.run(Ti(n,i),n)]),df=e=>pr(e.attributes),Dm=(e,n)=>({name:"MatMul",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[0,0,0]:[0,0],cacheHint:n}),$m=e=>{if(!e||e.length!==2)throw new Error("MatMul requires 2 inputs.");if(e[0].dims[e[0].dims.length-1]!==e[1].dims[e[1].dims.length-2])throw new Error("shared dimension does not match.");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64")throw new Error("inputs should be float type");if(e[0].type!==e[1].type)throw new Error("inputs types should match")}});function Fm(e,n,i,a){let p=[],o=[],s=i[0].dims,d=i[1].dims,c=s.length,r=d.length,u=a.length,l=u-c,h=u-r;p=s.map((x,P)=>`coords.${n[P+l]}`),p[c-1]="i*2",p.join(", "),o=d.map((x,P)=>`coords.${n[P+h]}`),o[r-2]="i*2",o.join(", ");let f=kt.getBroadcastDims(s,a),m=kt.getBroadcastDims(d,a),y=f.map(x=>`coords.${n[x+l]} = 0;`).join(`
`),_=m.map(x=>`coords.${n[x+h]} = 0;`).join(`
`),I=`int lastDim = coords.${n[u-1]};
  coords.${n[u-1]} = coords.${n[u-2]};
  coords.${n[u-2]} = lastDim;`;return`
vec4 getAAtOutCoordsMatmul(int i) {
  ${e} coords = getOutputCoords();
  ${I}
  ${y}
  vec4 outputValue = getA(${p});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${e} coords = getOutputCoords();
  ${I}
  ${_}
  vec4 outputValue = getB(${o});
  return outputValue;
}`}function Cm(e,n){let i="";for(let a=0;a<n-2;a++)i+=`rc.${e[a]}, `;return i+=`rc.${e[n-2]}, i*2`,i}function Nm(e,n){let i="";for(let a=0;a<n-2;a++)i+=`rc.${e[a]}, `;return i+=`i*2, rc.${e[n-1]}`,i}var km,Bm,Cn,vi=O(()=>{Y(),ut(),j(),pe(),qe(),Fn(),km=(e,n)=>({name:"MatMul (packed)",inputNames:e?["A","B","Bias"]:["A","B"],inputTypes:e?[2,2,2]:[2,2],cacheHint:n}),Bm=(e,n,i,a)=>{let p=i.length>2,o=p?"value += getBiasForMatmul();":"",s=i[0].dims,d=i[1].dims,c=kt.calcShape(s,d,!0),r=!B.areEqual(i[0].dims,i[1].dims);if(!c)throw new Error("Can't use matmul on the given tensors");let u=s[s.length-1],l=Math.ceil(u/2),h=s.length,f=d.length,m=G(e.session.backend.glContext.version),y=Bt(c.length),_=c.length,I=ne(),{activationFunction:x,applyActivation:P}=he(a),N=p?`${wi(y,I,i[2].dims,c,!0)}`:"",R=r?`${Fm(y,I,i,c)}`:"",ct=r?"getAAtOutCoordsMatmul(i)":`getA(${Cm(I,h)})`,st=r?"getBAtOutCoordsMatmul(i)":`getB(${Nm(I,f)})`,Dt=r?"":`${y} rc =
          getOutputCoords(); int lastDim = rc.${I[_-1]}; rc.${I[_-1]} =
          rc.${I[_-2]}; rc.${I[_-2]} = lastDim;
      `,Z=`
            ${R}
            ${N}
            ${x}
            void main() {
              ${Dt}

              vec4 value = vec4(0);
              for (int i = 0; i < ${l}; i++) {
                vec4 a = ${ct};
                vec4 b = ${st};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${o}
              ${P}
              ${m.output} = value;
            }`;return{...n,output:{dims:c,type:i[0].type,textureType:2},shaderSource:Z,hasMain:!0}},Cn=(e,n,i)=>{let a=km(n.length>2,i.activationCacheKey);return{...a,get:()=>Bm(e,a,n,i)}}}),hf,mf=O(()=>{Bn(),cf(),vi(),hf=(e,n,i)=>{let a=n[0].dims,p=n[1].dims,o=dr(a,p,i.dilations,i.pads,i.strides),s=e.run(ff(e,n[0],n[1],o,i),[n[0]]),d=e.reshapePacked(n[1],[p[0],p[1]*p[2]*p[3]]),c=n.length===3?[d,s,n[2]]:[d,s],r=e.run(Cn(e,c,i),c);return e.reshapePacked(r,o)}}),Rm,Gm,bf,Ii,_i=O(()=>{j(),Rm=e=>({name:"Im2Col",inputNames:["X"],inputTypes:[0],cacheHint:e}),Gm=(e,n,i,a,p,o)=>{let s=i.dims,d=a.dims,c=p.length,r=Ii(s,d,p,4),u=`
        const int XC = ${s[1]};
        const int XH = ${s[2]};
        const int XW = ${s[3]};
        const int KH = ${o.kernelShape[0]};
        const int KW = ${o.kernelShape[1]};
        const int dilationH = ${o.dilations[0]};
        const int dilationW = ${o.dilations[1]};
        const int strideH = ${o.strides[0]};
        const int strideW = ${o.strides[1]};
        const int padH = ${o.pads[0]};
        const int padW = ${o.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${c}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${s.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;return{...n,output:{dims:r,type:i.type,textureType:4},shaderSource:u}},bf=(e,n,i,a,p)=>{let o=Rm(p.cacheKey);return{...o,get:()=>Gm(e,o,n,i,a,p)}},Ii=(e,n,i,a=4)=>[i[0],i[2],i[3],Math.ceil(e[1]*n[2]*n[3]/a)]}),Mm,Um,gf,yf=O(()=>{Y(),ut(),j(),qe(),_i(),Mm=(e,n)=>({name:"ConvDotProduct",inputNames:e?["Im2Col","K","B"]:["Im2Col","K"],inputTypes:e?[0,4,0]:[0,4],cacheKey:n.activationCacheKey}),Um=(e,n,i,a,p)=>{let o=i[0].dims,s=i[1].dims,d=[s[0],Math.ceil(o[1]*s[2]*s[3]/4)],c=Ii(o,s,a),[r,u]=e.calculateTextureWidthAndHeight(d,4),l=B.computeStrides(c),[h,f]=e.calculateTextureWidthAndHeight(c,4),m=a.length,y=i.length<3?"0.0":"_B(b)",_=Math.ceil(o[1]*s[2]*s[3]/4),{activationFunction:I,applyActivation:x}=he(p),P=G(e.session.backend.glContext.version),N=`
${I}
float process(int indices[${m}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${l[0]} + im2col[1] * ${l[1]} + im2col[2] * ${l[2]};
  int kernelOffset = indices[1] * ${d[1]};
  float value = ${y};
  for (int i = 0; i < ${_}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${h}, ${f});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${r}, ${u});
    value += dot(${P.texture2D}(Im2Col, im2colCoords), ${P.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${x}
  return value;
}`;return{...n,output:{dims:a,type:i[0].type,textureType:0},shaderSource:N}},gf=(e,n,i,a)=>{let p=Mm(n.length>2,a);return{...p,get:()=>Um(e,p,n,i,a)}}}),dr,Oi,Vm,zm,Wm,Hm,Si,qm,Bn=O(()=>{It(),Y(),lf(),mf(),yf(),qe(),_i(),Fn(),dr=(e,n,i,a,p)=>{let o=e[0],s=e.slice(2),d=s.length,c=n[0],r=n.slice(2).map((l,h)=>l+(l-1)*(i[h]-1)),u=s.map((l,h)=>l+a[h]+a[h+d]).map((l,h)=>Math.floor((l-r[h]+p[h])/p[h]));return[o,c].concat(...u)},Oi=(e,n,i)=>(qm(n,i),Vm(e,n,i)),Vm=(e,n,i)=>{let a=Hm(i,n),p=e.session.pack,o=a.kernelShape[0]===1&&a.kernelShape[1]===1;return a.group>1?[e.run(uf(e,n,a),n)]:o&&p?[zm(e,n,a)]:p&&n[0].dims.length===4&&n[0].dims[0]===1&&!o?[hf(e,n,a)]:[Wm(e,n,a)]},zm=(e,n,i)=>{let a=n[0].dims,p=n[1].dims,o=dr(a,p,i.dilations,i.pads,i.strides),s=e.reshapeUnpacked(n[0],[a[1],a[2]*a[3]]),d=e.reshapeUnpacked(n[1],[p[0],p[1]]),c=n.length>2?[d,s,n[2]]:[d,s],r=e.run(Ti(c,i),c);return e.reshapeUnpacked(r,o)},Wm=(e,n,i)=>{let a=n[0].dims,p=n[1].dims,o=dr(a,p,i.dilations,i.pads,i.strides),s=e.run(bf(e,n[0],n[1],o,i),[n[0]]),d=n.length===3?[s,n[1],n[2]]:[s,n[1]];return e.run(gf(e,n,o,i),d)},Hm=(e,n)=>{let i=e.kernelShape.slice();if(e.kernelShape.length===0)for(let o=2;o<n[1].dims.length;++o)i.push(n[1].dims[o]);let a=e.pads.slice();Ue.adjustPadsBasedOnAutoPad(n[0].dims,e.strides,e.dilations,i,a,e.autoPad);let p=Object.assign({},e);return Object.assign(p,{kernelShape:i,pads:a,cacheKey:e.cacheKey}),p},Si=e=>{let n=e.attributes,i=pr(n),a=n.getString("auto_pad","NOTSET"),p=n.getInts("dilations",[1,1]),o=n.getInt("group",1),s=n.getInts("kernel_shape",[]),d=n.getInts("pads",[0,0,0,0]),c=n.getInts("strides",[1,1]);return W({autoPad:a,dilations:p,group:o,kernelShape:s,pads:d,strides:c,...i})},qm=(e,n)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let i=e[0].dims[1],a=e[1].dims[1]*n.group;if(i!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");if(e.length===3&&(e[2].dims.length!==1||e[1].dims[0]!==e[2].dims[0]))throw new Error("invalid bias");let p=e[0].dims.length-2;if(n.dilations.length!==p)throw new Error(`dilations should be ${p}D`);if(n.strides.length!==p)throw new Error(`strides should be ${p}D`);if(n.pads.length!==p*2)throw new Error(`pads should be ${p*2}D`);if(n.kernelShape.length!==0&&n.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("Conv input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("Conv input(bias) should be float tensor")}}),jm,Xm,Km,xf,Jm,Ym,Zm,Qm,tb,eb,Tf,rb,wf=O(()=>{It(),ut(),j(),qe(),jm=(e,n,i,a,p,o)=>(e-1)*n+i+(a-1)*p+1-o,Xm=(e,n,i,a,p)=>{let o=Math.floor(e/2);n==="SAME_UPPER"?(i[a]=o,i[p]=e-o):n==="SAME_LOWER"&&(i[a]=e-o,i[p]=o)},Km=(e,n,i,a,p,o,s,d)=>{let c=e.length-2,r=d.length===0;for(let u=0;u<c;++u){let l=r?e[u+2]*o[u]:d[u],h=jm(e[u+2],o[u],p[u],n[u],i[u],l);Xm(h,a,p,u,u+c),r&&d.push(o[u]*(e[u+2]-1)+s[u]+(n[u]-1)*i[u]+1-p[u]-p[u+c])}},xf=(e,n,i)=>(rb(n,i),Jm(e,n,i)),Jm=(e,n,i)=>{let a=eb(i,n);return[tb(e,n,a)]},Ym=(e,n)=>({name:"ConvTranspose",inputNames:e?["X","W","B"]:["X","W"],inputTypes:e?[0,0,0]:[0,0],cacheHint:n}),Zm=(e,n,i,a)=>{let p=n.length>2?"getB(output_channel)":"0.0",o=n[0].dims,s=n[1].dims,d=s[1],c=s[0]/a.group,r=[n[0].dims[0],n[1].dims[1]*a.group,...a.outputShape],u=G(e.session.backend.glContext.version),{activationFunction:l,applyActivation:h}=he(a),f=`
  const ivec2 strides = ivec2(${a.strides[0]}, ${a.strides[1]});
  const ivec2 pads = ivec2(${a.pads[0]}, ${a.pads[1]});
  ${l}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${d};
    int wOutChannel = output_channel - group_id * ${d};

    float value = ${p};
    for (int inChannelOffset = 0; inChannelOffset < ${c}; inChannelOffset++) {
      int input_channel = group_id * ${c} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${s[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${s[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${a.dilations[0]}, wHOff * ${a.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${o[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${o[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${h}
    ${u.output} = vec4(value, .0, .0, .0);
  }
`;return{...i,output:{dims:r,type:n[0].type,textureType:0},shaderSource:f,hasMain:!0}},Qm=(e,n,i)=>{let a=Ym(n.length>2,i.cacheKey);return{...a,get:()=>Zm(e,n,a,i)}},tb=(e,n,i)=>e.run(Qm(e,n,i),n),eb=(e,n)=>{let i=e.kernelShape.slice();if(e.kernelShape.length===0)for(let d=2;d<n[1].dims.length;++d)i.push(n[1].dims[d]);let a=e.pads.slice(),p=e.outputShape.slice(),o=n[0].dims;Km(o,i,e.dilations,e.autoPad,a,e.strides,e.outputPadding,p);let s=Object.assign({},e);return Object.assign(s,{kernelShape:i,pads:a,outputShape:p,cacheKey:e.cacheKey}),s},Tf=e=>{let n=e.attributes,i=pr(n),a=n.getString("auto_pad","NOTSET"),p=n.getInts("dilations",[1,1]),o=n.getInt("group",1),s=n.getInts("kernel_shape",[]),d=n.getInts("output_padding",[0,0]),c=n.getInts("output_shape",[]),r=n.getInts("pads",[0,0,0,0]),u=n.getInts("strides",[1,1]);return W({autoPad:a,dilations:p,group:o,kernelShape:s,outputPadding:d,outputShape:c,pads:r,strides:u,...i})},rb=(e,n)=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Conv requires 2 or 3 inputs");if(e[0].dims.length!==4||e[1].dims.length!==4)throw new Error("currently only support 2-dimensional conv");let i=e[0].dims[1],a=e[1].dims[0];if(i!==a)throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");let p=e[1].dims[1]*n.group;if(e.length===3&&(e[2].dims.length!==1||e[2].dims[0]!==p))throw new Error("invalid bias");let o=e[0].dims.length-2;if(n.dilations.length!==o)throw new Error(`dilations should be ${o}D`);if(n.strides.length!==o)throw new Error(`strides should be ${o}D`);if(n.pads.length!==o*2)throw new Error(`pads should be ${o*2}D`);if(n.outputPadding.length!==o)throw new Error(`output_padding should be ${o}D`);if(n.kernelShape.length!==0&&n.kernelShape.length!==e[1].dims.length-2)throw new Error("invalid kernel shape");if(n.outputShape.length!==0&&n.outputShape.length!==e[0].dims.length-2)throw new Error("invalid output shape");if(e[0].type!=="float32"||e[1].type!=="float32")throw new Error("ConvTranspose input(X,W) should be float tensor");if(e.length===3&&e[2].type!=="float32")throw new Error("ConvTranspose input(bias) should be float tensor")}}),vf,je,If,nb,_f,ob,ib,ab,Nn=O(()=>{It(),Y(),j(),vf={name:"Transpose",inputNames:["A"],inputTypes:[0]},je=(e,n,i)=>(ab(n),[e.run({...vf,cacheHint:i.cacheKey,get:()=>nb(e,n[0],i.perm)},n)]),If=e=>W({perm:e.attributes.getInts("perm",[])}),nb=(e,n,i)=>{let a=n.dims;i=_f(a,i);let p=ob(a,i),o=a.length,s=`
      ${ib("perm",i,o)}
      float process(int indices[${o}]) {
        int a[${o}];
        perm(a, indices);
        return _A(a);
      }`;return{...vf,output:{dims:p,type:n.type,textureType:0},shaderSource:s}},_f=(e,n)=>(n&&n.length!==e.length&&(n=[...e.keys()].reverse()),n),ob=(e,n)=>(n=_f(e,n),B.sortBasedOnPerm(e,n)),ib=(e,n,i)=>{let a=[];a.push(`void ${e}(out int a[${i}], int src[${i}]) {`);for(let p=0;p<i;++p)a.push(`	a[${n[p]}]=src[${p}];`);return a.push("	}"),a.join(`
`)},ab=e=>{if(!e||e.length!==1)throw new Error("Transpose requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("input should be float tensor")}}),Of,Sf,sb,Af=O(()=>{Nn(),Of=(e,n,i)=>{sb(n);let a=i.blocksize,p=a*a,o=i.mode==="DCR"?[0,3,4,1,5,2]:[0,1,4,2,5,3],s=i.mode==="DCR"?[n[0].dims[0],a,a,n[0].dims[1]/p,n[0].dims[2],n[0].dims[3]]:[n[0].dims[0],n[0].dims[1]/p,a,a,n[0].dims[2],n[0].dims[3]],d=e.reshapeUnpacked(n[0],s),c={perm:o,cacheKey:`${o}`},[r]=je(e,[d],c),u=[n[0].dims[0],n[0].dims[1]/p,n[0].dims[2]*a,n[0].dims[3]*a];return[e.reshapeUnpacked(r,u)]},Sf=e=>{let n=e.attributes.getInt("blocksize");if(n<1)throw new Error(`blocksize must be >= 1, but got : ${n} for DepthToSpace`);let i=e.attributes.getString("mode","DCR");if(i!=="DCR"&&i!=="CRD")throw new Error(`unrecognized mode: ${i} for DepthToSpace`);return{mode:i,blocksize:n}},sb=e=>{if(e.length!==1)throw new Error(`DepthToSpace expect 1 inputs, but got ${e.length}`);if(e[0].type==="string"||e[0].dims.length!==4)throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")}}),Pf,Ef,ub,Df=O(()=>{Y(),Pf=(e,n,i)=>{ub(n,i);let a=B.flattenShape(n[0].dims,i);return[e.reshapeUnpacked(n[0],a)]},Ef=e=>e.attributes.getInt("axis",1),ub=(e,n)=>{if(!e||e.length!==1)throw new Error("Flatten requires 1 input.");let i=e[0].dims.length;if(i===0)throw new Error("scalar tensor is not supported.");if(n<-i||n>i)throw new Error("Invalid axis");if(e[0].type==="string")throw new Error("string tensor is not supported.")}}),Pe,Rr=O(()=>{Pe=["float32","float64","int32","int16","int8","uint16","uint32","uint8"]}),Lf,$f,lb,fb,cb,pb,kf=O(()=>{It(),Rr(),Y(),j(),Lf=(e,n,i)=>(pb(n,i.axis),[e.run(cb(e,n,i),n)]),$f=e=>W({axis:e.attributes.getInt("axis",0)}),lb={name:"Gather",inputNames:["A","B"],inputTypes:[0,0]},fb=(e,n,i,a)=>{let p=i[0].dims.slice(),o=i[1].dims.slice(),s=new Array(p.length+o.length-1);a=B.normalizeAxis(a,p.length);let d=[];for(let h=0;h<s.length;h++)h<a?(s[h]=p[h],d.push(`inputIdx[${h}] = outputIdx[${h}];`)):h<a+o.length?(s[h]=o[h-a],d.push(`indexDataIdx[${h-a}] = outputIdx[${h}];`)):(s[h]=p[h-o.length+1],d.push(`inputIdx[${h-o.length+1}] = outputIdx[${h}];`));let c=s.length||1,r=p.length,u=o.length||1,l=`
      float process(int outputIdx[${c}]) {
        int inputIdx[${r}];
        int indexDataIdx[${u}];
        indexDataIdx[0] = 0;
        ${d.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${a}] = idx < 0 ? idx + ${p[a]} : idx;
        return _A(inputIdx);
      }`;return{...n,output:{dims:s,type:i[0].type,textureType:0},shaderSource:l}},cb=(e,n,i)=>{let a={...lb,cacheHint:i.cacheKey};return{...a,get:()=>fb(e,a,n,i.axis)}},pb=(e,n)=>{if(!e||e.length!==2)throw new Error("Gather requires 2 inputs.");let i=e[0].dims.length;if(i<1)throw new Error("Invalid input shape.");if(n<-i||n>i-1)throw new Error("Invalid axis.");if(Pe.indexOf(e[0].type)===-1)throw new Error("Invaid input type.");if(e[1].type!=="int32"&&e[1].type!=="int16")throw new Error("Invaid input type.")}}),Ai,Bf,Ff,Cf,db,hb,mb,Nf=O(()=>{It(),Y(),j(),Ai=(e,n,i)=>(mb(n,i),[e.run(db(n,i),n)]),Bf=(e,n)=>{let i=e.attributes.getInt("transA",0)!==0,a=e.attributes.getInt("transB",0)!==0,p=e.attributes.getFloat("alpha",1),o=e.attributes.getFloat("beta",1);return W({transA:i,transB:a,alpha:p,beta:o,isOptionalC:n})},Ff=e=>Bf(e,!1),Cf=e=>Bf(e,!0),db=(e,n)=>{let i={name:"Gemm",inputNames:e.length===3?["A","B","C"]:["A","B"],inputTypes:e.length===3?[0,0,0]:[0,0],key:n.cacheKey};return{...i,get:()=>hb(i,e,n)}},hb=(e,n,i)=>{let a=n[0].dims.slice(),p=n[1].dims.slice(),[o,s]=Sn.getShapeOfGemmResult(a,i.transA,p,i.transB,n.length===3?n[2].dims:void 0),d=[o,s];if(!d)throw new Error("Can't use gemm on the given tensors");let c=a[a.length-1],r="";i.transA&&(c=a[0]),i.transA&&i.transB?r="value += _A_T(a) * _B_T(b);":i.transA&&!i.transB?r="value += _A_T(a) * _B(b);":!i.transA&&i.transB?r="value += _A(a) * _B_T(b);":!i.transA&&!i.transB&&(r="value += _A(a) * _B(b);");let u=d.length,l=n.length===3?`int c[${n[2].dims.length}];`:"",h=n.length===3?"bcastIndices_C(indices, c);":"",f=n.length===3?"value += beta * _C(c);":"",m=`
      float process(int indices[${u}]) {
          int a[${u}];
          int b[${u}];
          ${l}

          copyVec(indices, a);
          copyVec(indices, b);
          ${h}

          float value = 0.0;
          for (int k=0; k<${c}; ++k) {
              a[${u-1}] = k;
              b[${u-2}] = k;
              ${r}
          }

          value = value * alpha;
          ${f}
          return value;
      }`;return{...e,output:{dims:d,type:n[0].type,textureType:0},variables:[{name:"alpha",type:"float",data:i.alpha},{name:"beta",type:"float",data:i.beta}],shaderSource:m}},mb=(e,n)=>{if(!e)throw new Error("Input is missing");if(n.isOptionalC&&(e.length<2||e.length>3))throw new Error("Invaid input shape.");if(!n.isOptionalC&&e.length!==3)throw new Error("Gemm requires 3 inputs");if(e.length===3&&e[2].dims.length!==1&&e[2].dims.length!==2)throw new Error("Invalid input shape of C");if(e[0].type!=="float32"&&e[0].type!=="float64"||e[1].type!=="float32"&&e[1].type!=="float64"||e.length===3&&e[2].type!=="float32"&&e[2].type!=="float64")throw new Error("Invalid input type.");if(e[0].type!==e[1].type||e.length===3&&e[0].type!==e[2].type)throw new Error("Input types are mismatched")}}),Rf,Gf,bb,gb,yb,xb,Tb,Mf=O(()=>{It(),j(),Rf=(e,n,i)=>(Tb(n),[e.run(yb(e,n,i),n)]),Gf=e=>{let n=e.attributes.getFloat("scale"),i=e.attributes.getFloats("bias");return W({scale:n,bias:i})},bb={name:"ImageScaler",inputNames:["X"],inputTypes:[0]},gb=(e,n,i,a)=>{let p=i[0].dims.slice(),o=p.length,s=`
      ${xb(a.bias.length)}
      float process(int indices[${o}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;return{...n,output:{dims:p,type:i[0].type,textureType:0},variables:[{name:"bias",type:"float",arrayLength:a.bias.length,data:a.bias},{name:"scale",type:"float",data:a.scale}],shaderSource:s}},yb=(e,n,i)=>{let a={...bb,cacheHint:i.cacheKey};return{...a,get:()=>gb(e,a,n,i)}},xb=e=>{let n=[`float getBias(float bias[${e}], int channel) {`];for(let i=0;i<e;++i)i===0?n.push(`	if (channel == ${i}) { return bias[${i}]; }`):i===e-1?n.push(`	else { return bias[${i}]; }`):n.push(`	else if (channel == ${i}) { return bias[${i}]; }`);return n.push("	}"),n.join(`
`)},Tb=e=>{if(!e||e.length!==1)throw new Error("ImageScaler requires 1 input.");if(e[0].dims.length!==4)throw new Error("Invalid input shape.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")}}),Vf,zf,Uf,wb,vb,Ib,_b,Ob,Sb,Wf=O(()=>{ut(),j(),Vf=(e,n,i)=>{Sb(n);let a=e.run(vb(n[0]),n);return[e.run(Ob(e,n[0],i,a.dims),[n[0],a,n[1],n[2]])]},zf=e=>e.attributes.getFloat("epsilon",1e-5),Uf={name:"InstanceNormalization_MeanAndVariance",inputNames:["X"],inputTypes:[0]},wb=(e,n)=>{let i=n.dims.slice(),a=i[1],p=i[2]*i[3],o=[i[0],a],s=`
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${p});
        temp = 0.0;
        for(int a2=0; a2<${i[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${i[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${p});

        return v;
      }`;return{...e,output:{dims:o,type:n.type,textureType:4},shaderSource:s}},vb=e=>({...Uf,get:()=>wb(Uf,e)}),Ib={name:"InstanceNormalization_ComputeOutput",inputNames:["X","MeanAndVariance","Scale","B"],inputTypes:[0,4,0,0]},_b=(e,n,i,a,p)=>{let o=G(e.session.backend.glContext.version),[s,d]=e.calculateTextureWidthAndHeight(p,4),[c,r]=[s/4,d],u=`
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${c}, ${r});
        return ${o.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;return{...n,output:{dims:i.dims,type:i.type,textureType:0},variables:[{name:"epsilon",type:"float",data:a}],shaderSource:u}},Ob=(e,n,i,a)=>{let p={...Ib,cacheHint:`${i}`};return{...p,get:()=>_b(e,p,n,i,a)}},Sb=e=>{if(!e||e.length!==3)throw new Error("InstanceNormalization requires 3 inputs.");let n=e[0],i=e[1],a=e[2];if(n.dims.length<3||i.dims.length!==1||a.dims.length!==1)throw new Error("Invalid input shape.");if(i.dims[0]!==n.dims[1]||a.dims[0]!==n.dims[1])throw new Error("Input shapes are mismatched.");if(n.type!=="float32"&&n.type!=="float64"||i.type!=="float32"&&i.type!=="float64"||a.type!=="float32"&&a.type!=="float64")throw new Error("Invalid input type.");if(e[0].dims.length!==4)throw new Error("Only support 4-D input shape.")}});function Ab(e,n){let i=e[0].dims[1],a=e[0].dims.length,p=-Math.floor((n.size-1)/2),o=Math.ceil((n.size-1)/2),s=`float(${n.alpha}) / float(${n.size})`,d=`float(${n.bias})`,c=`float(${n.beta})`,r=`
    float process(int indices[${a}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${p}; i <= ${o}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${i}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(${d} + ${s} * square_sum, ${c});
    }`;return{...jf,cacheHint:n.cacheKey,output:{dims:e[0].dims,type:e[0].type,textureType:0},shaderSource:r}}function Pb(e,n){return{...jf,cacheHint:n.cacheKey,get:()=>Ab(e,n)}}var Hf,qf,jf,Eb,Xf=O(()=>{It(),j(),Hf=(e,n,i)=>(Eb(n),[e.run(Pb(n,i),n)]),qf=e=>{let n=e.attributes.getFloat("alpha",1e-4),i=e.attributes.getFloat("beta",.75),a=e.attributes.getFloat("bias",1),p=e.attributes.getInt("size");return W({alpha:n,beta:i,bias:a,size:p})},jf={name:"LRN",inputNames:["X"],inputTypes:[0]},Eb=e=>{if(!e||e.length!==1)throw new Error("LRN requires 1 input.");if(e[0].dims.length!==4)throw new Error('currently only support LRN for input with "NCHW" format');if(e[0].type!=="float32")throw new Error("input should be float type")}}),Db,Pi,Kf,Jf,Yf,Lb,$b,kb,Bb,Fb,Cb,Nb,Rb,Zf=O(()=>{It(),Y(),ut(),j(),Db={name:"Pad",inputNames:["A"],inputTypes:[0]},Pi=(e,n,i)=>(kb(n),[e.run({...Db,cacheHint:i.cacheKey,get:()=>$b(e,n[0],i)},n)]),Kf=e=>{let n=e.attributes.getString("mode","constant"),i=e.attributes.getFloat("value",0),a=e.attributes.getInts("pads");return W({mode:n,value:i,pads:a})},Jf=(e,n,i)=>{Bb(n);let a=Lb(e,n,i);return Pi(e,[n[0]],a)},Yf=e=>e.attributes.getString("mode","constant"),Lb=(e,n,i)=>{if(!e.session.isInitializer(n[1].dataId)||n.length>=3&&!e.session.isInitializer(n[2].dataId))throw new Error("dynamic pad attributes are not allowed");let a=Array.from(n[1].integerData),p=n.length>=3?n[2].floatData[0]:0;return W({mode:i,pads:a,value:p})},$b=(e,n,i)=>{let a=B.padShape(n.dims.slice(),i.pads),p=a.length,o=`
      ${Fb(e,n,i)}
      float process(int[${p}] indices) {
          return padA(indices);
      }`;return{name:"Pad",inputNames:["A"],inputTypes:[0],output:{dims:a,type:n.type,textureType:0},shaderSource:o}},kb=e=>{if(!e||e.length!==1)throw new Error("Pad requires 1 input");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")},Bb=e=>{if(!e||e.length!==2&&e.length!==3)throw new Error("Pad requires 2 or 3 inputs");if(e[1].type!=="int32")throw new Error("Invalid input type.");if(e.length>=3&&e[2].type==="string")throw new Error("Invalid input type.")},Fb=(e,n,i)=>{let a=G(e.session.backend.glContext.version),[p,o]=e.calculateTextureWidthAndHeight(n.dims,0),s=B.computeStrides(n.dims);switch(i.mode){case"constant":return Cb(a,n.dims,s,p,o,i.pads,i.value);case"reflect":return Nb(a,n.dims,s,p,o,i.pads);case"edge":return Rb(a,n.dims,s,p,o,i.pads);default:throw new Error("Invalid mode")}},Cb=(e,n,i,a,p,o,s)=>{let d=n.length,c="";for(let r=d-1;r>=0;--r)c+=`
        k = m[${r}] - ${o[r]};
        if (k < 0)  return constant;
        if (k >= ${n[r]}) return constant;
        offset += k * ${i[r]};
        `;return`
      float padA(int m[${d}]) {
        const float constant = float(${s});
        int offset = 0;
        int k = 0;
        ${c}
        vec2 coords = offsetToCoords(offset, ${a}, ${p});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `},Nb=(e,n,i,a,p,o)=>{let s=n.length,d="";for(let c=s-1;c>=0;--c)d+=`
        k = m[${c}] - ${o[c]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2*(n[c]-1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${n[c]}) { k = _2n_1 - k; }
        }
        offset += k * ${i[c]};
        `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${d}
        vec2 coords = offsetToCoords(offset, ${a}, ${p});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `},Rb=(e,n,i,a,p,o)=>{let s=n.length,d="";for(let c=s-1;c>=0;--c)d+=`
        k = m[${c}] - ${o[c]};
        if (k < 0)  k = 0;
        if (k >= ${n[c]}) k = ${n[c]-1};
        offset += k * ${i[c]};
      `;return`
      float padA(int m[${s}]) {
        int offset = 0;
        int k = 0;
        ${d}
        vec2 coords = offsetToCoords(offset, ${a}, ${p});
        float value = getColorAsFloat(${e.texture2D}(A, coords));
        return value;
      }
      `}}),tc,ec,rc,nc,oc,ic,ac,sc,uc,Gb,Qf,lc,Gn,fc,Rn,Mb,cc=O(()=>{It(),Y(),j(),tc=(e,n,i)=>{Gn(n);let a={name:"AveragePool",inputNames:["X"],inputTypes:[0],cacheHint:i.cacheKey};return[e.run({...a,get:()=>rc(n,a,!1,i)},n)]},ec=e=>{let n=e.attributes.getString("auto_pad","NOTSET"),i=e.attributes.getInt("ceil_mode",0),a=e.attributes.getInt("count_include_pad",0)!==0,p=e.attributes.getInts("kernel_shape"),o=e.attributes.getInts("strides",[]),s=e.attributes.getInts("pads",[]);if(i!==0)throw new Error("using ceil() in shape computation is not yet supported for AveragePool");return W({autoPad:n,ceilMode:i,countIncludePad:a,kernelShape:p,strides:o,pads:s})},rc=(e,n,i,a)=>{let[p,o]=uc(e,a,i),s=B.size(p.kernelShape),d="value += _X(x);",c="";p.countIncludePad?c+=`value /= float(${s});`:c+=`value /= float(${s} - pad);`;let r=`
        ${fc(e[0].dims,p,d,c,"0.0")}
      `;return{...n,output:{dims:o,type:e[0].type,textureType:0},shaderSource:r}},nc=(e,n,i)=>{Gn(n);let a={name:"GlobalAveragePool",inputNames:["X"],inputTypes:[0],cacheHint:`${i.countIncludePad}`};return[e.run({...a,get:()=>rc(n,a,!0,i)},n)]},oc=e=>{let n=e.attributes.getInt("count_include_pad",0)!==0;return W({autoPad:"",ceilMode:0,countIncludePad:n,kernelShape:[],strides:[],pads:[]})},ic=(e,n,i)=>{Gn(n);let a={name:"MaxPool",inputNames:["X"],inputTypes:[0],cacheHint:i.cacheKey};return[e.run({...a,get:()=>sc(n,a,!1,i)},n)]},ac=e=>{let n=e.attributes.getString("auto_pad","NOTSET"),i=e.attributes.getInt("ceil_mode",0),a=e.attributes.getInts("kernel_shape"),p=e.attributes.getInts("strides",[]),o=e.attributes.getInts("pads",[]),s=e.attributes.getInt("storage_order",0),d=e.attributes.getInts("dilations",[]);if(s!==0)throw new Error("column major storage order is not yet supported for MaxPool");if(i!==0)throw new Error("using ceil() in shape computation is not yet supported for MaxPool");return W({autoPad:n,ceilMode:i,countIncludePad:!1,kernelShape:a,strides:p,pads:o,storageOrder:s,dilations:d})},sc=(e,n,i,a)=>{let[p,o]=uc(e,a,i),s=`
      value = max(_X(x), value);
    `,d="",c=`
      ${fc(e[0].dims,p,s,d,"-1e5")}
    `;return{...n,output:{dims:o,type:e[0].type,textureType:0},shaderSource:c}},uc=(e,n,i)=>{let a=e[0].dims.slice(),p=Object.hasOwnProperty.call(n,"dilations"),o=n.kernelShape.slice(),s=n.strides.slice(),d=p?n.dilations.slice():[],c=n.pads.slice();Ue.adjustPoolAttributes(i,a,o,s,d,c);let r=Ue.computePoolOutputShape(i,a,s,d,o,c,n.autoPad),u=Object.assign({},n);return p?Object.assign(u,{kernelShape:o,strides:s,pads:c,dilations:d,cacheKey:n.cacheKey}):Object.assign(u,{kernelShape:o,strides:s,pads:c,cacheKey:n.cacheKey}),[u,r]},Gb={autoPad:"",ceilMode:0,countIncludePad:!1,kernelShape:[],strides:[],pads:[],storageOrder:0,dilations:[],cacheKey:""},Qf={name:"GlobalMaxPool",inputNames:["X"],inputTypes:[0]},lc=(e,n)=>(Gn(n),[e.run({...Qf,get:()=>sc(n,Qf,!0,Gb)},n)]),Gn=e=>{if(!e||e.length!==1)throw new Error("Pool ops requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.")},fc=(e,n,i,a,p)=>{let o=e.length;if(n.kernelShape.length<=2){let s=n.kernelShape[n.kernelShape.length-1],d=n.strides[n.strides.length-1],c=n.pads[n.pads.length/2-1],r=n.pads[n.pads.length-1],u=e[o-1],l="",h="",f="";if(c+r!==0?l=`
          for (int i = 0; i < ${s}; i++) {
            x[${o} - 1] = indices[${o} - 1] * ${d} - ${c} + i;
            if (x[${o} - 1] < 0 || x[${o} - 1] >= ${u}) {
              pad++;
              continue;
            }
            ${i}
          }`:l=`
          for (int i = 0; i < ${s}; i++) {
            x[${o} - 1] = indices[${o} - 1] * ${d} - ${c} + i;
            ${i}
          }`,n.kernelShape.length===2){let m=n.kernelShape[n.kernelShape.length-2],y=n.strides[n.strides.length-2],_=n.pads[n.pads.length/2-2],I=n.pads[n.pads.length-2],x=e[o-2];_+I!==0?h=`
            for (int j = 0; j < ${m}; j++) {
              x[${o} - 2] = indices[${o} - 2] * ${y} - ${_} + j;
              if (x[${o} - 2] < 0 || x[${o} - 2] >= ${x}) {
                pad+= ${s};
                continue;
              }
          `:h=`
            for (int j = 0; j < ${m}; j++) {
              x[${o} - 2] = indices[${o} - 2] * ${y} - ${_} + j;
            `,f=`
          }
        `}return`
        float process(int indices[${o}]) {
          int x[${o}];
          copyVec(indices, x);

          float value = ${p};
          int pad = 0;
          ${h}
          ${l}
          ${f}
          ${a}
          return value;
        }
      `}else{let s=B.size(n.kernelShape),d=B.computeStrides(n.kernelShape),c=d.length,r=n.pads.length,u=Mb(c),l=Rn(e,"inputDims"),h=Rn(n.pads,"pads"),f=Rn(d,"kernelStrides"),m=Rn(n.strides,"strides"),y=n.pads.reduce((I,x)=>I+x),_="";return y?_=`
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${i}
          }`:_=`
          }
          ${i}
        `,`
        ${u}
        float process(int indices[${o}]) {
          int x[${o}];
          copyVec(indices, x);
          int offset[${c}];
          int pads[${r}];
          int inputDims[${o}];
          int kernelStrides[${c}];
          int strides[${c}];
          ${h}
          ${l}
          ${m}
          ${f}

          float value = ${p};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${o} - ${c}; j < ${o}; j++) {
              x[j] = indices[j] * strides[j - ${o} + ${c}]
                + offset[j - ${o} + ${c}] - pads[j - 2];
              ${_}
          }
          ${a}

          return value;
        }
      `}},Rn=(e,n)=>{let i="";for(let a=0;a<e.length;a++)i+=`
      ${n}[${a}] = ${e[a]};
    `;return i},Mb=e=>`
  void offsetToIndices(int offset, int[${e}] strides, out int[${e}] indices) {
    if (${e} == 0) {
      return;
    }
    for (int i = 0; i < ${e} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${e} - 1] = offset;
  }`}),Xe,Ee,Ub,Vb,pc,dc,hc,mc,bc,gc,yc,xc=O(()=>{It(),Rr(),Y(),j(),Xe=(e,n,i,a,p)=>{Vb(n);let o={name:a,inputNames:["A"],inputTypes:[0]};return[e.run({...o,cacheHint:i.cacheKey,get:()=>Ub(e,n,i,a,p,o)},n)]},Ee=e=>{let n=e.attributes.getInts("axes",[]),i=e.attributes.getInt("keepdims",1)===1;return W({axes:n,keepDims:i})},Ub=(e,n,i,a,p,o)=>{let s=[],d=n[0].dims.length||1,c=[],r=B.normalizeAxes(i.axes,n[0].dims.length),u=p(n,r),l=u[1];for(let f=0;f<n[0].dims.length;f++)r.indexOf(f)>=0||r.length===0?(i.keepDims&&s.push(1),l=`
          for(int j${f} = 0; j${f} < ${n[0].dims[f]}; j${f}++) {
            inputIdx[${f}] = j${f};
            ${l}
          }`):(c.push(`inputIdx[${f}] = outputIdx[${s.length}];`),s.push(n[0].dims[f]));let h=`
      float process(int outputIdx[${s.length||1}]) {
        float value;                 // final result
        int inputIdx[${d}];      // addressing input data
        ${c.join(`
`)}
        ${u[0]}       // init ops for reduce max/min
        ${l}
        ${u[2]}       // final computation for reduce mean
        return value;
      }`;return{...o,output:{dims:s,type:n[0].type,textureType:0},shaderSource:h}},Vb=e=>{if(!e||e.length!==1)throw new Error("Reduce op requires 1 input.");if(Pe.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")},pc=(e,n,i)=>Xe(e,n,i,"ReduceSum",()=>["value = 0.0;","value += _A(inputIdx);",""]),dc=(e,n,i)=>Xe(e,n,i,"ReduceMean",(a,p)=>{let o=1;for(let s=0;s<a[0].dims.length;s++)(p.indexOf(s)>=0||p.length===0)&&(o*=a[0].dims[s]);return["value = 0.0;","value += _A(inputIdx);",`value /= ${o}.;`]}),hc=(e,n,i)=>Xe(e,n,i,"ReduceMax",(a,p)=>{let o=[];for(let s=0;s<a[0].dims.length;s++)(p.indexOf(s)>=0||p.length===0)&&o.push(`inputIdx[${s}] = 0;`);return[`${o.join(`
`)}
value = _A(inputIdx);`,"value = max(value, _A(inputIdx));",""]}),mc=(e,n,i)=>Xe(e,n,i,"ReduceMin",(a,p)=>{let o=[];for(let s=0;s<a[0].dims.length;s++)(p.indexOf(s)>=0||p.length===0)&&o.push(`inputIdx[${s}] = 0;`);return[`${o.join(`
`)}
value = _A(inputIdx);`,"value = min(value, _A(inputIdx));",""]}),bc=(e,n,i)=>Xe(e,n,i,"ReduceProd",()=>["value = 1.0;","value *= _A(inputIdx);",""]),gc=(e,n,i)=>Xe(e,n,i,"ReduceLogSum",()=>["value = 0.0;","value += _A(inputIdx);","value = log(value);"]),yc=(e,n,i)=>Xe(e,n,i,"ReduceLogSumSquare",()=>["float t; value = 0.0;","t = _A(inputIdx); value += t * t;",""])}),Tc,wc=O(()=>{Y(),Tc=(e,n)=>{let i=B.calculateReshapedDims(n[0].dims,n[1].integerData);return e.session.pack?[e.reshapePacked(n[0],i)]:[e.reshapeUnpacked(n[0],i)]}}),vc,Ei,Ic,_c,Gr,zb,Di,Mn,Li=O(()=>{It(),ut(),j(),vc={name:"Upsample",inputNames:["X"],inputTypes:[0]},Ei=(e,n,i)=>(Di(n,i),[e.run({...vc,cacheHint:i.cacheKey,get:()=>zb(e,n,i)},n)]),Ic=e=>Gr(e,7),_c=e=>Gr(e,9),Gr=(e,n)=>{let i=n>=10,a=e.attributes.getString("mode","nearest");if(a!=="nearest"&&a!=="linear"&&(n<11||a!=="cubic"))throw new Error(`unrecognized mode: ${a}`);let p=[];n<9&&(p=e.attributes.getFloats("scales"),Mn(p,a,i));let o=e.attributes.getFloat("extrapolation_value",0),s=n>10?e.attributes.getString("coordinate_transformation_mode","half_pixel"):"asymmetric";if(["asymmetric","pytorch_half_pixel","tf_half_pixel_for_nn","align_corners","tf_crop_and_resize","half_pixel"].indexOf(s)===-1)throw new Error(`coordinate_transform_mode '${s}' is not supported`);let d=s==="tf_crop_and_resize",c=d,r=a==="nearest"&&n>=11?e.attributes.getString("nearest_mode","round_prefer_floor"):"";if(["round_prefer_floor","round_prefer_ceil","floor","ceil",""].indexOf(r)===-1)throw new Error(`nearest_mode '${r}' is not supported`);let u=e.attributes.getFloat("cubic_coeff_a",-.75),l=e.attributes.getInt("exclude_outside",0)!==0;if(l&&a!=="cubic")throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");let h=n<11?!0:a==="nearest"&&s==="asymmetric"&&r==="floor",f=0,m=0,y=0;return n>10?e.inputs.length>2?(f=1,m=2,y=3):(m=1,y=2):n===9&&(m=1),W({opset:n,isResize:i,mode:a,scales:p,extrapolationValue:o,coordinateTransformMode:s,useExtrapolation:c,needRoiInput:d,nearestMode:r,cubicCoefficientA:u,excludeOutside:l,useNearest2xOptimization:h,roiInputIdx:f,scalesInputIdx:m,sizesInputIdx:y})},zb=(e,n,i)=>{let a=G(e.session.backend.glContext.version),[p,o]=e.calculateTextureWidthAndHeight(n[0].dims,0),s=n[0].dims.map((y,_)=>Math.floor(y*i.scales[_])),[d,c]=e.calculateTextureWidthAndHeight(s,0),r=s.length,u=new Array(r),l=new Array(r),h=`
      int output_pitches[${r}];
      int input_pitches[${r}];
      `;for(let y=r-1;y>=0;y--)u[y]=y===r-1?1:u[y+1]*s[y+1],l[y]=y===r-1?1:l[y+1]*n[0].dims[y+1],h+=`
        output_pitches[${y}] = ${u[y]};
        input_pitches[${y}] = ${l[y]};
        `;let f=`
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${p}, ${o});
        float value = getColorAsFloat(${a.texture2D}(X, coords));
        return value;
      }
      `,m=i.mode==="nearest"?`
    ${f}
    float process(int indices[${r}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${d}, ${c});

      ${h}

      int d, m;
      for (int dim = 0; dim < ${r}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }`:r===4?`
    ${f}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${d}, ${c});

      ${h}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${n[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }`:`
    ${f}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${d}, ${c});

      ${h}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${n[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;return{...vc,output:{dims:s,type:n[0].type,textureType:0},shaderSource:m,variables:[{name:"scales",type:"int",arrayLength:i.scales.length,data:i.scales.map(y=>Math.ceil(y))}]}},Di=(e,n)=>{if(!e||n.opset<9&&e.length!==1||n.opset>=9&&n.opset<11&&e.length!==2||n.opset>=11&&e.length<2)throw new Error("invalid inputs.");if(n.scales.length>0&&e[0].dims.length!==n.scales.length)throw new Error("Invalid input shape.");if(e[0].type==="string")throw new Error("Invalid input tensor types.")},Mn=(e,n,i)=>{if(i){for(let a of e)if(a<=0)throw new Error("Scale value should be greater than 0.")}else for(let a of e)if(a<1)throw new Error("Scale value should be greater than or equal to 1.");if((n==="linear"||n==="cubic")&&e.length!==2&&(e.length!==4||e[0]!==1||e[1]!==1))throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${i?"Resize":"Upsample"} opeartor.`)}}),$i,ki,Oc,Sc,Wb,Hb,qb,jb,Ac=O(()=>{ut(),j(),pe(),He(),Li(),$i={name:"Resize",inputNames:["A"],inputTypes:[2]},ki=(e,n,i)=>(Di(n,i),[e.run({...$i,cacheHint:i.cacheKey,get:()=>Wb(e,n,i)},n)]),Oc=e=>Gr(e,10),Sc=e=>Gr(e,11),Wb=(e,n,i)=>{let a=G(e.session.backend.glContext.version),[p,o]=Hb(n,i);if(p.every(x=>x===1)&&i.coordinateTransformMode!=="tf_crop_and_resize")return{...$i,output:{dims:o,type:n[0].type,textureType:2},hasMain:!0,shaderSource:`void main() {
                    vec4 v = ${a.texture2D}(X, TexCoords);
                    ${a.output} = v;
                }`};let s=o.length;if(s<2)throw new Error(`output dimension should be at least 2, but got ${s}`);let d=o[s-2],c=o[s-1],r=n[0].dims;if(s!==r.length)throw new Error(`output dimension should match input ${r.length}, but got ${s}`);let u=r[s-2],l=r[s-1],h=p[s-2],f=p[s-1],m="";if(i.mode!=="linear")throw new Error(`resize (packed) does not support mode: '${i.mode}'`);switch(i.coordinateTransformMode){case"asymmetric":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;break;case"half_pixel":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;break;case"pytorch_half_pixel":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${c}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${d}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${c}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${d}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;break;case"align_corners":m=`
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${c}.0 - 1.0, ${d}.0 - 1.0, ${c}.0 - 1.0,
                            ${d}.0 - 1.0);
                        vec4 original = vec4(${l}.0 - 1.0, ${u}.0 - 1.0, ${l}.0 - 1.0,
                            ${u}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;break;default:throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${i.coordinateTransformMode}'`)}let y=Bt(s),_=de(),I=`
            const vec2 inputWH = vec2(${u}.0, ${l}.0);
            const vec4 scaleWHWH = vec4(float(${h}), float(${f}), float(${h}), float(${f}));
            ${_}
            ${m}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${y} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${d-1};
                bool hasNextCol = rc.z < ${c-1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${a.output} = vec4(newValue);
            }
        `;return{...$i,output:{dims:o,type:n[0].type,textureType:2},hasMain:!0,shaderSource:I}},Hb=(e,n)=>{let i=e[0].dims,a=n.scales,p;if(a.length===0){let s=e[n.scalesInputIdx];if(s&&s.size!==0){if(e[n.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");a=qb(s,n.mode,n.isResize)}else{let d=e[n.sizesInputIdx];if(!d||d.size===0)throw new Error("Either scales or sizes MUST be provided as input.");p=Array.from(d.integerData),a=jb(p,i,n.mode,n.isResize)}}else if(e[n.sizesInputIdx])throw new Error("Only one of scales or sizes must be provided as input.");let o=p||i.map((s,d)=>Math.floor(s*a[d]));return[a,o]},qb=(e,n,i)=>{let a=Array.from(e.floatData);return Mn(a,n,i),a},jb=(e,n,i,a)=>{let p=n.length,o=new Array(p);for(let s=0,d=p;s<d;s++)if(n[s]===0){if(e[s]!==0)throw new Error("Input dim is zero but required output dim is non-zero.");o[s]=1}else o[s]=e[s]/n[s];return Mn(o,i,a),o}}),Pc,Xb,Ec=O(()=>{We(),Pc=(e,n)=>(Xb(n),[new bt([n[0].dims.length],"int32",void 0,void 0,new Int32Array(n[0].dims))]),Xb=e=>{if(!e||e.length!==1)throw new Error("Shape requires 1 input.")}}),Bi,Dc,Lc,$c,Kb,kc,Jb,Yb,Bc=O(()=>{It(),Rr(),Y(),j(),Bi={name:"Slice",inputNames:["A"],inputTypes:[0]},Dc=(e,n,i)=>(Kb(n),[e.run({...Bi,cacheHint:i.cacheKey,get:()=>$c(e,n[0],i)},n)]),Lc=e=>{let n=e.attributes.getInts("starts"),i=e.attributes.getInts("ends"),a=e.attributes.getInts("axes",[]);return W({starts:n,ends:i,axes:a})},$c=(e,n,i)=>{let a=i.axes.length===0?n.dims.slice(0).map((u,l)=>l):i.axes,p=B.normalizeAxes(a,n.dims.length),o=i.starts.map((u,l)=>u>n.dims[p[l]]-1?n.dims[p[l]]:B.normalizeAxis(u,n.dims[p[l]])),s=i.ends.map((u,l)=>u>n.dims[p[l]]-1?n.dims[p[l]]:B.normalizeAxis(u,n.dims[p[l]])),d=n.dims.slice(),c=[];for(let u=0;u<p.length;u++)d[p[u]]=s[u]-o[u],o[u]>0&&c.push(`outputIdx[${p[u]}] += ${o[u]};`);let r=`
      float process(int outputIdx[${d.length}]) {
        ${c.join(`
      `)}
        return _A(outputIdx);
      }`;return{...Bi,output:{dims:d,type:n.type,textureType:0},shaderSource:r}},Kb=e=>{if(!e||e.length!==1)throw new Error("Slice requires 1 input.");if(Pe.indexOf(e[0].type)===-1)throw new Error("Invalid input type.")},kc=(e,n)=>{Yb(n);let i=Jb(e,n);return[e.run({...Bi,cacheHint:i.cacheKey,get:()=>$c(e,n[0],i)},[n[0]])]},Jb=(e,n)=>{if(!e.session.isInitializer(n[1].dataId)||!e.session.isInitializer(n[2].dataId)||n.length>=4&&!e.session.isInitializer(n[3].dataId)||n.length>=5&&!e.session.isInitializer(n[4].dataId))throw new Error("dynamic slice attributes are not allowed");if(n.length>=5&&n[4].integerData.some(s=>s!==1))throw new Error("currently non-1 steps is not supported for Slice");let i=Array.from(n[1].integerData),a=Array.from(n[2].integerData),p=n.length>=4?Array.from(n[3].integerData):[],o=`${p};${i};${a}`;return{starts:i,ends:a,axes:p,cacheKey:o}},Yb=e=>{if(!e||e.length<3||e.length>5)throw new Error("Invalid input number.");if(e[1].type!=="int32"||e[1].dims.length!==1)throw new Error("Invalid input type.");if(e[2].type!=="int32"||e[2].dims.length!==1)throw new Error("Invalid input type.");if(e.length>=4&&(e[3].type!=="int32"||e[3].dims.length!==1))throw new Error("Invalid input type.");if(e.length>=5&&(e[4].type!=="int32"||e[4].dims.length!==1))throw new Error("Invalid input type.")}}),Fc,Cc,Nc,Rc,Gc,Mc,Uc,Vc,Zb,Qb,tg,zc,Wc=O(()=>{It(),Y(),ut(),j(),Nn(),Fc={name:"SoftmaxComputeMax",inputNames:["A"],inputTypes:[0]},Cc={name:"SoftmaxComputeScale",inputNames:["A","Max"],inputTypes:[0,0]},Nc={name:"SoftMax",inputNames:["A","Max","Norm"],inputTypes:[0,0,0]},Rc=(e,n,i)=>{zc(n);let a=n[0].dims.slice(),p=B.normalizeAxis(i.axis,a.length),o=B.sizeToDimension(a,p),s=B.sizeFromDimension(a,p);return Vc(e,n,i,o,s)},Gc=e=>W({axis:e.attributes.getInt("axis",1)}),Mc=e=>W({axis:e.attributes.getInt("axis",-1)}),Uc=(e,n,i)=>{zc(n);let a=n[0].dims.slice(),p=B.normalizeAxis(i.axis,a.length),o=a.length,s=p!==o-1,d=[],c=[],r=[],u;s&&(c=Array.from({length:o}).map((m,y)=>y),c[p]=o-1,c[o-1]=p,c.map(m=>d.push(a[m])),u=W({perm:c}),r=je(e,n,u));let l=s?B.sizeToDimension(d,o-1):B.sizeToDimension(a,o-1),h=s?B.sizeFromDimension(d,o-1):B.sizeFromDimension(a,o-1),f=Vc(e,s?r:n,i,l,h);return s?je(e,f,u):f},Vc=(e,n,i,a,p)=>{let o=Zb(e,n[0],a,p,[a]),s=e.run({...Fc,cacheHint:i.cacheKey,get:()=>o},n),d=Qb(e,n[0],a,p,o.output.dims,[a]),c=e.run({...Cc,cacheHint:i.cacheKey,get:()=>d},[n[0],s]),r=tg(e,n[0],a,p,o.output.dims,d.output.dims);return[e.run({...Nc,cacheHint:i.cacheKey,get:()=>r},[n[0],s,c])]},Zb=(e,n,i,a,p)=>{let[o,s]=e.calculateTextureWidthAndHeight(n.dims,0),d=p.length;if(i<1||a<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(p.length!==1)throw new Error("Dimensionality of the output should be 1");if(p[0]!==i)throw new Error("Shape of the output should be equal to logical row count");let c=G(e.session.backend.glContext.version),r=`
      float process(int[${d}] indices) {
        int logical_row_start_offset = indices[0] * ${a};

        float max = getColorAsFloat(${c.texture2D}(A, offsetToCoords(logical_row_start_offset, ${o},
        ${s} )));
        for(int i=1; i<${a}; ++i)
        {
          float current = getColorAsFloat(${c.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${o}, ${s})));
          if(current > max)
          max = current;
        }

        return max;
      }`;return{...Fc,output:{dims:p,type:n.type,textureType:0},shaderSource:r}},Qb=(e,n,i,a,p,o)=>{let[s,d]=e.calculateTextureWidthAndHeight(n.dims,0),c=o.length;if(i<1||a<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(o.length!==1)throw new Error("Dimensionality of the output should be 1");if(o[0]!==i)throw new Error("Shape of the output should be equal to logical row count");if(p.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(p[0]!==i)throw new Error("Shape of the intermediate results should be equal to logical row count");let r=G(e.session.backend.glContext.version),u=`
      float process(int[${c}] indices) {
        int logical_row_start_offset = indices[0] * ${a};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${a}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${r.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s}, ${d}))) - max);
        }

        return norm_factor;
      }`;return{...Cc,output:{dims:o,type:n.type,textureType:0},shaderSource:u}},tg=(e,n,i,a,p,o)=>{let[s,d]=e.calculateTextureWidthAndHeight(n.dims,0),c=n.dims.length;if(i<1||a<1)throw new Error("Logical row count N and feature count D must be greater than or equal to 1");if(p.length!==1||o.length!==1)throw new Error("Dimensionality of the intermediate results should be 1");if(p[0]!==i||o[0]!==i)throw new Error("Shape of the intermediate results should be equal to logical row count");let r=`
      float process(int[${c}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s}, ${d});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${a};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;return{...Nc,output:{dims:n.dims,type:n.type,textureType:0},shaderSource:r}},zc=e=>{if(!e||e.length!==1)throw new Error("Softmax requires 1 input.");if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type")}}),Hc,qc,jc,eg,rg,ng,Xc=O(()=>{It(),Y(),j(),Hc={name:"Split",inputNames:["A"],inputTypes:[0]},qc=(e,n,i)=>{ng(n);let a=B.normalizeAxis(i.axis,n[0].dims.length),p=eg(e,n,a,i),o=[];for(let s=0;s<p;++s)o.push(e.run({...Hc,cacheHint:`${i.cacheKey};${s}`,get:()=>rg(e,n[0],i,a,s)},n));return o},jc=e=>{let n=e.attributes.getInt("axis",0),i=e.attributes.getInts("split",[]),a=e.outputs.length;return W({axis:n,split:i,numOutputs:a})},eg=(e,n,i,a)=>{let[,p]=$r.splitShape(n[0].dims,i,a.split,a.numOutputs);return p.length},rg=(e,n,i,a,p)=>{let[o,s]=$r.splitShape(n.dims,a,i.split,i.numOutputs),d=s[p],c=o[p],r=`
      float process(int indices[${c.length}]) {
        indices[${a}] += ${d};
        return _A(indices);
      }
    `;return{...Hc,cacheHint:`${i.cacheKey}:${p}`,output:{dims:c,type:n.type,textureType:0},shaderSource:r}},ng=e=>{if(!e||e.length!==1)throw new Error("Split requires one input.");if(e[0].type!=="int8"&&e[0].type!=="uint8"&&e[0].type!=="int16"&&e[0].type!=="uint16"&&e[0].type!=="int32"&&e[0].type!=="uint32"&&e[0].type!=="float32"&&e[0].type!=="float64"&&e[0].type!=="bool")throw new Error("Invalid input type.")}}),Fi,Kc,Jc,og,ig,Yc=O(()=>{Y(),Fi=(e,n,i)=>{og(n);let a=B.squeezeShape(n[0].dims,i);return[e.reshapeUnpacked(n[0],a)]},Kc=(e,n)=>(ig(n),Fi(e,[n[0]],Array.from(n[1].integerData))),Jc=e=>e.attributes.getInts("axes"),og=e=>{if(!e||e.length!==1)throw new Error("Squeeze requires 1 input.");if(e[0].type==="string")throw new Error("invalid input tensor types.")},ig=e=>{if(!e||e.length!==2)throw new Error("Squeeze requires 2 inputs.");if(e[1].type!=="int32")throw new Error("Invalid input type.")}}),Zc,ag,sg,Qc=O(()=>{ut(),j(),Zc=(e,n)=>{sg(n);let i={name:"Sum",inputNames:n.map((a,p)=>`X${p}`),inputTypes:new Array(n.length).fill(0)};return[e.run({...i,get:()=>ag(e,n,i)},n)]},ag=(e,n,i)=>{let a=G(e.session.backend.glContext.version),p=n[0].dims.slice(),o=`
      void main() {
        vec4 result = ${n.map((s,d)=>`${a.texture2D}(X${d},TexCoords)`).join(" + ")};
        ${a.output} = result;
      }
    `;return{...i,output:{dims:p,type:n[0].type,textureType:0},hasMain:!0,shaderSource:o}},sg=e=>{if(!e||e.length===0)throw new Error("Sum requires inputs.");let n=e[0].dims.length;for(let i=1;i<e.length;i++){if(n!==e[i].dims.length)throw new Error("Input shapes are mismatched.");for(let a=0;a<n;a++)if(e[0].dims[a]!==e[i].dims[a])throw new Error("Input shapes are not matched.")}if(e[0].type!=="float32"&&e[0].type!=="float64")throw new Error("Invalid input type.");for(let i=1;i<e.length;i++)if(e[0].type!==e[i].type)throw new Error("Input types are not matched.")}}),tp,ug,lg,ep=O(()=>{Rr(),j(),tp=(e,n)=>{lg(n);let i={name:"Tile",inputNames:["A"],inputTypes:[0]};return[e.run({...i,get:()=>ug(e,n,i)},n)]},ug=(e,n,i)=>{let a=n[0].dims.slice(),p=new Array(a.length),o=[];for(let c=0;c<a.length;c++)p[c]=a[c]*n[1].numberData[c],o.push(`inputIdx[${c}] = int(mod(float(outputIdx[${c}]), ${a[c]}.));`);let s=p.length,d=`
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${o.join(`
`)}
        return _A(inputIdx);
      }
    `;return{...i,output:{dims:p,type:n[0].type,textureType:0},shaderSource:d}},lg=e=>{if(!e||e.length!==2)throw new Error("Tile requires 2 input.");if(e[1].dims.length!==1)throw new Error("The second input shape must 1 dimension.");if(e[1].dims[0]!==e[0].dims.length)throw new Error("Invalid input shape.");if(Pe.indexOf(e[0].type)===-1)throw new Error("Invalid input type.");if(e[1].type!=="int32"&&e[1].type!=="int16")throw new Error("Invalid repeat type.")}}),Ci,rp,np,fg,cg,op=O(()=>{Y(),Ci=(e,n,i)=>{fg(n);let a=B.unsqueezeShape(n[0].dims,i);return[e.reshapeUnpacked(n[0],a)]},rp=(e,n)=>(cg(n),Ci(e,[n[0]],Array.from(n[1].integerData))),np=e=>e.attributes.getInts("axes"),fg=e=>{if(!e||e.length!==1)throw new Error("Unsqueeze requires 1 input.");if(e[0].type==="string")throw new Error("invalid input tensor types.")},cg=e=>{if(!e||e.length!==2)throw new Error("Unsqueeze requires 2 inputs.");if(e[1].type!=="int32")throw new Error("Invalid input type.")}}),ip,ap=O(()=>{ml(),Pl(),Ll(),Nl(),Bn(),wf(),Af(),Df(),kf(),Nf(),Mf(),Wf(),Xf(),Fn(),Zf(),cc(),xc(),wc(),Ac(),Ec(),Bc(),Wc(),Xc(),Yc(),Qc(),ep(),Nn(),xi(),op(),Li(),ip=[["Abs","","6+",Rl],["Acos","","7+",Gl],["Add","","7+",bl],["And","","7+",gl],["Asin","","7+",Ml],["Atan","","7+",Ul],["AveragePool","","7+",tc,ec],["BatchNormalization","","7+",dl,hl],["Cast","","6+",El,Dl],["Ceil","","6+",Wl],["Clip","","6-10",gi,Vl],["Clip","","11+",zl],["Concat","","4+",Bl,Cl],["Conv","","1+",Oi,Si],["ConvTranspose","","1+",xf,Tf],["Cos","","7+",Hl],["Div","","7+",yl],["Dropout","","7+",yi],["DepthToSpace","","1+",Of,Sf],["Equal","","7+",xl],["Elu","","6+",ql,jl],["Exp","","6+",Xl],["Flatten","","1+",Pf,Ef],["Floor","","6+",Kl],["FusedConv","com.microsoft","1+",Oi,Si],["Gather","","1+",Lf,$f],["Gemm","","7-10",Ai,Ff],["Gemm","","11+",Ai,Cf],["GlobalAveragePool","","1+",nc,oc],["GlobalMaxPool","","1+",lc],["Greater","","7+",Tl],["Identity","","1+",yi],["ImageScaler","","1+",Rf,Gf],["InstanceNormalization","","6+",Vf,zf],["LeakyRelu","","6+",Jl,Yl],["Less","","7+",wl],["LRN","","1+",Hf,qf],["Log","","6+",Zl],["MatMul","","1+",pf,df],["MaxPool","","1+",ic,ac],["Mul","","7+",vl],["Neg","","6+",Ql],["Not","","1+",tf],["Or","","7+",Il],["Pad","","2-10",Pi,Kf],["Pad","","11+",Jf,Yf],["Pow","","7+",_l],["PRelu","","7+",Ol],["ReduceLogSum","","1+",gc,Ee],["ReduceMax","","1+",hc,Ee],["ReduceMean","","1+",dc,Ee],["ReduceMin","","1+",mc,Ee],["ReduceProd","","1+",bc,Ee],["ReduceSum","","1-12",pc,Ee],["ReduceSumSquare","","1+",yc,Ee],["Relu","","6+",ef],["Reshape","","5+",Tc],["Resize","","10",ki,Oc],["Resize","","11+",ki,Sc],["Shape","","1+",Pc],["Sigmoid","","6+",rf],["Sin","","7+",nf],["Slice","","10+",kc],["Slice","","1-9",Dc,Lc],["Softmax","","1-12",Rc,Gc],["Softmax","","13+",Uc,Mc],["Split","","2-12",qc,jc],["Sqrt","","6+",of],["Squeeze","","1-12",Fi,Jc],["Squeeze","","13+",Kc],["Sub","","7+",Sl],["Sum","","6+",Zc],["Tan","","7+",af],["Tanh","","6+",sf],["Tile","","6+",tp],["Transpose","","1+",je,If],["Upsample","","7-8",Ei,Ic],["Upsample","","9",Ei,_c],["Unsqueeze","","1-12",Ci,np],["Unsqueeze","","13+",rp],["Xor","","7+",Al]]});function up(e){let n={},i;for(;(i=sp.exec(e))!==null;){let a=i[3].split(",").map(p=>{let o=p.trim().split(" ");return o&&o.length===2?{type:o[0],name:o[1]}:null}).filter(p=>p!==null);n[i[2]]={params:a,body:i[4]}}for(let a in n){let p=pg.replace("__FUNC__",a),o=new RegExp(p,"gm");for(;(i=o.exec(e))!==null;){let s=i[1],d=i[2],c=i[3].split(","),r=s?`${s} ${d};`:"",u=n[a].body,l="";n[a].params.forEach((f,m)=>{f&&(l+=`${f.type} ${f.name} = ${c[m]};
`)}),u=`${l}
 ${u}`,u=u.replace("return",`${d} = `);let h=`
      ${r}
      {
        ${u}
      }
      `;e=e.replace(i[0],h)}}return e=e.replace(sp,""),e}var sp,pg,lp=O(()=>{sp=/@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm,pg="(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;"});function hr(e,n){let i=[],a=[];for(let p=0;p<e.length;++p)e[p]!==1&&(i.push(e[p]),a.push(p));return{newShape:i,keptDims:a}}function mg(e){if(e.length===0)return 1;let n=e[0];for(let i=1;i<e.length;i++)n*=e[i];return n}function fp(e){let n=Math.ceil(Math.sqrt(e));return[n,Math.ceil(e/n)]}var Un,Ni=O(()=>{Ut(),Y(),Un=class{constructor(e){this.maxTextureSize=e}computeTextureWH(e,n){let i=this.computeTexture(e,n);return n&&n.isPacked&&(i[0]/=2,i[1]/=2),n&&n.reverseWH?[i[1],i[0]]:i}computeTexture(e,n){let i=n&&n.isPacked;if(e.length===0)return i?[2,2]:[1,1];let a=this.maxTextureSize;if(n&&n.breakAxis!==void 0){let s=n.breakAxis>=e.length?1:e.slice(n.breakAxis).reduce((c,r)=>c*r),d=n.breakAxis<=0?1:e.slice(0,n.breakAxis).reduce((c,r)=>c*r);if(s>a||d>a)tt.verbose("TextureLayout",`Given width/height preferences were unattainable: shape:${e}, breakAxis:${n.breakAxis}`);else return[s,d]}let p=e.slice(0);i&&(a=a*2,p=p.map((s,d)=>d>=p.length-2?p[d]%2===0?p[d]:p[d]+1:p[d]),p.length===1&&(p=[2,p[0]])),p.length!==2&&(p=hr(p).newShape);let o=mg(p);return p.length<=1&&o<=a?[1,o]:p.length===2&&p[0]<=a&&p[1]<=a?p:p.length===3&&p[0]*p[1]<=a&&p[2]<=a?[p[0]*p[1],p[2]]:p.length===3&&p[0]<=a&&p[1]*p[2]<=a?[p[0],p[1]*p[2]]:p.length===4&&p[0]*p[1]*p[2]<=a&&p[3]<=a?[p[0]*p[1]*p[2],p[3]]:p.length===4&&p[0]<=a&&p[1]*p[2]*p[3]<=a?[p[0],p[1]*p[2]*p[3]]:i?fp(o/4).map(s=>s*2):fp(o)}}}),Vn,cp=O(()=>{Y(),Te(),ut(),Ni(),pe(),Vn=class extends Ht{constructor(e){super(e)}getFunctions(){return{...this.offsetToCoords(),...this.coordsToOffset(),...this.toVec(),...this.valueFrom(),...this.getCommonUtilFuncs(),...this.getInputsSamplingSnippets(),...this.getOutputSamplingSnippet()}}getCustomTypes(){return{}}offsetToCoords(){let e="offsetToCoords";return{offsetToCoords:new k(`
      vec2 ${e}(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)}}coordsToOffset(){let e="coordsToOffset";return{coordsToOffset:new k(`
      int ${e}(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)}}getOutputSamplingSnippet(){let e=this.context.outputTextureLayout;return e.isPacked?this.getPackedOutputSamplingSnippet(e):this.getUnpackedOutputSamplingSnippet(e)}getPackedOutputSamplingSnippet(e){let n=e.unpackedShape,i=[e.width,e.height],a={},p="getOutputCoords";switch(n.length){case 0:a[p]=this.getOutputScalarCoords();break;case 1:a[p]=this.getOutputPacked1DCoords(n,i);break;case 2:a[p]=this.getOutputPacked2DCoords(n,i);break;case 3:a[p]=this.getOutputPacked3DCoords(n,i);break;default:a[p]=this.getOutputPackedNDCoords(n,i)}let o=`
      void setOutput(vec4 val) {
        ${G(this.context.glContext.version).output} = val;
      }
    `,s="floatTextureSetRGBA";return a[s]=new k(o),a}getUnpackedOutputSamplingSnippet(e){let n=e.unpackedShape,i=[e.width,e.height],a={},p="getOutputCoords";switch(n.length){case 0:a[p]=this.getOutputScalarCoords();break;case 1:a[p]=this.getOutputUnpacked1DCoords(n,i);break;case 2:a[p]=this.getOutputUnpacked2DCoords(n,i);break;case 3:a[p]=this.getOutputUnpacked3DCoords(n,i);break;case 4:a[p]=this.getOutputUnpacked4DCoords(n,i);break;case 5:a[p]=this.getOutputUnpacked5DCoords(n,i);break;case 6:a[p]=this.getOutputUnpacked6DCoords(n,i);break;default:throw new Error(`Unsupported output dimensionality: ${n.length}`)}let o=`
        void setOutput(float val) {
          ${G(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `,s="floatTextureSetR";return a[s]=new k(o),a}getOutputScalarCoords(){return new k(`
      int getOutputCoords() {
        return 0;
      }
    `)}getOutputPacked1DCoords(e,n){let i=n,a="";return i[0]===1?(a=`
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${i[1]}.0);
          }
        `,new k(a)):i[1]===1?(a=`
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${i[0]}.0);
          }
        `,new k(a)):(a=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${i[0]}, ${i[1]}));
          return 2 * (resTexRC.y * ${i[0]} + resTexRC.x);
        }
      `,new k(a))}getOutputPacked2DCoords(e,n){let i="";if(Me.arraysEqual(e,n))return i=`
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${n[0]}, ${n[1]}));
        }
      `,new k(i);let a=n,p=Math.ceil(e[1]/2);return i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${a[0]}, ${a[1]}));

          int index = resTexRC.y * ${a[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${p}) * 2;
          int c = 2 * (index / ${p});

          return ivec2(r, c);
        }
      `,new k(i)}getOutputPacked3DCoords(e,n){let i=[n[0],n[1]],a=Math.ceil(e[2]/2),p=a*Math.ceil(e[1]/2),o=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${i[0]}, ${i[1]}));
          int index = resTexRC.y * ${i[0]} + resTexRC.x;

          int b = index / ${p};
          index -= b * ${p};

          // reverse r and c order for packed texture
          int r = imod(index, ${a}) * 2;
          int c = 2 * (index / ${a});

          return ivec3(b, r, c);
        }
      `;return new k(o)}getOutputPackedNDCoords(e,n){let i=[n[0],n[1]],a=Math.ceil(e[e.length-1]/2),p=a*Math.ceil(e[e.length-2]/2),o=p,s="",d="b, r, c";for(let r=2;r<e.length-1;r++)o*=e[e.length-r-1],s=`
      int b${r} = index / ${o};
      index -= b${r} * ${o};
    `+s,d=`b${r}, `+d;let c=`
      ivec${e.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${i[0]}, ${i[1]}));
        int index = resTexRC.y * ${i[0]} + resTexRC.x;

        ${s}

        int b = index / ${p};
        index -= b * ${p};

        // reverse r and c order for packed texture
        int r = imod(index, ${a}) * 2;
        int c = 2 * (index / ${a});

        return ivec${e.length}(${d});
      }
    `;return new k(c)}getOutputUnpacked1DCoords(e,n){let i=`
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          return resTexRC.y * ${n[0]} + resTexRC.x;
        }
      `;return new k(i)}getOutputUnpacked2DCoords(e,n){let i=`
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          int r = index / ${e[1]};
          int c = index - r * ${e[1]};
          return ivec2(r, c);
        }
      `;return new k(i)}getOutputUnpacked3DCoords(e,n){let i="",a=e.length,p=null;a<2&&(p=[]),p=new Array(a-1),p[a-2]=e[a-1];for(let d=a-3;d>=0;--d)p[d]=p[d+1]*e[d+1];let o=["r","c","d"],s=p.map((d,c)=>{let r=`int ${o[c]} = index / ${d}`,u=c===p.length-1?`int ${o[c+1]} = index - ${o[c]} * ${d}`:`index -= ${o[c]} * ${d}`;return`${r}; ${u};`}).join("");return i=`
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${s}
          return ivec3(r, c, d);
        }
      `,new k(i)}getOutputUnpacked4DCoords(e,n){let i="",a=e.length,p=null;a<2&&(p=[]),p=new Array(a-1),p[a-2]=e[a-1];for(let d=a-3;d>=0;--d)p[d]=p[d+1]*e[d+1];let o=["r","c","d","d2"],s=p.map((d,c)=>{let r=`int ${o[c]} = index / ${d}`,u=c===p.length-1?`int ${o[c+1]} = index - ${o[c]} * ${d}`:`index -= ${o[c]} * ${d}`;return`${r}; ${u};`}).join("");return i=`
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${s}
          return ivec4(r, c, d, d2);
        }
      `,new k(i)}getOutputUnpacked5DCoords(e,n){let i="",a=e.length,p=null;a<2&&(p=[]),p=new Array(a-1),p[a-2]=e[a-1];for(let d=a-3;d>=0;--d)p[d]=p[d+1]*e[d+1];let o=["r","c","d","d2","d3"],s=p.map((d,c)=>{let r=`int ${o[c]} = index / ${d}`,u=c===p.length-1?`int ${o[c+1]} = index - ${o[c]} * ${d}`:`index -= ${o[c]} * ${d}`;return`${r}; ${u};`}).join("");return i=`
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n[0]}, ${n[1]}));
          int index = resTexRC.y * ${n[0]} + resTexRC.x;
          ${s}
          return ivec5(r, c, d, d2, d3);
        }
      `,new k(i)}getOutputUnpacked6DCoords(e,n){let i="",a=e.length,p=null;a<2&&(p=[]),p=new Array(a-1),p[a-2]=e[a-1];for(let d=a-3;d>=0;--d)p[d]=p[d+1]*e[d+1];let o=["r","c","d","d2","d3","d4"],s=p.map((d,c)=>{let r=`int ${o[c]} = index / ${d}`,u=c===p.length-1?`int ${o[c+1]} = index - ${o[c]} * ${d}`:`index -= ${o[c]} * ${d}`;return`${r}; ${u};`}).join("");return i=`
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${n[0]}, ${n[1]}));
         int index = resTexRC.y * ${n[0]} + resTexRC.x;
         ${s}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,new k(i)}getCommonUtilFuncs(){let e={},n="uvFromFlat";e[n]=new k(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),n="packedUVfrom1D",e[n]=new k(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="packedUVfrom2D",e[n]=new k(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="packedUVfrom3D",e[n]=new k(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),n="sampleTexture";let i=G(this.context.glContext.version);return e[n]=new k(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${i.texture2D}(textureSampler, uv).r;
        }`),e}getInputsSamplingSnippets(){let e={},n=this.context.outputTextureLayout;return this.context.programInfo.inputNames.forEach((i,a)=>{let p=this.context.inputTextureLayouts[a],o=An(i);p.isPacked?e[o]=this.getPackedSamplerFromInput(o,i,p):e[o]=this.getUnpackedSamplerFromInput(o,i,p);let s=Yu(i);p.unpackedShape.length<=n.unpackedShape.length&&(p.isPacked?e[s]=this.getPackedSamplerAtOutputCoords(s,p,n,i):e[s]=this.getUnpackedSamplerAtOutputCoords(s,p,n,i))}),e}getPackedSamplerAtOutputCoords(e,n,i,a){let p=n.unpackedShape,o=i.unpackedShape,s=An(a),d=p.length,c=o.length,r=kt.getBroadcastDims(p,o),u=Bt(c),l=c-d,h,f=ne();d===0?h="":c<2&&r.length>=1?h="coords = 0;":h=r.map(N=>`coords.${f[N+l]} = 0;`).join(`
`);let m="";c<2&&d>0?m="coords":m=p.map((N,R)=>`coords.${f[R+l]}`).join(", ");let y="return outputValue;",_=B.size(p)===1,I=B.size(o)===1;if(d===1&&!_&&!I)y=`
        return vec4(outputValue.xy, outputValue.xy);
      `;else if(_&&!I)c===1?y=`
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        `:y=`
          return vec4(outputValue.x);
        `;else if(r.length){let N=d-2,R=d-1;r.indexOf(N)>-1&&r.indexOf(R)>-1?y="return vec4(outputValue.x);":r.indexOf(N)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":r.indexOf(R)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}let x=`
        int lastDim = coords.${f[c-1]};
        coords.${f[c-1]} = coords.${f[c-2]};
        coords.${f[c-2]} = lastDim;
      `,P=`
      vec4 ${e}() {
        ${u} coords = getOutputCoords();
        ${x}
        ${h}
        vec4 outputValue = ${s}(${m});
        ${y}
      }
    `;return new k(P,["coordinates.getOutputCoords"])}getUnpackedSamplerAtOutputCoords(e,n,i,a){let p=[i.width,i.height],o=[n.width,n.height],s=n.unpackedShape.length,d=i.unpackedShape.length,c=n.unpackedShape,r=i.unpackedShape,u=An(a);if(s===d&&Me.arraysEqual(o,p)){let x=`
          float ${e}() {
            return sampleTexture(${a}, TexCoords);
          }
        `;return new k(x,["coordinates.sampleTexture"])}let l=Bt(d),h=kt.getBroadcastDims(c,r),f=d-s,m,y=ne();s===0?m="":d<2&&h.length>=1?m="coords = 0;":m=h.map(x=>`coords.${y[x+f]} = 0;`).join(`
`);let _="";d<2&&s>0?_="coords":_=n.unpackedShape.map((x,P)=>`coords.${y[P+f]}`).join(", ");let I=`
        float ${e}() {
          ${l} coords = getOutputCoords();
          ${m}
          return ${u}(${_});
        }
      `;return new k(I,["coordinates.getOutputCoords"])}getPackedSamplerFromInput(e,n,i){switch(i.unpackedShape.length){case 0:return this.getPackedSamplerScalar(e,n);case 1:return this.getPackedSampler1D(e,n,i);case 2:return this.getPackedSampler2D(e,n,i);case 3:return this.getPackedSampler3D(e,n,i);default:return this.getPackedSamplerND(e,n,i)}}getUnpackedSamplerFromInput(e,n,i){let a=i.unpackedShape;switch(a.length){case 0:return this.getUnpackedSamplerScalar(e,n,i);case 1:return this.getUnpackedSampler1D(e,n,i);case 2:return this.getUnpackedSampler2D(e,n,i);case 3:return this.getUnpackedSampler3D(e,n,i);case 4:return this.getUnpackedSampler4D(e,n,i);case 5:return this.getUnpackedSampler5D(e,n,i);case 6:return this.getUnpackedSampler6D(e,n,i);default:throw new Error(`Unsupported dimension ${a.length}-D`)}}getPackedSamplerScalar(e,n){let i=G(this.context.glContext.version),a=`
          vec4 ${e}() {
            return ${i.texture2D}(${n}, halfCR);
          }
        `;return new k(a)}getPackedSampler1D(e,n,i){let a=[i.width,i.height],p=[a[1],a[0]],o=G(this.context.glContext.version),s=`vec4 ${e}(int index) {
      vec2 uv = packedUVfrom1D(
      ${p[0]}, ${p[1]}, index);
      return ${o.texture2D}(${n}, uv);
    }`;return new k(s,["coordinates.packedUVfrom1D"])}getPackedSampler2D(e,n,i){let a=i.unpackedShape,p=[i.width,i.height],o=G(this.context.glContext.version),s=p[0],d=p[1];if(p!=null&&Me.arraysEqual(a,p)){let l=`vec4 ${e}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${s}.0);
        return ${o.texture2D}(${n}, uv);
      }`;return new k(l)}let c=p,r=Math.ceil(a[1]/2),u=`vec4 ${e}(int row, int col) {
      vec2 uv = packedUVfrom2D(${c[1]}, ${c[0]}, ${r}, row, col);
      return ${o.texture2D}(${n}, uv);
    }`;return new k(u,["coordinates.packedUVfrom2D"])}getPackedSampler3D(e,n,i){let a=i.unpackedShape,p=[i.width,i.height],o=[p[0],p[1]],s=G(this.context.glContext.version);if(a[0]===1){let h=a.slice(1),f=[1,2],m=lr(a,h),y=["b","row","col"],_=JSON.parse(JSON.stringify(i));_.unpackedShape=m;let I=this.getPackedSamplerFromInput(e,n,_),x=`${I.routineBody}
      vec4 ${e}(int b, int row, int col) {
        return ${e}(${fr(y,f)});
      } `;return new k(x,I.dependencies)}let d=o[0],c=o[1],r=Math.ceil(a[2]/2),u=r*Math.ceil(a[1]/2),l=`vec4 ${e}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${d}, ${u}, ${r}, b, row, col);
      return ${s.texture2D}(${n}, uv);}`;return new k(l,["coordinates.packedUVfrom3D"])}getPackedSamplerND(e,n,i){let a=i.unpackedShape,p=a.length,o=[i.width,i.height],s=G(this.context.glContext.version),d=[o[0],o[1]],c=d[1],r=d[0],u=Math.ceil(a[p-1]/2),l=u*Math.ceil(a[p-2]/2),h="int b, int row, int col",f=`b * ${l} + (row / 2) * ${u} + (col / 2)`;for(let y=2;y<p-1;y++)h=`int b${y}, `+h,l*=a[p-y-1],f=`b${y} * ${l} + `+f;let m=`vec4 ${e}(${h}) {
      int index = ${f};
      int texR = index / ${r};
      int texC = index - texR * ${r};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}, ${c});
      return ${s.texture2D}(${n}, uv);
    }`;return new k(m)}getUnpackedSamplerScalar(e,n,i){let[a,p]=[i.width,i.height];if(a===1&&p===1){let s=`
          float ${e}() {
            return sampleTexture(${n}, halfCR);
          }
        `;return new k(s,["coordinates.sampleTexture"])}let o=`
        float ${e}() {
          int offset_${n} = coordsToOffset(TexCoords, ${a}, ${p});
          vec2 uv = uvFromFlat(${a}, ${p}, offset_${n});
          return sampleTexture(${n}, uv);
        }
      `;return new k(o,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler1D(e,n,i){let a=i.width,p=i.height;if(p===1&&a===1){let s=`
        float ${e}(int index) {
          return sampleTexture(${n}, halfCR);
        }
      `;return new k(s,["coordinates.sampleTexture"])}if(p===1){let s=`
          float ${e}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${a}.0, 0.5);
            return sampleTexture(${n}, uv);
          }
        `;return new k(s,["coordinates.sampleTexture"])}if(a===1){let s=`
          float ${e}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${p}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new k(s,["coordinates.sampleTexture"])}let o=`
        float ${e}(int index) {
          vec2 uv = uvFromFlat(${a}, ${p}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new k(o,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler2D(e,n,i){let a=i.unpackedShape,p=[i.height,i.width];if(p!=null&&Me.arraysEqual(a,p)){let l=p[1],h=p[0],f=`
          float ${e}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${l}.0, ${h}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new k(f,["coordinates.sampleTexture"])}let{newShape:o,keptDims:s}=hr(a),d=o;if(d.length<a.length){let l=lr(a,d),h=JSON.parse(JSON.stringify(i));h.unpackedShape=l;let f=["col","row"],m=`
          ${this.getUnpackedSamplerFromInput(e,n,h).routineBody}
          float ${e}(int row, int col) {
            return ${e}(${fr(f,s)});
          }
        `;return new k(m,["coordinates.sampleTexture"])}let c=p[1],r=p[0];if(r===1){let l=`
          float ${e}(int row, int col) {
            int offset_${n} = coordsToOffset(TexCoords, ${c}, ${r});
            float index = dot(vec3(row, col, offset_${n}), vec3(${a[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
            return sampleTexture(${n}, uv);
          }
        `;return new k(l,["coordinates.sampleTexture","coordinates.coordsToOffset"])}if(c===1){let l=`
          float ${e}(int row, int col) {
            int offset_${n} = coordsToOffset(TexCoords, ${c}, ${r});
            float index = dot(vec3(row, col, offset_${n}), vec3(${a[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${r}.0, 0.5);
            return sampleTexture(${n}, uv);
          }
        `;return new k(l,["coordinates.sampleTexture","coordinates.coordsToOffset"])}let u=`
        float ${e}(int row, int col) {
          int index = col * ${a[1]} + row;
          vec2 uv = uvFromFlat(${c}, ${r}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new k(u,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler3D(e,n,i){let a=i.unpackedShape,p=a[1]*a[2],o=a[2],{newShape:s,keptDims:d}=hr(a),c=s;if(c.length<a.length){let h=lr(a,c),f=["batch","col","row"],m=JSON.parse(JSON.stringify(i));m.unpackedShape=h;let y=this.getUnpackedSamplerFromInput(e,n,m),_=d.reverse(),I=`
          ${y.routineBody}
          float ${e}(int batch, int row, int col) {
            return ${e}(${fr(f,_)});
          }
        `;return new k(I,y.dependencies)}let r=i.width,u=i.height,l=`
          float ${e}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${p} + col * ${o} + row;
            vec2 uv = uvFromFlat(${r}, ${u}, index);
            return sampleTexture(${n}, uv);
          }
      `;return new k(l,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}getUnpackedSampler4D(e,n,i){let a=i.unpackedShape,p=a[3],o=a[2]*p,s=a[1]*o,d=i.width,c=i.height,r=`
        float ${e}(int row, int col, int depth, int depth2) {
          int index = row * ${s} + col * ${o} +
              depth2 * ${p} + depth;
          vec2 uv = uvFromFlat(${d}, ${c}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new k(r,["coordinates.uvFromFlat","coordinates.sampleTexture"])}getUnpackedSampler5D(e,n,i){let a=i.unpackedShape,p=a[4],o=a[3]*p,s=a[2]*o,d=a[1]*s,{newShape:c,keptDims:r}=hr(a);if(c.length<a.length){let f=lr(a,c),m=["row","col","depth","depth2","depth3"],y=JSON.parse(JSON.stringify(i));y.unpackedShape=f;let _=`
          ${this.getUnpackedSamplerFromInput(e,n,y).routineBody}
          float ${e}(int row, int col, int depth, int depth2, int depth3) {
            return ${e}(${fr(m,r)});
          }
        `;return new k(_,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let u=i.width,l=i.height,h=`
        float ${e}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${d} + col * ${s} + depth * ${o} +
          depth3 * ${p} + depth2;
          vec2 uv = uvFromFlat(${u}, ${l}, index);
          return sampleTexture(${n}, uv);
        }
      `;return new k(h,["coordinates.sampleTexture","coordinates.uvFromFlat"])}getUnpackedSampler6D(e,n,i){let a=i.unpackedShape,p=a[5],o=a[4]*p,s=a[3]*o,d=a[2]*s,c=a[1]*d,{newShape:r,keptDims:u}=hr(a);if(r.length<a.length){let m=lr(a,r),y=["row","col","depth","depth2","depth3","depth4"],_=JSON.parse(JSON.stringify(i));_.unpackedShape=m;let I=`
            ${this.getUnpackedSamplerFromInput(e,n,_).routineBody}
            float ${e}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${e}(${fr(y,u)});
            }
          `;return new k(I,["coordinates.sampleTexture","coordinates.uvFromFlat"])}let l=i.width,h=i.height,f=`
          float ${e}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${c} + col * ${d} + depth * ${s} +
            depth2 * ${o} + depth3 * ${p} + depth4;
            vec2 uv = uvFromFlat(${l}, ${h}, index);
            return sampleTexture(${n}, uv);
          }
        `;return new k(f,["coordinates.uvFromFlat","coordinates.sampleTexture","coordinates.coordsToOffset"])}toVec(){let e=this.context.outputTextureLayout,n=e.shape.length,i=e.strides,a=e.width,p=e.height,o=[];for(let d=0;d<n-1;++d)o.push(`
        c[${d}] = offset / ${i[d]};`),o.push(`
        offset -= c[${d}] * ${i[d]};`);o.push(`
        c[${n-1}] = offset;`);let s=`
      void toVec(vec2 texCoords, out int c[${n}]) {
        int offset = coordsToOffset(texCoords, ${a}, ${p});
        ${o.join("")}
      }
      void toVec(int offset, out int c[${n}]) {
        ${o.join("")}
      }
    `;return{toVec:new k(s,["coordinates.coordsToOffset"])}}valueFrom(){let e={};return this.context.programInfo.inputNames.forEach((n,i)=>{let a=this.context.inputTextureLayouts[i],p=(a.unpackedShape.length>0?a.unpackedShape:a.shape).length,o=`_${n}`;e[o]=new k(this.getValueFromSingle(n,p,a.width,a.height,!1),[`shapeUtils.indicesToOffset${o}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"]),o=o+"_T",e[o]=new k(this.getValueFromSingle(n,p,a.width,a.height,!0),[`shapeUtils.indicesToOffset${o}`,"coordinates.offsetToCoords","fragcolor.getColorAsFloat"])}),e}getValueFromSingle(e,n,i,a,p){let o=`_${e}`;p&&(o=o+"_T");let s=G(this.context.glContext.version);return`
        float ${o}(int m[${n}]) {
          int offset = indicesToOffset${o}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${a});
          float value = getColorAsFloat(${s.texture2D}(${e}, coords));
          return value;
        }
        `}getPackedValueFrom(e,n,i,a,p){let o=`_${e}_Pack`;p&&(o=o+"_T");let s=G(this.context.glContext.version);return`
        vec4 ${o}(int m[${n}]) {
          int offset = indicesToOffset_${e}(m);
          vec2 coords = offsetToCoords(offset, ${i}, ${a});
          return ${s.texture2D}(${e}, coords);
        }
        `}}}),zn,pp=O(()=>{Te(),zn=class rn extends Ht{constructor(n){super(n)}getFunctions(){return{...this.encodeFloat32(),...this.decodeFloat32()}}getCustomTypes(){return{}}encodeFloat32(){return{encode:new k(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)}}decodeFloat32(){return{decode:new k(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)}}encodeUint8(){let n=rn.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{encode:new k(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${n}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)}}decodeUint8(){let n=rn.isLittleEndian()?"rgba.rgba=rgba.abgr;":"";return{decode:new k(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${n}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)}}static isLittleEndian(){let n=new ArrayBuffer(4),i=new Uint32Array(n),a=new Uint8Array(n);if(i[0]=3735928559,a[0]===239)return!0;if(a[0]===222)return!1;throw new Error("unknown endianness")}}}),Wn,dp=O(()=>{Te(),ut(),Wn=class extends Ht{constructor(e){super(e)}getFunctions(){return{...this.setFragColor(),...this.getColorAsFloat()}}getCustomTypes(){return{}}setFragColor(){let e=G(this.context.glContext.version);return{setFragColor:new k(`
        void setFragColor(float value) {
            ${e.output} = encode(value);
        }
        `,["encoding.encode"])}}getColorAsFloat(){return{getColorAsFloat:new k(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])}}}}),Hn,hp=O(()=>{Te(),Hn=class Oe extends Ht{constructor(n){super(n)}getFunctions(){return{...this.bcastIndex(),...this.bcastMatmulIndex(),...this.offsetToIndices(),...this.indicesToOffset(),...this.incrementIndices()}}getCustomTypes(){return{}}bcastIndex(){let n=this.context.outputTextureLayout.shape.length,i={};return this.context.programInfo.inputNames.forEach((a,p)=>{let o=this.context.inputTextureLayouts[p].unpackedShape;if(o.length<=n){let s=o.length,d=n-s,c=`bcastIndices_${a}`,r="";for(let l=0;l<s;++l)r+=`
          realIndices[${l}] = int( mod(float(bcastedIndices[${d+l}]), ${o[l]}.0) );
          `;let u=`
        void ${c} (int bcastedIndices[${n}], out int realIndices[${s}]) {
          ${r}
        }
        `;i[c]=new k(u)}}),i}bcastMatmulIndex(){let n=this.context.outputTextureLayout.shape.length,i={};return this.context.programInfo.inputNames.forEach((a,p)=>{let o=this.context.inputTextureLayouts[p].shape;if(!(o.length<2||o.length>n)){let s=o.length,d=n-s,c=`bcastMatmulIndices_${a}`,r="";for(let l=0;l<s-2;++l)r+=`
          realIndices[${l}] = int( mod(float(bcastedIndices[${d+l}]), ${o[l]}.0) );
          `;let u=`
        void ${c}(int bcastedIndices[${n}], out int realIndices[${s}]) {
          ${r}
          realIndices[${s-1}] = bcastedIndices[${n-1}];
          realIndices[${s-2}] = bcastedIndices[${n-2}];
        }
        `;i[c]=new k(u)}}),i}indicesToOffset(){let n={};return this.context.programInfo.inputNames.forEach((i,a)=>{let p=this.context.inputTextureLayouts[a].shape,o=this.context.inputTextureLayouts[a].strides,s=p.length,d=`indicesToOffset_${i}`;n[d]=new k(Oe.indexToOffsetSingle(d,s,o)),d=`indicesToOffset_${i}_T`,n[d]=new k(Oe.indexToOffsetSingle(d,s,o.slice().reverse()))}),n}static indexToOffsetSingle(n,i,a){let p="";for(let o=i-1;o>=0;--o)p+=`
        offset += indices[${o}] * ${a[o]};
        `;return`
      int ${n}(int indices[${i}]) {
        int offset = 0;
        ${p}
        return offset;
      }
      `}offsetToIndices(){let n={};return this.context.programInfo.inputNames.forEach((i,a)=>{let p=this.context.inputTextureLayouts[a].shape,o=this.context.inputTextureLayouts[a].strides,s=p.length,d=`offsetToIndices_${i}`;n[d]=new k(Oe.offsetToIndicesSingle(d,s,o)),d=`offsetToIndices_${i}_T`,n[d]=new k(Oe.offsetToIndicesSingle(d,s,o.slice().reverse()))}),n}static offsetToIndicesSingle(n,i,a){let p=[];for(let o=0;o<i-1;++o)p.push(`
      indices[${o}] = offset / ${a[o]};`),p.push(`
        offset -= indices[${o}] * ${a[o]};`);return p.push(`
      indices[${i-1}] = offset;`),`
      void ${n}(int offset, out int indices[${i}]) {
        ${p.join("")}
      }
      `}incrementIndices(){let n={};return this.context.programInfo.inputNames.forEach((i,a)=>{let p=this.context.inputTextureLayouts[a].shape,o=p.length,s=`incrementIndices_${i}`,d="";for(let r=0;r<o;++r)d+=`
        shape[${r}] = ${p[r]};`;let c=`
        void ${s}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${d};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;n[s]=new k(c)}),n}}}),qn,mp=O(()=>{Te(),qn=class extends Ht{constructor(e){super(e)}getCustomTypes(){return{}}getFunctions(){return{...this.binaryVecFunctions(),...this.copyVec(),...this.setVecItem(),...this.getVecItem()}}binaryVecFunctions(){let e=this.context.outputTextureLayout.shape.length,n={add:"+=",sub:"-=",mul:"*=",div:"/="},i={};for(let a in n){let p=`${a}Vec`,o="";for(let d=0;d<e;++d)o+=`
          dest[${d}] ${n[a]} src[${d}];
          `;let s=`
        void ${p}(int src[${e}], out int dest[${e}]) {
          ${o}
        }
        `;i[p]=new k(s)}return i}copyVec(){let e=this.context.outputTextureLayout.shape.length,n="";for(let a=0;a<e;++a)n+=`
        dest[${a}] = src[${a}];
        `;let i=`
      void copyVec(int src[${e}], out int dest[${e}]) {
        ${n}
      }
      `;return{copyVec:new k(i)}}setVecItem(){let e=this.context.outputTextureLayout.shape.length,n=`
        if(index < 0)
            index =${e} + index;
        if (index == 0)
            m[0] = value;
        `;for(let a=1;a<e-1;++a)n+=`
        else if (index == ${a})
            m[${a}] = value;
            `;n+=`
        else
            m[${e-1}] = value;
        `;let i=`
      void setVecItem(out int m[${e}], int index, int value) {
        ${n}
      }
        `;return{setVecItem:new k(i)}}getVecItem(){let e=this.context.outputTextureLayout.shape.length,n=`
        if(index < 0)
            index = ${e} + index;
        if (index == 0)
            return m[0];
      `;for(let a=1;a<e-1;++a)n+=`
        else if (index == ${a})
            return m[${a}];
      `;n+=`
        else
            return m[${e-1}];
        `;let i=`
      int getVecItem(int m[${e}], int index) {
        ${n}
      }
    `;return{getVecItem:new k(i)}}}}),Ri,bp=O(()=>{cp(),pp(),dp(),hp(),mp(),Ri={encoding:zn,fragcolor:Wn,vec:qn,shapeUtils:Hn,coordinates:Vn}}),jn,gp=O(()=>{Te(),lp(),bp(),ut(),jn=class{constructor(e,n,i,a){this.libs={},this.glslLibRoutineDependencyGraph={},this.context=new Ln(e,n,i,a),Object.keys(Ri).forEach(o=>{let s=new Ri[o](this.context);this.libs[o]=s});let p=this.glslLibRoutineDependencyGraph;for(let o in this.libs){let s=this.libs[o].getFunctions();for(let d in s){let c=o+"."+d,r;p[c]?(r=p[c],r.routineBody=s[d].routineBody):(r=new Nr(c,s[d].routineBody),p[c]=r);let u=s[d].dependencies;if(u)for(let l=0;l<u.length;++l)if(p[u[l]])r.addDependency(p[u[l]]);else{let h=new Nr(u[l]);p[u[l]]=h,r.addDependency(h)}}}}preprocess(){let e=this.context.programInfo,n=e.shaderSource;return this.context.programInfo.hasMain||(n=`${n}
      ${Ju(this.context.glContext.version,this.context.outputTextureLayout.shape.length)}`),n=up(n),`${Ku(this.context.glContext.version)}
    ${this.getUniforms(e.inputNames,e.variables)}
    ${this.getImports(n)}
    ${n}`}getImports(e){let n=this.selectGlslLibRoutinesToBeIncluded(e);if(n.length===0)return"";let i="";for(let a=0;a<n.length;++a)if(n[a].routineBody)i+=n[a].routineBody+`
`;else throw new Error(`Missing body for the Glsl Library routine: ${n[a].name}`);return i}selectGlslLibRoutinesToBeIncluded(e){let n=[];return Object.keys(this.glslLibRoutineDependencyGraph).forEach(i=>{let a=i.split(".")[1];e.indexOf(a)!==-1&&n.push(this.glslLibRoutineDependencyGraph[i])}),$n.returnOrderedNodes(n)}getUniforms(e,n){let i=[];if(e)for(let a of e)i.push(`uniform sampler2D ${a};`);if(n)for(let a of n)i.push(`uniform ${a.type} ${a.name}${a.arrayLength?`[${a.arrayLength}]`:""};`);return i.join(`
`)}}}),Xn,yp=O(()=>{Yt(),Ut(),gp(),ut(),Xn=class{constructor(e,n,i){this.profiler=e,this.glContext=n,this.textureLayoutStrategy=i,this.repo=new Map,this.attributesBound=!1}getArtifact(e){return this.repo.get(e)}setArtifact(e,n){this.repo.set(e,n)}run(e,n,i){this.profiler.event("op",`ProgramManager.run ${e.programInfo.name??"unknown kernel"}`,()=>{let a=this.glContext.gl,p=e.program;a.useProgram(p);try{this.bindOutput(i),this.attributesBound||this.bindAttributes(e.attribLocations),this.bindUniforms(e.uniformLocations,e.programInfo.variables??[],n)}catch(o){throw tt.error("ProgramManager",e.programInfo.shaderSource),o}this.profiler.event("backend","GlContext.draw()",()=>{this.glContext.draw()})},this.glContext)}dispose(){this.vertexShader&&this.glContext.deleteShader(this.vertexShader),this.repo.forEach(e=>this.glContext.deleteProgram(e.program))}build(e,n,i){return this.profiler.event("backend","ProgramManager.build",()=>{let a=new jn(this.glContext,e,n,i),p=a.preprocess(),o=this.compile(p);return{programInfo:e,program:o,uniformLocations:this.getUniformLocations(o,a.context.programInfo.inputNames,a.context.programInfo.variables),attribLocations:this.getAttribLocations(o)}})}compile(e){if(!this.vertexShader){tt.verbose("ProrgramManager","Compiling and caching Vertex shader for the first time");let a=Xu(this.glContext.version);this.vertexShader=this.glContext.compileShader(a,this.glContext.gl.VERTEX_SHADER)}z.debug&&tt.verbose("ProrgramManager",`FragShader:
${e}
`);let n=this.glContext.compileShader(e,this.glContext.gl.FRAGMENT_SHADER),i=this.glContext.createProgram(this.vertexShader,n);return this.glContext.deleteShader(n),i}bindOutput(e){let n=e.width,i=e.height;tt.verbose("ProrgramManager",`Binding output texture to Framebuffer: w/h=${n}/${i}, shape=${e.shape}, type=${e.tensor.type}`),this.glContext.attachFramebuffer(e.texture,n,i)}bindAttributes(e){let n=e.position,i=e.textureCoord;this.glContext.setVertexAttributes(n,i),this.attributesBound=!0}bindUniforms(e,n,i){var o;let a=this.glContext.gl,p=0;for(let{name:s,type:d,location:c,arrayLength:r}of e){let u=(o=n.find(l=>l.name===s))==null?void 0:o.data;if(d!=="sampler2D"&&!u)throw new Error(`variable '${s}' does not have data defined in program info`);switch(d){case"sampler2D":this.bindTexture(i[p],c,p),p++;break;case"float":r?a.uniform1fv(c,u):a.uniform1f(c,u);break;case"int":r?a.uniform1iv(c,u):a.uniform1i(c,u);break;default:throw new Error(`Uniform not implemented: ${d}`)}}}bindTexture(e,n,i){this.glContext.bindTextureToUniform(e.texture,i,n)}getAttribLocations(e){return{position:this.getAttribLocation(e,"position"),textureCoord:this.getAttribLocation(e,"textureCoord")}}getUniformLocations(e,n,i){let a=[];if(n)for(let p of n)a.push({name:p,type:"sampler2D",location:this.getUniformLocation(e,p)});if(i)for(let p of i)a.push({...p,location:this.getUniformLocation(e,p.name)});return a}getUniformLocation(e,n){let i=this.glContext.gl.getUniformLocation(e,n);if(i===null)throw new Error(`Uniform ${n} not found.`);return i}getAttribLocation(e,n){return this.glContext.gl.getAttribLocation(e,n)}}}),Kn,xp=O(()=>{Ut(),Fr(),Kn=class{constructor(e,n,i,a){this.glContext=e,this.layoutStrategy=n,this.profiler=i,this.config=a,this.pendingRead=new Map,a.reuseTextures&&(this.inUseTextures=new Map,this.idleTextures=new Map,this.textureLookup=new Map)}createTextureFromLayout(e,n,i,a){let p=this.toEncoderType(e),o=this.glContext.getEncoder(p,n.channels||1,a);if(n.isPacked&&a===1)throw new Error("not implemented");let s=n.width,d=n.height,c,r;if(this.config.reuseTextures){c=`${s}x${d}_${o.format}_${o.internalFormat}_${o.textureType}`,r=this.inUseTextures.get(c),r||(r=[],this.inUseTextures.set(c,r));let l=this.idleTextures.get(c);if(l&&l.length>0){let h=l.pop();return r.push(h),a===1&&this.glContext.updateTexture(h,s,d,o,this.toTextureData(e,i)),h}}tt.verbose("TextureManager",`Creating new texture of size ${n.width}x${n.height}`);let u=this.glContext.allocateTexture(s,d,o,this.toTextureData(e,i));return this.config.reuseTextures&&(r.push(u),this.textureLookup.set(u,c)),u}readTexture(e,n,i){return i||(i=1),this.profiler.event("backend","TextureManager.readTexture",()=>{let a=e.shape.reduce((o,s)=>o*s)*i,p=this.glContext.readTexture(e.texture,e.width,e.height,a,this.toEncoderType(n),i);return this.toTensorData(n,p)})}async readTextureAsync(e,n,i){let a=e.tensor.dataId;if(i||(i=1),this.pendingRead.has(a)){let p=this.pendingRead.get(a);return new Promise(o=>p==null?void 0:p.push(o))}return this.profiler.event("backend","TextureManager.readTextureAsync",async()=>{this.pendingRead.set(a,[]);let p=e.shape.reduce((c,r)=>c*r)*i;await this.glContext.createAndWaitForFence();let o=this.glContext.readTexture(e.texture,e.width,e.height,p,this.toEncoderType(n),i),s=this.toTensorData(n,o),d=this.pendingRead.get(a);return this.pendingRead.delete(a),d==null||d.forEach(c=>c(s)),s})}readUint8TextureAsFloat(e){return this.profiler.event("backend","TextureManager.readUint8TextureAsFloat",()=>{let n=e.shape.reduce((a,p)=>a*p),i=this.glContext.readTexture(e.texture,e.width,e.height,n*4,"byte",4);return new Float32Array(i.buffer,i.byteOffset,n)})}releaseTexture(e,n){let i;if(this.config.reuseTextures&&(i=this.textureLookup.get(e.texture),i)){n&&this.textureLookup.delete(i);let a=this.inUseTextures.get(i);if(a){let p=a.indexOf(e.texture);if(p!==-1){a.splice(p,1);let o=this.idleTextures.get(i);o||(o=[],this.idleTextures.set(i,o)),o.push(e.texture)}}}(!i||n)&&(tt.verbose("TextureManager",`Deleting texture of size ${e.width}x${e.height}`),this.glContext.deleteTexture(e.texture))}toTensorData(e,n){switch(e){case"int16":return n instanceof Int16Array?n:Int16Array.from(n);case"int32":return n instanceof Int32Array?n:Int32Array.from(n);case"int8":return n instanceof Int8Array?n:Int8Array.from(n);case"uint16":return n instanceof Uint16Array?n:Uint16Array.from(n);case"uint32":return n instanceof Uint32Array?n:Uint32Array.from(n);case"uint8":case"bool":return n instanceof Uint8Array?n:Uint8Array.from(n);case"float32":return n instanceof Float32Array?n:Float32Array.from(n);case"float64":return n instanceof Float64Array?n:Float64Array.from(n);default:throw new Error(`TensorData type ${e} is not supported`)}}toTextureData(e,n){if(n)return n instanceof Float32Array?n:new Float32Array(n)}toEncoderType(e){return"float"}clearActiveTextures(){this.glContext.clearActiveTextures()}}}),Jn,Tp=O(()=>{Ut(),Bs(),cl(),ap(),yp(),Ni(),xp(),Jn=class{constructor(e,n){this.backend=e,this.context=n,this.layoutStrategy=new Un(e.glContext.maxTextureSize),this.programManager=new Xn(this.context.profiler,e.glContext,this.layoutStrategy),this.textureManager=new Kn(e.glContext,this.layoutStrategy,this.context.profiler,{reuseTextures:e.textureCacheMode==="full"}),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache=new Map,this.pack=e.pack,this.pack2unpackMap=new Map,this.unpack2packMap=new Map}createInferenceHandler(){return new Dn(this)}onGraphInitialized(e){let n=e.getValues().filter(i=>i.from===-1&&i.tensor).map(i=>i.tensor.dataId);this.initializers=new Set(n)}isInitializer(e){return this.initializers?this.initializers.has(e):!1}addInitializer(e){this.initializers.add(e)}getTextureData(e,n){return n?this.packedTextureDataCache.get(e):this.unpackedTextureDataCache.get(e)}setTextureData(e,n,i=!1){tt.verbose("WebGLSessionHandler","Storing Texture data in cache"),i?this.packedTextureDataCache.set(e,n):this.unpackedTextureDataCache.set(e,n)}dispose(){this.programManager.dispose(),this.textureManager.clearActiveTextures(),this.packedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.packedTextureDataCache=new Map,this.unpackedTextureDataCache.forEach(e=>this.textureManager.releaseTexture(e,!0)),this.unpackedTextureDataCache=new Map}resolve(e,n,i){let a=ks(e,n,ip);return{impl:a.opImpl,context:a.opInit?a.opInit(e,i):e}}}});function bg(e){let n=0;for(;n<e.length&&e[n]();++n);return n-1}var Mr,wp=O(()=>{Yt(),Fr(),Fr(),pe(),Mr=class{constructor(e,n){this.frameBufferBound=!1,this.itemsToPoll=[],this.gl=e,this.version=n,this.getExtensions(),this.vertexbuffer=this.createVertexbuffer(),this.framebuffer=this.createFramebuffer(),this.queryVitalParameters()}allocateTexture(e,n,i,a){let p=this.gl,o=p.createTexture();p.bindTexture(p.TEXTURE_2D,o),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MIN_FILTER,p.NEAREST),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_MAG_FILTER,p.NEAREST),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_S,p.CLAMP_TO_EDGE),p.texParameteri(p.TEXTURE_2D,p.TEXTURE_WRAP_T,p.CLAMP_TO_EDGE);let s=a?i.encode(a,e*n):null;return p.texImage2D(p.TEXTURE_2D,0,i.internalFormat,e,n,0,i.format,i.textureType,s),this.checkError(),o}updateTexture(e,n,i,a,p){let o=this.gl;o.bindTexture(o.TEXTURE_2D,e);let s=a.encode(p,n*i);o.texSubImage2D(o.TEXTURE_2D,0,0,0,n,i,a.format,a.textureType,s),this.checkError()}attachFramebuffer(e,n,i){let a=this.gl;a.bindTexture(a.TEXTURE_2D,e),a.bindFramebuffer(a.FRAMEBUFFER,this.framebuffer),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e,0),this.checkError(),a.viewport(0,0,n,i),a.scissor(0,0,n,i)}readTexture(e,n,i,a,p,o){let s=this.gl;o||(o=1),this.frameBufferBound||this.attachFramebuffer(e,n,i);let d=this.getEncoder(p,o),c=d.allocate(n*i);return s.bindTexture(s.TEXTURE_2D,e),s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,e,0),s.readPixels(0,0,n,i,s.RGBA,d.textureType,c),this.checkError(),d.decode(c,a)}isFramebufferReady(){return!0}getActiveTexture(){let e=this.gl;return`TEXTURE${e.getParameter(this.gl.ACTIVE_TEXTURE)-e.TEXTURE0}`}getTextureBinding(){return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)}getFramebufferBinding(){return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)}setVertexAttributes(e,n){let i=this.gl;i.vertexAttribPointer(e,3,i.FLOAT,!1,20,0),i.enableVertexAttribArray(e),n!==-1&&(i.vertexAttribPointer(n,2,i.FLOAT,!1,20,12),i.enableVertexAttribArray(n)),this.checkError()}createProgram(e,n){let i=this.gl,a=i.createProgram();return i.attachShader(a,e),i.attachShader(a,n),i.linkProgram(a),a}compileShader(e,n){let i=this.gl,a=i.createShader(n);if(!a)throw new Error(`createShader() returned null with type ${n}`);if(i.shaderSource(a,e),i.compileShader(a),i.getShaderParameter(a,i.COMPILE_STATUS)===!1)throw new Error(`Failed to compile shader: ${i.getShaderInfoLog(a)}
Shader source:
${e}`);return a}deleteShader(e){this.gl.deleteShader(e)}bindTextureToUniform(e,n,i){let a=this.gl;a.activeTexture(a.TEXTURE0+n),this.checkError(),a.bindTexture(a.TEXTURE_2D,e),this.checkError(),a.uniform1i(i,n),this.checkError()}draw(){this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.checkError()}checkError(){if(z.debug){let e=this.gl,n=e.getError(),i="";switch(n){case e.NO_ERROR:return;case e.INVALID_ENUM:i="INVALID_ENUM";break;case e.INVALID_VALUE:i="INVALID_VALUE";break;case e.INVALID_OPERATION:i="INVALID_OPERATION";break;case e.INVALID_FRAMEBUFFER_OPERATION:i="INVALID_FRAMEBUFFER_OPERATION";break;case e.OUT_OF_MEMORY:i="OUT_OF_MEMORY";break;case e.CONTEXT_LOST_WEBGL:i="CONTEXT_LOST_WEBGL";break;default:i=`Unknown WebGL Error: ${n.toString(16)}`}throw new Error(i)}}deleteTexture(e){this.gl.deleteTexture(e)}deleteProgram(e){this.gl.deleteProgram(e)}getEncoder(e,n,i=0){if(this.version===2)return new Pn(this.gl,n);switch(e){case"float":return i===1||this.isRenderFloat32Supported?new Br(this.gl,n):new Br(this.gl,n,this.textureHalfFloatExtension.HALF_FLOAT_OES);case"int":throw new Error("not implemented");case"byte":return new En(this.gl,n);default:throw new Error(`Invalid dataType: ${e}`)}}clearActiveTextures(){let e=this.gl;for(let n=0;n<this.maxTextureImageUnits;++n)e.activeTexture(e.TEXTURE0+n),e.bindTexture(e.TEXTURE_2D,null)}dispose(){if(this.disposed)return;let e=this.gl;e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(this.framebuffer),e.bindBuffer(e.ARRAY_BUFFER,null),e.deleteBuffer(this.vertexbuffer),e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null),e.finish(),this.disposed=!0}createDefaultGeometry(){return new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0])}createVertexbuffer(){let e=this.gl,n=e.createBuffer();if(!n)throw new Error("createBuffer() returned null");let i=this.createDefaultGeometry();return e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,i,e.STATIC_DRAW),this.checkError(),n}createFramebuffer(){let e=this.gl.createFramebuffer();if(!e)throw new Error("createFramebuffer returned null");return e}queryVitalParameters(){let e=this.gl;if(this.isFloatTextureAttachableToFrameBuffer=this.checkFloatTextureAttachableToFrameBuffer(),this.isRenderFloat32Supported=this.checkRenderFloat32(),this.isFloat32DownloadSupported=this.checkFloat32Download(),this.version===1&&!this.textureHalfFloatExtension&&!this.isRenderFloat32Supported)throw new Error("both float32 and float16 TextureType are not supported");this.isBlendSupported=!this.isRenderFloat32Supported||this.checkFloat32Blend(),this.maxTextureSize=e.getParameter(e.MAX_TEXTURE_SIZE),this.maxTextureImageUnits=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),this.version}getExtensions(){this.version===2?(this.colorBufferFloatExtension=this.gl.getExtension("EXT_color_buffer_float"),this.disjointTimerQueryWebgl2Extension=this.gl.getExtension("EXT_disjoint_timer_query_webgl2")):(this.textureFloatExtension=this.gl.getExtension("OES_texture_float"),this.textureHalfFloatExtension=this.gl.getExtension("OES_texture_half_float"))}checkFloatTextureAttachableToFrameBuffer(){let e=this.gl,n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);let i=this.version===2?e.RGBA32F:e.RGBA;e.texImage2D(e.TEXTURE_2D,0,i,1,1,0,e.RGBA,e.FLOAT,null);let a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);let p=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),p}checkRenderFloat32(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension)return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Download(){if(this.version===2){if(!this.colorBufferFloatExtension)return!1}else if(!this.textureFloatExtension||!this.gl.getExtension("WEBGL_color_buffer_float"))return!1;return this.isFloatTextureAttachableToFrameBuffer}checkFloat32Blend(){let e=this.gl,n,i,a,p,o;try{n=e.createTexture(),i=e.createFramebuffer(),e.bindTexture(e.TEXTURE_2D,n);let s=this.version===2?e.RGBA32F:e.RGBA;return e.texImage2D(e.TEXTURE_2D,0,s,1,1,0,e.RGBA,e.FLOAT,null),e.bindFramebuffer(e.FRAMEBUFFER,i),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0),e.enable(e.BLEND),a=e.createShader(e.VERTEX_SHADER),!a||(e.shaderSource(a,"void main(){}"),e.compileShader(a),p=e.createShader(e.FRAGMENT_SHADER),!p)||(e.shaderSource(p,"precision highp float;void main(){gl_FragColor=vec4(0.5);}"),e.compileShader(p),o=e.createProgram(),!o)?!1:(e.attachShader(o,a),e.attachShader(o,p),e.linkProgram(o),e.useProgram(o),e.drawArrays(e.POINTS,0,1),e.getError()===e.NO_ERROR)}finally{e.disable(e.BLEND),o&&e.deleteProgram(o),a&&e.deleteShader(a),p&&e.deleteShader(p),i&&(e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteFramebuffer(i)),n&&(e.bindTexture(e.TEXTURE_2D,null),e.deleteTexture(n))}}beginTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,n=this.disjointTimerQueryWebgl2Extension,i=e.createQuery();return e.beginQuery(n.TIME_ELAPSED_EXT,i),i}else throw new Error("WebGL1 profiling currently not supported.")}endTimer(){if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let e=this.gl,n=this.disjointTimerQueryWebgl2Extension;e.endQuery(n.TIME_ELAPSED_EXT);return}else throw new Error("WebGL1 profiling currently not supported")}isTimerResultAvailable(e){let n=!1,i=!1;if(this.version===2&&this.disjointTimerQueryWebgl2Extension){let a=this.gl,p=this.disjointTimerQueryWebgl2Extension;n=a.getQueryParameter(e,a.QUERY_RESULT_AVAILABLE),i=a.getParameter(p.GPU_DISJOINT_EXT)}else throw new Error("WebGL1 profiling currently not supported");return n&&!i}getTimerResult(e){let n=0;if(this.version===2){let i=this.gl;n=i.getQueryParameter(e,i.QUERY_RESULT),i.deleteQuery(e)}else throw new Error("WebGL1 profiling currently not supported");return n/1e6}async waitForQueryAndGetTime(e){return await li(()=>this.isTimerResultAvailable(e)),this.getTimerResult(e)}async createAndWaitForFence(){let e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,i=e,a=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);return e.flush(),a===null?n=()=>!0:n=()=>{let p=i.clientWaitSync(a,0,0);return p===i.ALREADY_SIGNALED||p===i.CONDITION_SATISFIED},{query:a,isFencePassed:n}}async pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){let e=bg(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){let{resolveFn:i}=this.itemsToPoll[n];i()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}async addItemToPoll(e,n){this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),!(this.itemsToPoll.length>1)&&await li(()=>(this.pollItems(),this.itemsToPoll.length===0))}}});function Gi(e){let n;if((!e||e==="webgl2")&&"webgl2"in mr?n=mr.webgl2:(!e||e==="webgl")&&"webgl"in mr&&(n=mr.webgl),!n)try{let a=yg();n=vp(a,e)}catch{let a=gg();n=vp(a,e)}e=e||n.version===1?"webgl":"webgl2";let i=n.gl;return mr[e]=n,i.isContextLost()?(delete mr[e],Gi(e)):(i.disable(i.DEPTH_TEST),i.disable(i.STENCIL_TEST),i.disable(i.BLEND),i.disable(i.DITHER),i.disable(i.POLYGON_OFFSET_FILL),i.disable(i.SAMPLE_COVERAGE),i.enable(i.SCISSOR_TEST),i.enable(i.CULL_FACE),i.cullFace(i.BACK),n)}function vp(e,n){let i={alpha:!1,depth:!1,antialias:!1,stencil:!1,preserveDrawingBuffer:!1,premultipliedAlpha:!1,failIfMajorPerformanceCaveat:!1},a,p=i;if((!n||n==="webgl2")&&(a=e.getContext("webgl2",p),a))try{return new Mr(a,2)}catch(o){tt.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl2'. Error: ${o}`)}if((!n||n==="webgl")&&(a=e.getContext("webgl",p)||e.getContext("experimental-webgl",p),a))try{return new Mr(a,1)}catch(o){tt.warning("GlContextFactory",`failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${o}`)}throw new Error("WebGL is not supported")}function gg(){if(typeof document>"u")throw new TypeError("failed to create canvas: document is not supported");let e=document.createElement("canvas");return e.width=1,e.height=1,e}function yg(){if(typeof OffscreenCanvas>"u")throw new TypeError("failed to create offscreen canvas: OffscreenCanvas is not supported");return new OffscreenCanvas(1,1)}var mr,Ip=O(()=>{Ut(),wp(),mr={}}),Yn,_p=O(()=>{Yt(),Ut(),Tp(),Ip(),Yn=class{get contextId(){return z.webgl.contextId}set contextId(e){z.webgl.contextId=e}get matmulMaxBatchSize(){return z.webgl.matmulMaxBatchSize}set matmulMaxBatchSize(e){z.webgl.matmulMaxBatchSize=e}get textureCacheMode(){return z.webgl.textureCacheMode}set textureCacheMode(e){z.webgl.textureCacheMode=e}get pack(){return z.webgl.pack}set pack(e){z.webgl.pack=e}get async(){return z.webgl.async}set async(e){z.webgl.async=e}initialize(){try{return this.glContext=Gi(this.contextId),typeof this.matmulMaxBatchSize!="number"&&(this.matmulMaxBatchSize=16),typeof this.textureCacheMode!="string"&&(this.textureCacheMode="full"),typeof this.pack!="boolean"&&(this.pack=!1),typeof this.async!="boolean"&&(this.async=!1),tt.setWithEnv(z),z.webgl.context||Object.defineProperty(z.webgl,"context",{value:this.glContext.gl}),tt.verbose("WebGLBackend",`Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),!0}catch(e){return tt.warning("WebGLBackend",`Unable to initialize WebGLBackend. ${e}`),!1}}createSessionHandler(e){return new Jn(this,e)}dispose(){this.glContext.dispose()}}});async function Mi(e){if(e){let n=typeof e=="string"?[e]:e;for(let i of n){let a=Op.get(i);if(a)return a;let p=await Tg(i);if(p)return p}}else return Mi(["webgl"]);throw new Error("no available backend to use")}async function Tg(e){let n=xg;if(typeof n[e]<"u"&&wg(n[e])){let i=n[e],a=i.initialize();if(typeof a=="object"&&"then"in a&&(a=await a),a)return Op.set(e,i),i}}function wg(e){let n=e;return"initialize"in n&&typeof n.initialize=="function"&&"createSessionHandler"in n&&typeof n.createSessionHandler=="function"&&"dispose"in n&&typeof n.dispose=="function"}var Op,xg,Sp=O(()=>{_p(),Op=new Map,xg={webgl:new Yn}}),Ui,Zn,Ap=O(()=>{Ut(),Ui=class{constructor(e,n){this.op=e,this.node=n}},Zn=class{constructor(e,n,i){this.graph=e,this.profiler=i,this.initialize(n)}initialize(e){this.profiler.event("session","ExecutionPlan.initialize",()=>{let n=this.graph.getNodes();if(n.length!==e.length)throw new Error("The size of nodes and OPs do not match.");this._ops=e.map((i,a)=>new Ui(i,n[a])),this.reset(),this._starter=[],this._ops.forEach((i,a)=>{let p=!0;for(let o of i.node.inputs)if(!this._values[o]&&this.graph.getInputIndices().indexOf(o)===-1){p=!1;break}p&&this._starter.push(a)})})}reset(){this._values=this.graph.getValues().map(e=>e.tensor)}async execute(e,n){return this.profiler.event("session","ExecutionPlan.execute",async()=>{this.reset();let i=e.createInferenceHandler(),a=this.graph.getInputIndices();if(n.length!==a.length)throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${n.length} expected: ${a.length}`);n.forEach((r,u)=>{let l=a[u];this._values[l]=r});let p=this._starter.slice(0),o=this.graph.getValues(),s=this.graph.getNodes(),d=0;for(;d<p.length;){let r=p[d++],u=this._ops[r],l=u.node.inputs.map(y=>this._values[y]);if(l.indexOf(void 0)!==-1)throw new Error(`unresolved input detected: op: ${u.node}`);let h=l;tt.verbose("ExecPlan",`Running op:${u.node.name} (${h.map((y,_)=>`'${u.node.inputs[_]}': ${y.type}[${y.dims.join(",")}]`).join(", ")})`);let f=await this.profiler.event("node",u.node.name,async()=>u.op.impl(i,h,u.op.context));if(f.length!==u.node.outputs.length)throw new Error("the size of output does not match model definition.");f.forEach((y,_)=>{let I=u.node.outputs[_];if(this._values[I])throw new Error(`output [${I}] already has value: op:${u.node.name}`);this._values[I]=y});let m=new Set;f.forEach((y,_)=>{let I=u.node.outputs[_];for(let x of o[I].to){let P=s[x],N=!0;for(let R of P.inputs)if(!this._values[R]){N=!1;break}N&&m.add(x)}}),p.push(...m)}let c=[];for(let r=0;r<this.graph.getOutputIndices().length;r++){let u=this.graph.getOutputIndices()[r],l=this._values[u];if(l===void 0)throw new Error(`required output [${u}] does not have value`);u===0?await l.getData():l.data,c.push(l)}return tt.verbose("ExecPlan","disposing of inferenceHandler"),i.dispose(),c})}}}),q,Xt,Ur,Pp=O(()=>{Pr(),q=rr(sr()),We(),Y(),Xt=F.experimental.fbs,Ur=class Ie{constructor(n){if(this._attributes=new Map,n!=null){for(let i of n)i instanceof q.onnx.AttributeProto?this._attributes.set(i.name,[Ie.getValue(i),Ie.getType(i)]):i instanceof Xt.Attribute&&this._attributes.set(i.name(),[Ie.getValue(i),Ie.getType(i)]);if(this._attributes.size<n.length)throw new Error("duplicated attribute names")}}set(n,i,a){this._attributes.set(n,[a,i])}delete(n){this._attributes.delete(n)}getFloat(n,i){return this.get(n,"float",i)}getInt(n,i){return this.get(n,"int",i)}getString(n,i){return this.get(n,"string",i)}getTensor(n,i){return this.get(n,"tensor",i)}getFloats(n,i){return this.get(n,"floats",i)}getInts(n,i){return this.get(n,"ints",i)}getStrings(n,i){return this.get(n,"strings",i)}getTensors(n,i){return this.get(n,"tensors",i)}get(n,i,a){let p=this._attributes.get(n);if(p===void 0){if(a!==void 0)return a;throw new Error(`required attribute not found: ${n}`)}if(p[1]!==i)throw new Error(`type mismatch: expected ${i} but got ${p[1]}`);return p[0]}static getType(n){let i=n instanceof q.onnx.AttributeProto?n.type:n.type();switch(i){case q.onnx.AttributeProto.AttributeType.FLOAT:return"float";case q.onnx.AttributeProto.AttributeType.INT:return"int";case q.onnx.AttributeProto.AttributeType.STRING:return"string";case q.onnx.AttributeProto.AttributeType.TENSOR:return"tensor";case q.onnx.AttributeProto.AttributeType.FLOATS:return"floats";case q.onnx.AttributeProto.AttributeType.INTS:return"ints";case q.onnx.AttributeProto.AttributeType.STRINGS:return"strings";case q.onnx.AttributeProto.AttributeType.TENSORS:return"tensors";default:throw new Error(`attribute type is not supported yet: ${q.onnx.AttributeProto.AttributeType[i]}`)}}static getValue(n){let i=n instanceof q.onnx.AttributeProto?n.type:n.type();if(i===q.onnx.AttributeProto.AttributeType.GRAPH||i===q.onnx.AttributeProto.AttributeType.GRAPHS)throw new Error("graph attribute is not supported yet");let a=this.getValueNoCheck(n);if(i===q.onnx.AttributeProto.AttributeType.INT&&Rt.isLong(a))return Rt.longToNumber(a);if(i===q.onnx.AttributeProto.AttributeType.INTS){let p=a,o=new Array(p.length);for(let s=0;s<p.length;s++){let d=p[s];o[s]=Rt.longToNumber(d)}return o}if(i===q.onnx.AttributeProto.AttributeType.TENSOR)return n instanceof q.onnx.AttributeProto?bt.fromProto(a):bt.fromOrtTensor(a);if(i===q.onnx.AttributeProto.AttributeType.TENSORS){if(n instanceof q.onnx.AttributeProto)return a.map(p=>bt.fromProto(p));if(n instanceof Xt.Attribute)return a.map(p=>bt.fromOrtTensor(p))}return i===q.onnx.AttributeProto.AttributeType.STRING&&n instanceof q.onnx.AttributeProto?kr(a):i===q.onnx.AttributeProto.AttributeType.STRINGS&&n instanceof q.onnx.AttributeProto?a.map(kr):a}static getValueNoCheck(n){return n instanceof q.onnx.AttributeProto?this.getValueNoCheckFromOnnxFormat(n):this.getValueNoCheckFromOrtFormat(n)}static getValueNoCheckFromOnnxFormat(n){switch(n.type){case q.onnx.AttributeProto.AttributeType.FLOAT:return n.f;case q.onnx.AttributeProto.AttributeType.INT:return n.i;case q.onnx.AttributeProto.AttributeType.STRING:return n.s;case q.onnx.AttributeProto.AttributeType.TENSOR:return n.t;case q.onnx.AttributeProto.AttributeType.GRAPH:return n.g;case q.onnx.AttributeProto.AttributeType.FLOATS:return n.floats;case q.onnx.AttributeProto.AttributeType.INTS:return n.ints;case q.onnx.AttributeProto.AttributeType.STRINGS:return n.strings;case q.onnx.AttributeProto.AttributeType.TENSORS:return n.tensors;case q.onnx.AttributeProto.AttributeType.GRAPHS:return n.graphs;default:throw new Error(`unsupported attribute type: ${q.onnx.AttributeProto.AttributeType[n.type]}`)}}static getValueNoCheckFromOrtFormat(n){switch(n.type()){case Xt.AttributeType.FLOAT:return n.f();case Xt.AttributeType.INT:return n.i();case Xt.AttributeType.STRING:return n.s();case Xt.AttributeType.TENSOR:return n.t();case Xt.AttributeType.GRAPH:return n.g();case Xt.AttributeType.FLOATS:return n.floatsArray();case Xt.AttributeType.INTS:{let i=[];for(let a=0;a<n.intsLength();a++)i.push(n.ints(a));return i}case Xt.AttributeType.STRINGS:{let i=[];for(let a=0;a<n.stringsLength();a++)i.push(n.strings(a));return i}case Xt.AttributeType.TENSORS:{let i=[];for(let a=0;a<n.tensorsLength();a++)i.push(n.tensors(a));return i}default:throw new Error(`unsupported attribute type: ${Xt.AttributeType[n.type()]}`)}}}}),zi,Qn,Wi,me,to,Vi,Ep=O(()=>{Pp(),Pr(),zi=rr(sr()),We(),Y(),Qn=F.experimental.fbs,Wi={from:(e,n)=>new Vi(e,n)},me=class{constructor(e){this._from=void 0,this._to=[],this.tensor=void 0,this.type=void 0,e&&(this.type=At.tensorValueTypeFromProto(e.type.tensorType))}get from(){return this._from}get to(){return this._to}},to=class{constructor(e,n){e instanceof zi.onnx.NodeProto?(this.name=e.name,this.opType=e.opType,this.attributes=new Ur(e.attribute)):e instanceof Qn.Node&&(this.name=n??e.name(),this.opType=e.opType(),this.attributes=new Ur(At.tensorAttributesFromORTFormat(e))),this.inputs=[],this.outputs=[],this.executeNode=!0}},Vi=class{constructor(e,n){if(!e)throw new TypeError("graph is empty");this.buildGraph(e),this.transformGraph(n),this.checkIsAcyclic()}getInputIndices(){return this._allInputIndices}getInputNames(){return this._allInputNames}getOutputIndices(){return this._allOutputIndices}getOutputNames(){return this._allOutputNames}getValues(){return this._allData}getNodes(){return this._nodes}buildGraph(e){if(e instanceof zi.onnx.GraphProto)this.buildGraphFromOnnxFormat(e);else if(e instanceof Qn.Graph)this.buildGraphFromOrtFormat(e);else throw new TypeError("Graph type is not supported.")}buildGraphFromOnnxFormat(e){let n=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map;if(!e.input)throw new Error("missing information in graph: input");let a=[];for(let p of e.input){if(n.has(p.name))throw new Error(`duplicated input name: ${p.name}`);let o=this._allData.push(new me(p))-1;n.set(p.name,o),a.push(p.name)}if(!e.initializer)throw new Error("missing information in graph: initializer");for(let p of e.initializer){let o=n.get(p.name);if(o===void 0){let s=new me;s.type={shape:{dims:At.tensorDimsFromProto(p.dims)},tensorType:At.tensorDataTypeFromProto(p.dataType)},o=this._allData.push(s)-1,n.set(p.name,o)}this._allData[o]._from=-1,this._allData[o].tensor=bt.fromProto(p)}for(let p=0;p<this._allData.length;p++)this._allData[p].tensor||(this._allInputIndices.push(p),this._allInputNames.push(a[p]));if(!e.output)throw new Error("missing information in graph: output");for(let p of e.output){if(n.has(p.name))throw new Error(`duplicated output name: ${p.name}`);let o=this._allData.push(new me(p))-1;n.set(p.name,o),this._allOutputIndices.push(o),this._allOutputNames.push(p.name)}if(!e.node)throw new Error("missing information in graph: node");for(let p of e.node){if(!p.name)for(let s=0;;s++){let d=`unnamed_${p.opType}_${s}`;if(!i.has(d)){p.name=d;break}}if(i.has(p.name))throw new Error(`duplicated node name: ${p.name}`);let o=this._nodes.push(new to(p))-1;i.set(p.name,o)}for(let p=0;p<this._nodes.length;p++){let o=this._nodes[p],s=e.node[p];if(!s.output)throw new Error(`missing output for node: ${s.name}`);for(let d of s.output){let c=n.get(d);if(typeof c>"u"&&(c=this._allData.push(new me)-1,n.set(d,c)),o.outputs.push(c),this._allData[c]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${c}`);if(this._allData[c]._from=p,s.opType==="Constant"){if(!s.attribute||s.attribute.length!==1||!s.attribute[0].t)throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(!s.output||s.output.length!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");o.outputs.pop(),o.executeNode=!1,this._allData[c]._from=-1,this._allData[c].tensor=bt.fromProto(s.attribute[0].t)}}}for(let p=0;p<this._nodes.length;p++){let o=this._nodes[p],s=e.node[p];if(!s.input)throw new Error(`missing input for node: ${s.name}`);for(let d of s.input){let c=n.get(d);if(typeof c>"u"){if(d===""&&(s.input.length===3||s.input.length===4)&&s.opType==="Resize")continue;throw new Error(`unrecognized input '${d}' for node: ${s.name}`)}o.inputs.push(c),this._allData[c]._to.push(p)}}return!0}buildGraphFromOrtFormat(e){var p,o,s;let n=new Map;this._allData=[],this._allInputIndices=[],this._allInputNames=[],this._allOutputIndices=[],this._allOutputNames=[],this._nodes=[];let i=new Map,a=[];for(let d=0;d<e.inputsLength();d++){let c=e.inputs(d);if(n.has(c))throw new Error(`duplicated input name: ${c}`);for(let r=0;r<e.nodeArgsLength();r++)if(((p=e.nodeArgs(r))==null?void 0:p.name())===c){let u=new me;if(((s=(o=e.nodeArgs(r))==null?void 0:o.type())==null?void 0:s.valueType())!==Qn.TypeInfoValue.tensor_type)throw new Error("Unexpected value type for the nodeArg.");let l=e.nodeArgs(r).type().value(new Qn.TensorTypeAndShape),h=At.tensorDataTypeFromProto(l.elemType()),f=l.shape(),m=[];for(let _=0;_<f.dimLength();_++)m.push(Rt.longToNumber(f.dim(_).value().dimValue()));u.type={shape:{dims:m},tensorType:h};let y=this._allData.push(u)-1;n.set(c,y),a.push(c)}}for(let d=0;d<e.initializersLength();d++){let c=e.initializers(d),r=n.get(c.name());if(r===void 0){let u=new me,l=At.tensorDimsFromORTFormat(c),h=At.tensorDataTypeFromProto(c.dataType());u.type={shape:{dims:l},tensorType:h},r=this._allData.push(u)-1,n.set(c.name(),r)}this._allData[r]._from=-1,this._allData[r].tensor=bt.fromOrtTensor(c)}for(let d=0;d<this._allData.length;d++)this._allData[d].tensor||(this._allInputIndices.push(d),this._allInputNames.push(a[d]));for(let d=0;d<e.outputsLength();d++){let c=e.outputs(d);if(n.has(c))throw new Error(`duplicated output name: ${c}`);let r=this._allData.push(new me)-1;n.set(c,r),this._allOutputIndices.push(r),this._allOutputNames.push(c)}if(!e.nodes)throw new Error("missing information in graph: node");for(let d=0;d<e.nodesLength();d++){let c=e.nodes(d),r=c.name();if(!r)for(let l=0;r=`unnamed_${c.opType()}_${l}`,!!i.has(r);l++);if(i.has(r))throw new Error(`duplicated node name: ${r}`);let u=this._nodes.push(new to(c,r))-1;i.set(r,u)}for(let d=0;d<this._nodes.length;d++){let c=this._nodes[d],r=e.nodes(d);if(r==null)throw new Error(`No node exists at index ${d}`);if((r==null?void 0:r.outputsLength())===0)throw new Error(`missing output for node: ${r.name}`);for(let u=0;u<(r==null?void 0:r.outputsLength());u++){let l=r==null?void 0:r.outputs(u),h=n.get(l);if(typeof h>"u"&&(h=this._allData.push(new me)-1,n.set(l,h)),c.outputs.push(h),this._allData[h]._from!==void 0)throw new Error(`multiple nodes output to one data value: ${h}`);if(this._allData[h]._from=d,r.opType()==="Constant"){if(r.attributesLength()!==1||!r.attributes(0).t())throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");if(r.outputsLength()!==1)throw new Error("missing output or incorrect number of outputs for this Constant operator");c.outputs.pop(),c.executeNode=!1,this._allData[h]._from=-1,this._allData[h].tensor=bt.fromOrtTensor(r.attributes(0).t())}}}for(let d=0;d<this._nodes.length;d++){let c=this._nodes[d],r=e.nodes(d);if(r.inputsLength()===0)throw new Error(`missing input for node: ${r.name}`);for(let u=0;u<r.inputsLength();u++){let l=r.inputs(u),h=n.get(l);if(typeof h>"u")throw new Error(`unrecognized input '${l}' for node: ${r.name()}`);c.inputs.push(h),this._allData[h]._to.push(d)}}}checkIsAcyclic(){let e=new Set;this._allInputIndices.forEach(a=>{this._allData[a]._to.forEach(p=>{e.add(p)})});let n=Array.from(e),i=new Array(this._nodes.length).fill("white");for(;n.length>0;){let a=n.pop();i[a]==="gray"?i[a]="black":(n.push(a),i[a]="gray",this._nodes[a].outputs.forEach(p=>{let o=this._allData[p];if(typeof o.tensor<"u")throw new Error("node outputs should not be initialized");if(o._from!==a)throw new Error("from property of the Value object doesn't match index of Node being processed");o._to.forEach(s=>{if(i[s]==="gray")throw new Error("model graph is cyclic");i[s]==="white"&&n.push(s)})}))}}transformGraph(e){this.removeAllIdentityNodes(),this.removeAllDropoutNodes(),this.fuseConvActivationNodes(),e&&e.transformGraph(this),this.finalizeGraph()}finalizeGraph(){let e=0,n=new Array(this._nodes.length,0),i=0;for(let a=0;a<this._nodes.length;a++)n[a]=i,this._nodes[a].executeNode?(i!==a&&(this._nodes[i]=this._nodes[a]),i++):this._nodes[a].outputs.forEach(p=>{this._allData[p]._from=-2});this._nodes.splice(i,this._nodes.length-i);for(let a=0;a<this._allData.length;a++){let p=this._allData[a];p._from!==void 0&&p._from!==-1&&p._from!==-2&&(p._from=n[p._from]);for(let o=0;o<p._to.length;o++)if(p._to[o]>=0)p._to[o]=n[p._to[o]];else throw new Error("Trying to update a removed node")}e=0;for(let a=0;a<this._allData.length;a++){if(this._allData[a].from===-2&&this._allOutputIndices.indexOf(a+e)===-1){e++,this._allData.splice(a,1),a--;continue}if(e>0){let p=-1;this._allData[a].from!==void 0&&this._allData[a].from!==-1?(p=this._nodes[this._allData[a].from].outputs.indexOf(a+e),p!==-1&&(this._nodes[this._allData[a].from].outputs[p]=a)):(p=this._allInputIndices.indexOf(a+e),p!==-1&&(this._allInputIndices[p]=a)),this._allData[a].to.forEach(o=>{p=this._nodes[o].inputs.indexOf(a+e),p!==-1&&(this._nodes[o].inputs[p]=a)}),this._allData[a].to.length===0&&(p=this._allOutputIndices.indexOf(a+e),p!==-1&&(this._allOutputIndices[p]=a))}}}deleteNode(e){let n=this._nodes[e];if(n.outputs.length>1){for(let s=1;s<n.outputs.length;s++)if(this._allData[n.outputs[s]].to.length>0)throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")}n.executeNode=!1;let i=n.inputs[0],a=n.outputs[0],p=this._allData[a].to;for(let s=0;s<n.inputs.length;s++){let d=this._allData[n.inputs[s]].to.indexOf(e);if(d===-1)throw new Error("The Value object doesn't have the current Node in it's 'to' property ");this._allData[n.inputs[s]].to.splice(d,1)}this._allData[a]._to=[];let o=this._allOutputIndices.indexOf(a);if(o!==-1&&(this._allOutputIndices[o]=i),p&&p.length>0)for(let s of p){let d=this._nodes[s].inputs.indexOf(a);if(d===-1)throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");this._nodes[s].inputs[d]=i,this._allData[i].to.push(s)}}removeAllDropoutNodes(){let e=0;for(let n of this._nodes){if(n.opType==="Dropout"){if(n.inputs.length!==1)throw new Error("Dropout nodes should only contain one input. ");if(n.outputs.length!==1&&n.outputs.length!==2)throw new Error("Dropout nodes should contain either 1 or 2 output(s)");if(n.outputs.length===2&&this._allData[n.outputs[1]]._to.length!==0)throw new Error("Dropout nodes's second output should not be referenced by other nodes");this.deleteNode(e)}e++}}removeAllIdentityNodes(){let e=0;for(let n of this._nodes)n.opType==="Identity"&&this.deleteNode(e),e++}isActivation(e){switch(e.opType){case"Relu":case"Sigmoid":case"Clip":return!0;default:return!1}}fuseConvActivationNodes(){for(let e of this._nodes)if(e.opType==="Conv"){let n=this._allData[e.outputs[0]]._to;if(n.length===1&&this.isActivation(this._nodes[n[0]])){let i=this._nodes[n[0]];if(i.opType==="Clip")if(i.inputs.length===1)try{e.attributes.set("activation_params","floats",[i.attributes.getFloat("min"),i.attributes.getFloat("max")])}catch{e.attributes.set("activation_params","floats",[Ve,ze])}else if(i.inputs.length>=3&&this._allData[i.inputs[1]].tensor!==void 0&&this._allData[i.inputs[2]].tensor!==void 0)e.attributes.set("activation_params","floats",[this._allData[i.inputs[1]].tensor.floatData[0],this._allData[i.inputs[2]].tensor.floatData[0]]);else continue;e.attributes.set("activation","string",i.opType),this.deleteNode(n[0])}}}}}),Dp,vg,eo,Lp=O(()=>{wn(),Ep(),Pr(),Dp=rr(sr()),Y(),vg=F.experimental.fbs,eo=class{constructor(){}load(e,n,i){let a;if(!i)try{this.loadFromOnnxFormat(e,n);return}catch(p){if(i!==void 0)throw p;a=p}try{this.loadFromOrtFormat(e,n)}catch(p){throw i!==void 0?p:new Error(`Failed to load model as ONNX format: ${a}
as ORT format: ${p}`)}}loadFromOnnxFormat(e,n){let i=Dp.onnx.ModelProto.decode(e);if(Rt.longToNumber(i.irVersion)<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=i.opsetImport.map(a=>({domain:a.domain,version:Rt.longToNumber(a.version)})),this._graph=Wi.from(i.graph,n)}loadFromOrtFormat(e,n){let i=new w.ByteBuffer(e),a=vg.InferenceSession.getRootAsInferenceSession(i).model();if(Rt.longToNumber(a.irVersion())<3)throw new Error("only support ONNX model with IR_VERSION>=3");this._opsets=[];for(let p=0;p<a.opsetImportLength();p++){let o=a.opsetImport(p);this._opsets.push({domain:o==null?void 0:o.domain(),version:Rt.longToNumber(o.version())})}this._graph=Wi.from(a.graph(),n)}get graph(){return this._graph}get opsets(){return this._opsets}}}),ro,$p=O(()=>{Sp(),Ap(),Ut(),Lp(),ro=class{constructor(e={}){this._initialized=!1,this.backendHint=e.backendHint,this.profiler=xn.create(e.profiler),this.context={profiler:this.profiler,graphInputTypes:[],graphInputDims:[]}}get inputNames(){return this._model.graph.getInputNames()}get outputNames(){return this._model.graph.getOutputNames()}startProfiling(){this.profiler.start()}endProfiling(){this.profiler.stop()}async loadModel(e,n,i){await this.profiler.event("session","Session.loadModel",async()=>{let a=await Mi(this.backendHint);if(this.sessionHandler=a.createSessionHandler(this.context),this._model=new eo,typeof e=="string"){let p=e.endsWith(".ort");{let o=await(await fetch(e)).arrayBuffer();this.initialize(new Uint8Array(o),p)}}else if(ArrayBuffer.isView(e))this.initialize(e);else{let p=new Uint8Array(e,n||0,i||e.byteLength);this.initialize(p)}})}initialize(e,n){if(this._initialized)throw new Error("already initialized");this.profiler.event("session","Session.initialize",()=>{let i=this.sessionHandler.transformGraph?this.sessionHandler:void 0;this._model.load(e,i,n),this.sessionHandler.onGraphInitialized&&this.sessionHandler.onGraphInitialized(this._model.graph),this.initializeOps(this._model.graph),this._executionPlan=new Zn(this._model.graph,this._ops,this.profiler)}),this._initialized=!0}async run(e){if(!this._initialized)throw new Error("session not initialized yet");return this.profiler.event("session","Session.run",async()=>{let n=this.normalizeAndValidateInputs(e),i=await this._executionPlan.execute(this.sessionHandler,n);return this.createOutput(i)})}normalizeAndValidateInputs(e){let n=this._model.graph.getInputNames();if(Array.isArray(e)){if(e.length!==n.length)throw new Error(`incorrect input array length: expected ${n.length} but got ${e.length}`)}else{if(e.size!==n.length)throw new Error(`incorrect input map size: expected ${n.length} but got ${e.size}`);let i=new Array(e.size),a=0;for(let p=0;p<n.length;++p){let o=e.get(n[p]);if(!o)throw new Error(`missing input tensor for: '${name}'`);i[a++]=o}e=i}if(!this.context.graphInputTypes||this.context.graphInputTypes.length===0||!this.context.graphInputDims||this.context.graphInputDims.length===0){let i=this._model.graph.getInputIndices(),a=this._model.graph.getValues(),p=new Array(i.length);for(let o=0;o<i.length;++o){let s=a[i[o]];p[o]=s.type.shape.dims,this.context.graphInputTypes.push(s.type.tensorType),this.context.graphInputDims.push(e[o].dims)}this.validateInputTensorDims(p,e,!0)}else this.validateInputTensorDims(this.context.graphInputDims,e,!1);return this.validateInputTensorTypes(this.context.graphInputTypes,e),e}validateInputTensorTypes(e,n){for(let i=0;i<n.length;i++){let a=e[i],p=n[i].type;if(a!==p)throw new Error(`input tensor[${i}] check failed: expected type '${a}' but got ${p}`)}}validateInputTensorDims(e,n,i){for(let a=0;a<n.length;a++){let p=e[a],o=n[a].dims;if(!this.compareTensorDims(p,o,i))throw new Error(`input tensor[${a}] check failed: expected shape '[${p.join(",")}]' but got [${o.join(",")}]`)}}compareTensorDims(e,n,i){if(e.length!==n.length)return!1;for(let a=0;a<e.length;++a)if(e[a]!==n[a]&&(!i||e[a]!==0))return!1;return!0}createOutput(e){let n=this._model.graph.getOutputNames();if(e.length!==n.length)throw new Error("expected number of outputs do not match number of generated outputs");let i=new Map;for(let a=0;a<n.length;++a)i.set(n[a],e[a]);return i}initializeOps(e){let n=e.getNodes();this._ops=new Array(n.length);for(let i=0;i<n.length;i++)this._ops[i]=this.sessionHandler.resolve(n[i],this._model.opsets,e)}}}),no,kp=O(()=>{Yt(),We(),no=class{constructor(e){this.session=e,this.inputNames=this.session.inputNames,this.outputNames=this.session.outputNames}async dispose(){}async run(e,n,i){let a=new Map;for(let s in e)if(Object.hasOwnProperty.call(e,s)){let d=e[s];a.set(s,new bt(d.dims,d.type,void 0,void 0,d.data))}let p=await this.session.run(a),o={};return p.forEach((s,d)=>{o[d]=new yt(s.type,s.data,s.dims)}),o}startProfiling(){this.session.startProfiling()}endProfiling(){this.session.endProfiling()}}}),Bp={};Or(Bp,{onnxjsBackend:()=>Ig});var Hi,Ig,Fp=O(()=>{$p(),kp(),Hi=class{async init(){}async createInferenceSessionHandler(e,n){let i=new ro(n);return typeof e=="string"?await i.loadModel(e):await i.loadModel(e),new no(i)}},Ig=new Hi}),oo=O(()=>{}),Rp={};Or(Rp,{default:()=>_g});var Cp,Np,_g,Gp=O(()=>{var e;qi(),Ke(),Vr(),Cp="ort-wasm-proxy-worker",Np=((e=globalThis.self)==null?void 0:e.name)===Cp,Np&&(self.onmessage=n=>{let{type:i,in:a}=n.data;try{switch(i){case"init-wasm":io(a.wasm).then(()=>{ao(a).then(()=>{postMessage({type:i})},p=>{postMessage({type:i,err:p})})},p=>{postMessage({type:i,err:p})});break;case"init-ep":{let{epName:p,env:o}=a;so(o,p).then(()=>{postMessage({type:i})},s=>{postMessage({type:i,err:s})});break}case"copy-from":{let{buffer:p}=a,o=zr(p);postMessage({type:i,out:o});break}case"create":{let{model:p,options:o}=a;uo(p,o).then(s=>{postMessage({type:i,out:s})},s=>{postMessage({type:i,err:s})});break}case"release":lo(a),postMessage({type:i});break;case"run":{let{sessionId:p,inputIndices:o,inputs:s,outputIndices:d,options:c}=a;fo(p,o,s,d,new Array(d.length).fill(null),c).then(r=>{r.some(u=>u[3]!=="cpu")?postMessage({type:i,err:"Proxy does not support non-cpu tensor location."}):postMessage({type:i,out:r},po([...s,...r]))},r=>{postMessage({type:i,err:r})});break}case"end-profiling":co(a),postMessage({type:i});break;default:}}catch(p){postMessage({type:i,err:p})}}),_g=Np?null:n=>new Worker(n??br,{type:"module",name:Cp})}),Up={};Or(Up,{default:()=>Og});var ji,Mp,Og,Vp=O(()=>{var e;Mp=(ji=_documentCurrentScript&&_documentCurrentScript.tagName.toUpperCase()==="SCRIPT"&&_documentCurrentScript.src||new URL("segmentation.js",document.baseURI).href,async function(n={}){function i(){return ft.buffer!=gt.buffer&&it(),gt}function a(){return ft.buffer!=gt.buffer&&it(),U}function p(){return ft.buffer!=gt.buffer&&it(),Mt}function o(){return ft.buffer!=gt.buffer&&it(),De}function s(){return ft.buffer!=gt.buffer&&it(),ae}var d,c,r=Object.assign({},n),u=new Promise((g,b)=>{d=g,c=b}),l=typeof window=="object",h=typeof importScripts=="function",f=h&&self.name=="em-pthread";r.mountExternalData=(g,b)=>{g.startsWith("./")&&(g=g.substring(2)),(r.Ua||(r.Ua=new Map)).set(g,b)},r.unmountExternalData=()=>{delete r.Ua};var m,y,_=globalThis.SharedArrayBuffer??new WebAssembly.Memory({initial:0,maximum:0,shared:!0}).buffer.constructor,I=Object.assign({},r),x="./this.program",P=(g,b)=>{throw b},N="";(l||h)&&(h?N=self.location.href:typeof document<"u"&&document.currentScript&&(N=document.currentScript.src),ji&&(N=ji),N=N.startsWith("blob:")?"":N.substr(0,N.replace(/[?#].*/,"").lastIndexOf("/")+1),h&&(y=g=>{var b=new XMLHttpRequest;return b.open("GET",g,!1),b.responseType="arraybuffer",b.send(null),new Uint8Array(b.response)}),m=(g,b,v)=>{var S=new XMLHttpRequest;S.open("GET",g,!0),S.responseType="arraybuffer",S.onload=()=>{S.status==200||S.status==0&&S.response?b(S.response):v()},S.onerror=v,S.send(null)});var R,ct=console.log.bind(console),st=console.error.bind(console),Dt=ct,Z=st;if(Object.assign(r,I),I=null,f){let g=function(b){try{var v=b.data,S=v.cmd;if(S==="load"){let E=[];self.onmessage=$=>E.push($),self.startWorker=()=>{postMessage({cmd:"loaded"});for(let $ of E)g($);self.onmessage=g};for(let $ of v.handlers)r[$]&&!r[$].proxy||(r[$]=(...L)=>{postMessage({Za:"callHandler",kb:$,args:L})},$=="print"&&(Dt=r[$]),$=="printErr"&&(Z=r[$]));ft=v.wasmMemory,it(),Ot(v.wasmModule)}else if(S==="run"){Jr(v.pthread_ptr,0,0,1,0,0),Ir(v.pthread_ptr),Ia(),_o(),Ae||(Ae=!0);try{Pa(v.start_routine,v.arg)}catch(E){if(E!="unwind")throw E}}else S==="cancel"?le()&&er(-1):v.target!=="setimmediate"&&(S==="checkMailbox"?Ae&&Ze():S&&(Z(`worker: received unknown command ${S}`),Z(v)))}catch(E){throw ga(),E}};var Ot,Ae=!1;Z=function(...b){b=b.join(" "),console.error(b)},self.alert=function(...b){postMessage({Za:"alert",text:b.join(" "),nb:le()})},r.instantiateWasm=(b,v)=>new Promise(S=>{Ot=E=>{E=new WebAssembly.Instance(E,nn()),v(E),S()}}),self.onunhandledrejection=b=>{throw b.reason||b},self.onmessage=g}r.wasmBinary&&(R=r.wasmBinary);var ft,$e,Nt,gt,U,Mt,De,vt,ae,nt=!1;function it(){var g=ft.buffer;r.HEAP8=gt=new Int8Array(g),r.HEAP16=new Int16Array(g),r.HEAPU8=U=new Uint8Array(g),r.HEAPU16=new Uint16Array(g),r.HEAP32=Mt=new Int32Array(g),r.HEAPU32=De=new Uint32Array(g),r.HEAPF32=new Float32Array(g),r.HEAPF64=ae=new Float64Array(g),r.HEAP64=vt=new BigInt64Array(g),r.HEAPU64=new BigUint64Array(g)}if(!f){if(!((ft=new WebAssembly.Memory({initial:256,maximum:65536,shared:!0})).buffer instanceof _))throw Z("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),Error("bad memory");it()}var ee=[],Wt=[],Le=[],re=0,_t=null;function Pt(){if(--re==0&&_t){var g=_t;_t=null,g()}}function Ft(g){throw Z(g="Aborted("+g+")"),nt=!0,Nt=1,g=new WebAssembly.RuntimeError(g+". Build with -sASSERTIONS for more info."),c(g),g}var et,at=g=>g.startsWith("data:application/octet-stream;base64,"),Lt=g=>g.startsWith("file://");function ue(g){if(g==et&&R)return new Uint8Array(R);if(y)return y(g);throw"both async and sync fetching of the wasm failed"}function Re(g,b,v){return function(S){if(!R&&(l||h)){if(typeof fetch=="function"&&!Lt(S))return fetch(S,{credentials:"same-origin"}).then(E=>{if(!E.ok)throw`failed to load wasm binary file at '${S}'`;return E.arrayBuffer()}).catch(()=>ue(S));if(m)return new Promise((E,$)=>{m(S,L=>E(new Uint8Array(L)),$)})}return Promise.resolve().then(()=>ue(S))}(g).then(S=>WebAssembly.instantiate(S,b)).then(v,S=>{Z(`failed to asynchronously prepare wasm: ${S}`),Ft(S)})}function nn(){return{a:{j:Ea,b:$a,E:Po,g:Do,V:ko,A:jo,C:Bo,W:zo,T:Xo,L:Ko,S:Yo,o:Jo,B:Zo,y:Qo,U:ti,z:ri,_:Da,Z:ka,P:Na,w:Fa,F:Ca,k:La,O:Ir,Y:Ra,I:ja,J:Ba,K:Ma,G:ea,H:ra,v:Va,q:za,l:Ua,p:Ga,e:Ha,X:qa,x:Wa,d:na,f:Xa,i:Ka,u:Ya,t:Ja,s:Za,Q:aa,R:sa,D:Er,h:la,n:ua,M:pa,m:da,a:ft,r:_r,N:fa,c:Ks}}}var on={837620:(g,b,v,S,E)=>{if(r===void 0||!r.Ua)return 1;if((g=fe(g>>>0)).startsWith("./")&&(g=g.substring(2)),!(g=r.Ua.get(g)))return 2;if(S>>>=0,(b>>>=0)+(v>>>=0)>g.byteLength)return 3;try{let $=g.subarray(b,b+v);switch(E){case 0:a().set($,S>>>0);break;case 1:r.mb(S,$);break;default:return 4}return 0}catch{return 4}},838303:()=>typeof wasmOffsetConverter<"u"};function Ea(){return typeof wasmOffsetConverter<"u"}function wr(g){this.name="ExitStatus",this.message=`Program terminated with exit(${g})`,this.status=g}var vr=g=>{g.terminate(),g.onmessage=()=>{}},vn=g=>{Jt.length==0&&(So(),Oo(Jt[0]));var b=Jt.pop();if(!b)return 6;oe.push(b),$t[g.Ra]=b,b.Ra=g.Ra;var v={cmd:"run",start_routine:g.cb,arg:g.ab,pthread_ptr:g.Ra};return b.postMessage(v,g.ib),0},ce=0,K=(g,b,...v)=>{for(var S=2*v.length,E=tn(),$=Qr(8*S),L=$>>>3,X=0;X<v.length;X++){var lt=v[X];typeof lt=="bigint"?(vt[L+2*X]=1n,vt[L+2*X+1]=lt):(vt[L+2*X]=0n,s()[L+2*X+1>>>0]=lt)}return g=ma(g,0,S,$,b),ar(E),g};function _r(g){if(f)return K(0,1,g);if(Nt=g,!(0<ce)){for(var b of oe)vr(b);for(b of Jt)vr(b);Jt=[],oe=[],$t=[],nt=!0}P(g,new wr(g))}function _n(g){if(f)return K(1,0,g);Er(g)}var Er=g=>{if(Nt=g,f)throw _n(g),"unwind";_r(g)},Jt=[],oe=[],On=[],$t={},In=g=>{var b=g.Ra;delete $t[b],Jt.push(g),oe.splice(oe.indexOf(g),1),g.Ra=0,Zr(b)};function _o(){On.forEach(g=>g())}var Oo=g=>new Promise(b=>{g.onmessage=E=>{var $=(E=E.data).cmd;if(E.targetThread&&E.targetThread!=le()){var L=$t[E.targetThread];L?L.postMessage(E,E.transferList):Z(`Internal error! Worker sent a message "${$}" to target pthread ${E.targetThread}, but that thread no longer exists!`)}else $==="checkMailbox"?Ze():$==="spawnThread"?vn(E):$==="cleanupThread"?In($t[E.thread]):$==="killThread"?(E=E.thread,$=$t[E],delete $t[E],vr($),Zr(E),oe.splice(oe.indexOf($),1),$.Ra=0):$==="cancelThread"?$t[E.thread].postMessage({cmd:"cancel"}):$==="loaded"?(g.loaded=!0,b(g)):$==="alert"?alert(`Thread ${E.threadId}: ${E.text}`):E.target==="setimmediate"?g.postMessage(E):$==="callHandler"?r[E.handler](...E.args):$&&Z(`worker sent an unknown command ${$}`)},g.onerror=E=>{throw Z(`worker sent an error! ${E.filename}:${E.lineno}: ${E.message}`),E};var v,S=[];for(v of[])r.hasOwnProperty(v)&&S.push(v);g.postMessage({cmd:"load",handlers:S,wasmMemory:ft,wasmModule:$e})});function So(){var g=new Worker(new URL(_documentCurrentScript&&_documentCurrentScript.tagName.toUpperCase()==="SCRIPT"&&_documentCurrentScript.src||new URL("segmentation.js",document.baseURI).href),{type:"module",workerData:"em-pthread",name:"em-pthread"});Jt.push(g)}var Eo,Ge=g=>{for(;0<g.length;)g.shift()(r)},Ia=()=>{var g=le(),b=o()[g+52>>>2>>>0];g=o()[g+56>>>2>>>0],ya(b,b-g),ar(b)},Ye=[],Pa=(g,b)=>{ce=0;var v=Ye[g];v||(g>=Ye.length&&(Ye.length=g+1),Ye[g]=v=Eo.get(g)),g=v(b),0<ce?Nt=g:er(g)};class Aa{constructor(b){this.Xa=b-24}}function $a(g,b,v){var S=new Aa(g>>>=0);throw b>>>=0,v>>>=0,o()[S.Xa+16>>>2>>>0]=0,o()[S.Xa+4>>>2>>>0]=b,o()[S.Xa+8>>>2>>>0]=v,g}function Io(g,b,v,S){return f?K(2,1,g,b,v,S):Po(g,b,v,S)}function Po(g,b,v,S){if(g>>>=0,b>>>=0,v>>>=0,S>>>=0,_===void 0)return Z("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var E=[];return f&&E.length===0?Io(g,b,v,S):(g={cb:v,Ra:g,ab:S,ib:E},f?(g.Za="spawnThread",postMessage(g,E),0):vn(g))}var Ao=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,$o=(g,b,v)=>{var S=(b>>>=0)+v;for(v=b;g[v]&&!(v>=S);)++v;if(16<v-b&&g.buffer&&Ao)return Ao.decode(g.buffer instanceof _?g.slice(b,v):g.subarray(b,v));for(S="";b<v;){var E=g[b++];if(128&E){var $=63&g[b++];if((224&E)==192)S+=String.fromCharCode((31&E)<<6|$);else{var L=63&g[b++];65536>(E=(240&E)==224?(15&E)<<12|$<<6|L:(7&E)<<18|$<<12|L<<6|63&g[b++])?S+=String.fromCharCode(E):(E-=65536,S+=String.fromCharCode(55296|E>>10,56320|1023&E))}}else S+=String.fromCharCode(E)}return S},fe=(g,b)=>(g>>>=0)?$o(a(),g,b):"";function Do(g,b,v){return f?K(3,1,g,b,v):0}function ko(g,b){if(f)return K(4,1,g,b)}var Fo=g=>{for(var b=0,v=0;v<g.length;++v){var S=g.charCodeAt(v);127>=S?b++:2047>=S?b+=2:55296<=S&&57343>=S?(b+=4,++v):b+=3}return b},Lo=(g,b,v,S)=>{if(!(0<S))return 0;var E=v>>>=0;S=v+S-1;for(var $=0;$<g.length;++$){var L=g.charCodeAt($);if(55296<=L&&57343>=L&&(L=65536+((1023&L)<<10)|1023&g.charCodeAt(++$)),127>=L){if(v>=S)break;b[v++>>>0]=L}else{if(2047>=L){if(v+1>=S)break;b[v++>>>0]=192|L>>6}else{if(65535>=L){if(v+2>=S)break;b[v++>>>0]=224|L>>12}else{if(v+3>=S)break;b[v++>>>0]=240|L>>18,b[v++>>>0]=128|L>>12&63}b[v++>>>0]=128|L>>6&63}b[v++>>>0]=128|63&L}}return b[v>>>0]=0,v-E},ge=(g,b,v)=>Lo(g,a(),b,v);function jo(g,b){if(f)return K(5,1,g,b)}function Bo(g,b,v){if(f)return K(6,1,g,b,v)}function zo(g,b,v){return f?K(7,1,g,b,v):0}function Xo(g,b){if(f)return K(8,1,g,b)}function Ko(g,b,v){if(f)return K(9,1,g,b,v)}function Yo(g,b,v,S){if(f)return K(10,1,g,b,v,S)}function Jo(g,b,v,S){if(f)return K(11,1,g,b,v,S)}function Zo(g,b,v,S){if(f)return K(12,1,g,b,v,S)}function Qo(g){if(f)return K(13,1,g)}function ti(g,b){if(f)return K(14,1,g,b)}function ri(g,b,v){if(f)return K(15,1,g,b,v)}var Da=()=>{Ft("")},ka=()=>1;function Na(g){Jr(g>>>0,!h,1,!l,131072,!1),_o()}function Ir(g){g>>>=0,typeof Atomics.jb=="function"&&(Atomics.jb(p(),g>>>2,g).value.then(Ze),g+=128,Atomics.store(p(),g>>>2,1))}var Ze=()=>{var g=le();if(g&&(Ir(g),g=ba,!nt))try{if(g(),!(0<ce))try{f?er(Nt):Er(Nt)}catch(b){b instanceof wr||b=="unwind"||P(1,b)}}catch(b){b instanceof wr||b=="unwind"||P(1,b)}};function Fa(g,b){(g>>>=0)==b>>>0?setTimeout(Ze):f?postMessage({targetThread:g,cmd:"checkMailbox"}):(g=$t[g])&&g.postMessage({cmd:"checkMailbox"})}var Dr=[];function Ca(g,b,v,S,E){for(b>>>=0,S/=2,Dr.length=S,v=E>>>0>>>3,E=0;E<S;E++)Dr[E]=vt[v+2*E]?vt[v+2*E+1]:s()[v+2*E+1>>>0];return(b?on[b]:Js[g])(...Dr)}function La(g){g>>>=0,f?postMessage({cmd:"cleanupThread",thread:g}):In($t[g])}function Ra(g){}function ja(g,b){g=-9007199254740992>g||9007199254740992<g?NaN:Number(g),b>>>=0,g=new Date(1e3*g),p()[b>>>2>>>0]=g.getUTCSeconds(),p()[b+4>>>2>>>0]=g.getUTCMinutes(),p()[b+8>>>2>>>0]=g.getUTCHours(),p()[b+12>>>2>>>0]=g.getUTCDate(),p()[b+16>>>2>>>0]=g.getUTCMonth(),p()[b+20>>>2>>>0]=g.getUTCFullYear()-1900,p()[b+24>>>2>>>0]=g.getUTCDay(),g=(g.getTime()-Date.UTC(g.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,p()[b+28>>>2>>>0]=g}var se=g=>g%4==0&&(g%100!=0||g%400==0),ni=[0,31,60,91,121,152,182,213,244,274,305,335],ii=[0,31,59,90,120,151,181,212,243,273,304,334];function Ba(g,b){g=-9007199254740992>g||9007199254740992<g?NaN:Number(g),b>>>=0,g=new Date(1e3*g),p()[b>>>2>>>0]=g.getSeconds(),p()[b+4>>>2>>>0]=g.getMinutes(),p()[b+8>>>2>>>0]=g.getHours(),p()[b+12>>>2>>>0]=g.getDate(),p()[b+16>>>2>>>0]=g.getMonth(),p()[b+20>>>2>>>0]=g.getFullYear()-1900,p()[b+24>>>2>>>0]=g.getDay();var v=(se(g.getFullYear())?ni:ii)[g.getMonth()]+g.getDate()-1|0;p()[b+28>>>2>>>0]=v,p()[b+36>>>2>>>0]=-60*g.getTimezoneOffset(),v=new Date(g.getFullYear(),6,1).getTimezoneOffset();var S=new Date(g.getFullYear(),0,1).getTimezoneOffset();g=0|(v!=S&&g.getTimezoneOffset()==Math.min(S,v)),p()[b+32>>>2>>>0]=g}function Ma(g){g>>>=0;var b=new Date(p()[g+20>>>2>>>0]+1900,p()[g+16>>>2>>>0],p()[g+12>>>2>>>0],p()[g+8>>>2>>>0],p()[g+4>>>2>>>0],p()[g>>>2>>>0],0),v=p()[g+32>>>2>>>0],S=b.getTimezoneOffset(),E=new Date(b.getFullYear(),6,1).getTimezoneOffset(),$=new Date(b.getFullYear(),0,1).getTimezoneOffset(),L=Math.min($,E);return 0>v?p()[g+32>>>2>>>0]=+(E!=$&&L==S):0<v!=(L==S)&&(E=Math.max($,E),b.setTime(b.getTime()+6e4*((0<v?L:E)-S))),p()[g+24>>>2>>>0]=b.getDay(),v=(se(b.getFullYear())?ni:ii)[b.getMonth()]+b.getDate()-1|0,p()[g+28>>>2>>>0]=v,p()[g>>>2>>>0]=b.getSeconds(),p()[g+4>>>2>>>0]=b.getMinutes(),p()[g+8>>>2>>>0]=b.getHours(),p()[g+12>>>2>>>0]=b.getDate(),p()[g+16>>>2>>>0]=b.getMonth(),p()[g+20>>>2>>>0]=b.getYear(),g=b.getTime(),BigInt(isNaN(g)?-1:g/1e3)}function ea(g,b,v,S,E,$,L){return f?K(16,1,g,b,v,S,E,$,L):-52}function ra(g,b,v,S,E,$){if(f)return K(17,1,g,b,v,S,E,$)}function Va(g,b,v,S){g>>>=0,b>>>=0,v>>>=0,S>>>=0;var E=new Date().getFullYear(),$=new Date(E,0,1),L=new Date(E,6,1);E=$.getTimezoneOffset();var X=L.getTimezoneOffset(),lt=Math.max(E,X);o()[g>>>2>>>0]=60*lt,p()[b>>>2>>>0]=+(E!=X),$=(g=pt=>pt.toLocaleTimeString(void 0,{hour12:!1,timeZoneName:"short"}).split(" ")[1])($),L=g(L),X<E?(ge($,v,17),ge(L,S,17)):(ge($,S,17),ge(L,v,17))}var Lr=[];function za(g,b,v){g>>>=0,b>>>=0,v>>>=0,Lr.length=0;for(var S;S=a()[b++>>>0];){var E=S!=105;v+=(E&=S!=112)&&v%8?4:0,Lr.push(S==112?o()[v>>>2>>>0]:S==106?vt[v>>>3]:S==105?p()[v>>>2>>>0]:s()[v>>>3>>>0]),v+=E?8:4}return on[g](...Lr)}var Ua=()=>{},Ga=()=>Date.now();function Ha(g,b){return Z(fe(g>>>0,b>>>0))}var na,qa=()=>{throw ce+=1,"unwind"};function Wa(){return 4294901760}na=()=>performance.timeOrigin+performance.now();var Xa=()=>navigator.hardwareConcurrency;function Ka(){return Ft("Cannot use emscripten_pc_get_function without -sUSE_OFFSET_CONVERTER"),0}function Ya(g){g>>>=0;var b=a().length;if(g<=b||4294901760<g)return!1;for(var v=1;4>=v;v*=2){var S=b*(1+.2/v);S=Math.min(S,g+100663296);var E=Math;S=Math.max(g,S);t:{E=(E.min.call(E,4294901760,S+(65536-S%65536)%65536)-ft.buffer.byteLength+65535)/65536;try{ft.grow(E),it();var $=1;break t}catch{}$=void 0}if($)return!0}return!1}var Qe=()=>(Ft("Cannot use convertFrameToPC (needed by __builtin_return_address) without -sUSE_OFFSET_CONVERTER"),0),be={},oa=g=>{g.forEach(b=>{Qe()})};function Ja(){var g=Error().stack.toString().split(`
`);return g[0]=="Error"&&g.shift(),oa(g),be.$a=Qe(),be.bb=g,be.$a}function Za(g,b,v){if(g>>>=0,b>>>=0,be.$a==g)var S=be.bb;else(S=Error().stack.toString().split(`
`))[0]=="Error"&&S.shift(),oa(S);for(var E=3;S[E]&&Qe()!=g;)++E;for(g=0;g<v&&S[g+E];++g)p()[b+4*g>>>2>>>0]=Qe();return g}var Kr,Yr={},ia=()=>{if(!Kr){var g,b={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:x};for(g in Yr)Yr[g]===void 0?delete b[g]:b[g]=Yr[g];var v=[];for(g in b)v.push(`${g}=${b[g]}`);Kr=v}return Kr};function aa(g,b){if(f)return K(18,1,g,b);g>>>=0,b>>>=0;var v=0;return ia().forEach((S,E)=>{var $=b+v;for(E=o()[g+4*E>>>2>>>0]=$,$=0;$<S.length;++$)i()[E++>>>0]=S.charCodeAt($);i()[E>>>0]=0,v+=S.length+1}),0}function sa(g,b){if(f)return K(19,1,g,b);g>>>=0,b>>>=0;var v=ia();o()[g>>>2>>>0]=v.length;var S=0;return v.forEach(E=>S+=E.length+1),o()[b>>>2>>>0]=S,0}function la(g){return f?K(20,1,g):52}function ua(g,b,v,S){return f?K(21,1,g,b,v,S):52}function pa(g,b,v,S){return f?K(22,1,g,b,v,S):70}var qs=[null,[],[]];function da(g,b,v,S){if(f)return K(23,1,g,b,v,S);b>>>=0,v>>>=0,S>>>=0;for(var E=0,$=0;$<v;$++){var L=o()[b>>>2>>>0],X=o()[b+4>>>2>>>0];b+=8;for(var lt=0;lt<X;lt++){var pt=a()[L+lt>>>0],wt=qs[g];pt===0||pt===10?((g===1?Dt:Z)($o(wt,0)),wt.length=0):wt.push(pt)}E+=X}return o()[S>>>2>>>0]=E,0}var ca=[31,29,31,30,31,30,31,31,30,31,30,31],ha=[31,28,31,30,31,30,31,31,30,31,30,31],Xs=(g,b)=>{i().set(g,b>>>0)};function fa(g,b,v,S){function E(A,V,Q){for(A=typeof A=="number"?A.toString():A||"";A.length<V;)A=Q[0]+A;return A}function $(A,V){return E(A,V,"0")}function L(A,V){function Q(Ta){return 0>Ta?-1:0<Ta?1:0}var ie;return(ie=Q(A.getFullYear()-V.getFullYear()))===0&&(ie=Q(A.getMonth()-V.getMonth()))===0&&(ie=Q(A.getDate()-V.getDate())),ie}function X(A){switch(A.getDay()){case 0:return new Date(A.getFullYear()-1,11,29);case 1:return A;case 2:return new Date(A.getFullYear(),0,3);case 3:return new Date(A.getFullYear(),0,2);case 4:return new Date(A.getFullYear(),0,1);case 5:return new Date(A.getFullYear()-1,11,31);case 6:return new Date(A.getFullYear()-1,11,30)}}function lt(A){var V=A.Sa;for(A=new Date(new Date(A.Ta+1900,0,1).getTime());0<V;){var Q=A.getMonth(),ie=(se(A.getFullYear())?ca:ha)[Q];if(!(V>ie-A.getDate())){A.setDate(A.getDate()+V);break}V-=ie-A.getDate()+1,A.setDate(1),11>Q?A.setMonth(Q+1):(A.setMonth(0),A.setFullYear(A.getFullYear()+1))}return Q=new Date(A.getFullYear()+1,0,4),V=X(new Date(A.getFullYear(),0,4)),Q=X(Q),0>=L(V,A)?0>=L(Q,A)?A.getFullYear()+1:A.getFullYear():A.getFullYear()-1}g>>>=0,b>>>=0,v>>>=0,S>>>=0;var pt=o()[S+40>>>2>>>0];for(var wt in S={gb:p()[S>>>2>>>0],fb:p()[S+4>>>2>>>0],Va:p()[S+8>>>2>>>0],Ya:p()[S+12>>>2>>>0],Wa:p()[S+16>>>2>>>0],Ta:p()[S+20>>>2>>>0],Qa:p()[S+24>>>2>>>0],Sa:p()[S+28>>>2>>>0],ob:p()[S+32>>>2>>>0],eb:p()[S+36>>>2>>>0],hb:pt?fe(pt):""},v=fe(v),pt={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})v=v.replace(new RegExp(wt,"g"),pt[wt]);var va="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),xa="January February March April May June July August September October November December".split(" ");for(wt in pt={"%a":A=>va[A.Qa].substring(0,3),"%A":A=>va[A.Qa],"%b":A=>xa[A.Wa].substring(0,3),"%B":A=>xa[A.Wa],"%C":A=>$((A.Ta+1900)/100|0,2),"%d":A=>$(A.Ya,2),"%e":A=>E(A.Ya,2," "),"%g":A=>lt(A).toString().substring(2),"%G":lt,"%H":A=>$(A.Va,2),"%I":A=>((A=A.Va)==0?A=12:12<A&&(A-=12),$(A,2)),"%j":A=>{for(var V=0,Q=0;Q<=A.Wa-1;V+=(se(A.Ta+1900)?ca:ha)[Q++]);return $(A.Ya+V,3)},"%m":A=>$(A.Wa+1,2),"%M":A=>$(A.fb,2),"%n":()=>`
`,"%p":A=>0<=A.Va&&12>A.Va?"AM":"PM","%S":A=>$(A.gb,2),"%t":()=>"	","%u":A=>A.Qa||7,"%U":A=>$(Math.floor((A.Sa+7-A.Qa)/7),2),"%V":A=>{var V=Math.floor((A.Sa+7-(A.Qa+6)%7)/7);if(2>=(A.Qa+371-A.Sa-2)%7&&V++,V)V==53&&((Q=(A.Qa+371-A.Sa)%7)==4||Q==3&&se(A.Ta)||(V=1));else{V=52;var Q=(A.Qa+7-A.Sa-1)%7;(Q==4||Q==5&&se(A.Ta%400-1))&&V++}return $(V,2)},"%w":A=>A.Qa,"%W":A=>$(Math.floor((A.Sa+7-(A.Qa+6)%7)/7),2),"%y":A=>(A.Ta+1900).toString().substring(2),"%Y":A=>A.Ta+1900,"%z":A=>{var V=0<=(A=A.eb);return A=Math.abs(A)/60,(V?"+":"-")+("0000"+(A/60*100+A%60)).slice(-4)},"%Z":A=>A.hb,"%%":()=>"%"},v=v.replace(/%%/g,"\0\0"),pt)v.includes(wt)&&(v=v.replace(new RegExp(wt,"g"),pt[wt](S)));return wt=function(A){var V=Array(Fo(A)+1);return Lo(A,V,0,V.length),V}(v=v.replace(/\0\0/g,"%")),wt.length>b?0:(Xs(wt,g),wt.length-1)}function Ks(g,b,v,S){return fa(g>>>0,b>>>0,v>>>0,S>>>0)}f||function(){for(var g=r.numThreads-1;g--;)So();ee.unshift(()=>{re++,function(b){f?b():Promise.all(Jt.map(Oo)).then(b)}(()=>Pt())})}();var Js=[_r,_n,Io,Do,ko,jo,Bo,zo,Xo,Ko,Yo,Jo,Zo,Qo,ti,ri,ea,ra,aa,sa,la,ua,pa,da],M=function(){function g(v,S){return M=v.exports,M=function(){var E=M,$=X=>()=>X()>>>0,L=X=>lt=>X(lt)>>>0;return(E=Object.assign({},E)).Ba=$(E.Ba),E.Ca=L(E.Ca),E.emscripten_main_runtime_thread_id=$(E.emscripten_main_runtime_thread_id),E.Oa=L(E.Oa),E.Pa=$(E.Pa),E}(),On.push(M.Ea),Eo=M.Fa,Wt.unshift(M.$),$e=S,Pt(),M}var b=nn();if(re++,r.instantiateWasm)try{return r.instantiateWasm(b,g)}catch(v){Z(`Module.instantiateWasm callback failed with error: ${v}`),c(v)}return et||(et=r.locateFile?at("ort-wasm-simd-threaded.wasm")?"ort-wasm-simd-threaded.wasm":r.locateFile?r.locateFile("ort-wasm-simd-threaded.wasm",N):N+"ort-wasm-simd-threaded.wasm":""),function(v,S){var E=et;return R||typeof WebAssembly.instantiateStreaming!="function"||at(E)||Lt(E)||typeof fetch!="function"?Re(E,v,S):fetch(E,{credentials:"same-origin"}).then($=>WebAssembly.instantiateStreaming($,v).then(S,function(L){return Z(`wasm streaming compile failed: ${L}`),Z("falling back to ArrayBuffer instantiation"),Re(E,v,S)}))}(b,function(v){g(v.instance,v.module)}).catch(c),{}}();r._OrtInit=(g,b)=>(r._OrtInit=M.aa)(g,b),r._OrtGetLastError=(g,b)=>(r._OrtGetLastError=M.ba)(g,b),r._OrtCreateSessionOptions=(g,b,v,S,E,$,L,X,lt,pt)=>(r._OrtCreateSessionOptions=M.ca)(g,b,v,S,E,$,L,X,lt,pt),r._OrtAppendExecutionProvider=(g,b)=>(r._OrtAppendExecutionProvider=M.da)(g,b),r._OrtAddFreeDimensionOverride=(g,b,v)=>(r._OrtAddFreeDimensionOverride=M.ea)(g,b,v),r._OrtAddSessionConfigEntry=(g,b,v)=>(r._OrtAddSessionConfigEntry=M.fa)(g,b,v),r._OrtReleaseSessionOptions=g=>(r._OrtReleaseSessionOptions=M.ga)(g),r._OrtCreateSession=(g,b,v)=>(r._OrtCreateSession=M.ha)(g,b,v),r._OrtReleaseSession=g=>(r._OrtReleaseSession=M.ia)(g),r._OrtGetInputOutputCount=(g,b,v)=>(r._OrtGetInputOutputCount=M.ja)(g,b,v),r._OrtGetInputName=(g,b)=>(r._OrtGetInputName=M.ka)(g,b),r._OrtGetOutputName=(g,b)=>(r._OrtGetOutputName=M.la)(g,b),r._OrtFree=g=>(r._OrtFree=M.ma)(g),r._OrtCreateTensor=(g,b,v,S,E,$)=>(r._OrtCreateTensor=M.na)(g,b,v,S,E,$),r._OrtGetTensorData=(g,b,v,S,E)=>(r._OrtGetTensorData=M.oa)(g,b,v,S,E),r._OrtReleaseTensor=g=>(r._OrtReleaseTensor=M.pa)(g),r._OrtCreateRunOptions=(g,b,v,S)=>(r._OrtCreateRunOptions=M.qa)(g,b,v,S),r._OrtAddRunConfigEntry=(g,b,v)=>(r._OrtAddRunConfigEntry=M.ra)(g,b,v),r._OrtReleaseRunOptions=g=>(r._OrtReleaseRunOptions=M.sa)(g),r._OrtCreateBinding=g=>(r._OrtCreateBinding=M.ta)(g),r._OrtBindInput=(g,b,v)=>(r._OrtBindInput=M.ua)(g,b,v),r._OrtBindOutput=(g,b,v,S)=>(r._OrtBindOutput=M.va)(g,b,v,S),r._OrtClearBoundOutputs=g=>(r._OrtClearBoundOutputs=M.wa)(g),r._OrtReleaseBinding=g=>(r._OrtReleaseBinding=M.xa)(g),r._OrtRunWithBinding=(g,b,v,S,E)=>(r._OrtRunWithBinding=M.ya)(g,b,v,S,E),r._OrtRun=(g,b,v,S,E,$,L,X)=>(r._OrtRun=M.za)(g,b,v,S,E,$,L,X),r._OrtEndProfiling=g=>(r._OrtEndProfiling=M.Aa)(g);var le=()=>(le=M.Ba)();r._malloc=g=>(r._malloc=M.Ca)(g),r._free=g=>(r._free=M.Da)(g);var tr,Jr=(g,b,v,S,E,$)=>(Jr=M.Ga)(g,b,v,S,E,$),ga=()=>(ga=M.Ha)(),ma=(g,b,v,S,E)=>(ma=M.Ia)(g,b,v,S,E),Zr=g=>(Zr=M.Ja)(g),er=g=>(er=M.Ka)(g),ba=()=>(ba=M.La)(),ya=(g,b)=>(ya=M.Ma)(g,b),ar=g=>(ar=M.Na)(g),Qr=g=>(Qr=M.Oa)(g),tn=()=>(tn=M.Pa)();function wa(){0<re||(f?(d(r),f||Ge(Wt),startWorker(r)):(Ge(ee),0<re||tr||(tr=!0,r.calledRun=!0,nt||(f||Ge(Wt),d(r),f||Ge(Le)))))}return r.___start_em_js=838360,r.___stop_em_js=838421,r.stackSave=()=>tn(),r.stackRestore=g=>ar(g),r.stackAlloc=g=>Qr(g),r.UTF8ToString=fe,r.stringToUTF8=ge,r.lengthBytesUTF8=Fo,_t=function g(){tr||wa(),tr||(_t=g)},wa(),u}),Og=Mp,((e=globalThis.self)==null?void 0:e.name)==="em-pthread"&&Mp()}),br,Sg,Ag,Pg,zp,Wp,Eg,Hp,Vr=O(()=>{var e,n;oo(),br=(_documentCurrentScript&&_documentCurrentScript.tagName.toUpperCase()==="SCRIPT"&&_documentCurrentScript.src||new URL("segmentation.js",document.baseURI).href)??(typeof document<"u"?(e=document.currentScript)==null?void 0:e.src:typeof self<"u"?(n=self.location)==null?void 0:n.href:void 0),Sg=typeof location>"u"?void 0:location.origin,Ag=(i,a)=>{try{let p=a??br;return(p?new URL(i,p):new URL(i)).origin===Sg}catch{return!1}},Pg=async i=>{let a=await(await fetch(i,{credentials:"same-origin"})).blob();return URL.createObjectURL(a)},zp=(Gp(),sn(Rp)).default,Wp=async()=>{if(!br)throw new Error("Failed to load proxy worker: cannot determine the script source URL.");if(Ag(br))return[void 0,zp()];let i=await Pg(br);return[i,zp(i)]},Eg=(Vp(),sn(Up)).default,Hp=async(i,a,p)=>[void 0,Eg]}),Xi,Ki,ho,qp,Dg,Lg,io,xt,Ke=O(()=>{Vr(),Ki=!1,ho=!1,qp=!1,Dg=()=>{if(typeof SharedArrayBuffer>"u")return!1;try{return typeof MessageChannel<"u"&&new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11]))}catch{return!1}},Lg=()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch{return!1}},io=async e=>{if(Ki)return Promise.resolve();if(ho)throw new Error("multiple calls to 'initializeWebAssembly()' detected.");if(qp)throw new Error("previous call to 'initializeWebAssembly()' failed.");ho=!0;let n=e.initTimeout,i=e.numThreads;if(!Lg())throw new Error("WebAssembly SIMD is not supported in the current environment.");let a=Dg();i>1&&!a&&(typeof self<"u"&&!self.crossOriginIsolated&&console.warn("env.wasm.numThreads is set to "+i+", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."),console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."),e.numThreads=i=1);let p=e.wasmPaths,o=typeof p=="string"?p:void 0,s=p==null?void 0:p.mjs,d=(s==null?void 0:s.href)??s,c=p==null?void 0:p.wasm,r=(c==null?void 0:c.href)??c,u=e.wasmBinary,[l,h]=await Hp(d,o,i>1),f=!1,m=[];if(n>0&&m.push(new Promise(y=>{setTimeout(()=>{f=!0,y()},n)})),m.push(new Promise((y,_)=>{let I={numThreads:i};u?I.wasmBinary=u:(r||o)&&(I.locateFile=(x,P)=>r??(o??P)+x),h(I).then(x=>{ho=!1,Ki=!0,Xi=x,y(),l&&URL.revokeObjectURL(l)},x=>{ho=!1,qp=!0,_(x)})})),await Promise.race(m),f)throw new Error(`WebAssembly backend initializing failed due to timeout: ${n}ms`)},xt=()=>{if(Ki&&Xi)return Xi;throw new Error("WebAssembly is not initialized yet.")}}),Tt,Wr,ht,mo=O(()=>{Ke(),Tt=(e,n)=>{let i=xt(),a=i.lengthBytesUTF8(e)+1,p=i._malloc(a);return i.stringToUTF8(e,p,a),n.push(p),p},Wr=(e,n,i,a)=>{if(typeof e=="object"&&e!==null){if(i.has(e))throw new Error("Circular reference in options");i.add(e)}Object.entries(e).forEach(([p,o])=>{let s=n?n+p:p;if(typeof o=="object")Wr(o,s+".",i,a);else if(typeof o=="string"||typeof o=="number")a(s,o.toString());else if(typeof o=="boolean")a(s,o?"1":"0");else throw new Error(`Can't handle extra config type: ${typeof o}`)})},ht=e=>{let n=xt(),i=n.stackSave();try{let a=n.stackAlloc(8);n._OrtGetLastError(a,a+4);let p=n.HEAP32[a/4],o=n.HEAPU32[a/4+1],s=o?n.UTF8ToString(o):"";throw new Error(`${e} ERROR_CODE: ${p}, ERROR_MESSAGE: ${s}`)}finally{n.stackRestore(i)}}}),jp,Xp=O(()=>{Ke(),mo(),jp=e=>{let n=xt(),i=0,a=[],p=e||{};try{if((e==null?void 0:e.logSeverityLevel)===void 0)p.logSeverityLevel=2;else if(typeof e.logSeverityLevel!="number"||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if((e==null?void 0:e.logVerbosityLevel)===void 0)p.logVerbosityLevel=0;else if(typeof e.logVerbosityLevel!="number"||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);(e==null?void 0:e.terminate)===void 0&&(p.terminate=!1);let o=0;return(e==null?void 0:e.tag)!==void 0&&(o=Tt(e.tag,a)),i=n._OrtCreateRunOptions(p.logSeverityLevel,p.logVerbosityLevel,!!p.terminate,o),i===0&&ht("Can't create run options."),(e==null?void 0:e.extra)!==void 0&&Wr(e.extra,"",new WeakSet,(s,d)=>{let c=Tt(s,a),r=Tt(d,a);n._OrtAddRunConfigEntry(i,c,r)!==0&&ht(`Can't set a run config entry: ${s} - ${d}.`)}),[i,a]}catch(o){throw i!==0&&n._OrtReleaseRunOptions(i),a.forEach(s=>n._free(s)),o}}}),$g,kg,Bg,Fg,Kp,Jp=O(()=>{Ke(),mo(),$g=e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}},kg=e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}},Bg=e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});let n=e.extra.session;n.use_ort_model_bytes_directly||(n.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some(i=>(typeof i=="string"?i:i.name)==="webgpu")&&(e.enableMemPattern=!1)},Fg=(e,n,i)=>{for(let a of n){let p=typeof a=="string"?a:a.name;switch(p){case"webnn":if(p="WEBNN",typeof a!="string"){let s=a==null?void 0:a.deviceType;if(s){let d=Tt("deviceType",i),c=Tt(s,i);xt()._OrtAddSessionConfigEntry(e,d,c)!==0&&ht(`Can't set a session config entry: 'deviceType' - ${s}.`)}}break;case"webgpu":if(p="JS",typeof a!="string"){let s=a;if(s!=null&&s.preferredLayout){if(s.preferredLayout!=="NCHW"&&s.preferredLayout!=="NHWC")throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${s.preferredLayout}`);let d=Tt("preferredLayout",i),c=Tt(s.preferredLayout,i);xt()._OrtAddSessionConfigEntry(e,d,c)!==0&&ht(`Can't set a session config entry: 'preferredLayout' - ${s.preferredLayout}.`)}}break;case"wasm":case"cpu":continue;default:throw new Error(`not supported execution provider: ${p}`)}let o=Tt(p,i);xt()._OrtAppendExecutionProvider(e,o)!==0&&ht(`Can't append execution provider: ${p}.`)}},Kp=e=>{let n=xt(),i=0,a=[],p=e||{};Bg(p);try{let o=$g(p.graphOptimizationLevel??"all"),s=kg(p.executionMode??"sequential"),d=typeof p.logId=="string"?Tt(p.logId,a):0,c=p.logSeverityLevel??2;if(!Number.isInteger(c)||c<0||c>4)throw new Error(`log serverity level is not valid: ${c}`);let r=p.logVerbosityLevel??0;if(!Number.isInteger(r)||r<0||r>4)throw new Error(`log verbosity level is not valid: ${r}`);let u=typeof p.optimizedModelFilePath=="string"?Tt(p.optimizedModelFilePath,a):0;if(i=n._OrtCreateSessionOptions(o,!!p.enableCpuMemArena,!!p.enableMemPattern,s,!!p.enableProfiling,0,d,c,r,u),i===0&&ht("Can't create session options."),p.executionProviders&&Fg(i,p.executionProviders,a),p.enableGraphCapture!==void 0){if(typeof p.enableGraphCapture!="boolean")throw new Error(`enableGraphCapture must be a boolean value: ${p.enableGraphCapture}`);let l=Tt("enableGraphCapture",a),h=Tt(p.enableGraphCapture.toString(),a);n._OrtAddSessionConfigEntry(i,l,h)!==0&&ht(`Can't set a session config entry: 'enableGraphCapture' - ${p.enableGraphCapture}.`)}if(p.freeDimensionOverrides)for(let[l,h]of Object.entries(p.freeDimensionOverrides)){if(typeof l!="string")throw new Error(`free dimension override name must be a string: ${l}`);if(typeof h!="number"||!Number.isInteger(h)||h<0)throw new Error(`free dimension override value must be a non-negative integer: ${h}`);let f=Tt(l,a);n._OrtAddFreeDimensionOverride(i,f,h)!==0&&ht(`Can't set a free dimension override: ${l} - ${h}.`)}return p.extra!==void 0&&Wr(p.extra,"",new WeakSet,(l,h)=>{let f=Tt(l,a),m=Tt(h,a);n._OrtAddSessionConfigEntry(i,f,m)!==0&&ht(`Can't set a session config entry: ${l} - ${h}.`)}),[i,a]}catch(o){throw i!==0&&n._OrtReleaseSessionOptions(i),a.forEach(s=>n._free(s)),o}}}),Hr,Yp,qr,Zp,Qp,bo,go,td,Ji=O(()=>{Hr=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float16":return 10;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;case"int4":return 22;case"uint4":return 21;default:throw new Error(`unsupported data type: ${e}`)}},Yp=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 10:return"float16";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";case 22:return"int4";case 21:return"uint4";default:throw new Error(`unsupported data type: ${e}`)}},qr=(e,n)=>{let i=[-1,4,1,1,2,2,4,8,-1,1,2,8,4,8,-1,-1,-1,-1,-1,-1,-1,.5,.5][e],a=typeof n=="number"?n:n.reduce((p,o)=>p*o,1);return i>0?Math.ceil(a*i):void 0},Zp=e=>{switch(e){case"float16":return typeof Float16Array<"u"&&Float16Array.from?Float16Array:Uint16Array;case"float32":return Float32Array;case"uint8":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"bool":return Uint8Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},Qp=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}},bo=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint8"||e==="bool"||e==="uint4"||e==="int4",go=e=>e==="float32"||e==="float16"||e==="int32"||e==="int64"||e==="uint32"||e==="uint64"||e==="int8"||e==="uint8"||e==="bool",td=e=>{switch(e){case"none":return 0;case"cpu":return 1;case"cpu-pinned":return 2;case"texture":return 3;case"gpu-buffer":return 4;case"ml-tensor":return 5;default:throw new Error(`unsupported data location: ${e}`)}}}),jr,Yi=O(()=>{oo(),jr=async e=>{if(typeof e=="string"){let n=await fetch(e);if(!n.ok)throw new Error(`failed to load external data file: ${e}`);let i=n.headers.get("Content-Length"),a=i?parseInt(i,10):0;if(a<1073741824)return new Uint8Array(await n.arrayBuffer());{if(!n.body)throw new Error(`failed to load external data file: ${e}, no response body.`);let p=n.body.getReader(),o;try{o=new ArrayBuffer(a)}catch(d){if(d instanceof RangeError){let c=Math.ceil(a/65536);o=new WebAssembly.Memory({initial:c,maximum:c}).buffer}else throw d}let s=0;for(;;){let{done:d,value:c}=await p.read();if(d)break;let r=c.byteLength;new Uint8Array(o,s,r).set(c),s+=r}return new Uint8Array(o,0,a)}}else return e instanceof Blob?new Uint8Array(await e.arrayBuffer()):e instanceof Uint8Array?e:new Uint8Array(e)}}),Cg,ao,so,yr,Ng,zr,uo,lo,ed,fo,co,po,qi=O(()=>{Xp(),Jp(),Ji(),Ke(),mo(),Yi(),Cg=(e,n)=>{xt()._OrtInit(e,n)!==0&&ht("Can't initialize onnxruntime.")},ao=async e=>{Cg(e.wasm.numThreads,Qp(e.logLevel))},so=async(e,n)=>{},yr=new Map,Ng=e=>{let n=xt(),i=n.stackSave();try{let a=n.stackAlloc(8);return n._OrtGetInputOutputCount(e,a,a+4)!==0&&ht("Can't get session input/output count."),[n.HEAP32[a/4],n.HEAP32[a/4+1]]}finally{n.stackRestore(i)}},zr=e=>{let n=xt(),i=n._malloc(e.byteLength);if(i===0)throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);return n.HEAPU8.set(e,i),[i,e.byteLength]},uo=async(e,n)=>{var u;let i,a,p=xt();Array.isArray(e)?[i,a]=e:e.buffer===p.HEAPU8.buffer?[i,a]=[e.byteOffset,e.byteLength]:[i,a]=zr(e);let o=0,s=0,d=[],c=[],r=[];try{if([s,d]=Kp(n),(n==null?void 0:n.externalData)&&p.mountExternalData){let x=[];for(let P of n.externalData){let N=typeof P=="string"?P:P.path;x.push(jr(typeof P=="string"?P:P.data).then(R=>{p.mountExternalData(N,R)}))}await Promise.all(x)}for(let x of(n==null?void 0:n.executionProviders)??[])if((typeof x=="string"?x:x.name)==="webnn"){if(p.shouldTransferToMLTensor=!1,p.currentContext)throw new Error("WebNN execution provider is already set.");if(typeof x!="string"){let P=x,N=P==null?void 0:P.context,R=P==null?void 0:P.gpuDevice,ct=P==null?void 0:P.deviceType,st=P==null?void 0:P.numThreads,Dt=P==null?void 0:P.powerPreference;N?p.currentContext=N:R?p.currentContext=await navigator.ml.createContext(R):p.currentContext=await navigator.ml.createContext({deviceType:ct,numThreads:st,powerPreference:Dt})}else p.currentContext=await navigator.ml.createContext();break}o=await p._OrtCreateSession(i,a,s),o===0&&ht("Can't create a session."),p.currentContext&&(p.jsepRegisterMLContext(o,p.currentContext),p.currentContext=void 0,p.shouldTransferToMLTensor=!0);let[l,h]=Ng(o),f=!!(n!=null&&n.enableGraphCapture),m=[],y=[],_=[];for(let x=0;x<l;x++){let P=p._OrtGetInputName(o,x);P===0&&ht("Can't get an input name."),c.push(P),m.push(p.UTF8ToString(P))}for(let x=0;x<h;x++){let P=p._OrtGetOutputName(o,x);P===0&&ht("Can't get an output name."),r.push(P);let N=p.UTF8ToString(P);y.push(N)}return yr.set(o,[o,c,r,null,f,!1]),[o,m,y]}catch(l){throw c.forEach(h=>p._OrtFree(h)),r.forEach(h=>p._OrtFree(h)),o!==0&&p._OrtReleaseSession(o),l}finally{p._free(i),s!==0&&p._OrtReleaseSessionOptions(s),d.forEach(l=>p._free(l)),(u=p.unmountExternalData)==null||u.call(p)}},lo=e=>{var c;let n=xt(),i=yr.get(e);if(!i)throw new Error(`cannot release session. invalid session id: ${e}`);let[a,p,o,s,d]=i;s&&(d&&n._OrtClearBoundOutputs(s.handle),n._OrtReleaseBinding(s.handle)),(c=n.jsepOnReleaseSession)==null||c.call(n,e),p.forEach(r=>n._OrtFree(r)),o.forEach(r=>n._OrtFree(r)),n._OrtReleaseSession(a),yr.delete(e)},ed=(e,n,i,a,p,o=!1)=>{if(!e){n.push(0);return}let s=xt(),d=e[0],c=e[1],r=e[3],u,l;if(d==="string"&&(r==="gpu-buffer"||r==="ml-tensor"))throw new Error("String tensor is not supported on GPU.");if(o&&r!=="gpu-buffer")throw new Error(`External buffer must be provided for input/output index ${p} when enableGraphCapture is true.`);if(r==="gpu-buffer"){let m=e[2].gpuBuffer;l=qr(Hr(d),c);let y=s.jsepRegisterBuffer;if(!y)throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');u=y(a,p,m,l)}else if(r==="ml-tensor"){let m=e[2].mlTensor;l=qr(Hr(d),c);let y=s.jsepRegisterMLTensor;if(!y)throw new Error('Tensor location "ml-tensor" is not supported without using WebNN.');u=y(m,Hr(d),c)}else{let m=e[2];if(Array.isArray(m)){l=4*m.length,u=s._malloc(l),i.push(u);let y=u/4;for(let _=0;_<m.length;_++){if(typeof m[_]!="string")throw new TypeError(`tensor data at index ${_} is not a string`);s.HEAPU32[y++]=Tt(m[_],i)}}else l=m.byteLength,u=s._malloc(l),i.push(u),s.HEAPU8.set(new Uint8Array(m.buffer,m.byteOffset,l),u)}let h=s.stackSave(),f=s.stackAlloc(4*c.length);try{let m=f/4;c.forEach(_=>s.HEAP32[m++]=_);let y=s._OrtCreateTensor(Hr(d),u,l,f,c.length,td(r));y===0&&ht(`Can't create tensor for input/output. session=${a}, index=${p}.`),n.push(y)}finally{s.stackRestore(h)}},fo=async(e,n,i,a,p,o)=>{var Z;let s=xt(),d=yr.get(e);if(!d)throw new Error(`cannot run inference. invalid session id: ${e}`);let c=d[0],r=d[1],u=d[2],l=d[3],h=d[4];d[5];let f=n.length,m=a.length,y=0,_=[],I=[],x=[],P=[],N=s.stackSave(),R=s.stackAlloc(f*4),ct=s.stackAlloc(f*4),st=s.stackAlloc(m*4),Dt=s.stackAlloc(m*4);try{(Z=s.jsepOnRunStart)==null||Z.call(s,c),[y,_]=jp(o);for(let U=0;U<f;U++)ed(i[U],I,P,e,n[U],h);for(let U=0;U<m;U++)ed(p[U],x,P,e,f+a[U],h);let Ot=R/4,Ae=ct/4,ft=st/4,$e=Dt/4;for(let U=0;U<f;U++)s.HEAPU32[Ot++]=I[U],s.HEAPU32[Ae++]=r[n[U]];for(let U=0;U<m;U++)s.HEAPU32[ft++]=x[U],s.HEAPU32[$e++]=u[a[U]];let Nt;Nt=await s._OrtRun(c,ct,R,f,Dt,m,st,y),Nt!==0&&ht("failed to call OrtRun().");let gt=[];for(let U=0;U<m;U++){let Mt=s.HEAPU32[st/4+U];if(Mt===x[U]){gt.push(p[U]);continue}let De=s.stackSave(),vt=s.stackAlloc(4*4),ae=!1,nt,it=0;try{s._OrtGetTensorData(Mt,vt,vt+4,vt+8,vt+12)!==0&&ht(`Can't access output tensor data on index ${U}.`);let ee=vt/4,Wt=s.HEAPU32[ee++];it=s.HEAPU32[ee++];let Le=s.HEAPU32[ee++],re=s.HEAPU32[ee++],_t=[];for(let et=0;et<re;et++)_t.push(s.HEAPU32[Le/4+et]);s._OrtFree(Le);let Pt=_t.reduce((et,at)=>et*at,1);nt=Yp(Wt);let Ft=l==null?void 0:l.outputPreferredLocations[a[U]];if(nt==="string"){if(Ft==="gpu-buffer"||Ft==="ml-tensor")throw new Error("String tensor is not supported on GPU.");let et=[],at=it/4;for(let Lt=0;Lt<Pt;Lt++){let ue=s.HEAPU32[at++],Re=Lt===Pt-1?void 0:s.HEAPU32[at]-ue;et.push(s.UTF8ToString(ue,Re))}gt.push([nt,_t,et,"cpu"])}else if(Ft==="gpu-buffer"&&Pt>0){let et=s.jsepGetBuffer;if(!et)throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');let at=et(it),Lt=qr(Wt,Pt);if(Lt===void 0||!bo(nt))throw new Error(`Unsupported data type: ${nt}`);ae=!0,gt.push([nt,_t,{gpuBuffer:at,download:s.jsepCreateDownloader(at,Lt,nt),dispose:()=>{s._OrtReleaseTensor(Mt)}},"gpu-buffer"])}else if(Ft==="ml-tensor"&&Pt>0){let et=s.jsepEnsureTensor;if(!et)throw new Error('preferredLocation "ml-tensor" is not supported without using WebNN.');if(qr(Wt,Pt)===void 0||!go(nt))throw new Error(`Unsupported data type: ${nt}`);let at=await et(it,Wt,_t,!1);ae=!0,gt.push([nt,_t,{mlTensor:at,download:s.jsepCreateMLTensorDownloader(it,nt),dispose:()=>{s.jsepReleaseTensorId(it),s._OrtReleaseTensor(Mt)}},"ml-tensor"])}else{let et=Zp(nt),at=new et(Pt);new Uint8Array(at.buffer,at.byteOffset,at.byteLength).set(s.HEAPU8.subarray(it,it+at.byteLength)),gt.push([nt,_t,at,"cpu"])}}finally{s.stackRestore(De),nt==="string"&&it&&s._free(it),ae||s._OrtReleaseTensor(Mt)}}return l&&!h&&(s._OrtClearBoundOutputs(l.handle),yr.set(e,[c,r,u,l,h,!1])),gt}finally{s.stackRestore(N),I.forEach(Ot=>s._OrtReleaseTensor(Ot)),x.forEach(Ot=>s._OrtReleaseTensor(Ot)),P.forEach(Ot=>s._free(Ot)),y!==0&&s._OrtReleaseRunOptions(y),_.forEach(Ot=>s._free(Ot))}},co=e=>{let n=xt(),i=yr.get(e);if(!i)throw new Error("invalid session id");let a=i[0],p=n._OrtEndProfiling(a);p===0&&ht("Can't get an profile file name."),n._OrtFree(p)},po=e=>{let n=[];for(let i of e){let a=i[2];!Array.isArray(a)&&"buffer"in a&&n.push(a.buffer)}return n}}),Je,Kt,Xr,xo,To,yo,Zi,Qi,xr,Tr,Gg,rd,nd,od,id,ad,sd,ud,ta=O(()=>{Yt(),qi(),Ke(),Vr(),Je=()=>!!z.wasm.proxy&&typeof document<"u",Xr=!1,xo=!1,To=!1,Qi=new Map,xr=(e,n)=>{let i=Qi.get(e);i?i.push(n):Qi.set(e,[n])},Tr=()=>{if(Xr||!xo||To||!Kt)throw new Error("worker not ready")},Gg=e=>{switch(e.data.type){case"init-wasm":Xr=!1,e.data.err?(To=!0,Zi[1](e.data.err)):(xo=!0,Zi[0]()),yo&&(URL.revokeObjectURL(yo),yo=void 0);break;case"init-ep":case"copy-from":case"create":case"release":case"run":case"end-profiling":{let n=Qi.get(e.data.type);e.data.err?n.shift()[1](e.data.err):n.shift()[0](e.data.out);break}}},rd=async()=>{if(!xo){if(Xr)throw new Error("multiple calls to 'initWasm()' detected.");if(To)throw new Error("previous call to 'initWasm()' failed.");if(Xr=!0,Je())return new Promise((e,n)=>{Kt==null||Kt.terminate(),Wp().then(([i,a])=>{try{Kt=a,Kt.onerror=o=>n(o),Kt.onmessage=Gg,Zi=[e,n];let p={type:"init-wasm",in:z};Kt.postMessage(p),yo=i}catch(p){n(p)}},n)});try{await io(z.wasm),await ao(z),xo=!0}catch(e){throw To=!0,e}finally{Xr=!1}}},nd=async e=>{if(Je())return Tr(),new Promise((n,i)=>{xr("init-ep",[n,i]);let a={type:"init-ep",in:{epName:e,env:z}};Kt.postMessage(a)});await so(z,e)},od=async e=>Je()?(Tr(),new Promise((n,i)=>{xr("copy-from",[n,i]);let a={type:"copy-from",in:{buffer:e}};Kt.postMessage(a,[e.buffer])})):zr(e),id=async(e,n)=>{if(Je()){if(n!=null&&n.preferredOutputLocation)throw new Error('session option "preferredOutputLocation" is not supported for proxy.');return Tr(),new Promise((i,a)=>{xr("create",[i,a]);let p={type:"create",in:{model:e,options:{...n}}},o=[];e instanceof Uint8Array&&o.push(e.buffer),Kt.postMessage(p,o)})}else return uo(e,n)},ad=async e=>{if(Je())return Tr(),new Promise((n,i)=>{xr("release",[n,i]);let a={type:"release",in:e};Kt.postMessage(a)});lo(e)},sd=async(e,n,i,a,p,o)=>{if(Je()){if(i.some(s=>s[3]!=="cpu"))throw new Error("input tensor on GPU is not supported for proxy.");if(p.some(s=>s))throw new Error("pre-allocated output tensor is not supported for proxy.");return Tr(),new Promise((s,d)=>{xr("run",[s,d]);let c=i,r={type:"run",in:{sessionId:e,inputIndices:n,inputs:c,outputIndices:a,options:o}};Kt.postMessage(r,po(c))})}else return fo(e,n,i,a,p,o)},ud=async e=>{if(Je())return Tr(),new Promise((n,i)=>{xr("end-profiling",[n,i]);let a={type:"end-profiling",in:e};Kt.postMessage(a)});co(e)}}),ld,Mg,wo,fd=O(()=>{Yt(),ta(),Ji(),oo(),Yi(),ld=(e,n)=>{switch(e.location){case"cpu":return[e.type,e.dims,e.data,"cpu"];case"gpu-buffer":return[e.type,e.dims,{gpuBuffer:e.gpuBuffer},"gpu-buffer"];case"ml-tensor":return[e.type,e.dims,{mlTensor:e.mlTensor},"ml-tensor"];default:throw new Error(`invalid data location: ${e.location} for ${n()}`)}},Mg=e=>{switch(e[3]){case"cpu":return new yt(e[0],e[2],e[1]);case"gpu-buffer":{let n=e[0];if(!bo(n))throw new Error(`not supported data type: ${n} for deserializing GPU tensor`);let{gpuBuffer:i,download:a,dispose:p}=e[2];return yt.fromGpuBuffer(i,{dataType:n,dims:e[1],download:a,dispose:p})}case"ml-tensor":{let n=e[0];if(!go(n))throw new Error(`not supported data type: ${n} for deserializing MLTensor tensor`);let{mlTensor:i,download:a,dispose:p}=e[2];return yt.fromMLTensor(i,{dataType:n,dims:e[1],download:a,dispose:p})}default:throw new Error(`invalid data location: ${e[3]}`)}},wo=class{async fetchModelAndCopyToWasmMemory(e){return od(await jr(e))}async loadModel(e,n){Fe();let i;typeof e=="string"?i=await this.fetchModelAndCopyToWasmMemory(e):i=e,[this.sessionId,this.inputNames,this.outputNames]=await id(i,n),Ce()}async dispose(){return ad(this.sessionId)}async run(e,n,i){Fe();let a=[],p=[];Object.entries(e).forEach(l=>{let h=l[0],f=l[1],m=this.inputNames.indexOf(h);if(m===-1)throw new Error(`invalid input '${h}'`);a.push(f),p.push(m)});let o=[],s=[];Object.entries(n).forEach(l=>{let h=l[0],f=l[1],m=this.outputNames.indexOf(h);if(m===-1)throw new Error(`invalid output '${h}'`);o.push(f),s.push(m)});let d=a.map((l,h)=>ld(l,()=>`input "${this.inputNames[p[h]]}"`)),c=o.map((l,h)=>l?ld(l,()=>`output "${this.outputNames[s[h]]}"`):null),r=await sd(this.sessionId,p,d,s,c,i),u={};for(let l=0;l<r.length;l++)u[this.outputNames[s[l]]]=o[l]??Mg(r[l]);return Ce(),u}startProfiling(){}endProfiling(){ud(this.sessionId)}}}),pd={};Or(pd,{OnnxruntimeWebAssemblyBackend:()=>vo,initializeFlags:()=>cd,wasmBackend:()=>Ug});var cd,vo,Ug,dd=O(()=>{Yt(),ta(),fd(),Vr(),cd=()=>{if((typeof z.wasm.initTimeout!="number"||z.wasm.initTimeout<0)&&(z.wasm.initTimeout=0),z.wasm.simd===!1&&console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'),typeof z.wasm.proxy!="boolean"&&(z.wasm.proxy=!1),typeof z.wasm.trace!="boolean"&&(z.wasm.trace=!1),typeof z.wasm.numThreads!="number"||!Number.isInteger(z.wasm.numThreads)||z.wasm.numThreads<=0)if(typeof self<"u"&&!self.crossOriginIsolated)z.wasm.numThreads=1;else{let e=typeof navigator>"u"?Co("node:os").cpus().length:navigator.hardwareConcurrency;z.wasm.numThreads=Math.min(4,Math.ceil((e||1)/2))}},vo=class{async init(e){cd(),await rd(),await nd(e)}async createInferenceSessionHandler(e,n){let i=new wo;return await i.loadModel(e,n),Promise.resolve(i)}},Ug=new vo});Yt(),Yt(),Yt();var Ds="1.20.1";{let e=(Fp(),sn(Bp)).onnxjsBackend;nr("webgl",e,-10)}{let e=(dd(),sn(pd)).wasmBackend;nr("cpu",e,10),nr("wasm",e,10)}Object.defineProperty(z.versions,"web",{value:Ds,enumerable:!0});/*! Bundled license information:

    long/index.js:
      (**
       * @license
       * Copyright 2009 The Closure Library Authors
       * Copyright 2020 Daniel Wirtz / The long.js Authors.
       *
       * Licensed under the Apache License, Version 2.0 (the "License");
       * you may not use this file except in compliance with the License.
       * You may obtain a copy of the License at
       *
       *     http://www.apache.org/licenses/LICENSE-2.0
       *
       * Unless required by applicable law or agreed to in writing, software
       * distributed under the License is distributed on an "AS IS" BASIS,
       * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       * See the License for the specific language governing permissions and
       * limitations under the License.
       *
       * SPDX-License-Identifier: Apache-2.0
       *)
    */function C(e){if(e.startsWith("blob:"))return!0;try{return new URL(e),!0}catch{return!1}}const T=(e,n)=>!n||e.startsWith("http")?new URL(e).href:e?n.replace(/\/+$/,"")+"/"+e.replace(/^\/+/,""):n;class t{constructor(){this.resolvedUriCache=new Map}async resolveUri(n,i){if(!i)throw new Error("Asset URI is undefined.");if(this.resolvedUriCache.has(i))return this.resolvedUriCache.get(i);let a;if(C(i)?a=i:i.match(/\.[a-z0-9]+$/i)?typeof n.assetUrlResolver=="function"&&(a=await n.assetUrlResolver(i,n)):a=T(i,n.baseUrl),!a)throw new Error(`Failed to resolve asset URI: ${i}`);return this.resolvedUriCache.set(i,a),a}}const d$1=new t;function stripQueryParams(e){try{const n=new URL(e);return n.search="",n.toString()}catch{return e}}async function loadAndCacheFile(e){const n=await caches.open("ladon-cache"),i=stripQueryParams(e),a=await n.match(i);if(a)return a.arrayBuffer();const p=await fetch(e);if(!p.ok)throw new Error(`Failed to fetch file: ${e}`);const o=p.headers.get("Content-Type")||"binary/octet-stream";if(!o.includes("application/wasm")&&!o.includes("binary/octet-stream"))throw new Error(`Unexpected MIME type: ${o} for ${i}`);const s=await p.arrayBuffer(),d=new Response(s,{headers:{"Content-Type":o,"Content-Length":s.byteLength.toString()}});return await n.put(i,d),s}const ONNX_WASM_FILENAME="ort-wasm-simd-threaded.wasm";class ModelManager{constructor(){this.modelSessions={}}async loadModel(n){const{mask:i,executionProviders:a}=n;z.wasm.numThreads=1;const p=await d$1.resolveUri(n,n.wasmUri);if(p)try{z.wasm.wasmBinary=await loadAndCacheFile(p+ONNX_WASM_FILENAME)}catch(d){console.warn("Failed to load or cache WASM file. Using WASM paths.",d),z.wasm.wasmPaths=p}const o=await d$1.resolveUri(n,i.modelUri);let s=this.modelSessions[o];if(!s){const c={executionProviders:a!=null&&a.length?a:["wasm"]};try{const r=await loadAndCacheFile(o);s=await Yd.create(r,c)}catch(r){console.warn("Failed to load or cache model file. Using model URL.",r),s=await Yd.create(o,c)}}return this.modelSessions[o]=s,await this.warmupModel(s,i.inputSize,i.modelRank),s}async warmupModel(n,i={width:1280,height:720},a=3,p="float32"){const o=i.height*i.width,s=new Float32Array(a*o).fill(0),d=new yt(p,s,[1,a,i.height,i.width]),c={[n.inputNames[0]]:d};if(a===3){const r=new Float32Array(o).fill(0),u=new yt(p,r,[1,1,i.height,i.width]);c[n.inputNames[1]]=u}await n.run(c)}getModelSession(n){return this.modelSessions[n]}async destroyModel(n){const i=this.modelSessions[n];i&&(await i.release(),delete this.modelSessions[n])}}const modelManager=new ModelManager;class LadonGenerator{constructor(n){this.config=n,this.lastMaskGenerationTime=0;const{height:i,width:a}=this.config.mask.outputSize;this.lastMask=new yt("float32",new Float32Array(i*a),[1,1,i,a]),this.lastResult={data:this.lastMask.data,facesAndLandmarks:{data:new Float32Array(0),dims:[]},gesture:new Float32Array(0),motion:0,timestamp:0,warm:!1}}isLoaded(){return!!this.maskModel}preprocess(n,i){const{modelRank:a,inputSize:p,outputSize:o}=this.config.mask,{height:s,width:d}=p,c=s*d;this.output??(this.output=new Float32Array(c*a));const r=n.length/4;for(let h=0;h<3;h++)for(let f=0;f<r;f++)this.output[f+h*c]=n[f*4+(2-h)];const u=o.width/d,l=o.height/s;for(let h=0;h<d;h++){const f=Math.floor(h*u);for(let m=0;m<s;m++){const y=Math.floor(m*l),_=f+y*o.width,I=h+m*d+3*c,x=Math.min(Math.max(i[_],0),255);this.output[I]=x}}return this.output}getTimeSinceLastGeneration(){return Date.now()-this.lastMaskGenerationTime}async getLadonOutput(n,i){var o,s,d,c;if(!this.maskModel)throw new Error("[ladon-ts] Mask model not loaded.");if(this.getTimeSinceLastGeneration()<this.config.mask.generationIntervalMs)return{data:this.lastMask.data,facesAndLandmarks:this.lastResult.facesAndLandmarks,gesture:this.lastResult.gesture,motion:this.lastResult.motion,warm:!1,timestamp:i};this.lastMaskGenerationTime=Date.now();const a=new yt("float32",this.preprocess(n,this.lastMask.data),[1,this.config.mask.modelRank,this.config.mask.inputSize.height,this.config.mask.inputSize.width]),p=await this.maskModel.run({input:a});return this.lastMask=p.segmentation,this.lastResult={data:this.lastMask.data??new Float32Array(0),facesAndLandmarks:{data:((o=p.faces_and_landmarks)==null?void 0:o.data)??new Float32Array(0),dims:((s=p.faces_and_landmarks)==null?void 0:s.dims)??[]},gesture:((d=p.gesture)==null?void 0:d.data)??new Float32Array(0),motion:((c=p.motion)==null?void 0:c.data[0])??0,timestamp:i,warm:!0},this.lastResult}async load(){if(this.modelUrl=await d$1.resolveUri(this.config,this.config.mask.modelUri),this.maskModel=modelManager.getModelSession(this.modelUrl),this.maskModel??(this.maskModel=await modelManager.loadModel(this.config)),!this.maskModel)throw new Error("Failed to load the ONNX model.")}async postRender(){}async destroy(){if(!this.modelUrl)throw new Error("[ladon-ts] Generator teardown failed. Model URL is not defined.");await modelManager.destroyModel(this.modelUrl),this.modelUrl=void 0,this.maskModel=void 0,this.output=void 0}}const MAX_QUEUE_SIZE=3,queue=[];let preloadPromise=null,generator,processing=!1;async function processQueue(){if(!processing){for(processing=!0;queue.length>0;){const{image:e,timestamp:n}=queue.shift();await handleGenerate(e,n)}setTimeout(()=>{processing=!1},0)}}self.addEventListener("message",async e=>{const{type:n,config:i,image:a,timestamp:p}=e.data;try{switch(n){case"preload":i&&(preloadPromise=handlePreload(i),await preloadPromise);break;case"init":i&&(preloadPromise&&await preloadPromise,await handleInit(i));break;case"generate":if(a){if(queue.length>=MAX_QUEUE_SIZE){const o=queue.shift();o&&postMessage({facesAndLandmarks:null,gesture:null,mask:null,motion:null,timestamp:o.timestamp,status:"dropped",warm:!1})}queue.push({image:a,timestamp:p}),processQueue()}break;case"destroy":await handleDestroy();break;default:console.warn(`[ladon-ts] Worker generator recieved unknown message: ${JSON.stringify(e.data)}`)}}catch(o){console.error(`[ladon-ts] Worker generator error handling message: ${o}`),postMessage({status:"error",error:o.message})}});async function handlePreload(e){await modelManager.loadModel(e),postMessage({status:"preloaded"})}async function handleInit(e){generator=new LadonGenerator(e),await generator.load(),postMessage({status:"initialized"})}async function handleGenerate(e,n){if(!generator||!generator.isLoaded()){console.warn("[ladon-ts] Generator is not initialized");return}if(!e){console.warn("[ladon-ts] No valid input provided for generation");return}const i=await generator.getLadonOutput(e,n);postMessage({facesAndLandmarks:i.facesAndLandmarks,gesture:i.gesture,mask:i.data,motion:i.motion,timestamp:i.timestamp,status:"generated",warm:i.warm})}async function handleDestroy(){generator?await generator.destroy():console.warn("[ladon-ts] No generator to destroy"),postMessage({status:"destroyed"})}})();
//# sourceMappingURL=segmentation.js.map
