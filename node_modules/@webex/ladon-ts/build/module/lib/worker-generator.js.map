{"version":3,"file":"worker-generator.js","sources":["../../../src/lib/worker-generator.ts"],"sourcesContent":["import { PipelineConfig } from './config-types';\nimport { LadonOutput, MaskGenerator, WorkerGeneratedResult } from './generator-types';\nimport { workerManager } from './worker-manager';\n\nexport class WorkerGenerator implements MaskGenerator {\n    private pending: Map<number, (result: LadonOutput) => void> = new Map();\n    private lastResult: LadonOutput;\n    private newMask = true;\n\n    constructor(public readonly config: PipelineConfig) {\n        this.lastResult = {\n            data: new Float32Array(\n                this.config.mask.outputSize.height * this.config.mask.outputSize.width\n            ),\n            facesAndLandmarks: { data: new Float32Array(0), dims: [] },\n            gesture: new Float32Array(0),\n            motion: 0,\n            timestamp: 0,\n            warm: false,\n        };\n    }\n\n    public isLoaded(): boolean {\n        return !!workerManager.getWorker();\n    }\n\n    public async getLadonOutput(): Promise<LadonOutput> {\n        const toReturn = {\n            data: this.lastResult.data,\n            facesAndLandmarks: this.lastResult.facesAndLandmarks,\n            gesture: this.lastResult.gesture,\n            motion: this.lastResult.motion,\n            timestamp: this.lastResult.timestamp,\n            warm: this.newMask,\n        };\n\n        this.newMask = false;\n\n        return toReturn;\n    }\n\n    /**\n     * Returns a promise that resolves when the worker returns the mask for the given timestamp.\n     * This is useful for synchronizing the processing of frames with their corresponding masks.\n     * The promise will be resolved with the mask data when it is available.\n     *\n     * @param timestamp - The timestamp of the frame for which the mask is requested.\n     * @returns A promise that resolves with the mask data when available.\n     */\n    public async getLadonOutputForTimestamp(timestamp: number): Promise<LadonOutput> {\n        return new Promise<LadonOutput>((resolve) => {\n            this.pending.set(timestamp, resolve);\n        });\n    }\n\n    /**\n     * Loads the worker and initializes it with the provided configuration.\n     * The worker is responsible for processing the input image and generating the mask.\n     * Prepares the worker configuration by resolving the final URLs and paths to send to the worker.\n     *\n     * @returns A promise that resolves when the worker is loaded and initialized.\n     */\n    public async load(): Promise<void> {\n        const config = await workerManager.prepareWorkerConfig(this.config);\n\n        // Listen for worker events\n        return new Promise<void>((resolve) => {\n            workerManager.onInitialized(() => {\n                resolve();\n            });\n            workerManager.onGenerated((data: WorkerGeneratedResult) => {\n                const result: LadonOutput = {\n                    data: data.mask,\n                    facesAndLandmarks: data.facesAndLandmarks,\n                    gesture: data.gesture,\n                    motion: data.motion,\n                    timestamp: data.timestamp,\n                    warm: true,\n                };\n                this.lastResult = result;\n                this.newMask = true;\n\n                // Resolve the pending promise for this timestamp, if any\n                const cb = this.pending.get(data.timestamp);\n                if (cb) {\n                    cb(result);\n                    this.pending.delete(data.timestamp);\n                }\n            });\n            workerManager.onDropped((timestamp: number) => {\n                // Resolve the pending promise for this timestamp with the last result\n                const cb = this.pending.get(timestamp);\n                if (cb) {\n                    cb(this.lastResult);\n                    this.pending.delete(timestamp);\n                }\n            });\n            workerManager.onLog((message, severity) => {\n                const msg = `[ladon-ts] Message received from worker: ${message}`;\n                switch (severity) {\n                    case 'warn':\n                        console.warn(msg);\n                        break;\n                    case 'error':\n                        console.error(msg);\n                        break;\n                    default:\n                        console.log(msg);\n                }\n            });\n\n            // Initialize the worker if not already done, then always send init\n            (async () => {\n                await (workerManager.getWorker() ?? workerManager.initializeWorker(config));\n                workerManager.sendInit({\n                    baseUrl: config.baseUrl,\n                    input: config.input,\n                    mask: config.mask,\n                    wasmUri: config.wasmUri,\n                    render: { type: 'passthrough' },\n                });\n            })();\n        });\n    }\n\n    /**\n     * Sends the input image to the worker for processing.\n     * The input image is expected to be a Uint8ClampedArray.\n     * Claims ownership of the input tensor's buffer and forwards it to the worker.\n     *\n     * @param input - The input image as a Uint8ClampedArray.\n     * @param timestamp - The timestamp of the input image.\n     */\n    public async postRender(input: Uint8ClampedArray, timestamp: number): Promise<void> {\n        workerManager.sendGenerate(input, timestamp);\n    }\n\n    /**\n     * Destroys the worker and cleans up resources.\n     * First it sends a message to the worker to destroy itself,\n     * then it waits for the worker to respond with a 'destroyed' message.\n     * After that, it terminates the worker and revokes the URL if it exists.\n     *\n     * @returns A promise that resolves when the worker is destroyed.\n     */\n    public destroy(): Promise<void> {\n        return workerManager.destroyWorker();\n    }\n}\n"],"names":["WorkerGenerator","config","workerManager","toReturn","timestamp","resolve","data","result","cb","message","severity","msg","input"],"mappings":"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"}