var I = /* @__PURE__ */ ((o) => (o.Nearest = "nearest", o))(I || {});
const U = (o, n, u, r, e) => {
  const l = new Uint8ClampedArray(r * e * 4), p = n / r, y = u / e, s = n * 4;
  let a = 0;
  for (let t = 0; t < e; t++) {
    const f = Math.floor(t * y) * s;
    for (let c = 0; c < r; c++) {
      const m = f + Math.floor(c * p) * 4;
      l[a++] = o[m], l[a++] = o[m + 1], l[a++] = o[m + 2], l[a++] = o[m + 3];
    }
  }
  return l;
};
function A(o, n, u, r, e) {
  const l = new Uint8ClampedArray(r * e);
  if (n === r && u === e) {
    for (let s = 0; s < o.length; s++)
      l[s] = Math.min(Math.max(o[s], 0), 255);
    return l;
  }
  const p = (n - 1) / (r - 1), y = (u - 1) / (e - 1);
  for (let s = 0; s < e; s++)
    for (let a = 0; a < r; a++) {
      const t = p * a, f = y * s, c = Math.floor(t), m = Math.floor(f), S = Math.min(Math.ceil(t), n - 1), x = Math.min(Math.ceil(f), u - 1), w = t - c, i = f - m, M = o[m * n + c], h = o[m * n + S], k = o[x * n + c], P = o[x * n + S], E = M * (1 - w) * (1 - i) + h * w * (1 - i) + k * (1 - w) * i + P * w * i;
      l[s * r + a] = Math.min(Math.max(E, 0), 255);
    }
  return l;
}
function d(o, n, u, r, e) {
  const l = new Uint8ClampedArray(r * e), p = n / r, y = u / e, s = (t, f) => {
    if (t === 0) return 1;
    if (t < 0 && (t = -t), t < f) {
      const c = Math.PI * t;
      return f * Math.sin(c) * Math.sin(c / f) / (c * c);
    }
    return 0;
  }, a = 3;
  for (let t = 0; t < e; t++)
    for (let f = 0; f < r; f++) {
      const c = f * p, m = t * y, S = Math.floor(c), x = Math.floor(m);
      let w = 0, i = 0;
      for (let M = x - a + 1; M <= x + a; M++)
        for (let h = S - a + 1; h <= S + a; h++)
          if (h >= 0 && h < n && M >= 0 && M < u) {
            const k = o[M * n + h], P = s(c - h, a) * s(m - M, a);
            w += k * P, i += P;
          }
      l[t * r + f] = i !== 0 ? Math.round(w / i) : 0;
    }
  return l;
}
function L(o, n, u) {
  const r = o.createShader(n);
  if (!r)
    throw new Error("[ladon-ts] Error creating shader");
  if (o.shaderSource(r, u), o.compileShader(r), !o.getShaderParameter(r, o.COMPILE_STATUS)) {
    const e = o.getShaderInfoLog(r) ?? "unknown error compiling shader.";
    throw new Error("[ladon-ts] " + e);
  }
  return r;
}
function R(o, n, u) {
  const r = o.createProgram();
  if (!r)
    throw new Error("[ladon-ts] Error creating GPU program");
  if (o.attachShader(r, n), o.attachShader(r, u), o.linkProgram(r), !o.getProgramParameter(r, o.LINK_STATUS)) {
    const e = o.getProgramInfoLog(r) ?? "unknown error linking program.";
    throw new Error("[ladon-ts] " + e);
  }
  return r;
}
function C(o) {
  if (o.startsWith("blob:"))
    return !0;
  try {
    return new URL(o), !0;
  } catch {
    return !1;
  }
}
const T = (o, n) => !n || o.startsWith("http") ? new URL(o).href : o ? n.replace(/\/+$/, "") + "/" + o.replace(/^\/+/, "") : n;
export {
  I as InterpolationMethod,
  A as bilinearUpsample,
  L as compileShader,
  C as isResolvedUri,
  d as lanczos3Upsample,
  R as linkProgram,
  U as resizeImage,
  T as toAbsoluteURI
};
//# sourceMappingURL=util.js.map
