import { WorkerGenerator as n } from "./worker-generator.js";
import { BlurRenderer as o } from "./renderer/blur-renderer.js";
import { PassthroughRenderer as h } from "./renderer/passthrough-renderer.js";
import { ReplacementRenderer as d } from "./renderer/replacement-renderer.js";
import { resizeImage as u } from "./util.js";
class w {
  constructor(t, e, a, r) {
    this.inputCanvas = t, this.outputCanvas = e, this.config = a, this.videoElement = r, this.loaded = !1;
    const s = this.inputCanvas.getContext("2d", {
      alpha: !1,
      willReadFrequently: !0
    });
    if (!s)
      throw new Error("[ladon-ts] Error getting input context 2d");
    this.inputCanvasCtx = s;
  }
  /**
   * Processes a single frame and returns the inference result.
   * This method handles the frame data, performs inference if needed, and renders the output.
   *
   * @param timestamp - The timestamp of the frame.
   * @param performInference - Flag to perform mask inference.
   * @returns The result of the frame processing.
   * @throws If the pipeline (generator or renderer) is not loaded.
   */
  async onFrame(t, e = !0) {
    if (!this.generator || !this.renderer)
      throw new Error("[ladon-ts] Pipeline is not loaded.");
    const a = this.getInputFrameData(e);
    let r;
    if (a instanceof Uint8ClampedArray ? ((!this.frameDataBuffer || this.frameDataBuffer.length !== a.length) && (this.frameDataBuffer = new Uint8ClampedArray(a.length)), this.frameDataBuffer.set(a), r = this.frameDataBuffer) : r = a, e || !this.lastMaskResult) {
      const s = a, i = this.getMaskImageData(s);
      await this.generator.postRender(i, t), this.lastMaskResult = await this.generator.getLadonOutputForTimestamp(t);
    }
    return await this.renderer.render(r, this.lastMaskResult), this.createInferenceResult(t, e);
  }
  /**
   * Gets the raw image data from the input canvas context.
   *
   * @param needFreshImageData - Flag to indicate if fresh image data is needed.
   *
   * @returns The raw image data.
   */
  getInputFrameData(t) {
    return t || !this.videoElement ? this.inputCanvasCtx.getImageData(
      0,
      0,
      this.config.input.width,
      this.config.input.height
    ).data : this.videoElement;
  }
  /**
   * Resizes the image data if the model expects a fixed size input.
   *
   * @param {Uint8ClampedArray} rawImageData - The raw image data.
   * @returns {Uint8ClampedArray} - The processed mask image data.
   */
  getMaskImageData(t) {
    const e = this.config.mask.inputSize, a = this.config.input;
    return e.width === a.width && e.height === a.height ? t : u(
      t,
      a.width,
      a.height,
      e.width,
      e.height
    );
  }
  /**
   * Creates the inference result object.
   *
   * @param {number} timestamp - The timestamp of the frame.
   * @param {boolean} performedInference - Indicates if the inference was performed.
   * @returns {IFrameInferenceResult} - The result object containing inference details.
   */
  createInferenceResult(t, e) {
    return this.lastMaskResult ? {
      facesAndLandmarks: this.lastMaskResult.facesAndLandmarks,
      gesture: this.lastMaskResult.gesture,
      motion: this.lastMaskResult.motion,
      skipped: !e,
      timestamp: t
    } : {
      facesAndLandmarks: { data: new Float32Array(0), dims: [] },
      gesture: new Float32Array(0),
      motion: 0,
      skipped: !0,
      timestamp: t
    };
  }
  /**
   * Checks if the pipeline is loaded.
   *
   * @returns True if the pipeline is loaded, false otherwise.
   */
  isLoaded() {
    return this.loaded;
  }
  /**
   * Loads the pipeline components such as the generator and renderer.
   */
  async load() {
    switch (this.config.render.type) {
      case "blur":
        this.renderer = new o(this.outputCanvas, this.config);
        break;
      case "passthrough":
        this.renderer = new h(this.outputCanvas, this.config);
        break;
      case "replacement":
        this.renderer = new d(this.outputCanvas, this.config);
        break;
      default:
        throw new Error("[ladon-ts] Renderer not implemented.");
    }
    await this.renderer.load(), this.generator = new n(this.config), await this.generator.load(), this.loaded = !0;
  }
  reset() {
    this.lastMaskResult = void 0;
  }
  /**
   * Destroys the pipeline and cleans up resources.
   */
  async destroy() {
    var t, e;
    this.reset(), (t = this.renderer) == null || t.destroy(), await ((e = this.generator) == null ? void 0 : e.destroy()), this.frameDataBuffer = void 0, this.loaded = !1;
  }
}
export {
  w as Pipeline
};
//# sourceMappingURL=pipeline.js.map
