import { resourceLoader as a } from "./resource-loader.js";
class d {
  constructor() {
    this.destroyPromise = null, this.onInitializedCallbacks = [], this.onGeneratedCallbacks = [], this.onDroppedCallbacks = [], this.onLogCallbacks = [];
  }
  /**
   * Get the current worker instance.
   *
   * @returns The current worker instance or undefined if not initialized.
   */
  getWorker() {
    return this.worker;
  }
  /**
   * Initialize the worker using the provided configuration.
   *
   * @param config - The configuration object.
   * @returns A promise that resolves when the worker is initialized.
   */
  async initializeWorker(e) {
    if (typeof Worker > "u")
      throw new Error("[ladon-ts] web workers are not supported in this environment");
    this.destroyPromise && (await this.destroyPromise, this.destroyPromise = null), this.worker && (this.destroyPromise = this.destroyWorker(), await this.destroyPromise, this.destroyPromise = null);
    const r = await a.resolveUri(e, e.mask.workerUri), o = await (await fetch(r, { cache: "force-cache" })).text();
    return this.workerUrl = URL.createObjectURL(new Blob([o], { type: "text/javascript" })), this.worker = new Worker(this.workerUrl, { type: "module" }), this.worker.addEventListener("message", (t) => {
      if (t.data.type === "log") {
        const { message: s, severity: n } = t.data;
        this.onLogCallbacks.forEach((l) => l(s, n));
      } else t.data.status === "generated" ? this.onGeneratedCallbacks.forEach((s) => s(t.data)) : t.data.status === "dropped" ? this.onDroppedCallbacks.forEach((s) => s(t.data.timestamp)) : t.data.status === "initialized" && this.onInitializedCallbacks.forEach((s) => s());
    }), this.worker;
  }
  /**
   * Destroys the worker gracefully by sending a destroy message and waiting for confirmation.
   *
   * @returns A promise that resolves when the worker is destroyed.
   *          If no worker is available, it resolves immediately.
   */
  destroyWorker() {
    return new Promise((e) => {
      const r = (i) => {
        var o;
        i.data.status === "destroyed" && ((o = this.worker) == null || o.removeEventListener("message", r), this.terminateWorker(), e());
      };
      if (!this.worker) {
        console.warn("[ladon-ts] No worker to destroy"), e();
        return;
      }
      this.worker.addEventListener("message", r), this.worker.postMessage({ type: "destroy" });
    });
  }
  /**
   * Terminate the worker.
   */
  terminateWorker() {
    this.worker && (this.worker.terminate(), this.worker = void 0), this.workerUrl && (URL.revokeObjectURL(this.workerUrl), this.workerUrl = void 0);
  }
  /**
   * Preload the worker using the provided configuration.
   *
   * @param config - The configuration object.
   * @returns A promise that resolves when the worker is preloaded.
   */
  async preloadWorker(e) {
    const r = await this.prepareWorkerConfig(e);
    this.worker = await this.initializeWorker(r), this.worker.postMessage({ type: "preload", config: r });
  }
  /**
   * Prepare the worker configuration by resolving the final URLs and paths to send to the
   * worker. This is necessary because we can't send functions to the worker. We also need to
   * remove the assetUrlResolver function from the configuration.
   *
   * @param config - The preload configuration.
   * @returns The worker configuration.
   */
  async prepareWorkerConfig(e) {
    const r = await a.resolveUri(e, e.mask.modelUri), i = await a.resolveUri(e, e.mask.workerUri), o = await a.resolveUri(e, e.wasmUri), s = { ...{
      ...e,
      mask: { ...e.mask, modelUri: r, workerUri: i },
      wasmUri: o
    }, assetUrlResolver: void 0 };
    return JSON.parse(JSON.stringify(s));
  }
  /**
   * Register a callback for when the worker is initialized.
   */
  onInitialized(e) {
    this.onInitializedCallbacks.push(e);
  }
  /**
   * Register a callback for when the worker generates output.
   *
   * @param callback - The callback function to be called with the generated data.
   * @param data - The generated data from the worker.
   * @param data.mask - The generated mask.
   * @param data.facesAndLandmarks - The detected faces and landmarks.
   * @param data.gesture - The detected gesture.
   * @param data.motion - The detected motion.
   */
  onGenerated(e) {
    this.onGeneratedCallbacks.push(e);
  }
  /**
   * Register a callback for when the worker drops a frame.
   * This is useful for handling cases where the worker cannot keep up with the input frame rate.
   * The callback will be called with the timestamp of the dropped frame.
   *
   * @param callback - The callback function to be called with the timestamp of the dropped frame.
   */
  onDropped(e) {
    this.onDroppedCallbacks.push(e);
  }
  /**
   * Register a callback for log messages from the worker.
   *
   * @param callback - The callback function to be called with the log message and severity.
   * @param severity - The severity of the log message (e.g., 'info', 'warn', 'error').
   */
  onLog(e) {
    this.onLogCallbacks.push(e);
  }
  /**
   * Send an init message to the worker.
   *
   * @param config - The configuration object to initialize the worker.
   * @param config.baseUrl - The base URL for loading assets.
   * @param config.input - The input configuration for the worker.
   * @param config.mask - The mask configuration for the worker.
   * @param config.wasmUri - The URI for the WebAssembly module.
   * @param config.workerUri - The URI for the worker script.
   * @param config.assetUrlResolver - The function to resolve asset URLs.
   */
  sendInit(e) {
    if (!this.worker)
      throw new Error("[ladon-ts] Worker is not initialized, cannot send init");
    this.worker.postMessage({ type: "init", config: e });
  }
  /**
   * Send a generate message to the worker.
   *
   * @param input - The input image data as a Uint8ClampedArray.
   * @param timestamp - The timestamp of the input image.
   */
  sendGenerate(e, r) {
    if (!this.worker)
      throw new Error("[ladon-ts] Worker is not initialized, cannot send generate");
    this.worker.postMessage(
      {
        type: "generate",
        image: e,
        timestamp: r
      },
      [e.buffer]
    );
  }
}
const w = new d();
export {
  d as WorkerManager,
  w as workerManager
};
//# sourceMappingURL=worker-manager.js.map
