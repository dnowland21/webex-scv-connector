{"version":3,"file":"blur-renderer.js","sources":["../../../../src/lib/renderer/blur-renderer.ts"],"sourcesContent":["import { BlurConfig, PipelineConfig } from '../config-types';\nimport { FrameData, LadonOutput } from '../generator';\nimport { compileShader, linkProgram } from '../util';\n\nimport { LadonRenderer } from './ladon-renderer';\nimport { WebGLRenderer } from './webgl-renderer';\n\nexport class BlurRenderer extends WebGLRenderer implements LadonRenderer {\n    private program_1: WebGLProgram;\n    private program_2: WebGLProgram;\n\n    private framebuffer: WebGLFramebuffer;\n    private transfer_texture: WebGLTexture;\n\n    private u_blur: WebGLUniformLocation;\n\n    private fragment_shader_common = `#version 300 es\nprecision highp float;\n\n#define KERNEL_SIZE     ${(this.config.render as BlurConfig).kernelSize}\n#define HORIZONTAL      vec2(1.0, 0.0)\n#define VERTICAL        vec2(0.0, 1.0)\n\nout vec4 outColor;\n\nuniform sampler2D       u_image;\nuniform sampler2D       u_mask;\nuniform vec2            u_resolution;\nuniform float           u_kernel[KERNEL_SIZE];\n\n// Function to retrieve the mask value\nfloat get_mask(vec2 st) {\n    return texture(u_mask, st).r;\n}\n\n// Get the inverse of the masked area\nfloat get_inv_mask(vec2 st) {\n    return 1.0 - get_mask(st);\n}\n\n// Blurring function\nvec3 blur(sampler2D src, vec2 uv, vec2 direction) {\n    vec4 accum = vec4(0.0);\n    vec2 step = direction / u_resolution;\n    int offset = (KERNEL_SIZE - 1) / 2;\n\n    float weightSum = 0.0;\n    for (int i = 0; i < KERNEL_SIZE; i++) {\n        vec2 sampleUV = uv + step * float(i - offset);\n        vec4 sampleTex = texture(src, sampleUV);\n        float weight = u_kernel[i];\n        accum += sampleTex * weight;\n        weightSum += weight;\n    }\n\n    weightSum = max(weightSum, 0.001); // Avoid division by zero\n    return accum.rgb / weightSum;\n}\n`;\n\n    private fragment_shader_pass_1_src =\n        this.fragment_shader_common +\n        `\nvoid main() {\n    vec2 st = gl_FragCoord.xy / u_resolution;\n    outColor = vec4(blur(u_image, st, HORIZONTAL), 1.0);\n}\n`;\n\n    public fragment_shader_pass_2_src =\n        this.fragment_shader_common +\n        `\nuniform sampler2D   u_blur;\n\nvoid main() {\n    ${this.getUVCalculation()};\n\n    vec3 blurred = blur(u_blur, st, VERTICAL);\n    vec3 original = texture(u_image, st).rgb;\n    float mask = get_inv_mask(st); // Use inverse mask to blur background, not user\n\n    // Correct blending based on the mask\n    vec3 color = mix(original, blurred, mask); // Ensure mask properly determines blur influence on background\n    outColor = vec4(color, 1.0);\n}\n`;\n\n    constructor(public output_canvas: HTMLCanvasElement, public readonly config: PipelineConfig) {\n        super(output_canvas, config);\n\n        if ((this.config.render as BlurConfig).kernelSize % 2 === 0) {\n            throw new Error('[ladon-ts] Kernel_size must be odd');\n        }\n\n        // program pass 1 setup\n        {\n            const vertex_shader = compileShader(\n                this.gl,\n                this.gl.VERTEX_SHADER,\n                this.vertex_shader_src\n            );\n            const fragment_shader = compileShader(\n                this.gl,\n                this.gl.FRAGMENT_SHADER,\n                this.fragment_shader_pass_1_src\n            );\n\n            this.program_1 = linkProgram(this.gl, vertex_shader, fragment_shader);\n            this.gl.useProgram(this.program_1);\n\n            const framebuffer = this.gl.createFramebuffer();\n            if (!framebuffer) {\n                throw new Error('[ladon-ts] Error creating framebuffer');\n            }\n            this.framebuffer = framebuffer;\n\n            const transfer_texture = this.gl.createTexture();\n            if (!transfer_texture) {\n                throw new Error('[ladon-ts] Error creating output texture');\n            }\n            this.transfer_texture = transfer_texture;\n\n            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this.transfer_texture);\n            this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n            this.gl.texParameteri(\n                this.gl.TEXTURE_2D,\n                this.gl.TEXTURE_WRAP_S,\n                this.gl.CLAMP_TO_EDGE\n            );\n            this.gl.texParameteri(\n                this.gl.TEXTURE_2D,\n                this.gl.TEXTURE_WRAP_T,\n                this.gl.CLAMP_TO_EDGE\n            );\n            this.gl.texImage2D(\n                this.gl.TEXTURE_2D,\n                0,\n                this.gl.RGBA,\n                this.config.input.width,\n                this.config.input.height,\n                0,\n                this.gl.RGBA,\n                this.gl.UNSIGNED_BYTE,\n                null\n            );\n            this.gl.framebufferTexture2D(\n                this.gl.FRAMEBUFFER,\n                this.gl.COLOR_ATTACHMENT0,\n                this.gl.TEXTURE_2D,\n                this.transfer_texture,\n                0\n            );\n            this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n\n            this.setSharedUniforms(this.program_1);\n\n            const u_kernel = this.gl.getUniformLocation(this.program_1, 'u_kernel');\n            if (!u_kernel) {\n                throw new Error('[ladon-ts] Error finding \"u_kernel\" uniform');\n            }\n            this.gl.uniform1fv(u_kernel, this.getBlurKernel());\n        }\n\n        // program pass 2 setup\n        {\n            const vertex_shader = compileShader(\n                this.gl,\n                this.gl.VERTEX_SHADER,\n                this.vertex_shader_src\n            );\n            const fragment_shader = compileShader(\n                this.gl,\n                this.gl.FRAGMENT_SHADER,\n                this.fragment_shader_pass_2_src\n            );\n\n            this.program_2 = linkProgram(this.gl, vertex_shader, fragment_shader);\n            this.gl.useProgram(this.program_2);\n\n            const u_blur = this.gl.getUniformLocation(this.program_2, 'u_blur');\n            if (!u_blur) {\n                throw new Error('[ladon-ts] Error finding \"u_blur\" uniform');\n            }\n            this.u_blur = u_blur;\n            this.gl.activeTexture(this.gl.TEXTURE2);\n            this.gl.bindTexture(this.gl.TEXTURE_2D, this.transfer_texture);\n            this.gl.uniform1i(this.u_blur, 2);\n\n            this.setSharedUniforms(this.program_2);\n\n            const u_kernel = this.gl.getUniformLocation(this.program_2, 'u_kernel');\n            if (!u_kernel) {\n                throw new Error('[ladon-ts] Error finding \"u_kernel\" uniform');\n            }\n            this.gl.uniform1fv(u_kernel, this.getBlurKernel());\n        }\n    }\n\n    public async render(input: FrameData, mask?: LadonOutput): Promise<void> {\n        this.uploadVideoStream(input);\n        this.uploadMask(mask);\n\n        // program pass 1 - blur in one direction & output to framebuffer\n        this.gl.useProgram(this.program_1);\n\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer);\n        this.gl.drawArrays(this.gl.TRIANGLES, 0, this.verts.length / 3);\n        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);\n\n        // program pass 2 - blur in other direction & draw to screen\n        this.gl.useProgram(this.program_2);\n        this.gl.drawArrays(this.gl.TRIANGLES, 0, this.verts.length / 3);\n\n        this.postDraw();\n    }\n\n    public async load(): Promise<void> {\n        // empty\n    }\n\n    public destroy(): void {\n        // empty\n    }\n\n    private getBlurKernel(): Float32Array {\n        const kernel = [];\n        let sum = 0;\n        for (let i = 0; i < (this.config.render as BlurConfig).kernelSize; i++) {\n            let w = i - ((this.config.render as BlurConfig).kernelSize - 1) / 2;\n            w = Math.exp(-(w ** 2) / (this.config.render as BlurConfig).sigma ** 2);\n            kernel.push(w);\n            sum += w;\n        }\n\n        for (let i = 0; i < (this.config.render as BlurConfig).kernelSize; i++) {\n            kernel[i] = kernel[i] / sum;\n        }\n\n        return new Float32Array(kernel);\n    }\n}\n"],"names":["BlurRenderer","WebGLRenderer","output_canvas","config","vertex_shader","compileShader","fragment_shader","linkProgram","framebuffer","transfer_texture","u_kernel","u_blur","input","mask","kernel","sum","i","w"],"mappings":";;AAOO,MAAMA,UAAqBC,EAAuC;AAAA,EAgFrE,YAAmBC,GAAkDC,GAAwB;AAGzF,QAFA,MAAMD,GAAeC,CAAM,GADZ,KAAA,gBAAAD,GAAkD,KAAA,SAAAC,GAvErE,KAAQ,yBAAyB;AAAA;AAAA;AAAA,0BAGV,KAAK,OAAO,OAAsB,UAAU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAyC3D,KAAA,6BACJ,KAAK,yBACL;AAAA;AAAA;AAAA;AAAA;AAAA,GAOG,KAAA,6BACH,KAAK,yBACL;AAAA;AAAA;AAAA;AAAA,MAIF,KAAK,kBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAehB,KAAK,OAAO,OAAsB,aAAa,MAAM;AAChD,YAAA,IAAI,MAAM,oCAAoC;AAIxD;AACI,YAAMC,IAAgBC;AAAA,QAClB,KAAK;AAAA,QACL,KAAK,GAAG;AAAA,QACR,KAAK;AAAA,MACT,GACMC,IAAkBD;AAAA,QACpB,KAAK;AAAA,QACL,KAAK,GAAG;AAAA,QACR,KAAK;AAAA,MACT;AAEA,WAAK,YAAYE,EAAY,KAAK,IAAIH,GAAeE,CAAe,GAC/D,KAAA,GAAG,WAAW,KAAK,SAAS;AAE3B,YAAAE,IAAc,KAAK,GAAG,kBAAkB;AAC9C,UAAI,CAACA;AACK,cAAA,IAAI,MAAM,uCAAuC;AAE3D,WAAK,cAAcA;AAEb,YAAAC,IAAmB,KAAK,GAAG,cAAc;AAC/C,UAAI,CAACA;AACK,cAAA,IAAI,MAAM,0CAA0C;AAE9D,WAAK,mBAAmBA,GAExB,KAAK,GAAG,gBAAgB,KAAK,GAAG,aAAa,KAAK,WAAW,GAC7D,KAAK,GAAG,YAAY,KAAK,GAAG,YAAY,KAAK,gBAAgB,GACxD,KAAA,GAAG,cAAc,KAAK,GAAG,YAAY,KAAK,GAAG,oBAAoB,KAAK,GAAG,MAAM,GACpF,KAAK,GAAG;AAAA,QACJ,KAAK,GAAG;AAAA,QACR,KAAK,GAAG;AAAA,QACR,KAAK,GAAG;AAAA,MACZ,GACA,KAAK,GAAG;AAAA,QACJ,KAAK,GAAG;AAAA,QACR,KAAK,GAAG;AAAA,QACR,KAAK,GAAG;AAAA,MACZ,GACA,KAAK,GAAG;AAAA,QACJ,KAAK,GAAG;AAAA,QACR;AAAA,QACA,KAAK,GAAG;AAAA,QACR,KAAK,OAAO,MAAM;AAAA,QAClB,KAAK,OAAO,MAAM;AAAA,QAClB;AAAA,QACA,KAAK,GAAG;AAAA,QACR,KAAK,GAAG;AAAA,QACR;AAAA,MACJ,GACA,KAAK,GAAG;AAAA,QACJ,KAAK,GAAG;AAAA,QACR,KAAK,GAAG;AAAA,QACR,KAAK,GAAG;AAAA,QACR,KAAK;AAAA,QACL;AAAA,MACJ,GACA,KAAK,GAAG,gBAAgB,KAAK,GAAG,aAAa,IAAI,GAE5C,KAAA,kBAAkB,KAAK,SAAS;AAErC,YAAMC,IAAW,KAAK,GAAG,mBAAmB,KAAK,WAAW,UAAU;AACtE,UAAI,CAACA;AACK,cAAA,IAAI,MAAM,6CAA6C;AAEjE,WAAK,GAAG,WAAWA,GAAU,KAAK,eAAe;AAAA,IAAA;AAIrD;AACI,YAAMN,IAAgBC;AAAA,QAClB,KAAK;AAAA,QACL,KAAK,GAAG;AAAA,QACR,KAAK;AAAA,MACT,GACMC,IAAkBD;AAAA,QACpB,KAAK;AAAA,QACL,KAAK,GAAG;AAAA,QACR,KAAK;AAAA,MACT;AAEA,WAAK,YAAYE,EAAY,KAAK,IAAIH,GAAeE,CAAe,GAC/D,KAAA,GAAG,WAAW,KAAK,SAAS;AAEjC,YAAMK,IAAS,KAAK,GAAG,mBAAmB,KAAK,WAAW,QAAQ;AAClE,UAAI,CAACA;AACK,cAAA,IAAI,MAAM,2CAA2C;AAE/D,WAAK,SAASA,GACd,KAAK,GAAG,cAAc,KAAK,GAAG,QAAQ,GACtC,KAAK,GAAG,YAAY,KAAK,GAAG,YAAY,KAAK,gBAAgB,GAC7D,KAAK,GAAG,UAAU,KAAK,QAAQ,CAAC,GAE3B,KAAA,kBAAkB,KAAK,SAAS;AAErC,YAAMD,IAAW,KAAK,GAAG,mBAAmB,KAAK,WAAW,UAAU;AACtE,UAAI,CAACA;AACK,cAAA,IAAI,MAAM,6CAA6C;AAEjE,WAAK,GAAG,WAAWA,GAAU,KAAK,eAAe;AAAA,IAAA;AAAA,EACrD;AAAA,EAGJ,MAAa,OAAOE,GAAkBC,GAAmC;AACrE,SAAK,kBAAkBD,CAAK,GAC5B,KAAK,WAAWC,CAAI,GAGf,KAAA,GAAG,WAAW,KAAK,SAAS,GAEjC,KAAK,GAAG,gBAAgB,KAAK,GAAG,aAAa,KAAK,WAAW,GACxD,KAAA,GAAG,WAAW,KAAK,GAAG,WAAW,GAAG,KAAK,MAAM,SAAS,CAAC,GAC9D,KAAK,GAAG,gBAAgB,KAAK,GAAG,aAAa,IAAI,GAG5C,KAAA,GAAG,WAAW,KAAK,SAAS,GAC5B,KAAA,GAAG,WAAW,KAAK,GAAG,WAAW,GAAG,KAAK,MAAM,SAAS,CAAC,GAE9D,KAAK,SAAS;AAAA,EAAA;AAAA,EAGlB,MAAa,OAAsB;AAAA,EAAA;AAAA,EAI5B,UAAgB;AAAA,EAAA;AAAA,EAIf,gBAA8B;AAClC,UAAMC,IAAS,CAAC;AAChB,QAAIC,IAAM;AACV,aAASC,IAAI,GAAGA,IAAK,KAAK,OAAO,OAAsB,YAAYA,KAAK;AACpE,UAAIC,IAAID,KAAM,KAAK,OAAO,OAAsB,aAAa,KAAK;AAC9D,MAAAC,IAAA,KAAK,IAAI,EAAEA,KAAK,KAAM,KAAK,OAAO,OAAsB,SAAS,CAAC,GACtEH,EAAO,KAAKG,CAAC,GACNF,KAAAE;AAAA,IAAA;AAGX,aAASD,IAAI,GAAGA,IAAK,KAAK,OAAO,OAAsB,YAAYA;AAC/D,MAAAF,EAAOE,CAAC,IAAIF,EAAOE,CAAC,IAAID;AAGrB,WAAA,IAAI,aAAaD,CAAM;AAAA,EAAA;AAEtC;"}