import { bilinearUpsample as h } from "../util.js";
class o {
  constructor(t, i) {
    this.output_canvas = t, this.config = i, this.verts = new Float32Array([
      -1,
      -1,
      0,
      // Vertex 1
      -1,
      1,
      0,
      // Vertex 2
      1,
      1,
      0,
      // Vertex 3
      1,
      1,
      0,
      // Vertex 4
      1,
      -1,
      0,
      // Vertex 5
      -1,
      -1,
      0
      // Vertex 6
    ]), this.vertex_shader_src = `#version 300 es

in vec4 position;

void main() {
    gl_Position = position;
}
`, this.fragment_shader_header = `#version 300 es
precision highp float;

out vec4 outColor;

uniform sampler2D u_image;
uniform sampler2D u_mask;
uniform vec2 u_resolution;
`, this.shared_shader_functions = `
float get_mask(vec2 uv) {
    float maskValue = texture(u_mask, uv).r;
    return smoothstep(0.0, 1.0, maskValue);
}
`;
    const e = this.output_canvas.getContext("webgl2", { antialias: !0 });
    if (e)
      this.gl = e;
    else {
      const s = this.output_canvas.getContext("2d");
      if (!s)
        throw new Error("[ladon-ts] Output canvas context must be webgl2 or 2d");
      this.output_canvas_2d = s, this.intermediate_canvas = document.createElement("canvas"), this.intermediate_canvas.height = this.config.input.height, this.intermediate_canvas.width = this.config.input.width;
      const r = this.intermediate_canvas.getContext("webgl2", {
        antialias: !0
      });
      if (!r)
        throw new Error("[ladon-ts] Error getting output context webgl");
      this.gl = r;
    }
    this.initTexturesAndBuffers();
  }
  initTexturesAndBuffers() {
    this.image_texture = this.createTexture(
      this.gl.RGBA,
      this.config.input.width,
      this.config.input.height
    ), this.mask_texture = this.createTexture(
      this.gl.R8,
      this.config.mask.upscaleSize.width,
      this.config.mask.upscaleSize.height
    );
    const t = this.gl.createVertexArray();
    if (!t)
      throw new Error("[ladon-ts] Error creating vertex array");
    this.gl.bindVertexArray(t);
    const i = this.gl.createBuffer();
    if (!i)
      throw new Error("[ladon-ts] Error creating buffer");
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, i), this.gl.bufferData(this.gl.ARRAY_BUFFER, this.verts, this.gl.STATIC_DRAW), this.gl.vertexAttribPointer(0, 3, this.gl.FLOAT, !1, 0, 0), this.gl.enableVertexAttribArray(0), this.gl.viewport(0, 0, this.config.input.width, this.config.input.height);
  }
  createTexture(t, i, e, s = () => {
    this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      t,
      i,
      e,
      0,
      t === this.gl.RGBA ? this.gl.RGBA : this.gl.RED,
      this.gl.UNSIGNED_BYTE,
      null
    );
  }) {
    const r = this.gl.createTexture();
    if (!r)
      throw new Error("[ladon-ts] Error creating texture");
    return this.gl.bindTexture(this.gl.TEXTURE_2D, r), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE), s(), this.gl.bindTexture(this.gl.TEXTURE_2D, null), r;
  }
  getUVCalculation() {
    return this.config.render.horizontalMirror ? "vec2 st = vec2(1.0 - gl_FragCoord.x / u_resolution.x, 1.0 - gl_FragCoord.y / u_resolution.y);" : "vec2 st = vec2(gl_FragCoord.x / u_resolution.x, 1.0 - gl_FragCoord.y / u_resolution.y);";
  }
  setSharedUniforms(t) {
    const i = this.gl.getUniformLocation(t, "u_resolution");
    if (!i)
      throw new Error('[ladon-ts] Error finding "u_resolution" uniform');
    this.gl.uniform2f(i, this.config.input.width, this.config.input.height);
    const e = this.gl.getUniformLocation(t, "u_image");
    if (!e)
      throw new Error('[ladon-ts] Error finding "u_image" uniform');
    this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, this.image_texture), this.gl.uniform1i(e, 0);
    const s = this.gl.getUniformLocation(t, "u_mask");
    s && (this.gl.activeTexture(this.gl.TEXTURE1), this.gl.bindTexture(this.gl.TEXTURE_2D, this.mask_texture), this.gl.uniform1i(s, 1));
  }
  uploadVideoStream(t) {
    this.gl.activeTexture(this.gl.TEXTURE0), this.gl.bindTexture(this.gl.TEXTURE_2D, this.image_texture), t instanceof HTMLVideoElement ? this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      this.gl.RGBA,
      this.gl.RGBA,
      this.gl.UNSIGNED_BYTE,
      t
    ) : this.gl.texImage2D(
      this.gl.TEXTURE_2D,
      0,
      this.gl.RGBA,
      this.config.input.width,
      this.config.input.height,
      0,
      this.gl.RGBA,
      this.gl.UNSIGNED_BYTE,
      t
    );
  }
  uploadMask(t) {
    if (t != null && t.warm) {
      const i = h(
        t.data,
        this.config.mask.outputSize.width,
        this.config.mask.outputSize.height,
        this.config.mask.upscaleSize.width,
        this.config.mask.upscaleSize.height
      );
      this.gl.activeTexture(this.gl.TEXTURE1), this.gl.bindTexture(this.gl.TEXTURE_2D, this.mask_texture), this.gl.texImage2D(
        this.gl.TEXTURE_2D,
        0,
        this.gl.R8,
        this.config.mask.upscaleSize.width,
        this.config.mask.upscaleSize.height,
        0,
        this.gl.RED,
        this.gl.UNSIGNED_BYTE,
        i
      );
    }
  }
  postDraw() {
    this.output_canvas_2d && this.intermediate_canvas && this.output_canvas_2d.drawImage(
      this.intermediate_canvas,
      0,
      0,
      this.config.input.width,
      this.config.input.height
    );
  }
}
export {
  o as WebGLRenderer
};
//# sourceMappingURL=webgl-renderer.js.map
