import { compileShader as o, linkProgram as h } from "../util.js";
import { WebGLRenderer as a } from "./webgl-renderer.js";
class _ extends a {
  constructor(e, i) {
    if (super(e, i), this.output_canvas = e, this.config = i, this.fragment_shader_common = `#version 300 es
precision highp float;

#define KERNEL_SIZE     ${this.config.render.kernelSize}
#define HORIZONTAL      vec2(1.0, 0.0)
#define VERTICAL        vec2(0.0, 1.0)

out vec4 outColor;

uniform sampler2D       u_image;
uniform sampler2D       u_mask;
uniform vec2            u_resolution;
uniform float           u_kernel[KERNEL_SIZE];

// Function to retrieve the mask value
float get_mask(vec2 st) {
    return texture(u_mask, st).r;
}

// Get the inverse of the masked area
float get_inv_mask(vec2 st) {
    return 1.0 - get_mask(st);
}

// Blurring function
vec3 blur(sampler2D src, vec2 uv, vec2 direction) {
    vec4 accum = vec4(0.0);
    vec2 step = direction / u_resolution;
    int offset = (KERNEL_SIZE - 1) / 2;

    float weightSum = 0.0;
    for (int i = 0; i < KERNEL_SIZE; i++) {
        vec2 sampleUV = uv + step * float(i - offset);
        vec4 sampleTex = texture(src, sampleUV);
        float weight = u_kernel[i];
        accum += sampleTex * weight;
        weightSum += weight;
    }

    weightSum = max(weightSum, 0.001); // Avoid division by zero
    return accum.rgb / weightSum;
}
`, this.fragment_shader_pass_1_src = this.fragment_shader_common + `
void main() {
    vec2 st = gl_FragCoord.xy / u_resolution;
    outColor = vec4(blur(u_image, st, HORIZONTAL), 1.0);
}
`, this.fragment_shader_pass_2_src = this.fragment_shader_common + `
uniform sampler2D   u_blur;

void main() {
    ${this.getUVCalculation()};

    vec3 blurred = blur(u_blur, st, VERTICAL);
    vec3 original = texture(u_image, st).rgb;
    float mask = get_inv_mask(st); // Use inverse mask to blur background, not user

    // Correct blending based on the mask
    vec3 color = mix(original, blurred, mask); // Ensure mask properly determines blur influence on background
    outColor = vec4(color, 1.0);
}
`, this.config.render.kernelSize % 2 === 0)
      throw new Error("[ladon-ts] Kernel_size must be odd");
    {
      const r = o(
        this.gl,
        this.gl.VERTEX_SHADER,
        this.vertex_shader_src
      ), t = o(
        this.gl,
        this.gl.FRAGMENT_SHADER,
        this.fragment_shader_pass_1_src
      );
      this.program_1 = h(this.gl, r, t), this.gl.useProgram(this.program_1);
      const s = this.gl.createFramebuffer();
      if (!s)
        throw new Error("[ladon-ts] Error creating framebuffer");
      this.framebuffer = s;
      const n = this.gl.createTexture();
      if (!n)
        throw new Error("[ladon-ts] Error creating output texture");
      this.transfer_texture = n, this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer), this.gl.bindTexture(this.gl.TEXTURE_2D, this.transfer_texture), this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR), this.gl.texParameteri(
        this.gl.TEXTURE_2D,
        this.gl.TEXTURE_WRAP_S,
        this.gl.CLAMP_TO_EDGE
      ), this.gl.texParameteri(
        this.gl.TEXTURE_2D,
        this.gl.TEXTURE_WRAP_T,
        this.gl.CLAMP_TO_EDGE
      ), this.gl.texImage2D(
        this.gl.TEXTURE_2D,
        0,
        this.gl.RGBA,
        this.config.input.width,
        this.config.input.height,
        0,
        this.gl.RGBA,
        this.gl.UNSIGNED_BYTE,
        null
      ), this.gl.framebufferTexture2D(
        this.gl.FRAMEBUFFER,
        this.gl.COLOR_ATTACHMENT0,
        this.gl.TEXTURE_2D,
        this.transfer_texture,
        0
      ), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.setSharedUniforms(this.program_1);
      const l = this.gl.getUniformLocation(this.program_1, "u_kernel");
      if (!l)
        throw new Error('[ladon-ts] Error finding "u_kernel" uniform');
      this.gl.uniform1fv(l, this.getBlurKernel());
    }
    {
      const r = o(
        this.gl,
        this.gl.VERTEX_SHADER,
        this.vertex_shader_src
      ), t = o(
        this.gl,
        this.gl.FRAGMENT_SHADER,
        this.fragment_shader_pass_2_src
      );
      this.program_2 = h(this.gl, r, t), this.gl.useProgram(this.program_2);
      const s = this.gl.getUniformLocation(this.program_2, "u_blur");
      if (!s)
        throw new Error('[ladon-ts] Error finding "u_blur" uniform');
      this.u_blur = s, this.gl.activeTexture(this.gl.TEXTURE2), this.gl.bindTexture(this.gl.TEXTURE_2D, this.transfer_texture), this.gl.uniform1i(this.u_blur, 2), this.setSharedUniforms(this.program_2);
      const n = this.gl.getUniformLocation(this.program_2, "u_kernel");
      if (!n)
        throw new Error('[ladon-ts] Error finding "u_kernel" uniform');
      this.gl.uniform1fv(n, this.getBlurKernel());
    }
  }
  async render(e, i) {
    this.uploadVideoStream(e), this.uploadMask(i), this.gl.useProgram(this.program_1), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, this.framebuffer), this.gl.drawArrays(this.gl.TRIANGLES, 0, this.verts.length / 3), this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null), this.gl.useProgram(this.program_2), this.gl.drawArrays(this.gl.TRIANGLES, 0, this.verts.length / 3), this.postDraw();
  }
  async load() {
  }
  destroy() {
  }
  getBlurKernel() {
    const e = [];
    let i = 0;
    for (let r = 0; r < this.config.render.kernelSize; r++) {
      let t = r - (this.config.render.kernelSize - 1) / 2;
      t = Math.exp(-(t ** 2) / this.config.render.sigma ** 2), e.push(t), i += t;
    }
    for (let r = 0; r < this.config.render.kernelSize; r++)
      e[r] = e[r] / i;
    return new Float32Array(e);
  }
}
export {
  _ as BlurRenderer
};
//# sourceMappingURL=blur-renderer.js.map
