import { workerManager as s } from "./worker-manager.js";
class m {
  constructor(e) {
    this.config = e, this.pending = /* @__PURE__ */ new Map(), this.newMask = !0, this.lastResult = {
      data: new Float32Array(
        this.config.mask.outputSize.height * this.config.mask.outputSize.width
      ),
      facesAndLandmarks: { data: new Float32Array(0), dims: [] },
      gesture: new Float32Array(0),
      motion: 0,
      timestamp: 0,
      warm: !1
    };
  }
  isLoaded() {
    return !!s.getWorker();
  }
  async getLadonOutput() {
    const e = {
      data: this.lastResult.data,
      facesAndLandmarks: this.lastResult.facesAndLandmarks,
      gesture: this.lastResult.gesture,
      motion: this.lastResult.motion,
      timestamp: this.lastResult.timestamp,
      warm: this.newMask
    };
    return this.newMask = !1, e;
  }
  /**
   * Returns a promise that resolves when the worker returns the mask for the given timestamp.
   * This is useful for synchronizing the processing of frames with their corresponding masks.
   * The promise will be resolved with the mask data when it is available.
   *
   * @param timestamp - The timestamp of the frame for which the mask is requested.
   * @returns A promise that resolves with the mask data when available.
   */
  async getLadonOutputForTimestamp(e) {
    return new Promise((a) => {
      this.pending.set(e, a);
    });
  }
  /**
   * Loads the worker and initializes it with the provided configuration.
   * The worker is responsible for processing the input image and generating the mask.
   * Prepares the worker configuration by resolving the final URLs and paths to send to the worker.
   *
   * @returns A promise that resolves when the worker is loaded and initialized.
   */
  async load() {
    const e = await s.prepareWorkerConfig(this.config);
    return new Promise((a) => {
      s.onInitialized(() => {
        a();
      }), s.onGenerated((t) => {
        const r = {
          data: t.mask,
          facesAndLandmarks: t.facesAndLandmarks,
          gesture: t.gesture,
          motion: t.motion,
          timestamp: t.timestamp,
          warm: !0
        };
        this.lastResult = r, this.newMask = !0;
        const n = this.pending.get(t.timestamp);
        n && (n(r), this.pending.delete(t.timestamp));
      }), s.onDropped((t) => {
        const r = this.pending.get(t);
        r && (r(this.lastResult), this.pending.delete(t));
      }), s.onLog((t, r) => {
        const n = `[ladon-ts] Message received from worker: ${t}`;
        switch (r) {
          case "warn":
            console.warn(n);
            break;
          case "error":
            console.error(n);
            break;
          default:
            console.log(n);
        }
      }), (async () => (await (s.getWorker() ?? s.initializeWorker(e)), s.sendInit({
        baseUrl: e.baseUrl,
        input: e.input,
        mask: e.mask,
        wasmUri: e.wasmUri,
        render: { type: "passthrough" }
      })))();
    });
  }
  /**
   * Sends the input image to the worker for processing.
   * The input image is expected to be a Uint8ClampedArray.
   * Claims ownership of the input tensor's buffer and forwards it to the worker.
   *
   * @param input - The input image as a Uint8ClampedArray.
   * @param timestamp - The timestamp of the input image.
   */
  async postRender(e, a) {
    s.sendGenerate(e, a);
  }
  /**
   * Destroys the worker and cleans up resources.
   * First it sends a message to the worker to destroy itself,
   * then it waits for the worker to respond with a 'destroyed' message.
   * After that, it terminates the worker and revokes the URL if it exists.
   *
   * @returns A promise that resolves when the worker is destroyed.
   */
  destroy() {
    return s.destroyWorker();
  }
}
export {
  m as WorkerGenerator
};
//# sourceMappingURL=worker-generator.js.map
