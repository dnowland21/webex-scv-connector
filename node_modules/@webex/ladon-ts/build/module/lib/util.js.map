{"version":3,"file":"util.js","sources":["../../../src/lib/util.ts"],"sourcesContent":["export enum InterpolationMethod {\n    Nearest = 'nearest',\n}\n\n/**\n * Resizes an image from the source dimensions to target dimensions.\n *\n * @param {Uint8ClampedArray} imageData The source image data in Uint8ClampedArray format.\n * @param {number} srcWidth The width of the source image.\n * @param {number} srcHeight The height of the source image.\n * @param {number} targetWidth The width of the target image.\n * @param {number} targetHeight The height of the target image.\n *\n * @returns {Uint8ClampedArray} The target image data in Uint8ClampedArray format.\n *\n * @example\n * const targetData = resizeImage(sourceData, 800, 600, 400, 300);\n *\n * @note The function uses a \"nearest neighbor\" algorithm for resizing,\n * which is fast but might not provide the best quality for all images.\n */\nexport const resizeImage = (\n    imageData: Uint8ClampedArray,\n    srcWidth: number,\n    srcHeight: number,\n    targetWidth: number,\n    targetHeight: number\n): Uint8ClampedArray => {\n    const targetData = new Uint8ClampedArray(targetWidth * targetHeight * 4);\n    const xRatio = srcWidth / targetWidth;\n    const yRatio = srcHeight / targetHeight;\n    const scaledSrcWidth = srcWidth * 4;\n    let offset = 0;\n\n    for (let y = 0; y < targetHeight; y++) {\n        const srcY = Math.floor(y * yRatio) * scaledSrcWidth;\n        for (let x = 0; x < targetWidth; x++) {\n            const srcOffset = srcY + Math.floor(x * xRatio) * 4;\n\n            targetData[offset++] = imageData[srcOffset];\n            targetData[offset++] = imageData[srcOffset + 1];\n            targetData[offset++] = imageData[srcOffset + 2];\n            targetData[offset++] = imageData[srcOffset + 3];\n        }\n    }\n\n    return targetData;\n};\n\n/**\n * Upsamples an image using the bilinear interpolation method. The input image is expected to be in\n * Float32Array format. The output image is in Uint8ClampedArray format. The input image is expected\n * to be in the [0, 1] range. The output image is in the [0, 255] range.\n *\n * @param {Float32Array} input The input image data in Float32Array format.\n * @param {number} srcWidth The width of the source image.\n * @param {number} srcHeight The height of the source image.\n * @param {number} targetWidth The width of the target image.\n * @param {number} targetHeight The height of the target image.\n *\n * @returns {Uint8ClampedArray} The upsampled image data in Uint8ClampedArray format.\n *\n */\nexport function bilinearUpsample(\n    input: Float32Array,\n    srcWidth: number,\n    srcHeight: number,\n    targetWidth: number,\n    targetHeight: number\n) {\n    const output = new Uint8ClampedArray(targetWidth * targetHeight);\n\n    // If the source and target dimensions are the same, just copy the input to the output.\n    // The output is expected to be in the [0, 255] range\n    if (srcWidth === targetWidth && srcHeight === targetHeight) {\n        for (let i = 0; i < input.length; i++) {\n            output[i] = Math.min(Math.max(input[i], 0), 255);\n        }\n        return output;\n    }\n\n    const xRatio = (srcWidth - 1) / (targetWidth - 1);\n    const yRatio = (srcHeight - 1) / (targetHeight - 1);\n\n    for (let i = 0; i < targetHeight; i++) {\n        for (let j = 0; j < targetWidth; j++) {\n            const x = xRatio * j;\n            const y = yRatio * i;\n\n            const xL = Math.floor(x);\n            const yL = Math.floor(y);\n            const xH = Math.min(Math.ceil(x), srcWidth - 1);\n            const yH = Math.min(Math.ceil(y), srcHeight - 1);\n\n            const xWeight = x - xL;\n            const yWeight = y - yL;\n\n            const a = input[yL * srcWidth + xL];\n            const b = input[yL * srcWidth + xH];\n            const c = input[yH * srcWidth + xL];\n            const d = input[yH * srcWidth + xH];\n\n            const value =\n                a * (1 - xWeight) * (1 - yWeight) +\n                b * xWeight * (1 - yWeight) +\n                c * (1 - xWeight) * yWeight +\n                d * xWeight * yWeight;\n\n            output[i * targetWidth + j] = Math.min(Math.max(value, 0), 255);\n        }\n    }\n\n    return output;\n}\n\n/**\n * Upsamples an image using the Lanczos3 interpolation method. The input image is expected to be in\n * Float32Array format. The output image is in Uint8ClampedArray format. The input image is expected\n * to be in the [0, 1] range. The output image is in the [0, 255] range.\n *\n * @param {Float32Array} input The input image data in Float32Array format.\n * @param {number} srcWidth The width of the source image.\n * @param {number} srcHeight The height of the source image.\n * @param {number} targetWidth The width of the target image.\n * @param {number} targetHeight The height of the target image.\n *\n * @returns {Uint8ClampedArray} The upsampled image data in Uint8ClampedArray format.\n */\nexport function lanczos3Upsample(\n    input: Float32Array,\n    srcWidth: number,\n    srcHeight: number,\n    targetWidth: number,\n    targetHeight: number\n) {\n    const output = new Uint8ClampedArray(targetWidth * targetHeight);\n\n    const xRatio = srcWidth / targetWidth;\n    const yRatio = srcHeight / targetHeight;\n\n    const lanczos = (x: number, a: number) => {\n        if (x === 0) return 1;\n        if (x < 0) x = -x;\n        if (x < a) {\n            const piX = Math.PI * x;\n            return (a * Math.sin(piX) * Math.sin(piX / a)) / (piX * piX);\n        }\n        return 0;\n    };\n\n    const a = 3; // Lanczos parameter\n\n    for (let i = 0; i < targetHeight; i++) {\n        for (let j = 0; j < targetWidth; j++) {\n            const x = j * xRatio;\n            const y = i * yRatio;\n\n            const xL = Math.floor(x);\n            const yL = Math.floor(y);\n\n            let value = 0;\n            let weightSum = 0;\n\n            for (let ky = yL - a + 1; ky <= yL + a; ky++) {\n                for (let kx = xL - a + 1; kx <= xL + a; kx++) {\n                    if (kx >= 0 && kx < srcWidth && ky >= 0 && ky < srcHeight) {\n                        const pixel = input[ky * srcWidth + kx];\n                        const weight = lanczos(x - kx, a) * lanczos(y - ky, a);\n                        value += pixel * weight;\n                        weightSum += weight;\n                    }\n                }\n            }\n\n            output[i * targetWidth + j] = weightSum !== 0 ? Math.round(value / weightSum) : 0;\n        }\n    }\n\n    return output;\n}\n\nexport function compileShader(\n    gl: WebGL2RenderingContext,\n    shader_type: number,\n    source: string\n): WebGLShader {\n    const shader = gl.createShader(shader_type);\n\n    if (!shader) {\n        throw new Error('[ladon-ts] Error creating shader');\n    }\n\n    gl.shaderSource(shader, source);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        const error = gl.getShaderInfoLog(shader) ?? 'unknown error compiling shader.';\n        throw new Error('[ladon-ts] ' + error);\n    }\n\n    return shader;\n}\n\nexport function linkProgram(\n    gl: WebGL2RenderingContext,\n    vertex_shader: WebGLShader,\n    fragment_shader: WebGLShader\n): WebGLProgram {\n    const program = gl.createProgram();\n\n    if (!program) {\n        throw new Error('[ladon-ts] Error creating GPU program');\n    }\n\n    gl.attachShader(program, vertex_shader);\n    gl.attachShader(program, fragment_shader);\n\n    gl.linkProgram(program);\n\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n        const error = gl.getProgramInfoLog(program) ?? 'unknown error linking program.';\n        throw new Error('[ladon-ts] ' + error);\n    }\n\n    return program;\n}\n\n/**\n * Determines if a URI is already resolved.\n * A resolved URI is either:\n *  - A blob URL (starts with 'blob:')\n *  - A fully qualified URL (e.g., http:// or https://)\n *\n * @param uri - The URI to check.\n * @returns Whether the URI is already resolved.\n */\nexport function isResolvedUri(uri: string): boolean {\n    if (uri.startsWith('blob:')) {\n        // Blob URIs are resolved\n        return true;\n    }\n\n    try {\n        // Throws if the URI is not a valid full URL\n        new URL(uri);\n        return true;\n    } catch {\n        // Not a fully qualified URL\n        return false;\n    }\n}\n\nexport const toAbsoluteURI = (relativeURL: string, baseURL?: string) => {\n    // adapted from - https://github.com/axios/axios/blob/fe7d09bb08fa1c0e414956b7fc760c80459b0a43/lib/helpers/combineURLs.js\n\n    if (!baseURL || relativeURL.startsWith('http')) {\n        return new URL(relativeURL).href;\n    }\n\n    return relativeURL\n        ? baseURL.replace(/\\/+$/, '') + '/' + relativeURL.replace(/^\\/+/, '')\n        : baseURL;\n};\n"],"names":["InterpolationMethod","resizeImage","imageData","srcWidth","srcHeight","targetWidth","targetHeight","targetData","xRatio","yRatio","scaledSrcWidth","offset","y","srcY","x","srcOffset","bilinearUpsample","input","output","i","j","xL","yL","xH","yH","xWeight","yWeight","a","b","c","d","value","lanczos3Upsample","lanczos","piX","weightSum","ky","kx","pixel","weight","compileShader","gl","shader_type","source","shader","error","linkProgram","vertex_shader","fragment_shader","program","isResolvedUri","uri","toAbsoluteURI","relativeURL","baseURL"],"mappings":"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"}