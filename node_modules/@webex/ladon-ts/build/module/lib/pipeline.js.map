{"version":3,"file":"pipeline.js","sources":["../../../src/lib/pipeline.ts"],"sourcesContent":["import { PipelineConfig } from './config-types';\nimport {\n    FacesAndLandmarks,\n    FrameData,\n    LadonOutput,\n    MaskGenerator,\n    WorkerGenerator,\n} from './generator';\nimport { BlurRenderer, LadonRenderer, PassthroughRenderer, ReplacementRenderer } from './renderer';\nimport { resizeImage } from './util';\n\nexport interface IFrameInferenceResult {\n    facesAndLandmarks: FacesAndLandmarks;\n    gesture: Float32Array;\n    motion: number;\n    skipped: boolean;\n    timestamp: number;\n}\n\nexport interface IPipeline {\n    onFrame(timestamp: number, maskNeeded?: boolean): Promise<IFrameInferenceResult>;\n    isLoaded(): boolean;\n    load(): Promise<void>;\n    destroy(): Promise<void>;\n    reset(): void;\n}\n\nexport class Pipeline implements IPipeline {\n    private generator?: MaskGenerator;\n    private renderer?: LadonRenderer;\n    private loaded = false;\n\n    private inputCanvasCtx: CanvasRenderingContext2D;\n    private lastMaskResult?: LadonOutput;\n\n    private frameDataBuffer?: Uint8ClampedArray;\n\n    constructor(\n        private inputCanvas: HTMLCanvasElement,\n        private outputCanvas: HTMLCanvasElement,\n        public readonly config: PipelineConfig,\n        private readonly videoElement?: HTMLVideoElement\n    ) {\n        const inputCanvasCtx = this.inputCanvas.getContext('2d', {\n            alpha: false,\n            willReadFrequently: true,\n        });\n\n        if (!inputCanvasCtx) {\n            throw new Error('[ladon-ts] Error getting input context 2d');\n        }\n        this.inputCanvasCtx = inputCanvasCtx;\n    }\n\n    /**\n     * Processes a single frame and returns the inference result.\n     * This method handles the frame data, performs inference if needed, and renders the output.\n     *\n     * @param timestamp - The timestamp of the frame.\n     * @param performInference - Flag to perform mask inference.\n     * @returns The result of the frame processing.\n     * @throws If the pipeline (generator or renderer) is not loaded.\n     */\n    public async onFrame(\n        timestamp: number,\n        performInference = true\n    ): Promise<IFrameInferenceResult> {\n        if (!this.generator || !this.renderer) {\n            throw new Error('[ladon-ts] Pipeline is not loaded.');\n        }\n\n        // Get the current frame (raw image data or video element). Use the video element if skipping\n        // inference to avoid unnecessary processing when calling canvas getImageData.\n        const frameData = this.getInputFrameData(performInference);\n\n        // Reuse or create buffer for frame data copies, which is needed to ensure the data is not modified\n        // or garbage collected before the inference is done.\n        let frameDataCopy: FrameData;\n        if (frameData instanceof Uint8ClampedArray) {\n            if (!this.frameDataBuffer || this.frameDataBuffer.length !== frameData.length) {\n                this.frameDataBuffer = new Uint8ClampedArray(frameData.length);\n            }\n            this.frameDataBuffer.set(frameData);\n            frameDataCopy = this.frameDataBuffer;\n        } else {\n            frameDataCopy = frameData;\n        }\n\n        if (performInference || !this.lastMaskResult) {\n            // Send frame for inference and wait for the mask for this timestamp\n            const rawImageData = frameData as Uint8ClampedArray;\n            const maskImageData = this.getMaskImageData(rawImageData);\n            await this.generator.postRender(maskImageData, timestamp);\n            this.lastMaskResult = await this.generator.getLadonOutputForTimestamp(timestamp);\n        }\n\n        // Render the frame and mask together (mask may be stale if skipping inference)\n        await this.renderer.render(frameDataCopy, this.lastMaskResult);\n\n        return this.createInferenceResult(timestamp, performInference);\n    }\n\n    /**\n     * Gets the raw image data from the input canvas context.\n     *\n     * @param needFreshImageData - Flag to indicate if fresh image data is needed.\n     *\n     * @returns The raw image data.\n     */\n    private getInputFrameData(needFreshImageData: boolean): FrameData {\n        if (needFreshImageData || !this.videoElement) {\n            return this.inputCanvasCtx.getImageData(\n                0,\n                0,\n                this.config.input.width,\n                this.config.input.height\n            ).data;\n        }\n\n        return this.videoElement;\n    }\n\n    /**\n     * Resizes the image data if the model expects a fixed size input.\n     *\n     * @param {Uint8ClampedArray} rawImageData - The raw image data.\n     * @returns {Uint8ClampedArray} - The processed mask image data.\n     */\n    private getMaskImageData(rawImageData: Uint8ClampedArray): Uint8ClampedArray {\n        const modelInput = this.config.mask.inputSize;\n        const inputImage = this.config.input;\n\n        // Check if resizing is needed based on configuration.\n        if (modelInput.width === inputImage.width && modelInput.height === inputImage.height) {\n            return rawImageData;\n        }\n\n        // Resize the image data.\n        return resizeImage(\n            rawImageData,\n            inputImage.width,\n            inputImage.height,\n            modelInput.width,\n            modelInput.height\n        );\n    }\n\n    /**\n     * Creates the inference result object.\n     *\n     * @param {number} timestamp - The timestamp of the frame.\n     * @param {boolean} performedInference - Indicates if the inference was performed.\n     * @returns {IFrameInferenceResult} - The result object containing inference details.\n     */\n    private createInferenceResult(\n        timestamp: number,\n        performedInference: boolean\n    ): IFrameInferenceResult {\n        if (!this.lastMaskResult) {\n            return {\n                facesAndLandmarks: { data: new Float32Array(0), dims: [] },\n                gesture: new Float32Array(0),\n                motion: 0,\n                skipped: true,\n                timestamp,\n            };\n        }\n\n        return {\n            facesAndLandmarks: this.lastMaskResult.facesAndLandmarks,\n            gesture: this.lastMaskResult.gesture,\n            motion: this.lastMaskResult.motion,\n            skipped: !performedInference,\n            timestamp,\n        };\n    }\n\n    /**\n     * Checks if the pipeline is loaded.\n     *\n     * @returns True if the pipeline is loaded, false otherwise.\n     */\n    public isLoaded(): boolean {\n        return this.loaded;\n    }\n\n    /**\n     * Loads the pipeline components such as the generator and renderer.\n     */\n    public async load(): Promise<void> {\n        switch (this.config.render.type) {\n            case 'blur':\n                this.renderer = new BlurRenderer(this.outputCanvas, this.config);\n                break;\n            case 'passthrough':\n                this.renderer = new PassthroughRenderer(this.outputCanvas, this.config);\n                break;\n            case 'replacement':\n                this.renderer = new ReplacementRenderer(this.outputCanvas, this.config);\n                break;\n            default:\n                throw new Error('[ladon-ts] Renderer not implemented.');\n        }\n\n        await this.renderer.load();\n\n        this.generator = new WorkerGenerator(this.config);\n        await this.generator.load();\n\n        this.loaded = true;\n    }\n\n    public reset(): void {\n        this.lastMaskResult = undefined;\n    }\n\n    /**\n     * Destroys the pipeline and cleans up resources.\n     */\n    public async destroy(): Promise<void> {\n        this.reset();\n        this.renderer?.destroy();\n        await this.generator?.destroy();\n        this.frameDataBuffer = undefined;\n        this.loaded = false;\n    }\n}\n"],"names":["Pipeline","inputCanvas","outputCanvas","config","videoElement","inputCanvasCtx","timestamp","performInference","frameData","frameDataCopy","rawImageData","maskImageData","needFreshImageData","modelInput","inputImage","resizeImage","performedInference","BlurRenderer","PassthroughRenderer","ReplacementRenderer","WorkerGenerator","_a","_b"],"mappings":"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"}